{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Home","text":"本站已经运行","path":["Home"],"tags":["test"]},{"location":"#home","level":1,"title":"Home","text":"Yuri Anime List              这里收录了所有百合题材的番剧推荐与评价，点击查看详细列表与评分排行。          <p>官方文档</p> <p>Zensical 官方网站: https://zensical.org/ Zensical 官方文档: https://zensical.org/docs/</p> <p>目前大概是将原本MkDocs博客的一些板块迁移过来了</p>","path":["Home"],"tags":["test"]},{"location":"friends-link/","level":1,"title":"Friends link","text":"Academic homepage 学术主页 Meraki's bar 一位学弟的博客 Ice Year の位面 Il n’y a pas de hasard, il n’y a que des rendez-vous. 春风少年兄 你在世纪大道东门 Yon Zilch From the yon, into zilch. Life, a vanished dream. Wcowin's Blog 循此苦旅，以达星辰","path":["Friends link"],"tags":[]},{"location":"ACG/Anime/","level":1,"title":"Anime Rank","text":"<p>Hint</p> <p>你眼中的神作在别人的眼中不一定是神作甚至不一定是出色的作品，相应的别人批判的作品也有可能是你心中的神作，这一点是一切ACG排行榜的基本原则(Basic Principle)</p>","path":["ACG","Anime Rank"],"tags":["ACG"]},{"location":"ACG/Anime/#anime-rank","level":1,"title":"Anime Rank","text":"<ul> <li> 神作</li> <li> 佳作</li> <li> 良作</li> <li> 凡作</li> <li> 烂作</li> </ul> 排序方式： 按年份：从新到旧 按年份：从旧到新","path":["ACG","Anime Rank"],"tags":["ACG"]},{"location":"ACG/Anime/#_1","level":2,"title":"神作","text":"剧情或许有瑕疵，但是作画和特效已经杀穿了，百合番最富裕的一仗              超时空辉夜姬 2026                  这个也是看电波吧，我非常喜欢女主(有点像千反田)，实际上镜头给出的隐喻暗示是比较到位的，我很喜欢              熏香花朵凛然绽放 2025                  向命运发出呐喊，真正真实的矛盾的对立冲突，歌曲风格喜好，3D强大              Girls Band Cry 2024                  在平淡叙事中积累感动的作品，草蛇灰线，伏案千里              葬送的芙莉莲 2023                  入坑作，永远难以忘怀的一部作品，作画极其精良，感情纯粹              紫罗兰永恒花园 2018                  伟大的百合，伟大的作画，伟大的音乐，伟大的细节，最震惊的硬核百合              终将成为你 2018                  切入点与众不同，详细展示了动漫业从业人员的工作和日常，在平淡中有真实的感动，并且还穿插有一些历史叙事，是一部出色的作品              白箱 2014                  个人的性格使然，轻松而又不轻松的校园推理动漫(但是很多人都觉得这个很无聊，那么我觉得可能需要考虑是否能够对的上电波再考虑观看)              冰菓 2012                  开创性的作品，打开了萌纪元，我想看第三季(2025.9.14)，我好想看第三季啊！！！！！！！              轻音少女 2009","path":["ACG","Anime Rank"],"tags":["ACG"]},{"location":"ACG/Anime/#_2","level":2,"title":"佳作","text":"莫名在2025年爆火的百合后宫题材，感觉有点莫名其妙的，原作小说和漫画都是比较出色的，动画基本上维持了一定的作画水平              我们不可能成为恋人！(※似乎可行？) 2025                  我挺喜欢的，比较轻松日常的喜剧              坏女孩 2024                  慕名而来，可能没有达到心理的预期，虽然本人也是社恐，但是不太有共鸣，确实是非常不错的作品了              孤独摇滚 2022                  有最喜欢的角色小鞠知花，但是整体题材限制恐怕没有达到神作的潜力              败犬女主太多了 2024                  kiss kiss的过程              樱trick 2014                  柑橘味的由来，但是动漫表现可能比不上漫画那么出色              citrus～柑橘味香气～ 2018                  意外的成功吗?开创了少女乐队的一种新视角，个人的话喜欢角色大于喜欢番剧本身了              BanG Dream! It's MyGO!!!!! 2023                  有喜欢的角色(切绘)，整体节奏感偏轻松，在轻松这一块少有能比肩KON的              干物妹！小埋 2015                  很喜欢的画风和剧情，算是个人倾向了              擅长逃跑的殿下 2024 玉子市场 2013                  比较温馨的作品，优秀的作画，声优，剧情              间谍过家家 1 2022                  比较温馨的作品，优秀的作画，声优，剧情              间谍过家家 2 2023                  我的青春恋爱物语有问题，喜欢团子和阳乃，但是对于真物和谜语不太有共鸣              我的青春恋爱物语果然有问题 2013                  都说很刀，不过本人倒是不太有感觉，可能看太晚了，吃刀吃习惯了              四月是你的谎言 2014                  比较像科普番，但是有点爽              石纪元 2019                  喜欢伊蕾娜，白毛萝莉()，有很出色的地方，但是还是想控制一下神作数量              魔女之旅 2020                  结尾有点open了，中间有一些部分不是特别满意，不过也是难得的百合作品了              转生王女与天才千金的魔法革命 2023                  如果不是结尾很突兀，单凭堕落的那一段就有神作的实力              Charlotte 2015                  超级甜的一部              擅长捉弄的高木同学 2018                  很甜，很酸，题材的同质化问题              堀与宫村 2021                  充满了遗憾，伤痛              秒速五厘米 2007 天气之子 2019                  过于著名，但是对这类题材不太有感觉了              你的名字 2016                  结尾太快了，但是前面很出色，对于艾拉这种性格的女角色自动加分，如果有续集的话就好了！！！              可塑性记忆 2015","path":["ACG","Anime Rank"],"tags":["ACG"]},{"location":"ACG/Anime/#_3","level":2,"title":"良作","text":"我说不好，我不好说，看原作吧，谢谢              我的百合乃工作是也 2023 恋爱小行星 2020                  多组CP，一次满足              徒然喜欢你 2017                  经典泡面番，就那样吧              品酒要在成为夫妻后 2017 刺客伍六七 2018 式守同学不只可爱而已 2022","path":["ACG","Anime Rank"],"tags":["ACG"]},{"location":"ACG/Anime/#_4","level":2,"title":"凡作","text":"天才王子的赤字国家振兴术 2022                  我说不好，我不好说，看原作吧，谢谢(读到这里请为竹岛老师哀悼三分钟)              恋语轻唱 2024","path":["ACG","Anime Rank"],"tags":["ACG"]},{"location":"ACG/Anime/#_5","level":2,"title":"烂作","text":"懒得喷，柿本广大诗人握持              BanG Dream! Ave Mujica 2025","path":["ACG","Anime Rank"],"tags":["ACG"]},{"location":"ACG/Yuri/","level":1,"title":"Yuri Rank","text":"排序方式： 按年份：从新到旧 按年份：从旧到新                  剧情或许有瑕疵，但是作画和特效已经杀穿了，百合番最富裕的一仗              超时空辉夜姬 2026","path":["ACG","Yuri Rank"],"tags":[]},{"location":"Analysis/","level":1,"title":"分析学总站","text":"<p>与标题一致，这里主要存放关于分析学的课程笔记或是站长自己阅读的一些分析学书籍的笔记</p> <p>目前已有：</p> <ul> <li>数学分析(Mathematical Analysis)<ul> <li>南开大学数学分析月考</li> <li>南开大学数学分析答案</li> </ul> </li> <li>实分析(Real Analysis)</li> <li>初等概率论(Elementary Probability Theory)</li> <li>随机过程(Stochastic Process)</li> </ul> <p>以上内容均遵循CC BY-SA 4.0 license，如发现错误或是有反馈建议请email联系</p>","path":["Analysis","分析学总站"],"tags":["Analysis"]},{"location":"Analysis/%E5%8D%97%E5%BC%80%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%9C%88%E8%80%83%E7%9C%9F%E9%A2%98/","level":1,"title":"Exams","text":"<p>答案 我也不知道干嘛现在 还没写</p>","path":["南开大学数学分析月考答案"],"tags":["Mathematical Analysis","Exams"]},{"location":"Analysis/%E5%8D%97%E5%BC%80%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E7%AD%94%E6%A1%88/","level":1,"title":"南开大学数学分析答案","text":"<p>这里存放着笔者想在毕业前完成的一份答案</p>","path":["Analysis","Mathematical Analysis","南开大学数学分析课本答案","南开大学数学分析答案"],"tags":[]},{"location":"Analysis/%E5%8D%97%E5%BC%80%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E7%AD%94%E6%A1%88/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD/","level":1,"title":"多元函数的极限与连续_NKU(答案)","text":"","path":["Analysis","Mathematical Analysis","南开大学数学分析课本答案","多元函数的极限与连续_NKU(答案)"],"tags":[]},{"location":"Analysis/%E5%8D%97%E5%BC%80%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E7%AD%94%E6%A1%88/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD/#101","level":2,"title":"练习10.1","text":"<p>[!question] 10.1 1 在\\(\\mathbb{R}^{n}\\)中举出以下例子 (1) 无穷个开集之交不为开集.  (2) 无穷个闭集之并不为闭集. </p> <p><code>Sol.</code></p> <p>(1)考虑构造一个收敛的点列，\\(X_{k}=\\left\\{ \\left( x_{1},x_{2},\\dots,x_{n}\\right)|\\lvert x_{i} \\rvert&lt; \\frac{1}{k}  \\right\\}\\)</p> <p>那么可以得到\\(\\bigcap\\limits_{k=1}^{\\infty}X_{k}=\\left\\{ 0 \\right\\}\\)，单点集不为开集</p> <p>(2)考虑构造收敛于区间端点的点列，\\(X_{k}=\\left\\{ (x_{1},x_{2},\\dots,x_{n})|d=\\sqrt{ \\sum\\limits_{i=1}^{n}x_{i}^{2} }\\leqslant 1- \\frac{1}{k}\\right\\}\\)</p> <p>那么可以得到\\(\\bigcup\\limits_{k=1}^{\\infty}X_{k}=\\left\\{ (x_{1},x_{2},\\dots,x_{n})|d&lt;1 \\right\\}\\)，是一个开球(开集)</p> <p>[!question] 10.1 2 设\\(A\\)是\\(\\mathbb{R}^n\\)的子集，\\(X_0\\)是\\(A\\)的聚点，求证：存在点列\\(\\{X_m\\}\\subseteq A\\), 使得\\(X_m\\neq X_0\\),且</p> \\[\\lim_{m\\to\\infty}X_m=X_0\\] <p><code>Proof.</code></p> <p>根据聚点的定义知道\\(\\forall\\delta&gt;0,\\exists x'\\in V(X_{0},\\delta)\\bigcap A\\)，那么构造如下点列：</p> <p>固定\\(r_{1}=1,\\exists X_{1}\\in V(X_{0},r_{1}=1)\\bigcap A,X_{1}\\neq X_{0}\\)，再固定\\(r_{2}=\\min\\left\\{ \\frac{1}{2},\\lvert X_{1}-X_{0} \\rvert \\right\\},\\exists X_{2}\\in V(X_{0},r_{2})\\bigcap A,X_{2}\\neq X_{0}\\)</p> <p>以此类推，\\(r_{n}=\\min\\left\\{ \\frac{1}{n},\\lvert X_{n-1}-X_{0} \\rvert \\right\\},\\exists X_{n}\\in V(X_{0},r_{n})\\bigcap A,X_{n}\\neq X_{0}\\)</p> <p>这样就得到了\\(\\left\\{ X_{m} \\right\\},\\lim\\limits_{ m \\to \\infty }\\lvert X_{m}-X_{0} \\rvert =0,X_{m}\\neq X_{0},\\lim\\limits_{ m \\to \\infty }X_{m}=X_{0}\\)</p> <p>[!question] 10.1 3 设\\(A\\)是\\(\\mathbb{R}^n\\)的子集，求证：\\(\\overline A=A\\cup A^\\prime.\\)</p> <p><code>Proof.</code></p> <p>根据定义，若有\\(x\\in \\overline{A}\\)，讨论\\(x\\in A ,x\\not\\in A\\)，如果\\(x\\in A \\implies x\\in A\\bigcup A'\\);\\(x\\not\\in A,x\\in A'\\implies x\\in A\\bigcup A'\\)，那么有\\(\\overline{A}\\subset A\\bigcup A'\\)</p> <p>反方向\\(x\\in A\\)显然有\\(x\\in \\overline{A}\\)，若是\\(x\\in A'\\)同样根据定义可得\\(A'\\subset  \\overline{A}\\),综上可知\\(A\\bigcup A' \\subset  \\overline{A}\\)</p> <p>由相互包含可知\\(\\overline{A}=A\\bigcup A'\\)</p> <p>[!question] 10.1 4 求证下列命题： (1) \\(A\\subseteq B\\Rightarrow A^{\\circ }\\subseteq B^{\\circ }\\), \\(\\overline {A}\\subseteq \\overline {B};\\) (2) \\(\\overline {A\\cup B}= \\overline {A}\\cup \\overline {B}\\), \\(\\overline {A\\cap B}\\subseteq \\overline {A}\\cap \\overline {B};\\) (3) \\(( A\\cap B) ^{\\circ }= A^{\\circ }\\cap B^{\\circ }\\), \\(( A\\cup B) ^{\\circ }\\supseteq A^{\\circ }\\cup B^{\\circ }.\\)</p> <p><code>Proof.</code></p> <p>(1)</p> <p>若是\\(A\\subseteq B\\implies \\forall x\\in A^{\\circ},\\exists V(x,\\varepsilon)\\subset A\\subset B \\implies x\\in B^{\\circ}\\implies A^{\\circ}\\subseteq B^{\\circ}\\)</p> <p>同样的\\(\\forall x\\in \\overline{A}\\)，分类讨论\\(x\\in A\\)显然\\(x\\in B\\implies x\\in \\overline{B}\\)，若\\(x\\not\\in A,x\\in A'\\)，根据定义有\\(V(x,\\varepsilon)\\setminus \\left\\{ x \\right\\}\\bigcap A\\neq \\emptyset\\implies V(x,\\varepsilon)\\setminus \\left\\{ x \\right\\}\\bigcap B\\neq \\emptyset \\implies x\\in \\overline{B}\\)</p> <p>所以可得\\(\\overline{A}\\subseteq  \\overline{B}\\)</p> <p>(2)</p> <p>\\(\\forall x\\in \\overline{A\\bigcup B},\\forall V(x,\\varepsilon)\\bigcap\\left( A\\bigcup B \\right)\\setminus \\left\\{ x \\right\\}\\neq \\emptyset\\)</p> <p>由此可得\\(\\left( V(x,\\varepsilon)\\bigcap A\\setminus \\left\\{ x \\right\\}\\neq \\emptyset \\right) \\bigcup \\left( V(x,\\varepsilon)\\bigcap B\\setminus \\left\\{ x \\right\\}\\neq \\emptyset \\right)\\)，也就是属于A或者B的闭包(\\(\\overline{A}\\bigcup  \\overline{B}\\)),\\(\\overline{A\\bigcup B}\\subset  \\overline{A}\\bigcup  \\overline{B}\\)</p> <p>\\(V(x,\\varepsilon)\\bigcap A(B)\\setminus \\left\\{ x \\right\\}\\neq \\emptyset\\implies V(x,\\varepsilon)\\bigcap \\left( A\\bigcup B \\right)\\setminus \\left\\{ x \\right\\}\\neq \\emptyset\\)，也就是属于\\(A\\bigcup B\\)的闭包</p> <p>综上可知：\\(\\overline{A\\bigcup B}=\\overline{A}\\bigcup  \\overline{B}\\)</p> <p>同理\\(\\forall x\\in \\overline{A\\bigcap B},\\forall V(x,\\varepsilon)\\bigcap\\left( A\\bigcap B \\right)\\setminus \\left\\{ x \\right\\}\\neq \\emptyset\\)</p> <p>也就是说\\(\\left( V(x,\\varepsilon)\\bigcap A\\setminus \\left\\{ x \\right\\}\\neq \\emptyset \\right) \\bigcap \\left( V(x,\\varepsilon)\\bigcap B\\setminus \\left\\{ x \\right\\}\\neq \\emptyset \\right)\\)</p> <p>故\\(\\overline{A\\bigcap B} \\subseteq  \\overline{A} \\bigcap  \\overline{B}\\)</p> <p>(3)</p> <p>\\(\\forall x \\in \\left( A\\bigcap B \\right)^{\\circ},\\exists V(x,\\varepsilon)\\subset \\left( A\\bigcap B \\right)\\implies V(x,\\varepsilon)\\subset A(B)\\implies x\\in A^{\\circ}\\bigcap B^{\\circ}\\)，可知有\\(A^{\\circ}\\bigcap B^{\\circ}\\supset \\left( A\\bigcap B \\right)^{\\circ}\\)</p> <p>若是\\(x\\in A^{\\circ}\\bigcap B^{\\circ}\\)，\\(\\exists V(x,\\varepsilon_{1})\\subset A,V(x,\\varepsilon_{2})\\subset B\\),取\\(\\varepsilon=\\min\\left\\{ \\varepsilon_{1},\\varepsilon_{2} \\right\\},V(x,\\varepsilon)\\subset A\\bigcap B\\),可知有\\(A^{\\circ}\\bigcap B^{\\circ}\\subset \\left( A\\bigcap B \\right)^{\\circ}\\)</p> <p>综上可知,\\(A^{\\circ}\\bigcap B^{\\circ}=\\left( A\\bigcap B \\right)^{\\circ}\\)$</p> <p>\\(\\forall x\\in A^{\\circ}\\bigcup B^{\\circ},\\exists V(x,\\varepsilon)\\subset A(B),V(x,\\varepsilon)\\subset \\left( A\\bigcup B \\right)\\implies x\\in \\left( A\\bigcup B \\right)^{\\circ}\\)</p> <p>即证\\(A^{\\circ}\\bigcup B^{\\circ}\\subset \\left( A\\bigcup B \\right)^{\\circ}\\)</p> <p>[!question] 10.1 5 设\\(A\\)是\\(\\mathbb{R}^n\\)的子集，求证： (1) \\(A^{\\circ }\\)是开集； (2) \\(\\partial A\\)是闭集； (3) \\(\\overline{A}\\)是闭集； (4) \\(A^{\\prime }\\)是闭集. </p> <p><code>Proof.</code></p> <p>(1)</p> <p>根据定义证明\\((A^{\\circ})^{\\circ}=A^{\\circ}\\)，利用距离函数可知集合内部是其上每一点的邻域:\\(\\forall x\\in A^{\\circ},V(x,\\varepsilon)\\)上任取一点\\(x_{0}\\)，再选择一个邻域\\(V(x_{0},\\varepsilon-d(x,x_{0}))\\)上的点记为\\(y\\)，那么有三角不等式\\(d(x,y)\\leqslant d(x,x_{0})+d(x_{0},y)&lt;\\varepsilon\\),证毕。</p> <p>那么对于A内部上的任意点，选择比原本含于A的开邻域更小的邻域即可含于A的内部，也就是内部的内部仍然为内部，等价为\\(A^{\\circ}\\)是开集</p> <p>(2)</p> <p>反证法，假设存在\\(x\\not\\in \\partial A,\\forall V(x,\\varepsilon),V(x,\\varepsilon)\\bigcap \\partial A \\neq \\emptyset\\)，目标是导出\\(x\\in \\partial A\\)</p> <p>分类讨论，\\(x\\in A\\)时，\\(\\forall\\varepsilon,V(x,\\varepsilon)\\bigcap A\\neq \\emptyset\\)，再根据假设条件\\(V\\left( x,\\frac{\\varepsilon}{2} \\right)\\bigcap \\partial A\\neq \\emptyset,\\exists x_{1}\\in V\\left( x, \\frac{\\varepsilon}{2} \\right)\\)且\\(x_{1}\\in \\partial A\\)，那么根据定义有\\(V\\left( x_{1}, \\frac{\\varepsilon}{2} \\right)\\bigcap A^{c}\\neq \\emptyset,\\exists x_{2}\\in V\\left( x_{1}, \\frac{\\varepsilon}{2} \\right)\\bigcap A^{c},d(x,x_{2})\\leqslant d(x,x_{1})+d(x_{1},x_{2})&lt;\\varepsilon\\)，也就是\\(x_{2}\\in V(x,\\varepsilon),V(x,\\varepsilon)\\bigcap A^{c}\\neq \\emptyset\\)，再根据\\(\\varepsilon\\)的任意性得到\\(x\\in \\partial A\\)</p> <p>同理可得\\(x\\in A^{c}\\)时也有\\(x\\in \\partial A\\)，综上所述矛盾，\\(\\partial A=\\overline{\\partial A}\\)，\\(\\partial A\\)是闭集</p> <p>(3)</p> <p>考虑证明\\(\\overline{A}^{c}\\)是开的，\\(\\forall x\\in \\overline{A}^{c},x\\not\\in A,\\exists V(x,\\varepsilon)\\bigcap A\\neq \\emptyset\\)，还需证明\\(V(x,\\varepsilon)\\bigcap  \\overline{A}=\\emptyset\\)，若是不然，与A的闭包有交，记交点为\\(x_{1}\\)，闭包与A交非空， 那么取\\(d=\\varepsilon-d(x,x_{1}),V(x_{1},d)\\bigcap A\\neq \\emptyset\\)，记交点为\\(x_{2}\\in A\\)，\\(d(x,x_{2})&lt;\\varepsilon,x\\in A'\\subset  \\overline{A}\\),矛盾，所以\\(\\overline{A}\\)是闭集</p> <p>(4)</p> <p>同样考虑\\(\\left( A' \\right)^{c},\\forall x\\in \\left( A' \\right)^{c}\\)，\\(\\exists V(x,\\varepsilon)\\)，\\(x\\in A\\)时\\(V(x,\\varepsilon)\\bigcap A=\\left\\{ x \\right\\}\\)，\\(x\\not\\in A\\)时\\(V(x,\\varepsilon)\\bigcap A=\\emptyset\\)，欲证\\(\\exists V(x,\\varepsilon)\\bigcap A'=\\emptyset\\)，反证不然，\\(\\forall \\varepsilon,V(x,\\varepsilon)\\bigcap A'\\neq \\emptyset\\)，不妨记为\\(x_{1}\\)，方便起见取\\(\\varepsilon'= \\frac{\\varepsilon}{2},x_{1}\\in V(x,\\varepsilon')\\)，由于\\(x_{1}\\in A',V\\left( x_{1},\\varepsilon'= \\frac{\\varepsilon}{2} \\right)\\bigcap A\\neq \\emptyset\\)，交点记为\\(x_{2}\\neq x_{1}\\)，那么\\(x_{2}\\in V(x,\\varepsilon)\\)，\\(V(x,\\varepsilon)\\)与A有异于\\(x\\)的交点，故矛盾，\\(\\left( A' \\right)^{c}\\)是开集，取补集知结论成立</p> <p>[!question] 10.1 6 设\\(\\{X_m\\}\\)为\\(\\mathbb{R}^n\\)中的点列且\\(\\{X_m\\}\\)的任何子序列均在\\(\\mathbb{R}^n\\)中不收敛，求证：\\(\\lim\\limits_{m\\to\\infty}|X_m|=+\\infty.\\)</p> <p><code>Proof.</code></p> <p>反证，有界，根据Bolzano-Weierstrass定理(聚点定理)可知有界点列必有聚点即收敛子列，可知与无收敛子列矛盾，所以\\(\\lim\\limits_{ m \\to \\infty }\\lvert X_{m} \\rvert= +\\infty\\)</p>","path":["Analysis","Mathematical Analysis","南开大学数学分析课本答案","多元函数的极限与连续_NKU(答案)"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/","level":1,"title":"实分析(Real Analysis)","text":"<p>主要存放学习实分析时阅读教材的笔记包括课程笔记和读书笔记</p>","path":["实分析(Real Analysis)"],"tags":["Analysis","Real Analysis"]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/#reference","level":2,"title":"Reference","text":"<ul> <li>《实变函数》 周性伟 南开大学编写</li> <li>《实变函数论》 周民强 北京大学</li> <li>《Real Analysis》 Folland</li> <li>《Real Analysis》 Stein</li> </ul>","path":["实分析(Real Analysis)"],"tags":["Analysis","Real Analysis"]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/#_1","level":2,"title":"课程笔记","text":"","path":["实分析(Real Analysis)"],"tags":["Analysis","Real Analysis"]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/#1","level":3,"title":"第1章 集合与实数集","text":"","path":["实分析(Real Analysis)"],"tags":["Analysis","Real Analysis"]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E5%91%A8%E6%80%A7%E4%BC%9F-Ch1/","level":1,"title":"周性伟-Ch1","text":"","path":["周性伟-Ch1"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E5%91%A8%E6%80%A7%E4%BC%9F-Ch1/#1-10","level":2,"title":"1-10","text":"<p>[!question] Ch1 1 证明定理1.1.1、1.1.3、1.1.4</p> <p><code>Proof.</code></p> <p>定理1.1.1 (i)\\(A\\subset A\\),(ii)\\(A\\subset B,B\\subset C\\implies A\\subset C\\)</p> <p>按照集合包含的定义\\(x\\in A\\implies x\\in A,x\\in A\\implies x\\in B\\implies x\\in C\\)</p> <p>定理1.1.3 \\(\\left\\{ A_{\\lambda},\\lambda\\in\\Lambda \\right\\},\\left( \\bigcup A_{\\lambda} \\right)^{c}=\\bigcap A_{\\lambda}^{c},\\left( \\bigcap A_{\\lambda} \\right)^{c}=\\bigcup A_{\\lambda}^{c}\\)</p> \\[ \\begin{aligned} x\\in\\left( \\bigcup A_{\\lambda} \\right)^{c}&amp;\\iff x\\not\\in \\bigcup A_{\\lambda}\\\\ &amp;\\iff\\forall\\lambda,x\\not\\in A_{\\lambda}(x\\in A_{\\lambda}^{c})\\\\ &amp;\\iff x\\in \\bigcap A_{\\lambda}^{c} \\end{aligned} \\] <p>定理1.1.4 (i)\\(A\\Delta B=\\left( A\\bigcup B \\right)-\\left( A\\bigcap B \\right)\\)</p> \\[ \\begin{aligned} A\\Delta B=(A-B)\\bigcup(B-A)&amp;\\iff x\\in A,x\\not\\in B;x\\in B,x\\not\\in A\\\\ &amp;\\iff x\\not\\in A\\bigcap B,x \\in A\\bigcup B \\end{aligned} \\] <p>(ii)\\(A\\Delta B=B\\Delta A\\) 根据定义是显然的</p> <p>[!Question] Ch1 2 求证： (i) \\(A-B=A\\bigcap B^{c}=B^{c}-A^{c}\\) (ii) \\(\\bigcup\\limits_{n=1}^{\\infty}A_{n}-\\bigcup\\limits_{n=1}^{\\infty}B_{n}\\subset \\bigcup\\limits_{n=1}^{\\infty}(A_{n}-B_{n})\\) (iii)\\(\\bigcup\\limits_{n=1}^{\\infty}\\left( A-A_{n} \\right)=A-\\bigcap\\limits_{n=1}^{\\infty}A_{n}\\) (iv)\\(A_{1}\\times B_{1}-A_{2}\\times B_{2}=\\left[ \\left( A_{1}-A_{2} \\right)\\times B_{1} \\right]\\bigcup\\left[  A_{1}\\times\\left( B_{1}-B_{2} \\right) \\right]\\)</p> <p><code>Proof.</code></p> <p>(i):</p> \\[x\\in A-B\\implies x \\in A,x\\not\\in B\\iff x\\in A,x \\in B^{c}\\iff x \\in A\\bigcap B^{c}\\] <p>剩余同理</p> <p>(ii):</p> \\[ \\begin{aligned} x \\in \\bigcup\\limits_{n=1}^{\\infty} A_{n}-\\bigcup\\limits_{n=1}^{\\infty} B_{n}&amp;\\iff x\\in \\bigcup\\limits_{n=1}^{\\infty} A_{n} ,x\\not\\in \\bigcup\\limits_{n=1}^{\\infty} B_{n}\\\\ &amp;\\iff \\exists m,x\\in A_{m},\\forall n,x\\not\\in B_{n}\\\\ &amp;\\iff x\\in A_{m}-B_{m}\\\\ &amp;\\iff x\\in \\bigcup\\limits_{n=1}^{\\infty} (A_{n}-B_{n}) \\end{aligned} \\] <p>(iii):</p> <p>\\(\\forall x\\in A-\\bigcap\\limits_{n=1}^{\\infty}A_{n}\\)，\\(x \\not\\in \\bigcap\\limits_{n=1}^{\\infty}A_{n}\\implies\\exists k,x \\not\\in A_{k,} s.t.x\\in A-A_{k}\\)，得\\(x\\in \\bigcup\\limits_{n=1}^{\\infty}\\left( A-A_{n} \\right)\\),\\(LHS\\supset RHS\\)</p> <p>\\(\\forall x\\in \\bigcup\\limits_{n=1}^{\\infty}\\left( A-A_{n} \\right)\\implies\\exists k,x\\in A-A_{k}\\)，而\\(\\left( A-A_{k} \\right)\\subset A-\\bigcap\\limits_{n=1}^{\\infty}A_{n}\\)，\\(LHS\\subset RHS\\)</p> <p>综上所述：\\(\\bigcup\\limits_{n=1}^{\\infty}\\left( A-A_{n} \\right)=A-\\bigcap\\limits_{n=1}^{\\infty}A_{n}\\)</p> <p>(iv):</p> <p>\\((x,y)\\in(A_{1}-A_{2})\\times B_{1}\\subset A_{1}\\times B_{1},x \\not\\in A_{2},(x,y) \\not\\in A_{2}\\times B_{2},(x,y)\\in A_{1}\\times B_{1}-A_{2}\\times B_{2}\\)，同理可知另一侧也成立，即得\\(LHS \\supset RHS\\)</p> <p>若是\\((x,y)\\in A_{1}\\times B_{1}-A_{2}\\times B_{2}\\)，选择对\\(x\\)进行讨论： 假设若是\\(x\\in A_{2}\\implies y \\not\\in B_{2}\\)，相应的有\\((x,y)\\in A_{1}\\times \\left( B_{1}-B_{2} \\right)\\)，反之\\(x \\not\\in A_{2}\\)，则也有\\(x \\in \\left( A_{1}-A_{2} \\right)\\times B_{1}\\)，可以得出：\\(LHS \\subset RHS\\)</p> <p>综上所述：\\(A_{1}\\times B_{1}-A_{2}\\times B_{2}=\\left[ \\left( A_{1}-A_{2} \\right)\\times B_{1} \\right]\\bigcup\\left[  A_{1}\\times\\left( B_{1}-B_{2} \\right) \\right]\\)</p> <p>[!question] Ch1 3 设\\(f(x)\\)和\\(f_{n}(x)(n\\geqslant 1)\\)都是\\(\\mathbb{R}\\)上的实函数，求证：</p> \\[\\left\\{ x:\\lim\\limits_{ n \\to \\infty } f_{n}(x)=f(x) \\right\\}=\\bigcap\\limits_{r=1}^{\\infty} \\bigcup\\limits_{n=1}^{\\infty} \\bigcap\\limits_{k=n}^{\\infty} \\left\\{ x:\\lvert f_{k}(x)-f(x) \\rvert &lt; \\frac{1}{r} \\right\\}   \\] <p><code>Proof.</code></p> <p>根据连续的定义书写即可：将交翻译为任意，将并翻译为存在</p> <p>\\(\\forall r,\\exists n\\geqslant 1,\\forall k \\geqslant n, \\lvert f_{k}(x)-f(x) \\rvert&lt; \\frac{1}{r}\\)</p> <p>而对于连续的定义\\(\\varepsilon&gt;0,\\exists r,s.t. \\frac{1}{r}&lt;\\varepsilon\\)</p> <p>注：这个题目实际是相当重要的，蕴含了集合分解和集合表示的思想，还给出了并和交隐含的存在与任意的技巧.</p> <p>[!question] Ch1 4 证明： (i)对任何集\\(A\\)和\\(B\\)，必有集\\(C\\)，使\\(A\\Delta C=B\\) (ii)\\(A\\Delta(B\\Delta C)=(A\\Delta B)\\Delta C\\) (iii)\\(A_{1}\\Delta A_{2}\\Delta\\dots\\Delta A_{n}=\\left\\{ x:x\\text{属于且仅属于}\\left\\{ A_{k} \\right\\}_{1\\leqslant k \\leqslant n}\\text{中奇数个}A_{k} \\right\\}\\)</p> <p><code>Proof.</code></p> <p>(i)这个构造实际上可以通过Venn图分析得到</p> <p>注意到\\(A\\Delta A=\\emptyset,\\emptyset\\Delta A=A\\implies C=A\\Delta B\\)</p> <p>(ii)这个只需要集合表示一下就行</p> \\[ \\begin{aligned} x\\in(A\\Delta B)\\Delta C&amp;\\iff x\\in A\\Delta B-C,x\\in C-A\\Delta B\\\\ &amp;\\iff x\\in A,x\\not\\in B,x\\not\\in C;x \\in B,x\\not\\in A,x\\not\\in C;\\\\ &amp;+x\\in C-A\\Delta B\\left( x\\in C,x\\not\\in A,x\\not\\in B;x\\in \\bigcap A \\right)\\\\ &amp;\\iff x\\in A\\Delta(B\\Delta C) \\end{aligned} \\] <p>(iii)可以使用归纳法</p> <p>\\(n=1,n=2\\)，可以将目标转变为\\(x\\in(A_{1}\\Delta\\dots\\Delta A_{n-1})\\Delta A_{n}\\)，这样我们就可以运用归纳的结果了，若\\(x\\in(A_{1}\\Delta\\dots\\Delta A_{n-1}),x\\not\\in A_{n}\\)，由归纳假设只属于前面的奇数个项，而另一种情况只属于\\(A_{n}\\)和前面的偶数个项相加知道也是奇数情况，由此可得结论成立.</p> <p>[!question] Ch1 5 设\\(\\left\\{ A_{n} \\right\\}_{n\\geq_{1}}\\)是一个集列，令\\(B_{1}=A_{1},B_{n}=A_{n}-\\bigcup\\limits_{k=1}^{n-1}A_{k},n\\geq 2\\) 求证：\\(\\left\\{ B_{n} \\right\\}_{n\\geq{1}}\\)两两不相交且\\(\\bigcup\\limits_{n=1}^{\\infty}B_{n}=\\bigcup\\limits_{n=1}^{\\infty}A_{n}\\)</p> <p><code>Proof.</code></p> <p>先证明两两不相交，假设\\(B_{m},B_{n},m&lt;n\\)，若其中\\(m=1\\)，显然有\\(x\\in B_{n}(n \\geq 2),x \\not\\in A_{1}=B_{1}\\)</p> <p>若\\(m \\neq 1\\)，对于\\(B_{m}=A_{m}-\\bigcup\\limits_{k=1}^{m-1}A_{k},B_{n}=A_{n}-\\bigcup\\limits_{k=1}^{n-1}A_{k},\\bigcup\\limits_{k=1}^{m-1}A_{k}\\subset \\bigcup\\limits_{k=1}^{n-1}A_{k}\\)，假设存在\\(y\\in B_{m}\\bigcap B_{n},y\\in B_{n},y \\not\\in \\bigcup\\limits_{k=1}^{n-1}A_{k},y \\not\\in A_{m}(m&lt;n)\\implies y \\not\\in B_{m}\\)，矛盾，所以两两不相交，这是极其显然的.</p> <p>再证明\\(\\bigcup\\limits_{n=1}^{\\infty}B_{n}=\\bigcup\\limits_{n=1}^{\\infty}A_{n}\\)</p> <p>首先根据\\(B_{n}\\subset A_{n}\\implies \\bigcup\\limits_{n=1}^{\\infty}B_{n}\\subset \\bigcup\\limits_{n=1}^{\\infty}A_{n}\\)</p> \\[\\begin{aligned} x\\in \\bigcup\\limits_{n=1}^{\\infty}B_{n},\\exists k,x\\in B_{k}&amp;=A_{k}-\\bigcup\\limits_{n=1}^{k-1}A_{n} \\\\ &amp;\\implies x\\in A_{k}\\subset \\bigcup\\limits_{n=1}^{\\infty}A_{n}\\\\ &amp;\\implies\\bigcup\\limits_{n=1}^{\\infty}B_{n}\\subset\\bigcup\\limits_{n=1}^{\\infty}A_{n} \\end{aligned}\\] <p>同理若是\\(x\\in \\bigcup\\limits_{n=1}^{\\infty}A_{n},\\exists k,x\\in A_{k}\\)，构造一个集合\\(S=\\left\\{ n:x\\in A_{n} \\right\\}\\)，已知该集合非空，那么根据非空集合必有最小元素的性质，将最小元素记为\\(m\\)，</p> <p>那么\\(x\\in B_{m}=A_{m}-\\bigcup\\limits_{n=1}^{m-1}A_{n}\\implies x\\in \\bigcup\\limits_{n=1}^{\\infty}B_{n}\\implies\\bigcup\\limits_{n=1}^{\\infty}B_{n}\\supset\\bigcup\\limits_{n=1}^{\\infty}A_{n}\\)</p> <p>或者也可以用下面这种写法</p> \\[ \\begin{aligned} \\bigcup\\limits_{k=1}^{n} A_{k}&amp;=A_{1}\\bigcup A_{2}\\bigcup\\dots \\bigcup A_{n}\\\\ &amp;=A_{1}\\bigcup(A_{2}-A_{1})\\bigcup\\dots \\bigcup\\left( A_{n}-\\bigcup\\limits_{k=1}^{n-1} A_{k} \\right)\\\\ &amp;=\\bigcup\\limits_{k=1}^{n} B_{k} \\end{aligned} \\] <p>两边\\(n\\)同时取无穷也可以得到</p> <p>综上所述：\\(\\bigcup\\limits_{n=1}^{\\infty}B_{n}=\\bigcup\\limits_{n=1}^{\\infty}A_{n}\\)</p> <p>[!question] Ch1 6 设\\(\\left\\{ A_{n} \\right\\}\\)是一列集合.求证： (i)\\(\\chi_{\\varlimsup\\limits_{n\\to \\infty}A_{n}}(x)=\\varlimsup\\limits_{ n \\to \\infty }\\chi_{A_{n}}(x)\\) (ii)\\(\\chi_{\\varliminf\\limits_{n\\to \\infty}A_{n}}(x)=\\varliminf\\limits_{ n \\to \\infty }\\chi_{A_{n}}(x)\\)</p> <p><code>Proof.</code></p> <p>(i):</p> <p>根据上极限的定义可知，\\(\\varlimsup\\limits_{ n \\to \\infty }A_{n}=\\bigcap\\limits_{i=1}^{\\infty}\\bigcup\\limits_{n=i}^{\\infty}A_{n}\\)，无穷多个集合含有其中元素. 若\\(x\\in \\varlimsup\\limits_{ n \\to \\infty }A_{n}(\\chi_{\\varlimsup\\limits_{ n \\to \\infty }A_{n}}(x)=1),\\forall N,\\exists n,n&gt;N\\implies \\chi_{A_{n}}(x)=1，\\varlimsup\\limits_{ n \\to \\infty }\\chi_{A_{n}}(x)=1=\\chi_{\\varlimsup\\limits_{ n \\to \\infty }A_{n}}(x)\\) 若\\(x\\notin \\varlimsup\\limits_{ n \\to \\infty }A_{n}(\\chi_{\\varlimsup\\limits_{ n \\to \\infty }A_{n}}(x)=0)\\)，只有有限多个集合含有\\(x\\),那么\\(\\varliminf\\limits_{ n \\to \\infty }\\chi_{A_{n}}(x)=0=\\chi_{\\varlimsup\\limits_{ n \\to \\infty }A_{n}}(x)\\) 综上所述：证得\\(\\chi_{\\varlimsup\\limits_{n\\to \\infty}A_{n}}(x)=\\varlimsup\\limits_{ n \\to \\infty }\\chi_{A_{n}}(x)\\)</p> <p>(ii):</p> <p>根据下极限的定义可知，\\(\\varliminf\\limits_{ n \\to \\infty }A_{n}=\\bigcup\\limits_{i=1}^{\\infty}\\bigcap\\limits_{n=i}^{\\infty}A_{n}\\)，只有有限个集合不含有其中元素. 若\\(x\\in \\varliminf\\limits_{ n \\to \\infty }A_{n}(\\chi_{\\varliminf\\limits_{ n \\to \\infty }A_{n}}(x)=1),\\exists N,n&gt;N\\implies \\chi_{A_{n}}(x)=1，\\varliminf\\limits_{ n \\to \\infty }\\chi_{A_{n}}(x)=1=\\chi_{\\varliminf\\limits_{ n \\to \\infty }A_{n}}(x)\\) 若\\(x\\notin \\varliminf\\limits_{ n \\to \\infty }A_{n}(\\chi_{\\varliminf\\limits_{ n \\to \\infty }A_{n}}(x)=0)\\)，有无穷多个集合不含有\\(x\\)，那么\\(\\varliminf\\limits_{ n \\to \\infty }\\chi_{A_{n}}(x)=0=\\chi_{\\varliminf\\limits_{ n \\to \\infty }A_{n}}(x)\\) 综上所述：证得\\(\\chi_{\\varliminf\\limits_{n\\to \\infty}A_{n}}(x)=\\varliminf\\limits_{ n \\to \\infty }\\chi_{A_{n}}(x)\\)</p> <p>[!question] Ch1 7 设映射\\(f:X\\to Y\\)，求证： (i)若\\(A \\subset X\\), 则\\(A \\subset f^{-1}[f(A)]\\), 并且当\\(f\\)为一一映射时\\(A=f^{-1}[f(A)]\\); (ii)若\\(B\\subset Y\\)，则\\(f\\left[ f^{-1}(B) \\right]=B\\bigcap f(X)\\)且\\(f^{-1}(B^{c})=\\left[ f^{-1}(B) \\right]^{c}\\) (iii)当且仅当\\(f\\)为一一映射时，对任何\\(A,B\\subset X\\)有\\(f\\left( A\\bigcap B \\right)=f(A)\\bigcap f(B)\\) (iv)当且仅当\\(f\\)为完全一一映射时, 对任何\\(A \\subset X\\)有\\(f\\left(A^{c}\\right)=\\left[f(A)\\right]^{c}\\).</p> <p><code>Proof.</code></p> <p>(i):</p> <p>\\(x\\in A,f(x)\\in f(A)\\implies x\\in f^{-1}\\left( f(A) \\right)\\implies A\\subset f^{-1}[f(A)]\\)</p> <p>反证若是\\(A\\subset f^{-1}[f(A)],A\\neq f^{-1}[f(A)],\\exists y\\in f^{-1}[f(A)]-A\\)</p> <p>从而有\\(f(y) \\in f(A)\\implies \\exists x\\in A,f(x)\\in f(A)\\implies y=x\\)即得矛盾</p> <p>(ii):</p> <p>先证明\\(f\\left[ f^{-1}(B) \\right]=B\\bigcap f(X)\\):</p> <p>取任意\\(y\\in f\\left[ f^{-1}(B) \\right]\\)，存在\\(x\\in f^{-1}(B),f(x)=y\\implies f(x)\\in B ,y\\in B\\)</p> <p>同时有\\(x\\in X,y\\in f(X)\\),那么得到\\(f\\left[ f^{-1}(B) \\right]\\subset B\\bigcap f(X)\\)</p> <p>相应的，\\(y\\in B \\bigcap f(X) \\implies \\exists x\\in X,f(x)=y\\in B,x=f^{-1}(B)\\)，因此\\(y=f(x)\\in\\left[ f^{-1}(B) \\right]\\)</p> <p>那么得到\\(f\\left[ f^{-1}(B) \\right]\\supset B\\bigcap f(X)\\)</p> <p>综上所述：\\(f\\left[ f^{-1}(B) \\right]=B\\bigcap f(X)\\)</p> <p>再证明\\(f^{-1}(B^{c})=\\left[ f^{-1}(B) \\right]^{c}\\):</p> <p>取任意\\(x\\in f^{-1}(B^{c}),f(x)\\in B^{c}(f(x)\\not\\in B)\\implies x\\not\\in f^{-1}(B),x\\in \\left[ f^{-1}(B) \\right]^{c}\\)，即\\(f^{-1}(B^{c})\\subset\\left[ f^{-1}(B) \\right]^{c}\\)，相应的取\\(x\\in \\left[ f^{-1}(B) \\right]^{c},x \\not\\in f^{-1}(B),f(x)\\not\\in B\\implies f(x)\\in B^{c},x\\in f^{-1}(B^{c})\\)，即\\(f^{-1}(B^{c})\\supset\\left[ f^{-1}(B) \\right]^{c}\\)</p> <p>综上所述：\\(f^{-1}(B^{c})=\\left[ f^{-1}(B) \\right]^{c}\\)</p> <p>(iii):</p> <p>必要性证明：</p> <p>已知\\(f\\)为一一映射,当\\(x\\in A\\bigcap B,f(x)\\in f(A),f(x)\\in f(B),f\\left( A\\bigcap B \\right)\\subset f(A)\\bigcap f(B)\\).</p> <p>任取\\(y\\in f(A)\\bigcap f(B),\\exists a\\in A,b\\in B,s.t.f(a)=y,f(b)=y\\)，又根据单射的定义，得\\(a=b\\in A\\bigcap B\\)</p> <p>综上所述：\\(f\\left( A\\bigcap B \\right)=f(A)\\bigcap f(B)\\)</p> <p>充分性证明：</p> <p>反证法，若不是一一映射假设存在\\(x_{1}\\neq x_{2}\\),使得\\(f(x_{1})=f(x_{2})=C\\)， 构造\\(A=\\left\\{ x_{1} \\right\\},B=\\left\\{ x_{2} \\right\\}\\)，根据题设\\(f\\left( A\\bigcap B \\right)=f(\\emptyset)=\\emptyset\\neq f(A)\\bigcap f(B)=C\\)，矛盾，\\(f\\)为单射</p> <p>综上所述:当且仅当\\(f\\)为一一映射时，对任何\\(A,B\\subset X\\)有\\(f\\left( A\\bigcap B \\right)=f(A)\\bigcap f(B)\\)</p> <p>(iv):</p> <p>\\(x\\in A^{c},f(x)\\not\\in f(A)\\)，否则有\\(y\\in A,f(x)=f(y)\\implies x=y\\)矛盾，也就是\\(f(A^{c})\\subset[f(A)]^{c}\\)，由于是双射可以考虑\\(f^{-1}\\)，\\(f(x)\\not\\in f(A),x\\not\\in A^{c}\\)即得\\(f(A^{c})\\supset[f(A)]^{c}\\)</p> <p>再证明另一侧，取\\(A=X,f(A)^{c}=\\emptyset,f(A)=Y\\)，这步证明了满性，取\\(y\\neq x,A=\\left\\{ x \\right\\},y\\in A^{c}\\)，因此由\\(f(A^{c})=f(A)^{c}\\implies f(y)\\in f(A)^{c}\\implies f(y)\\neq f(x)\\)，这就证明了单性，综上所述可知双射.</p> <p>注：很容易把自己绕晕，可以多看看，尤其是对于任意的条件通过取不同集合证明不同的条件可以积累取特殊集合的技巧.</p> <p>[!Question] Ch1 8 设\\(f\\) 是 \\(\\mathbb{R}\\)上的实函数.若有 \\(M &gt;0\\)，使对任何有限个两两不等的实数 \\(x_1,\\dots,x_{n}\\)有\\(\\left\\lvert  \\sum\\limits_{k=1}^{n}f(x_{k})  \\right\\rvert\\le M\\). 求证:\\(\\left\\{ x:f(x) \\neq 0 \\right\\}\\)是至多可数集.</p> <p><code>Proof.</code></p> <p>反证法，假设\\(\\left\\{ x:f(x) \\neq 0 \\right\\}\\)并非至多可数，那么根据\\(\\left\\{ x:f(x) \\neq 0 \\right\\}=\\bigcup\\limits_{n=1}^{\\infty}\\left\\{ x:\\lvert f(x) \\rvert &gt; \\frac{1}{n} \\right\\}\\)</p> <p>其中必有一个不可数集，否则可数个至多可数集的并仍是至多可数集，与假设矛盾</p> <p>不妨设\\(\\left\\{ x:\\lvert f(x) \\rvert&gt; \\frac{1}{k} \\right\\}\\)是不可数集，那么再将集合分解为\\(\\left\\{ x: f(x)&gt; \\frac{1}{k} \\right\\}\\bigcup\\left\\{ x: f(x) &lt; -\\frac{1}{k} \\right\\}\\)，其中一定有一个不可数集，否则两个至多可数集的并仍是至多可数集，矛盾.</p> <p>不妨设\\(\\left\\{ x: f(x) &gt; \\frac{1}{k} \\right\\}\\)是不可数集，从中选取出一个可数子集记为\\(A\\)，再从\\(A\\)中选择\\([kM]+1\\)个元素，\\(\\left\\lvert  \\sum\\limits_{i=1}^{[kM]+1}f(x_{i})  \\right\\rvert&gt;kM \\cdot \\frac{1}{k}=M\\)</p> <p>得到矛盾，那么得证\\(\\left\\{ x:f(x)\\neq 0 \\right\\}\\)是至多可数集</p> <p>注：这里也运用了集合分解的技术，导出矛盾的思路是，固定一个\\(\\frac{1}{k}\\)然后才能通过题目给出的有限个条件制造出一个大于\\(M\\)的数</p> <p>[!question] Ch1 9 求证:\\(\\mathbb{R}\\)上单调函数的间断点是至多可数的.</p> <p><code>Proof.</code></p> <p>由于是\\(\\mathbb{R}\\)上单调函数\\(f\\)应当是单射，那么不妨先设单调递增，由此可知两边极限存在，任意选择\\(\\mathbb{R}\\)上的一个间断点记为\\(x_{0}\\)，那么根据函数的单调性知道\\(f(x_{0}^{-})\\le f(x_{0}^{+})\\)，如果不等那么取\\((f(x_{0}^{-}),f(x_{0}^{+}))\\)中的一个有理点\\(q_{x_{0}}\\)，如果相等也就是可去间断点取\\(f(x_{0}^{-})\\)的小邻域内的有理数，这样就构成了间断点和有理数的一个单射，而全体有理数是至多可数的，那么间断点也一定是至多可数的.</p> <p>[!question] Ch1 10 设\\(f\\)是\\([a,b]\\)上单增实值函数，\\(f([a,b])\\)是区间\\([f(a),f(b)]\\)的稠子集，求证：\\(f\\)连续.</p> <p><code>Proof.</code></p> <p>反证法，假设\\(f\\)有不连续点，那么设存在不连续点\\(x_{0}(x_{0}\\in [a,b])\\)，使得\\(f(x_{0}^{-})&lt;f(x_{0}^{+})\\),若是端点则选取单侧极限。 由于\\(f([a,b])\\)是区间\\([f(a),f(b)]\\)的稠子集，\\(\\forall I\\subset f([a,b]),I\\bigcap [f(a),f(b)]\\neq \\emptyset\\)，然而取\\(\\left( f(x_{0}^{-}),f(x_{0}^{+}) \\right)\\)，有\\(\\left( f(x_{0}^{-}),f(x_{0}^{+}) \\right)\\subset \\left[ f(a),f(b) \\right]\\)，因为单调递增有\\(f(a)\\leqslant f(x_{0}^{-})\\leqslant f(x_{0}^{+})\\leqslant f(b)\\).但是\\(f([a,b])\\bigcap(f(x_{0}^{-}),f(x_{0}^{+}))=\\emptyset\\)，所以矛盾，得知假设不成立，\\(f\\)连续</p>","path":["周性伟-Ch1"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E5%91%A8%E6%80%A7%E4%BC%9F-Ch1/#11-20","level":2,"title":"11-20","text":"<p>[!question] Ch1 11 若\\(A_{2} \\subset A_{1}, B_{2} \\subset B_{1}, A_{2} \\sim B_{2}, A_{1} \\sim B_{1}\\), 试问是否必有 \\(A_{1}-A_{2} \\sim B_{1}-B_{2}\\) ?</p> <p><code>Sol.</code></p> <p>构造思路：可以考虑\\(A_{1}=A_{2}\\)这样就可以使\\(A_{1}-A_{2}=\\emptyset\\)，然后使得\\(B_{1}-B_{2}\\neq \\emptyset\\)即可</p> <p>令\\(A_{1}=A_{2}=\\mathbb{Q},B_{2}=\\mathbb{Z},B_{1}=\\mathbb{Q}\\)</p> <p>注：经典的反例题，可以适当积累一下</p> <p>[!question] Ch1 12 求证: 有限个可数集的直积是可数集. (无限个可数集呢?)</p> <p><code>Proof.</code></p> <p>不妨设可数集为\\(\\mathbb{Q}\\)，只需要证明\\(\\mathbb{Q}^{2}\\)后续使用归纳法，\\(\\mathbb{Q}^{n}=\\mathbb{Q}^{n-1}\\times \\mathbb{Q}\\)</p> <p>我们知道\\(\\mathbb{Q}\\times \\mathbb{Q}=\\bigcup\\limits_{k=1}^{\\infty}\\mathbb{Q}\\times \\left\\{ r_{k} \\right\\},\\mathbb{Q}=\\left\\{ r_{1},r_{2},\\dots,r_{n}\\dots \\right\\}\\)</p> <p>这样可以得到一个至多可数集，而可数集的可数并是可数的</p> <p>至于无限个可数集，反例是容易举的，例如可数个整数集就相当于是\\(n\\)元数列全体的一个超集，而\\(n\\)元数列全体是具有连续统势的，所以应当不可数(即便是可数无穷也无法可数)</p> <p>[!question] Ch1 13 例 设实数集\\(E\\)不可数. 求证: 有\\(x\\), 使对任何\\(\\delta&gt;0, E \\cap(x-\\delta, x+\\delta)\\)不可数.</p> <p><code>Proof.</code></p> <p>用反证法. 不然对任何 \\(x \\in E\\), 必有 \\(\\delta_{x}&gt;0\\) 使 \\(E \\cap\\left(x-\\delta_{x}, x+\\delta_{x}\\right)\\) 至多可数. 从而对每一 \\(x \\in E\\), 必有满足 \\(r_{x}&lt;x&lt;r_{x}\\) 的有理数 \\(r_{x}\\) 和 \\(R_{x}\\), 使 \\(E \\cap\\left(r_{x}, R_{x}\\right)\\) 至多可数. 由题 12, \\(\\left\\{\\left(r_{x}, R_{x}\\right)\\right\\}_{x \\in E}\\) 中至多只有可数个开区间. 从而 \\(E=\\bigcup_{x \\in E}\\left[E \\cap\\left(r_{x}, R_{x}\\right)\\right]\\) 是一个至多可数集, 此与题设矛盾.</p> <p>注：很重要的题目，需要掌握取有理数这种证明手法，与之相关的题可以结合起来看如14，</p> <p>[!question] Ch1 14 求证：\\(E\\)中满足题13中条件的点\\(x\\)的全体是不可数集</p> <p><code>Proof.</code></p> <p>反证法，假设满足条件的全体为至多可数集，记为\\(A\\)</p> <p>那么对于\\(x\\in E-A\\)，利用条件，存在\\(\\delta_{x}&gt;0,s.t.E\\bigcap \\left( x-\\delta_{x},x+\\delta_{x} \\right)\\)至多可数，可以找到有理数\\(r_{x}\\)和\\(R_{x}\\)使得\\(r_{x}&lt;x&lt;R_{x}\\)，并且\\(E\\bigcap \\left( r_{x},R_{x} \\right)\\)至多可数，并且区间端点为有理数的区间只有至多可数个</p> <p>那么利用\\(E=A\\bigcup \\left( E-A \\right)\\)，并且\\(E-A=\\bigcup\\limits_{x\\in E-A}E\\bigcap \\left( r_{x},R_{x} \\right)\\)是至多可数集(至多可数个至多可数集的并还是至多可数集)，由假设得\\(A\\)是可数集，因此\\(E\\)也是至多可数集，与原题设矛盾</p> <p>综上：\\(A\\)是不可数集</p> <p>[!question] Ch1 15 设\\(\\{x_{n}\\}_{n\\geqslant 1}\\)是可数个实数. 试具体写出一个单增函数\\(f\\), 它以\\(\\{x_{n}\\}_{n\\geqslant 1}\\)为其间断点全体.</p> <p><code>Sol.</code></p> <p>考虑收敛级数\\(\\sum\\limits \\frac{1}{n^{2}}\\)，那么定义\\(f(x)=\\sum\\limits_{n:x_{n}&lt;x} \\frac{1}{n^{2}}\\)</p> <p>显然的有\\(f(x_{n_{0}}^{+})-f(x_{n_{0}})= \\frac{1}{n_{0}^{2}}\\)</p> <p>注1：这个构造比较巧妙，但是我想应当也可以给出一个解释，要想构造单增函数并且还需要以\\(x_{n}\\)为间断点，很自然会想到阶梯函数(经验分布函数！)所以下面这种构造实际是有道理的，并且为了避免溢出我们最好选择收敛的级数.</p> <p>注2：显然的构造方式不止这一种，但是需要注意的是不太能做到为\\(x_{n}\\)排序并且选取最小的那个，因为很有可能涉及无穷操作，这种证明是危险的.</p> <p>[!question] Ch1 16 证明:\\(\\mathbb{R}\\)上的实函数\\(f\\)的第一类间断点(即左右极限存在有限的间断点)是至多可数的.</p> <p>[!TIP]+ Hint 证明\\(\\left\\{ x:\\lvert f(x)-f(x^{+}) \\rvert&gt; \\frac{1}{n} \\right\\}\\)是至多可数集</p> <p><code>Proof.</code></p> <p>先明确研究目标：\\(\\left\\{ x:\\lvert f(x)-f(x+0) \\rvert&gt;0 \\right\\}\\bigcup \\left\\{ x:\\lvert f(x)-f(x-0) \\rvert&gt;0 \\right\\}\\)，我们很自然会考虑进行集合表示(常用的一个分解式)</p> \\[ \\left\\{ x:\\lvert f(x)-f(x+0) \\rvert&gt;0 \\right\\}=\\bigcup\\limits_{n=1}^{\\infty} \\left\\{ x:\\lvert f(x^{+})-f(x) \\rvert&gt; \\frac{1}{n} \\right\\} \\] <p>下面开始正式的证明：</p> <p>先定义\\(E=\\left\\{ x:f(x^{-}),f(x^{+})都存在 \\right\\}\\)不妨讨论右极限，左极限同理</p> <p>设右极限为\\(f(x^{+})\\)，那么定义\\(A=\\left\\{ x\\in E:\\lvert f(x^{+})-f(x) \\rvert&gt; 0 \\right\\}\\)，</p> <p>将集合进行分解\\(A=\\bigcup\\limits_{k=1}^{\\infty}A_{k},A_{k}=\\left\\{ x\\in E:\\lvert f(x^{+})-f(x) \\rvert&gt; \\frac{1}{k} \\right\\}\\)</p> <p>再证明\\(A_{k}\\)至多可数</p> <p>根据右极限定义，对于任意的\\(x\\in A_{k}\\)，\\(\\exists\\delta_{x}&gt;0,x&lt;y&lt;x+\\delta_{x}\\)都有\\(\\lvert f(y)-f(x^{+}) \\rvert&lt; \\frac{1}{4k}\\) ，对于任意的\\(x_{1},x_{2}\\in \\left( x,x+\\delta _{x} \\right)\\)，事实上可以直接由柯西收敛定理结合右极限的存在性直接得到下面的式子而不用通过三角不等式，\\(\\lvert f(x_{1})-f(x_{2}) \\rvert\\leq\\lvert f(x_{1})-f(x^{+}) \\rvert+\\lvert f(x_{2})-f(x^{+}) \\rvert&lt; \\frac{1}{2k}\\)</p> <p>再来说明\\(A_{k}\\bigcap \\left( x,x+\\delta_{x} \\right)=\\emptyset\\).这事实上是显然的，右极限的存在性保证了\\(x\\)右端的弱连续性由此可知不可能出现符合\\(A_{k}\\)条件的点</p> <p>反证法，如果存在\\(x_{0}\\in A_{k}\\bigcap \\left( x,x+\\delta_{x} \\right)\\),有\\(\\lvert f(x_{0}^{+})-f(x_{0}) \\rvert&gt; \\frac{1}{k}\\)，那么也存在\\(\\delta_{0},s.t.y_{0}\\in \\left( x_{0},x_{0}+\\delta_{0} \\right),x_{0}+\\delta_{0}&lt;x+\\delta_{x}\\),\\(\\lvert f(y_{0})-f(x_{0}^{+}) \\rvert&lt; \\frac{1}{2k}\\)</p> \\[ \\lvert f(x_{0})-f(y_{0}) \\rvert \\geq \\lvert \\lvert f(x_{0}^{+})-f(x_{0}) \\rvert - \\lvert f(x_{0}^{+})-f(y_{0}) \\rvert \\rvert &gt; \\frac{1}{2k} \\] <p>与原本条件的任取\\(x_{1},x_{2}\\in \\left( x,x+\\delta _{x} \\right)\\)，都有绝对值小于\\(\\frac{1}{2k}\\)矛盾，由此可得\\(A_{k}\\bigcap \\left( x,x+\\delta_{x} \\right)=\\emptyset\\)</p> <p>因此\\(\\left\\{ (x,x+\\delta_{x}) ,x\\in A_{k}\\right\\}\\)是两两不交的开区间，那么\\(A_{k}\\)是至多可数的，由于可数个至多可数集的并仍是至多可数的，我们得出\\(A\\)是至多可数集，那么左极限情形同理可证，综上可得，第一类间断点是至多可数的.</p> <p>[!question] Ch1 17 设\\(E\\subset \\mathbb{R}^{3}\\),\\(E\\) 中任何两点的距离是有理数,求证\\(E\\)至多可数</p> <p>[!tip]+ Hint 空间中两个圆，或是重合，或是至多相交两个点</p> <p><code>Proof.</code></p> <p>思考：\\(E\\)与\\(Q\\)应当是对等的，所以应该基数相同至多可数</p> <p>法一：</p> <p>选取\\(P_{1},P_{2},P_{3}\\in E\\)，\\(X=\\left\\{ x \\in \\mathbb{R}^{3}:d(x,P_{i}) \\in \\mathbb{Q},i=1,2,3\\right\\}\\)</p> <p>那么根据题意我们有\\(d(x,P_{i})=r_{i} \\in \\mathbb{Q}\\)，三个点可以确定一个平面了，其中任意两个点形成的以有理数为半径的球的交至多为一个圆，圆与球的交相当于两个圆的交，至多有两个交点，那么我们知道\\(\\mathbb{Q}^{3}\\)是至多可数的，那么得到\\(E\\)也至多可数(子集乘两倍仍然至多可数).</p> <p>法二：</p> <p>在\\(E\\)中任选一点\\(x_{0}\\)，根据条件得\\(E=\\bigcup\\limits_{r\\in Q^{+}}E\\bigcap S(x_{0},r)\\)，\\(S(x_{0},r)\\)是以\\(x_{0}\\)为圆心，\\(r\\)为半径的球面，只要证明\\(E\\bigcap S(x_{0},r)\\)至多可数即可证得\\(E\\)至多可数</p> <p>在\\(E\\bigcap S(x_{0},r)\\)中额外选取一点\\(x_{1}\\)(总可以选取到，否则该集合只有一个点，直接至多可数得到平凡)，可以得到</p> \\[E\\bigcap S(x_{0},r)=\\bigcup\\limits_{r_{1}\\in Q^{+}}E\\bigcap S(x_{0},r)\\bigcap S(x_{1},r_{1})\\] <p>而\\(S(x_{0},r)\\bigcap S(x_{1},r_{1})\\)是一个空间中的圆，可以仿照前面的步骤在其上再次选取一点\\(x_{2}\\)，并且选取有理数为半径，</p> \\[E\\bigcap S(x_{0},r)\\bigcap S(x_{1},r_{1})=\\bigcup\\limits_{r_{2}\\in Q^{+}}E\\bigcap S(x_{0},r)\\bigcap S(x_{1},r_{1})\\bigcap S(x_{2},r_{2})\\] <p>由于圆与球的交相当于两个圆的交，或是重合，或是至多相交两个点，根据选取过程知无法重合，那么至多相交两个点也就是至多可数，可数个至多可数集的并仍至多可数，则\\(E\\bigcap S(x_{0},r)\\bigcap S(x_{1},r_{1})\\)可数，一直运用可数个至多可数集的并为至多可数集，得到\\(E\\)至多可数.</p> <p>注：可以推广到\\(n\\)维，具体做法可以参考知乎上的一篇文章</p> <p>[!question] Ch1 18 求证: 有限\\(n\\)元数列全体及有理系数多项式全体都是可数集.</p> <p><code>Proof.</code></p> <p>首先有限\\(n\\)元数列，\\((a_{1},a_{2},\\dots,a_{k},\\dots)\\)存在一个\\(N\\)使得\\(\\forall n\\geqslant N,a_{n}=0\\)，然后我们可以考虑一个\\(n\\)进制的分解\\(\\sum\\limits_{k=1}^{\\infty} \\frac{a_{k}}{n^{k}}\\)，这显然是一个\\([0,1]\\)上有理数的\\(n\\)进制分解，所以显然是可数集.</p> <p>再考虑有理系数多项式全体显然可以将多项式\\(\\sum\\limits_{k=0}^{n}a_{k}x^{k}\\)映到\\((a_{0},a_{1},\\dots,a_{n},0\\dots)\\)上，那么也就是\\(\\mathbb{Q}^{n}\\times \\left\\{ \\mathbb{Q}-\\left\\{ 0 \\right\\} \\right\\}\\)显然是至多可数的记为\\(A_{n}\\)那么\\(A=\\bigcup\\limits_{n=0}^{\\infty}A_{n}\\)也是至多可数集</p> <p>[!question] Ch1 19 若\\(\\mathbb{R}\\)中的集\\(A\\)不可数,求证:必有\\(x\\in A\\),使对任何\\(\\delta&gt;0\\),\\((x-\\delta,x)\\)和\\((x,x+\\delta)\\)中都有\\(A\\)中的点,而且这种\\(x\\)全体也是不可数的.</p> <p><code>Proof.</code></p> <p>思考：由于条件比较少我们考虑反证法，只需要证明与题设相反的两个集合都是至多可数集即可</p> <p>反证法，构造逆否命题，\\(\\exists\\delta&gt;0,s.t.(x-\\delta,x),(x,x+\\delta)\\)中没有\\(A\\)的点，</p> <p>先讨论\\(A_{+}:=\\left\\{  x\\in A,A\\bigcap(x,x+\\delta)=\\emptyset \\right\\}\\),任取\\(x_{1},x_{2}\\in A_{+}\\),\\(x_{2}\\not\\in(x_{1},x_{1}+\\delta_{x_{1}}),x_{1}\\not\\in(x_{2},x_{2}+\\delta_{x_{2}})\\)，容易知道这样可以得到两两不交的开区间族，同理可证\\(A_{-}:=\\left\\{  x\\in A,A\\bigcap(x-\\delta,x)=\\emptyset \\right\\}\\)</p> <p>那么\\(A_{+},A_{-}\\)至多可数，与题设中的不可数矛盾，所以这种点必然存在而且这种点的全体(\\(A-A_{-}-A_{+}\\))也是不可数的.</p> <p>[!question] Ch1 20 例 设 \\(\\overline{\\overline{A \\cup B}}=c\\) (连续统势). 求证: \\(A\\) 和 \\(B\\) 中至少有一个的基数为 \\(c\\).</p> <p><code>Proof.</code></p> <p>我们不妨设 \\(A \\cup B=\\mathbf{R}^{2}, A\\) 和 \\(B\\) 是 \\(\\mathbf{R}^{2}\\) (平面) 中的两个子集, \\(\\mathbf{R}^{2}\\) 中的点用 \\((x, y)\\) 来表示. 现显然有 \\(\\bar{A} \\leqslant c\\) 及 \\(\\bar{B} \\leqslant c\\). 今假设 \\(\\bar{A}&lt;c\\) 及 \\(\\bar{B}&lt;c\\). 于是有 \\(x_{0} \\in \\mathbf{R}\\),使对一切 \\(y \\in \\mathbf{R}\\) 有 \\((x_{0}, y) \\notin A\\); </p> <p>注：可以考虑反面，\\(\\forall x\\in \\mathbb{R},\\exists y_{0}\\in \\mathbb{R},(x,y_{0})\\in A\\)，那么可以将这些点都映射到\\(x\\)轴上使得\\(A\\)有连续统势与假设矛盾.</p> <p>同样有 \\(y_{0} \\in \\mathbf{R}\\), 使对一切 \\(x \\in \\mathbf{R}\\) 有 \\((x, y_{0}) \\notin B\\). 这样 \\((x_{0}, y_{0}) \\notin A \\cup B=\\mathbf{R}^{2}\\), 矛盾.</p>","path":["周性伟-Ch1"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E5%91%A8%E6%80%A7%E4%BC%9F-Ch1/#21-30","level":2,"title":"21-30","text":"<p>[!question] Ch1 21 设 \\(\\bigcup\\limits_{n=1}^{\\infty} A_{n}\\) 有连续统势. 求证: 至少有一个 \\(A_{n}\\) 有连续统势.</p> <p><code>Proof.</code></p> <p>注：这里需要知道\\(\\overline{\\overline{\\mathbb{R}^{\\infty}}}=c\\)，然后就可以仿照上面的了</p> <p>直接利用20题的结论，仿照上面的证明即可，每个\\(A_{n}\\)都没有连续统势</p> <p>[!example] \\(\\mathbb{R}^{\\infty}\\) \\(\\forall x\\in \\mathbb{R}^{\\infty},x=(x_{1},x_{2},\\dots,x_{k}\\dots)\\)</p> \\[f(x)=\\left\\{ \\left\\{ (k,r) \\right\\} ,k\\to x_{k},r\\in \\mathbb{Q},r&lt;x_{k} \\right\\} \\] <p>这样定义了一个从\\(\\mathbb{R}^{\\infty}\\to P(N\\times \\mathbb{Q})\\)的单射，另一边显然有它的势大于\\(\\mathbb{R}\\)那么可得它有连续统势</p> <p>[!question] Ch1 22 具体构造下列集之间的一个完全一一映射 (i)\\(\\left[ 0,1 \\right]\\)与\\(\\left( 0,1 \\right)\\) (ii)\\((0,1]\\)与\\((0,1]\\times(0,1]\\) (iii)正整数列全体与严格单增正整数列全体</p> <p><code>Proof.</code></p> <p>注：构造方式均为无理点不动、有理点平移</p> <p>(i):</p> <p>我们将\\(\\left[ 0,1 \\right]\\)分为\\(0,1\\)和\\((0,1)\\)内的有理数和无理数，</p> <p>对无理数部分构造一个无理数的恒等映射也就是当\\(x\\in (0,1),x\\not\\in Q\\)时，\\(f(x)\\equiv x\\) </p> <p>对有理数部分先证明它是可数集，首先全体有理数是可数集，而开区间内的有理数有无限个，根据可数集的无限子集也是可数集，我们知道\\((0,1)\\)内的有理数一定也是可数集.这样就可以进行排列:对于所有的\\(x\\in(0,1),x\\in Q\\)都可以用\\(\\left\\{ x_{n} \\right\\}_{n \\geq 1}\\)表示.</p> <p>然后构造有理数部分的映射\\(f(x_{1})=0,f(x_{2})=1,f(x_{n})=x_{n-2},n \\geq 3\\)</p> <p>这样就得到了\\(\\left( 0,1 \\right)\\to[0,1]\\)的完全一一映射，下面进行分别验证.</p> <p>从构造过程中可以知道\\(\\forall x\\in[0,1]\\)，都有\\(y\\in(0,1)\\)使得\\(f(y)=x\\)(\\(x=0,y=x_{1};x=1,y=x_{2}\\)).</p> <p>\\(x \\not\\in Q,y=x;x \\in Q-\\left\\{ 0,1 \\right\\} ,\\exists k \\geq 1,s.t.x=x_{k},y=x_{k+2}\\)所以\\(f\\)是满射</p> <p>根据构造过程，若是\\(x_{1} \\neq x_{2}\\)，必有\\(f(x_{1}) \\neq f(x_{2})\\)，所以得到\\(f\\)是单射，综上所述：\\(f\\)是完全一一映射.</p> <p>(ii):</p> <p>这是一位学长的解答：</p> <p>考虑\\(\\forall x\\in(0,1]\\)，无限小数不允许某位后全为0，做十进制分解</p> <p>例如\\(0.100100234\\dots\\implies 1,001,002,3,4\\dots\\implies 0.10024\\dots ,0.0013\\dots\\)</p> <p>这样按照0出现的位置进行一个拆分将奇数段和偶数段分别映射到不同的集合中，相反则是拼接，容易知道这就是一种双射.</p> <p>注：应该也可以仿照\\(\\mathbb{R}\\to \\mathbb{R}^{2}\\)，例如下面这种方式：</p> <p>对于\\(x=0.a_{1}b_{1}a_{2}b_{2}\\dots\\implies x_{1}=0.a_{1}a_{2}\\dots,x_{2}=0.b_{1}b_{2}\\dots\\)</p> <p>(iii):</p> <p>直接考虑一阶差分即可\\(a_{1}=b_{1},b_{n+1}=b_{n}+a_{n}\\)</p> <p>[!question] Ch1 23 求证：\\(\\mathbb{R}\\)上实函数全体有基数\\(2^{c}\\)</p> <p><code>Proof.</code></p> <p>思考：显然我们可以考虑使用Berstein定理，而\\(\\mathbb{R}\\)有连续统势那么可以考虑构造\\(\\mathbb{R}\\)上实函数与\\(\\mathbb{R}^{2}\\)之间的单射</p> <p>容易看出\\(\\mathbb{R}\\)上的任一实函数可以由\\(\\mathbb{R}^{2}\\)的一个子集表示\\((x,f(x))\\)，而\\(\\mathbb{R}^{2}\\)和\\(\\mathbb{R}\\)都有连续统势，那么可以得到\\(\\mathbb{R}\\)上实函数全体的势一定小于等于\\(2^{c}\\)</p> <p>另一方面，对于\\(\\mathbb{R}\\)的任一子集\\(A\\)，构造特征函数\\(\\chi_{A}(x)=1(x \\in A)\\)，即得是一个单射，那么\\(2^{c}=\\overline{\\overline{P(A)}}\\leqslant \\mathbb{R}\\)上实函数的势</p> <p>综上可证.</p> <p>[!question] Ch1 24 若\\(A \\cap B=\\varnothing\\)，求证：\\(\\bar{A} \\cap B^{\\circ }=\\varnothing\\)。</p> <p><code>Proof.</code></p> <p>反证法，假设\\(\\exists x_{0}\\in \\overline{A}\\bigcap B^{\\circ}\\)，那么根据内部的定义，\\(x_{0}\\in B^{\\circ}\\implies \\exists\\epsilon, V(x_{0},\\epsilon)\\subset B\\)，再根据闭包的定义\\(x_{0}\\in \\overline{A} \\implies  V(x_{0},\\epsilon)\\bigcap A \\neq \\emptyset\\)，综上\\(\\exists x_{1}\\in V(x_{0},\\epsilon)\\bigcap A,x_{1}\\in B,x_{1}\\in A\\bigcap B\\)，与题设矛盾，即证\\(\\bar{A} \\cap B^{\\circ }=\\varnothing\\)</p> <p>[!question] 25 求证： (i) \\((A^c)^{\\circ}=(\\overline{A})^{c}\\); (ii) \\(\\overline{A^{c}}=(A^{\\circ})^{c}\\) (iii) \\(\\overline{A \\cup B}=\\overline{A} \\cup \\overline{B}\\); (iv) \\(\\overline{A \\cap B} \\subset  \\overline{A} \\cap \\overline{B}\\); (v) \\(A^{\\circ}\\bigcup B^{\\circ}\\subset\\left( A\\bigcup B \\right)^{\\circ}\\) (vi) \\(\\left( A\\bigcap B \\right)^{\\circ}=A^{\\circ}\\bigcap B^{\\circ}\\)</p> <p><code>Proof.</code></p> <p>(i)</p> \\[ \\begin{aligned} x\\in(A^{c})^{\\circ}&amp;\\iff \\exists\\delta&gt;0,V(x,\\delta)\\subset A^{c}\\\\ &amp;\\iff \\exists\\delta&gt;0,V(x,\\delta)\\bigcap A=\\emptyset\\\\ &amp;\\iff x\\not\\in \\overline{A}\\iff x\\in(\\overline{A})^{c} \\end{aligned} \\] <p>(ii)</p> \\[ \\begin{aligned} x\\in \\overline{A^{c}}&amp;\\iff \\forall\\delta&gt;0,V(x,\\delta)\\bigcap A^{c}\\neq \\emptyset\\\\ &amp;\\iff \\forall\\delta&gt;0,V(x,\\delta)\\not\\subset A\\\\ &amp;\\iff x\\in (A^{\\circ})^{c} \\end{aligned} \\] <p>(iii)</p> \\[ \\begin{aligned} x\\in \\overline{A\\bigcup B} &amp; \\iff  \\forall\\epsilon,V(x,\\epsilon)\\bigcap \\left( {A\\bigcup B} \\right) \\neq \\emptyset \\\\  &amp; \\iff V(x,\\epsilon)\\bigcap A \\neq \\emptyset \\bigvee V(x,\\epsilon)\\bigcap B\\neq \\emptyset \\\\  &amp; \\iff x\\in \\overline{A} \\bigvee x\\in \\overline{B} \\\\  &amp; \\iff x\\in \\left(  \\overline{A}\\bigcup  \\overline{B}  \\right)  \\end{aligned} \\] <p>(iv)</p> \\[ \\begin{aligned} x\\in \\overline{A\\bigcap B} &amp; \\iff  \\forall\\epsilon,V(x,\\epsilon)\\bigcap \\left( {A\\bigcap B} \\right) \\neq \\emptyset \\\\  &amp; \\implies V(x,\\epsilon)\\bigcap A \\neq \\emptyset \\bigwedge V(x,\\epsilon)\\bigcap B\\neq \\emptyset \\\\  &amp; \\iff x\\in \\overline{A} \\bigwedge x\\in \\overline{B} \\\\  &amp; \\iff x\\in \\left(  \\overline{A}\\bigcap  \\overline{B}  \\right)  \\end{aligned} \\] <p>(v)</p> <p>显然可以依据定义\\(x\\in A^{\\circ}\\bigcup B^{\\circ}\\)，那么\\(x\\in A^{\\circ}\\)或\\(x\\in B^{\\circ}\\)，不妨设是\\(x\\in A^{\\circ}\\)另一种情况同理可得，\\(\\exists\\delta,V(x,\\delta)\\subset A\\subset \\left( A\\bigcup B \\right)\\implies x\\in\\left( A\\bigcup B \\right)^{\\circ}\\)</p> <p>(vi)</p> <p>显然也可以按照定义：</p> \\[ \\begin{aligned} x\\in\\left( A\\bigcap B \\right)^{\\circ}&amp;\\iff \\exists\\delta&gt;0,V(x,\\delta)\\subset\\left( A\\bigcap B \\right)\\\\ &amp;\\iff \\exists\\delta&gt;0,V(x,\\delta)\\subset A(B)\\\\ &amp;\\iff x\\in A^{\\circ}\\bigcap B^{\\circ} \\end{aligned} \\] <p>[!question] Ch1 26 设A为开集。求证：为使\\(A \\subset \\overline{B}\\)，充要条件是A的任一非空开子集与B有非空交。</p> <p><code>Proof.</code></p> <p>\\(\\implies\\)</p> <p>必要性是显然的，对于任一A的非空开子集C，\\(C \\subset A\\subset  \\overline{B}\\)，根据闭包的定义C的每一点的任意邻域都与B与非空交，从而得证</p> <p>\\(\\impliedby\\)</p> <p>反证法，假设存在\\(x_{1}\\)，使得\\(x_{1}\\in A,x_{1}\\not\\in  \\overline{B}\\)，那么有\\(x_{1}\\in (\\overline{B})^{c}\\)，因为\\(( \\overline{B} )^{c}\\)是一个开集，可知\\(\\exists\\delta,V(x_{1},\\delta)\\bigcap  \\overline{B}=\\emptyset,B\\subset  \\overline{B},V(x_{1},\\delta)\\bigcap B=\\emptyset\\)，因为\\(A\\)为开集，\\(\\exists\\delta',V(x_{1},\\delta')\\subset A\\)，它是\\(A\\)的非空开子集</p> <p>取\\(\\delta''=min(\\delta,\\delta'),V(x_{1},\\delta'')\\bigcap B=\\emptyset\\)与题设矛盾</p> <p>[!question] Ch1 27 设 \\(A\\) 为开集. 求证: \\(A \\cap \\overline{B} \\subset \\overline{A \\cap B}\\).</p> <p><code>Proof.</code></p> \\[ \\begin{aligned} x\\in A\\bigcap  \\overline{B}&amp;\\iff x\\in A ,x\\in  \\overline{B}\\\\ &amp;\\iff \\forall\\delta&gt;0,V(x,\\delta)\\bigcap B\\neq \\emptyset;\\exists\\delta_{1}&gt;0,V(x,\\delta_{1})\\subset A\\\\ &amp;\\iff x_{0}\\in V(x,\\delta)\\bigcap B,x_{0}\\in A\\bigcap B\\\\ &amp;\\implies x\\in \\overline{A\\bigcap B} \\end{aligned} \\] <p>注：其实只需要说明\\(x_{0}\\)一定属于\\(A\\)即可(讨论半径即可)，也可以直接将\\(\\delta_{1}\\)作为一个固定的数处理，当半径大于\\(\\delta_{1}\\)时，选取在\\(\\delta_{1}\\)内的一个点\\(x_{1}\\in A\\bigcap B\\)，如果半径小于\\(\\delta_{1}\\)那么也显然.</p> <p>[!question] Ch1 28 (i) 若 \\(A\\) 为开集, 求证: \\(A \\subset(\\bar{A})^{\\circ}\\); (ii) 若 \\(A\\) 为闭集, 求证: \\(\\overline{A^{\\circ}}\\subset A\\).</p> <p><code>Proof.</code></p> <p>(i)利用开集的性质即可</p> <p>\\(x \\in A,\\exists\\delta&gt;0,\\bigcup(x,\\delta)\\subset A\\subset  \\overline{A}\\implies x \\in(\\overline{A})^{\\circ}\\)，那么肯定有\\(A\\subset(\\overline{A})^{\\circ}\\)</p> <p>(ii)</p> \\[ \\begin{aligned} \\forall x\\in \\overline{A^{\\circ}},\\forall\\delta&gt;0,V(x,\\delta)\\bigcap A^{\\circ}\\neq \\emptyset&amp;\\implies \\forall\\delta &gt;0,V(x,\\delta)\\bigcap A\\neq \\emptyset \\\\ &amp;\\implies x\\in \\overline{A}=A \\end{aligned} \\] <p>[!question] Ch1 29 求证：\\(R^{n}\\)中任一集的导集是闭集</p> <p><code>Proof.</code></p> <p>根据\\(\\overline{A'}=A'\\bigcup (A')'\\)，得如果能证明\\((A')'\\subset A'\\)，即可证明\\(A'\\)是闭集(\\(\\overline{A'}=A'\\))</p> <p>因此我们考虑\\((A')'\\subset A'\\)，即可证明导集为闭，如果\\(x_{0}\\in(A')',(V(x_{0},\\epsilon)\\setminus \\left\\{ x_{0} \\right\\})\\bigcap A'\\neq \\emptyset\\)</p> <p>在\\(V(x_{0},\\epsilon)\\)中取异于\\(x_{0}\\)的一点\\(x_{1}\\in A'\\)，那么再根据导集的定义有，\\((V(x_{1},\\epsilon')\\setminus \\left\\{ x_{1} \\right\\})\\bigcap A\\neq \\emptyset\\)</p> <p>注意令\\(\\epsilon'=min(d(x_{0},x_{1}),\\epsilon-d(x_{0},x_{1}))\\)，仍然有\\((V(x_{1},\\epsilon')\\setminus \\left\\{ x_{1} \\right\\})\\bigcap A\\neq \\emptyset\\)，再找出一个\\(x_{2}\\)异于\\(x_{1}\\),且\\(x_{2}\\in A\\)</p> <p>\\(d(x_{0},x_{2})\\leqslant d(x_{0},x_{1})+d(x_{1},x_{2})\\leqslant d(x_{0},x_{1})+\\epsilon-d(x_{0},x_{1})=\\epsilon\\)，根据选取方式可知，\\(x_{2}\\)异于点\\(x_{0},x_{1}\\)，且在\\(x_{0}\\)的非空邻域中，得\\(x_{0}\\in A',(A')'\\subset A'\\)</p> <p>证毕</p> <p>[!question] Ch1 30 (i) 若 \\(A \\subset B\\), 求证: \\(A^{\\prime} \\subset B^{\\prime}\\); (ii) 若 \\(A^{\\prime} \\subset B \\subset A\\), 求证: \\(B\\) 是闭集.</p> <p><code>Proof.</code></p> <p>注：简单的定义题，过于显然了</p> <p>(i)</p> \\[x \\in A',\\exists \\left\\{ x_{n} \\right\\}\\subset A\\subset B,x_{n}\\neq x,x_{n}\\to x\\implies x\\in B'\\] <p>(ii)</p> \\[ B\\subset A\\implies B'\\subset A'\\implies B'\\subset A'\\subset B \\] <p>根据一个非常基础的集合拆分式：\\(\\overline{A}=A'\\bigcup A\\)</p> <p>那么一下得到\\(\\overline{B}=B'\\bigcup B=B\\)</p>","path":["周性伟-Ch1"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E5%91%A8%E6%80%A7%E4%BC%9F-Ch1/#31-40","level":2,"title":"31-40","text":"<p>[!question] Ch1 31 求证: \\((A \\cup B)^{\\prime}=A^{\\prime} \\cup B^{\\prime},(A \\cap B)^{\\prime} \\subset A^{\\prime} \\cap B^{\\prime}\\).</p> <p><code>Proof</code></p> \\[ \\begin{aligned} x_{0} \\in\\left( A\\bigcup B \\right)'&amp;\\iff \\forall\\delta&gt;0,V(x_{0},\\delta)\\bigcap\\left( A\\bigcup B \\right)\\setminus \\left\\{ x_{0} \\right\\}\\neq \\emptyset\\\\ &amp;\\iff \\left( V(x_{0},\\delta) \\bigcap A\\right)\\bigcup\\left( V(x_{0},\\delta)\\bigcap B \\right)-\\left\\{ x_{0} \\right\\} \\neq \\emptyset\\\\ &amp;\\iff\\left( V(x_{0},\\delta) \\bigcap A-\\left\\{ x_{0} \\right\\} \\right)\\bigcup\\left( V(x_{0},\\delta)\\bigcap B -\\left\\{ x_{0} \\right\\} \\right)\\neq \\emptyset\\\\ &amp;\\iff x_{0}\\in A'\\bigcup B' \\end{aligned} \\] \\[ \\begin{aligned} x_{0} \\in\\left( A\\bigcap B \\right)'&amp;\\iff \\forall\\delta&gt;0,V(x_{0},\\delta)\\bigcap\\left( A\\bigcap B \\right)\\setminus \\left\\{ x_{0} \\right\\}\\neq \\emptyset\\\\ &amp;\\implies\\left( V(x_{0},\\delta) \\bigcap A\\right)\\bigcap\\left( V(x_{0},\\delta)\\bigcap B \\right)-\\left\\{ x_{0} \\right\\} \\neq \\emptyset\\\\ &amp;\\iff\\left( V(x_{0},\\delta) \\bigcap A-\\left\\{ x_{0} \\right\\} \\right)\\bigcap\\left( V(x_{0},\\delta)\\bigcap B -\\left\\{ x_{0} \\right\\} \\right)\\neq \\emptyset\\\\ &amp;\\iff x_{0}\\in A'\\bigcap B' \\end{aligned} \\] <p>由于\\(A\\bigcap B\\)有可能是空集，所以\\(x_{0}\\)实际上可能不存在所以是单边的</p> <p>[!question] Ch1 32 求证: \\(R^n\\)中任一集的孤立点是至多可数的.</p> <p><code>Proof.</code></p> <p>由孤立点的定义可知，可以构造一个半径为\\(\\epsilon\\)的开球，使得开球内除了孤立点外与原集合无交，又由于\\(Q^n\\)的稠密性，可在每个开球内选取一个有理点，又由于两两不交，有理点互不相同，这样就建立起了全体孤立点到\\(R^{n}\\)中\\(Q^n\\)的一个单射，全体孤立点势一定小于\\(Q^n\\)，又由于\\(R^{n}\\)中的\\(Q^n\\)是至多可数集，得证命题成立.</p> <p>注：需要check两两孤立点的开球之间不交</p> <p>[!question] Ch1 33 若 \\(A\\) 不可数, 求证: \\(A^{\\prime}\\) 也不可数.</p> <p><code>Proof.</code></p> <p>利用32，孤立点集是至多可数集，\\(A=A'\\bigcup(A-A')\\)，其中孤立点集为\\(A-A'\\)</p> <p>那么显然有\\(A'\\)是不可数的</p> <p>[!question] Ch1 34 设对每一整数\\(n,F_n\\)是\\([n,n+1)\\)中的闭集.求证：\\(\\bigcup\\limits_{n=-\\infty}^{\\infty}F_n\\)是 \\(\\mathbb{R}\\) 中的闭集.</p> <p><code>Proof.</code></p> <p>思考：利用闭集的充要条件，如果\\(F_{n}\\)是闭集那么有\\(\\forall \\left\\{ x_{n} \\right\\}\\in F_{n},x_{n}\\to x,x\\in F_{n}\\)</p> <p>任取\\(\\left\\{ x_{n} \\right\\}\\in\\bigcup\\limits_{n=-\\infty}^{\\infty}F_{n},x_{n}\\to x(n\\to \\infty)\\),取\\(\\epsilon=\\frac{1}{2},\\exists N,\\forall n&gt;N,\\lvert x_{n}-x \\rvert&lt; \\frac{1}{2}=\\epsilon\\)，由于\\(R=\\bigcup\\limits_{n=-\\infty}^{\\infty}[n,n+1),\\exists !k,s.t. x\\in[k,k+1)\\)，那么可以得出\\(n&gt;N\\)的\\(\\left\\{ x_{n} \\right\\}\\in \\bigcup\\limits_{i=k-1}^{k+1} F_{i}\\)，因为有限个闭集的并仍然为闭集则\\(\\bigcup\\limits_{i=k-1}^{k+1} F_{i}\\)为闭集，再根据闭集充要条件得出\\(x\\in\\bigcup\\limits_{i=k-1}^{k+1} F_{i}\\subset \\bigcup\\limits_{n=-\\infty}^{\\infty}F_n\\)</p> <p>综上所述：\\(\\bigcup\\limits_{n=-\\infty}^{\\infty}F_n\\)是 \\(\\mathbb{R}\\) 中的闭集.</p> <p>[!question] Ch1 35 设\\(A\\subset \\mathbb{R}^{n}\\)，若对任何\\(x\\in \\mathbb{R}^{n}\\)，必有\\(a_{x}\\in A\\)使\\(d(x,a_{x})=d(x,A)\\) 求证：\\(A\\)是闭集.</p> <p><code>Proof.</code></p> <p>反证，若\\(A\\)不是闭集，那么一定有\\(x\\in A'-A\\)，\\(\\left\\{ x_{n} \\right\\}\\subset A,x_{n}\\to x\\)</p> \\[ \\begin{aligned} d(x,A)&amp;=\\inf \\left\\{ d(x,y),y\\in A \\right\\} \\leqslant\\left\\{ d(x,x_{n}) \\right\\} \\to 0\\\\0&amp;=d(x,a_{x})\\iff x=a_{x}\\in A,A'\\subset A \\end{aligned} \\] <p>注：这是闭集一个非常重要的性质，仍然是利用\\(A'\\subset A\\)</p> <p>[!question] Ch1 36 设\\(f\\)在\\(\\mathbb{R}\\) 上单增.求证:\\(E=\\{x:\\)对任何\\(\\varepsilon&gt;0\\)有\\(f(x+\\varepsilon)-f(x-\\varepsilon)&gt;0\\}\\)是闭集.</p> <p><code>Proof.</code></p> <p>考虑证明\\(E^{c}\\)是开集，对于任意点\\(x\\)属于\\(E^{c},\\exists\\epsilon&gt;0,s.t.f(x+\\epsilon)\\leqslant f(x-\\epsilon)\\).</p> <p>又因为函数是单调递增的有\\(f(x+\\epsilon)\\geqslant f(x-\\epsilon)\\to f(x+\\epsilon)=f(x-\\epsilon)=A\\to \\forall x\\in(x-\\epsilon,x+\\epsilon),f(x)\\equiv A\\)</p> <p>根据开集的定义选取\\(\\delta=\\frac{\\epsilon}{2},V(x,\\delta)\\subset (x-\\epsilon,x+\\epsilon)\\)，又因为\\(\\forall x'\\in V(x,\\delta),\\delta'= \\frac{\\epsilon}{4},V(x',\\delta')\\subset(x-\\epsilon,x+\\epsilon)\\)，易知\\(x'\\in E^{c}\\)，那么有\\(V(x,\\delta)\\subset E^{c}\\),由\\(x\\)的任意性知\\(E^{c}\\)为开集，\\(E\\)为闭集.</p> <p>[!question] Ch1 37 设\\(F\\subset\\mathbf{R}^n\\)是一个无限集.求证；为使\\(F\\)是有界闭集，充要条件是对\\(F\\)的任一无限子集\\(E\\)有\\(E^\\prime\\bigcap F\\neq\\emptyset.\\)</p> <p><code>Proof.</code></p> <p>\\(\\implies\\) 假设有界闭集，那么\\(E\\subset F,F'\\subset F,E'\\subset F'\\subset F\\to E'\\bigcap F\\neq \\emptyset\\)(或者根据聚点定理)</p> <p>\\(\\impliedby\\) Step 1 假设无界，那么可以取\\(\\left\\{ x_{n} \\right\\}_{n\\geqslant 1},s.t.\\lvert x_{n} \\rvert&gt;n,\\lvert x_{n}-x_{n'} \\rvert&gt;1(n\\neq n')\\)，否则有界，那么可以知道该无限子集导集为空(全为孤立点)，那么与条件\\(E'\\bigcap F\\neq \\emptyset\\)矛盾</p> <p>Step 2 选取一个收敛点列\\(\\left\\{ x_{n} \\right\\}_{n\\geqslant {1}}\\subset F,x_{n}\\to x\\)，那么设\\(E=\\left\\{ x_{n} \\right\\}_{n\\geqslant 1}，E'=\\left\\{ x \\right\\},x\\in F\\left( E'\\bigcap F \\neq \\emptyset \\right)\\)</p> <p>[!question] Ch1 38 设 \\(E \\subset \\mathbf{R}\\). 若 \\(E\\) 被一个区间族 \\(\\left\\{I_{\\lambda}\\right\\}_{\\lambda \\in \\Lambda}\\) 所覆盖, 求证: \\(E\\) 可被 \\(\\left\\{I_{\\lambda}\\right\\}_{\\lambda \\in \\Lambda}\\) 的一个可数子族所覆盖. </p> <p>[!tip]- Hint 提示: 令 \\(a_{\\lambda}\\) 和 \\(b_{\\lambda}\\) 分别是 \\(I_{\\lambda}\\) 的左、右端点 \\(A=\\left\\{a_{\\lambda}\\right\\}_{\\lambda \\in \\Lambda}, B=\\left\\{b_{\\lambda}\\right\\}_{\\lambda \\in \\Lambda}, C=\\) \\(\\bigcup_{\\lambda \\in \\Lambda}\\left(a_{\\lambda}, b_{\\lambda}\\right)\\). 证明 \\(A-C\\) 和 \\(B-C\\) 都是至多可数集, 从而问题化为 \\(I_{\\lambda}\\) 都是开区间的情形.</p> <p><code>Proof.</code></p> <p>令 \\(a_{\\lambda}\\) 和 \\(b_{\\lambda}\\) 分别是 \\(I_{\\lambda}\\) 的左、右端点,\\(A=\\left\\{a_{\\lambda}\\right\\}_{\\lambda \\in \\Lambda}, B=\\left\\{b_{\\lambda}\\right\\}_{\\lambda \\in \\Lambda}, C=\\bigcup\\limits_{\\lambda \\in \\Lambda}\\left(a_{\\lambda}, b_{\\lambda}\\right)\\). </p> <p>Step 1 证明 \\(A-C\\) 和 \\(B-C\\) 都是至多可数集, 从而问题化为 \\(I_{\\lambda}\\) 都是开区间的情形.</p> <p>对于任意不同的两个指标\\(\\lambda_{1},\\lambda_{2}\\in A,a_{\\lambda_{1}}=a_{\\lambda_{2}}=x\\)，由于不属于\\(C\\)那么这种情况下，区间两两不相交</p> <p>注：点集拓扑中的一个很重要的定理叫做\\(Lind elof\\)定理，可以抽象出一个\\(Lind elof\\)空间，答案可以在任何一本点集拓扑书中找到.</p> <p>[!question] Ch1 39 设\\(F_1\\)和\\(F_2\\)是两个闭集，其中一个有界. 求证：必有\\(x_1\\in F_1\\)及\\(x_2\\in F_2\\)使\\(d(x_1,x_2)=\\inf\\{d(y_1,y_2):y_1\\in F_1,y_2\\in F_2\\}.\\)</p> <p><code>Proof.</code></p> <p>不妨设\\(F_{1}\\)有界，利用下确界性质，\\(\\exists x_{n}',y_{n}',s.t.d(F_{1},F_{2})\\leqslant d(x_{n}',y_{n}')\\leqslant d(F_{1},F_{2})+\\frac{1}{n}\\)，按照这种选取方式构造无穷点集</p> <p>利用Bolzano-Weierstrass定理，取\\(\\left\\{ x_{n}' \\right\\}\\)的收敛子列\\(\\left\\{ x_{n_{k}}' \\right\\},x_{n_{k}}'\\to x_{1},k\\to \\infty\\),又由于闭集性质\\(x_{1}\\in F_{1}\\) 那么有\\(d(x_{1},y_{n_{k}}')\\to d(F_{1},F_{2})\\)，再利用三角不等式，\\(d(y_{n_{k}}',0)\\leqslant d(x_{n_{k}}',y_{n_{k}}')+d(x_{n_{k}}',0)\\)也有界(其中一个是有界闭集)，那么仿照\\(F_{1}\\)中子列的证明，即可证得\\(F_{2}\\)存在收敛子列使得\\(k\\to \\infty,y_{n_{k}}'\\to x_{2},d(x_{1},x_{2})=d(F_{1},F_{2})\\)，</p> <p>[!question] Ch1 40 求证: 闭区间不能表示成两个不相交非空闭集的并.</p>","path":["周性伟-Ch1"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E5%91%A8%E6%80%A7%E4%BC%9F-Ch1/#41-50","level":2,"title":"41-50","text":"<p>[!question] Ch1 41 例 求证开区间 \\((a, b)\\) 不能表示成可数个两两不相交的闭集 \\(\\left\\{F_n\\right\\}_{n \\geqslant 1}\\) 的并.</p> <p><code>Proof.</code></p> <p>假设 \\((a, b)=\\bigcup_{n=1}^{\\infty} F_n\\). 由题 39 , 存在 \\(a_1\\) 和 \\(b_1\\) 使 \\(a&lt;a_1&lt;b_1&lt;b\\), 并且 \\(\\left\\{a_1, b_1\\right\\} \\subset F_1 \\cup F_2, \\left(a_1, b_1\\right) \\cap\\left(F_1 \\cup F_2\\right)=\\varnothing\\). 此时 \\(\\left(a_1, b_1\\right)=\\bigcup_{n=3}^{\\infty} F_n^{(1)}\\), 其中 \\(F_n^{(1)}=\\) \\(F_n \\cap\\left(a_1, b_1\\right)\\) 是闭集而且 \\(\\left\\{F_n^{(1)}\\right\\}_{n \\geqslant 3}\\) 两两不相交 (不妨设它们都非空).</p> <p>同理存在 \\(a_2\\) 和 \\(b_2\\) 使 \\(a_1&lt;a_2&lt;b_2&lt;b_1\\), 并且 \\(\\left\\{a_2, b_2\\right\\} \\subset F_3^{(1)} \\cup F_4^{(1)},\\left(a_2, b_2\\right) \\cap\\left(F_3^{(1}\\right.\\) \\(\\left.\\bigcup F_4^{(1)}\\right)=\\varnothing\\). 此时 \\(\\left(a_2, b_2\\right)=\\bigcup_{n=5}^{\\infty} F_n^{(2)}\\), 其中 \\(F_n^{(2)}=F_n^{(1)} \\cap\\left(a_2, b_2\\right)\\) 是闭集而且 \\(\\left\\{F_n^{(2)}\\right\\}_{n \\geqslant 5}\\) 两两不相交 (不妨设它们都非空).</p> <p>如此做下去, 可以证明 \\(E=\\bigcap_{n=1}^{\\infty}\\left(a_n, b_n\\right)\\) 非空, 而且 \\(E \\cap\\left(\\bigcup_{n=1}^{\\infty} F_n\\right)=\\varnothing\\). 此与 \\((a, b)=\\bigcup_{n=1}^{\\infty} F_n\\) 矛盾.</p> <ol> <li> <p>平面上的开圆盘或空间中的开球能表示成可数个两两不相交的闭集的并吗? (提示: 令 \\(D=\\{(x, y) \\in \\mathbf{R}^2: x^2+y^2&lt;1\\}\\) 是 \\(\\mathbf{R}^2\\) 中的开圆盘, 并假设 \\(D=\\bigcup F_n\\), 其中 \\(\\left\\{F_n\\right\\}\\) 是两两不相交闭集列. 令 \\(F_n^{\\ast}=\\{x \\in(-1,1):(x, 0) \\in F_n\\}\\), 然后研究 \\(\\left\\{F_n^{\\ast}\\right\\}\\).)</p> </li> <li> <p>证明定理 1.5.15.</p> </li> </ol> <p>[!question] Ch1 44 设\\(\\left\\{f_k\\right\\}_{k \\geqslant 1}\\)是R上一列连续函数。求证：\\(\\left\\{\\underline\\lim\\limits_{k\\to\\infty}f_k(x)&gt;0\\right\\}\\)是可数个闭集的并，\\(\\left\\{\\overline\\lim\\limits_{k\\to\\infty}f_k(x)=\\infty\\right\\}\\)是可数个开集的交。</p> <p><code>Proof.</code></p> <p>考虑构造:</p> \\[\\begin{aligned} \\left\\{\\varliminf\\limits_{k\\to\\infty}f_k(x)&gt;0\\right\\}=\\bigcup\\limits_{n=1}^{\\infty}\\left\\{  \\varliminf\\limits_{k\\to\\infty}f_k(x)\\geqslant\\frac{1}{n}\\right\\}\\\\ \\left\\{\\varlimsup\\limits_{k\\to\\infty}f_k(x)=\\infty\\right\\}=\\bigcap\\limits_{n=1}^{\\infty}\\left\\{  \\varliminf\\limits_{k\\to\\infty}f_k(x)&gt; n\\right\\} \\end{aligned}\\] <p>那么有：</p> \\[     \\begin{aligned}     \\left\\{\\varliminf\\limits_{k\\to\\infty}f_k(x)&gt;0\\right\\} &amp; =\\bigcup\\limits_{n=1}^{\\infty}\\left\\{  \\varliminf\\limits_{k\\to\\infty}f_k(x)\\geqslant\\frac{1}{n}\\right\\} \\\\      &amp; =\\bigcup\\limits_{n=1}^{\\infty} \\bigcup\\limits_{m=1}^{\\infty} \\bigcap\\limits_{k=m}^{\\infty} \\left\\{  f_k(x)\\geqslant\\frac{1}{n}\\right\\}     \\end{aligned} \\] <p>由于\\(\\left\\{  f_k(x)\\geqslant\\frac{1}{n}\\right\\}\\)是闭集，交后仍为闭集，再进行可数并故原式为可数个闭集的并</p> \\[ \\begin{aligned} \\left\\{\\varlimsup\\limits_{k\\to\\infty}f_k(x)=\\infty\\right\\} &amp; =\\bigcap\\limits_{n=1}^{\\infty}\\left\\{ \\varlimsup\\limits_{k\\to\\infty}f_k(x)&gt; n\\right\\} \\\\ &amp; =\\bigcap\\limits_{n=1}^{\\infty} \\bigcap\\limits_{m=1}^{\\infty} \\bigcup\\limits_{k=m}^{\\infty} \\left\\{  f_k(x)&gt;n\\right\\} \\end{aligned} \\] <p>同理可知，原式为可数个开集的交</p> <p>[!question] Ch1 45 求证：\\(\\mathbb{R}\\)上任一实函数的连续点全体是可数个开集的交</p> <p><code>Proof.</code></p> <p>注：相当重要的一个结论，可以使用振幅考虑</p> <p>定义一个振幅\\(w_{f(x_{0})}=\\lim\\limits_{ \\delta \\to 0 }\\sup\\left\\{  \\lvert f(x')-f(x'') \\rvert|:x',x'' \\in B_{\\delta}(x_{0})\\right\\}\\)，如果\\(f\\)在\\(x_{0}\\)连续显然有振幅为0，那么\\(x_{0}\\in \\bigcap\\limits_{n=1}^{\\infty}\\left\\{ x\\in \\mathbb{R}:w_{f(x)}&lt; \\frac{1}{n} \\right\\}\\)</p> \\[\\begin{aligned} &amp;\\forall x_{1}\\in \\left\\{ x\\in \\mathbb{R},w_{f(x)}&lt; \\frac{1}{n} \\right\\},w_{f(x_{1})}&lt; \\frac{1}{n}\\\\&amp;\\implies \\exists\\delta_{1}&gt;0,\\lvert f(x_{1}')-f(x_{1}'') \\rvert&lt; \\frac{1}{n}(x',x''\\in(x_{1}-\\delta_{1},x_{1}+\\delta_{1}))\\\\ &amp;\\implies \\forall x\\in(x_{1}-\\delta_{1},x_{1}+\\delta_{1}),w_{f(x)}\\leqslant w_{f(x_{1})}&lt; \\frac{1}{n}\\\\ &amp;\\implies(x_{1}-\\delta_{1},x_{1}+\\delta_{1})\\subset \\left\\{ x\\in \\mathbb{R}:w_{f(x)}&lt; \\frac{1}{n} \\right\\}  \\end{aligned}\\] <p>从而可知\\(\\left\\{ x\\in \\mathbb{R},w_{f(x)}&lt; \\frac{1}{n} \\right\\}\\)是一个开集，那么可以得到它是可数个开集的交</p> <p>[!question] Ch1 46 求证: 闭集是可数个开集的交, 开集是可数个闭集的并.</p> <p><code>Proof.</code></p> <p>注：只需要证前半部分,后面可以用De Morgan公式得出，构造如下\\(E\\)是闭集</p> \\[ E=\\bigcap\\limits_{n=1}^{\\infty} E_{n}=\\bigcap\\limits_{n=1}^{\\infty} \\left\\{ x:d(x,E) &lt; \\frac{1}{n}\\right\\}  \\] <p>首先我们证明距离函数是一个连续函数，那么令\\(f(x)=d(x,E)\\)我们有：</p> <p>\\(\\forall z\\in E,f(x)\\leqslant d(x,z)\\leqslant d(x,y)+d(y,z)\\)那么有\\(f(x)-d(x,y)\\leqslant d(y,z)\\leqslant d(y,E)+\\varepsilon\\)</p> <p>可以得到\\(f(x)-f(y)\\leqslant d(x,y)+\\varepsilon\\implies \\lvert f(x)-f(y) \\rvert\\leqslant d(x,y)\\)</p> <p>\\(\\forall x\\in E,d(x,E)=0\\)属于交集显然成立，\\(E\\subset \\bigcap\\limits_{n=1}^{\\infty}E_{n}\\)</p> <p>若是有\\(d(x,E)&lt; \\frac{1}{n},n\\to \\infty,d(x,E)=0\\)</p> <p>[!question] Ch1 47 设\\(F_1\\)和\\(F_2\\)是两个不相交的闭集. 求证: 有不相交开集\\(G_1\\)和\\(G_2\\), 使 \\(F_1\\subset G_1, F_2\\subset G_2\\).</p> <p><code>Proof.</code></p> <p>令\\(f(x)=d(x,F_{1})-d(x,F_{2})\\)</p> <p>\\(\\forall x\\in F_{1},f(x)=-d(x,F_{2})&lt;0,\\forall x\\in F_{2},f(x)=d(x,F_{1})&gt;0\\)</p> <p>取\\(G_{1}=f^{-1}(&lt;0),G_{2}=f^{-1}(&gt;0)\\)根据上面有\\(F_{1}\\subset G_{1},F_{2}\\subset G_{2}\\)，连续函数保证两个集合均为开集，那么证毕</p> <p>注：在点集拓扑中有相关的背景，这是\\(T_{4}\\)的空间，两个不相交的闭集，可以通过两个不相交的开集来分离，实际上任何一个度量空间都是\\(T_{4}\\)的</p> <p>[!question] Ch1 48 若有界闭集族\\(\\{F_\\lambda\\}_{\\lambda\\in\\Lambda}\\)中任何有限个元的交非空，求证\\(\\bigcap\\limits_{\\lambda\\in\\Lambda} F_\\lambda\\neq\\varnothing.\\) 上述命题中若把“有界闭集”改成“闭集”,命题是否还成立？</p> <p><code>Proof.</code></p> <p>根据条件有限个元交非空，考虑有限覆盖定理，考虑利用紧性构造有限个子覆盖(有界闭集族)，再利用反证法，假设\\(\\bigcap\\limits_{\\lambda\\in\\Lambda} F_\\lambda=\\emptyset\\),那么存在一个元素不妨记为\\(F_{\\lambda_{1}}\\)使得\\(F_{\\lambda_{1}}\\bigcap \\left( \\bigcap\\limits_{\\lambda \\in\\Lambda,\\lambda\\neq\\lambda_{1}} F_{\\lambda}\\right)=\\emptyset\\)，那么有\\(F_{\\lambda_{1}}\\subset \\bigcup\\limits_{\\lambda \\in\\Lambda,\\lambda\\neq\\lambda_{1}}F_{\\lambda}^{c}\\)，而\\(F_{\\lambda}^{c}\\)是开集，所以构成了一个开覆盖，由于有界闭集有紧性(一般的\\(\\mathbb{R}^{n}\\)空间中)，可以选取有限个子覆盖(为方便从2开始记)，那么\\(F_{\\lambda_{1}}\\subset \\bigcup\\limits_{n=2}^{m}F_{\\lambda_{n}}^{c},\\bigcup\\limits_{n=2}^{m}F_{\\lambda_{n}}\\subset F_{\\lambda_{1}}^{c},\\bigcap\\limits_{n=1}^{m}F_{\\lambda _{n}}=\\emptyset\\)</p> <p>所以导出矛盾，得证</p> <p>如果是闭集，构造反例选取有界开球的补：\\(F_{n}=\\left\\{ (x,y),x^{2}+y^{2}\\geqslant n \\right\\}\\)，不难看出有限个元的交非空但是\\(n\\)从1到无穷的交为空集，故命题不成立</p> <p>[!question] Ch1 49 设\\(G\\)是开集，\\(\\left\\{ F_{\\lambda} \\right\\}_{\\lambda\\in\\Lambda}\\)是有界闭集族并且\\(\\bigcap\\limits_{\\lambda\\in\\Lambda}F_{\\lambda }\\subset G\\).求证：\\(\\left\\{ F_{\\lambda} \\right\\}_{\\lambda\\in\\Lambda}\\)中有有限个元，它们的交是\\(G\\)的子集</p> <p><code>Proof.</code></p> <p>考虑使用Heine-Borel定理，那么需要一个开覆盖，考虑对原本的交取补</p> <p>由于\\(\\bigcap\\limits_{\\lambda\\in\\Lambda}F_{\\lambda }\\subset G\\implies\\bigcup\\limits_{\\lambda\\in\\Lambda}F_{\\lambda }^{c}\\supset G^{c}\\)，并且由于定理条件的有界性再做截断，选取\\(F_{\\lambda_{0}}\\in\\left\\{ F_{\\lambda} \\right\\}_{\\lambda\\in\\Lambda}\\)，可知\\(\\bigcup\\limits_{\\lambda\\in\\Lambda}F_{\\lambda }^{c}\\supset G^{c}\\bigcap F_{\\lambda_{0}}\\)，右边是有界闭集也就是紧的(\\(\\mathbb{R}^{n}\\)空间)，利用Heine-Borel定理，有\\(m&gt;0,m\\in \\mathbb{Z}^{+},s.t.\\bigcup\\limits_{i=1}^{m}F^{c}_{\\lambda}\\supset \\left( F_{\\lambda_{0}} \\bigcap G^{c}\\right)\\)，</p> <p>取补可得，\\(\\bigcap\\limits_{i=1}^{m}F_{\\lambda}\\subset \\left( F_{\\lambda_{0}} ^{c}\\bigcup G\\right)\\)，再将右侧限制在\\(G\\)内，\\(\\left( \\bigcap\\limits_{i=1}^{m}F_{\\lambda} \\right)\\bigcap F_{\\lambda_{0}}\\subset \\left( F_{\\lambda_{0}}^{c} \\bigcup G\\right)\\bigcap F_{\\lambda_{0}}=G\\bigcap F_{\\lambda_{0}}\\subset G\\)</p> <p>综上可证，有有限个元的交是\\(G\\)的子集</p> <p>[!question] Ch1 50 设 \\(f\\) 在 \\(\\mathbf{R}\\) 上可微, 而且对任何 \\(\\alpha \\in \\mathbf{R},\\left\\{x: f^{\\prime}(x)=\\alpha\\right\\}\\) 是闭集. 求证: \\(f^{\\prime}(x)\\) 连续.</p> <p><code>Proof.</code></p>","path":["周性伟-Ch1"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E5%91%A8%E6%80%A7%E4%BC%9F-Ch1/#51-60","level":2,"title":"51-60","text":"<p>[!question] Ch1 51 求证: 用十进制小数表示 \\([0,1]\\) 中的数时, 其用不着数字 7 的一切数构成一完备集.</p> <p><code>Proof.</code></p> <p>[!question] Ch1 52 求证：满足题13中条件的点\\(x\\)全体是一个完备集</p> <p><code>Proof.</code></p> <p>令满足13中条件的点构成的集合为\\(Y\\)，欲证\\(Y\\)是完备集即证\\(Y\\)是闭集且无孤立点，根据14可以知道这个集合是不可数集</p> <p>\\(1^{\\circ}\\) 闭集：证明\\(Y^{c}\\)是开集，取\\(y\\in Y^{c}\\)那么有\\(\\delta_{y},s.t.(y-\\delta_{y},y+\\delta_{y})\\bigcap E\\)至多可数，于是有\\((y-\\delta_{y},y+\\delta_{y})\\in Y^{c}\\)即开集，得到原集合闭集</p> <p>\\(2^{\\circ}\\) 无孤立点：任取\\(Y\\)中的点记为\\(x_{0},\\forall\\delta\\),\\((x_{0}-\\delta,x_{0}+\\delta)\\bigcap E\\)不可数，再构造两个新的集合\\(E_{1}=\\left\\{ \\left[ (x_{0}-\\delta,x_{0})\\bigcup(x_{0},x_{0}+\\delta) \\right]\\bigcap E \\right\\}\\)，容易知道\\(E_{1}\\)不可数且含于\\(E\\)，利用13的结论构造类似\\(Y\\)的集合\\(Y_{1}:=\\left\\{ x:\\forall\\delta&gt;0,(x-\\delta,x+\\delta)\\bigcap E_{1}\\text{不可数} \\right\\}\\)，集合\\(Y_{1}\\bigcap E_{1}\\)非空(13)，那么其中假设有一点\\(x_{1},\\lvert x_{1}-x_{0} \\rvert&lt;\\delta\\)，且\\(x_{1}\\in Y\\)，与假设矛盾，所以无孤立点.</p> <p>证法2：利用Lindelof性，可以找到一个可数覆盖</p> <ol> <li>求证: \\(\\mathbf{R}\\) 中任一不可数闭集必是一个完备集与一个至多可数集的并.</li> </ol> <p>[!question] Ch1 53 求证: \\(\\mathbf{R}\\) 中任一非空完备集有连续统势.</p> <ol> <li> <p>其中 \\(C\\) 是 Cantor 完备集, \\(C+C=\\left\\{x+y: x, y \\in C\\right\\}\\), 并且对每一 \\(x \\in[0,2]\\), 具体描述 \\(C\\) 中的 \\(y\\) 和 \\(z\\) 使 \\(x=y+z\\). (提示: 仅取 0 和 2 的二元数列 \\(\\left\\{a_{n}\\right\\}\\) 所对应的实数 \\(x=\\sum_{n=1}^{\\infty} \\frac{a_{n}}{3^{n}}\\) 都在 \\(C\\) 中.)</p> </li> <li> <p>集的并, 则 \\(A\\) 称为第一纲集; 非第一纲集称为第二纲集. 求证:</p> </li> </ol> <p>(i) 至多可数集是第一纲集;</p> <p>(ii) 区间是第二纲集;</p> <p>(iii) \\([a, b]\\) 中能表示为可数个开集的交的稠子集是第二纲集.</p> <ol> <li>若 \\(\\mathbf{R}\\) 上的连续函数列 \\(\\left\\{f_{k}\\right\\}_{k \\geqslant 1}\\) 使对每一 \\(x \\in \\mathbf{R}\\), 数列 \\(\\left\\{f_{k}(x)\\right\\}_{k \\geqslant 1}\\) 有界, 求证: \\(\\left\\{f_{k}\\right\\}\\) 必在一个区间上一致有界.</li> </ol> <p>[!question] Ch1 58 若 \\(f\\) 在 \\([0,1]\\) 中所有有理点处连续. 求证: \\(f\\) 至少在一个无理点处连续.</p> <p><code>Proof.</code></p> <p>利用45题的结论：</p> <p>[!question] Ch1 59 例 设对任何 \\(x, y \\in \\mathbf{R}, f(x+y)=f(x)+f(y)\\). 现若 \\(f\\) 不是连续函数 求证: \\(\\{(x, f(x)): x \\in \\mathbf{R}\\}\\) 在 \\(\\mathbf{R}^{2}\\) 中稠.</p> <p><code>Proof.</code></p> <p>思考：这个条件是很熟悉的一个柯西方程，我们很容易应用相关的方法</p> <p>此时由条件可得三个结论: \\(f\\) 在 \\(x=0\\) 不连续; \\(f(0)=0\\); 对每一有理数 \\(r\\) 有 \\(f(r x)=r f(x)\\). 因此不妨设有 \\(x_{k}&gt;0, x_{k} \\rightarrow 0, f\\left(x_{k}\\right) \\geqslant \\varepsilon\\), 其中 \\(\\varepsilon\\) 是与 \\(k\\) 无关的正数.</p> <p>现在首先可证明对任何实数 \\(y\\), 必有实数列 \\(\\left\\{b_{p}\\right\\}_{p \\geqslant 1}\\) 使 \\(\\left(b_{p}, f\\left(b_{p}\\right)\\right) \\rightarrow(0, y)\\). 事实上对每一 \\(p \\geqslant 1\\), 取 \\(k_{p}\\) 使 \\(x_{k_{p}}&lt;\\frac{1}{p}\\). 取有理数列 \\(\\left\\{r_{p}\\right\\}\\) 使 \\(r_{p} f\\left(x_{k_{p}}\\right) \\rightarrow y(p \\rightarrow \\infty)\\).此时易证 \\(\\left\\{r_{p}\\right\\}\\) 是有界的, 从而 \\(r_{p} x_{k_{p}} \\rightarrow 0(p \\rightarrow \\infty)\\). 取 \\(b_{p}=r_{p} x_{k_{p}}\\) 即可. 现对任何 \\((x, y) \\in \\mathbf{R}^{2}\\), 由上述, 存在 \\(\\left\\{b_{p}\\right\\}_{p \\geqslant 1}\\) 使 \\(\\left(b_{p}, f\\left(b_{p}\\right)\\right) \\rightarrow(0, y-f(x))(p \\rightarrow \\infty)\\). 从而得知 \\(\\left(b_{p}+x, f\\left(b_{p}+x\\right)\\right) \\rightarrow(x, y)\\).</p> <p>[!question] Ch1 60 把 \\([0,1)\\) 表示成 \\(c\\) 个两两不相交的完备集的并.</p>","path":["周性伟-Ch1"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E5%91%A8%E6%80%A7%E4%BC%9F-Ch2/","level":1,"title":"周性伟-Ch2","text":"","path":["周性伟-Ch2"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E5%91%A8%E6%80%A7%E4%BC%9F-Ch2/#1-10","level":2,"title":"1-10","text":"<p>[!question] Ch2 1 设\\(E_{1}\\subset E_{2}\\subset \\mathbb{R}\\)，求证：\\(m^{*}(E_{1})\\leqslant m^{*}(E_{2})\\)</p> <p><code>Proof.</code></p> <p>只需要按照定义，我们找一个开区间列覆盖\\(E_{2}\\)那么根据包含关系它们一定覆盖\\(E_{1}\\)，而外测度的定义是在所有覆盖中的下确界，那么\\(E_{2}\\)的所有覆盖一定能覆盖\\(E_{1}\\)，也就是\\(m^{*}(E_{1})\\leqslant m^{*}(E_{2})\\)</p> <p>[!question] Ch2 2 求证：\\(m^{*}(E)=\\inf\\left\\{ m(Q):E\\subset Q,Q\\text{是开集} \\right\\}\\)</p> <p><code>Proof.</code></p> <p><code>一维情形</code></p> <p>不妨将右侧记为\\(\\lambda\\)方便后续书写</p> <p>根据定义和外测度的单调性显然有\\(m^{*}(E)\\leqslant \\lambda\\)，下面对\\(m^{*}(E)\\)进行讨论，显然当\\(m^{*}(E)=\\infty\\)时结论成立，那么下面考虑\\(m^{*}(E)&lt;\\infty\\)时</p> <p>对于任意的正数\\(\\varepsilon&gt;0\\)，存在开区间列\\(\\left\\{ I_{k} \\right\\}_{k \\geqslant 1}s.t.E\\subset \\bigcup\\limits_{k=1}^{\\infty}I_{k},\\sum\\limits_{n=1}^{\\infty}l(I_{n})&lt;m^{*}(E)+\\varepsilon\\),而\\(Q=\\bigcup\\limits_{k=1}^{\\infty}I_{k}\\)也是开集那么有</p> \\[ \\lambda \\leqslant m(Q)&lt;m^{*}(E)+\\varepsilon \\] <p>再根据\\(\\varepsilon\\)的任意性即可得到结论成立.</p> <p><code>n维情形</code></p> <p>根据\\(\\mathbb{R}^{n}\\)中Lebesgue外测度的定义，开长方体的并集均为开集，所以</p> \\[ \\left\\{ Q|E\\subset Q,Q\\text{是开集} \\right\\} \\supseteq \\left\\{ \\bigcup\\limits_{i=1}^{\\infty} Q|E\\subseteq \\bigcup\\limits_{i=1}^{\\infty} Q,Q\\text{是开长方体} \\right\\}  \\] <p>所以我们有</p> \\[ \\begin{aligned} m^{*}(E)&amp;=\\inf \\left\\{ \\sum\\limits_{i=1}^{\\infty} m(Q_{i})|E\\subseteq \\bigcup\\limits_{i=1}^{\\infty} Q_{i},Q_{i}\\text{是开长方体} \\right\\} \\\\ &amp;\\geqslant \\inf \\left\\{ m\\left( \\bigcup\\limits_{i=1}^{\\infty} Q_{i} \\right)|E \\subseteq \\bigcup\\limits_{i=1}^{\\infty} Q_{i} ,Q_{i}\\text{是开长方体}\\right\\} \\\\ &amp;\\geqslant \\inf \\left\\{ m\\left( Q \\right)|E \\subseteq Q ,Q\\text{是开集}\\right\\} \\end{aligned} \\] <p>另一侧仍然显然.</p> <p>注：这种题目的做法是比较单一的：首先确认我们的目标，因为\\(E\\subset Q\\)，所以利用外测度的单调性显然有\\(m^{*}(E)\\leqslant \\lambda\\)，再考虑另一方向，通常会采用增减一个\\(\\varepsilon\\)利用它的任意性证明，而在这里我们可以考虑下确界的性质构造出\\(\\varepsilon\\)</p> <p>[!question] Ch2 3 设\\(E\\subset \\mathbb{R},M&gt;0.\\)求证：\\(m^{*}(E)=\\inf\\left\\{ \\sum\\limits_{n=1}^{\\infty}l(I_{n}):I_{n} \\text{为开区间}，l(I_{n})&lt;M,E\\subset \\bigcup\\limits_{n=1}^{\\infty}I_{n} \\right\\}\\)</p> <p><code>Proof.</code></p> <p>同2记号，有\\(m^{*}(E)\\leqslant \\lambda\\)，显然，另一边若是有\\(m^{*}(E)=\\infty\\)结论成立</p> <p>若是\\(m^{*}(E)&lt;\\infty\\)，则有\\(\\forall\\varepsilon&gt;0,\\exists \\left\\{ I_{n} \\right\\}_{n\\geqslant 1}s.t. E\\subset \\bigcup\\limits_{n=1}^{\\infty}I_{n},\\sum\\limits_{n=1}^{\\infty}l(I_{n})\\leqslant m^{*}(E)+\\varepsilon\\)，根据\\(m^{*}(E)\\)的有界性我们可以得到\\(l(I_{n})&lt; \\infty\\)，那么一定可以找到有限多个区间\\(I_{n}^{(k)}\\)使得\\(I_{n}\\subset \\bigcup\\limits_{k=1}^{m_{n}}I_{n}^{(k)},l(I_{n}^{(k)})&lt;M\\)并且为了后续的证明有\\(\\sum\\limits_{k=1}^{m_{n}}l(I_{n}^{(k)})&lt;l(I_{n})+ \\frac{\\varepsilon}{2^{n}}\\)</p> \\[ \\lambda \\leqslant \\sum\\limits_{n=1}^{\\infty} \\sum\\limits_{k=1}^{m_{n}} l(I_{n}^{(k)})\\leqslant\\sum\\limits_{n=1}^{\\infty} \\left( l(I_{n})+ \\frac{\\varepsilon}{2^{n}} \\right)\\leqslant m^{*}(E)+2\\varepsilon \\] <p>令\\(\\varepsilon \\to 0\\)即可得到所需结论</p> <p>[!question] Ch2 4 设\\(G_{1}\\)和\\(G_{2}\\)是不相交开集，\\(E_{1}\\subset G_{1},E_{2}\\subset G_{2}\\)，求证：\\(m^{*}\\left( E_{1}\\bigcup E_{2} \\right)=m^{*}(E_{1})+m^{*}(E_{2})\\)</p> <p><code>Proof</code></p> <p>由已知得两集合不交,那么\\(E_{1}\\subset G_{1},E_{2}\\subset G_{1}^{c}\\)，因为\\(G_{1}\\)可测，所以根据Caratheodory条件得</p> \\[ \\begin{aligned} m^{*}\\left( E_{1}\\bigcup E_{2} \\right)&amp;\\geqslant m^{*}\\left( \\left( E_{1}\\bigcup E_{2} \\right)\\bigcap G_{1} \\right)+m^{*}\\left( \\left( E_{1}\\bigcup E_{2} \\right)\\bigcap G_{1}^{c} \\right) \\\\ &amp;=m^{*}(E_{1})+m^{*}(E_{2}) \\end{aligned} \\] <p>反向由次可加性显然，从而得到\\(m^{*}\\left( E_{1}\\bigcup E_{2} \\right)=m^{*}(E_{1})+m^{*}(E_{2})\\)</p> <p>[!question] Ch2 5 若\\(d(E_{1},E_{2})=\\inf\\left\\{ d(x_{1},x_{2}):x_{1}\\in E_{1},x_{2}\\in E_{2} \\right\\}&gt;0\\)，求证：\\(m^{*}\\left( E_{1}\\bigcup E_{2} \\right)=m^{*}(E_{1})+m^{*}(E_{2})\\)</p> <p><code>Proof.</code></p> <p>考虑利用2.4结论，那么构造两个不相交的开集记为\\(G_{1},G_{2}\\),\\(G_{1}=\\bigcup\\limits_{x\\in E_{1}}V\\left( x, \\frac{1}{2}d(E_{1},E_{2}) \\right),G_{2}=\\bigcup\\limits_{x\\in E_{2}}V\\left( x, \\frac{1}{2}d(E_{1},E_{2}) \\right)\\)，可知\\(E_{1}\\subset G_{1},E_{2}\\subset G_{2}\\)，利用2.4可知结论成立</p> <p>[!question] Ch2 6 设\\(m^{*}(A)&lt;\\infty,m^{*}(B)&lt;\\infty\\)，求证：\\(\\lvert m^{*}(A) -m^{*}(B)\\rvert \\leqslant m^{*}(A\\Delta B)\\)</p> <p><code>Proof</code></p> <p>只需要使用两个集合关系和次可加性，\\(A\\subset (A\\Delta B)\\bigcup B\\implies m^{*}(A)\\leqslant m^{*}(A\\Delta B)+m^{*}(B)\\)，同理可知\\(m^{*}(B)\\leqslant m^{*}(A\\Delta B)+m^{*}(A)\\)，综合两个不等式即证</p> <p>注：仍然是集合表示的技巧</p> <p>[!question] Ch2 8(i)(ii) 设对每一\\(x\\in I=(a,b)\\)，\\(A_{x}\\)是一个实数集，而且当\\(x_{1}&lt;x_{2}\\)时\\(A_{x_{1}}\\subset A_{x_{2}}\\)，求证：</p> <p>(i)\\(m^{*}\\left( \\bigcup\\limits_{x\\in I}A_{x} \\right)=\\lim\\limits_{ x \\to b^{-} }m^{*}(A_{x})\\) (ii)\\(m^{*}\\left( \\bigcap\\limits_{x\\in I}A_{x} \\right)=\\lim\\limits_{ x \\to a^{+} }m^{*}(A_{x})\\)</p> <p><code>Proof.</code></p> <p>(i)利用2.7的结论，构造一个单调递增的点列\\(\\left\\{ x_{n} \\right\\}\\to b\\)，由题设单调性可知\\(\\bigcup\\limits_{x\\in I}A_{x}=\\bigcup\\limits_{n=1}^{\\infty}A_{x_{n}}\\)</p> \\[ \\begin{aligned} m^{*}\\left( \\bigcup\\limits_{x\\in I}A_{x} \\right)&amp;=\\lim\\limits_{ n \\to \\infty } m^{*}(A_{x_{n}})=\\lim\\limits_{ x \\to b^{-} }m^{*}(A_{x})  \\end{aligned} \\] <p>(ii)</p> \\[\\begin{aligned} \\forall y\\in(a,b),\\bigcap\\limits_{x\\in I}A_{x}\\subset A_{y}&amp;\\implies m^{*}\\left( \\bigcap\\limits_{x\\in I}A_{x} \\right)\\leqslant m^{*}(A_{y})\\\\ &amp;\\implies m^{*}\\left( \\bigcap\\limits_{x\\in I}A_{x} \\right)\\leqslant \\lim\\limits_{ x \\to a^{+} }m^{*}(A_{x}) \\end{aligned}\\] <p>9.设 \\(E \\subset \\mathbf{R}, 0 &lt; m^*(E) &lt; \\infty\\), 求证: \\(f(x) = m^*((-\\infty, x) \\cap E)\\) 是 \\(x\\) 的连续函数. 由此证明 \\(I = \\{m^*(F): F \\subset E\\}\\) 是一个有界闭区间.</p> <p>[!question] Ch2 10 设\\(\\left\\{ E_{n} \\right\\}_{n\\geqslant 1}\\)是可测集列 (i)求证\\(m\\left( \\varliminf\\limits_{ n \\to \\infty }E_{n} \\right)\\leqslant \\varliminf\\limits_{ n \\to \\infty }m(E_{n});\\) (ii)若有\\(k_{0}\\)使\\(m\\left( \\bigcup\\limits_{k=k_{0}}^{\\infty}E_{k} \\right)&lt;\\infty\\)，求证：</p> \\[ m\\left( \\varlimsup\\limits_{ n \\to \\infty }E_{n} \\right)\\geqslant \\varlimsup\\limits_{ n \\to \\infty }m(E_{n}); \\] <p>(iii) 若 \\(m\\left(\\bigcup_{k=1}^\\infty E_k\\right) &lt; \\infty\\) 且 \\(\\lim_{n \\to \\infty} E_n\\) 存在, 求证:</p> \\[m\\left(\\lim_{n \\to \\infty} E_n\\right) = \\lim_{n \\to \\infty} m(E_n).\\] <p><code>Proof.</code></p> <p>(i)</p> <p>\\(\\bigcap\\limits_{m=n}^{\\infty}E_{m}\\subset E_{n}\\)且关于n单增可得</p> \\[ \\begin{aligned} m\\left( \\varliminf\\limits_{ n \\to \\infty }E_{n} \\right)&amp;=m\\left( \\bigcup\\limits_{n=1}^{\\infty} \\bigcap\\limits_{m=n}^{\\infty} E_{m} \\right) =m\\left( \\lim\\limits_{ n \\to \\infty } \\bigcap\\limits_{m=n}^{\\infty} E_{m} \\right) \\\\ &amp;=\\lim\\limits_{ n \\to \\infty } m\\left( \\bigcap\\limits_{m=n}^{\\infty} E_{m} \\right) \\\\ &amp;\\leqslant \\varliminf\\limits_{ n \\to \\infty }m(E_{n}) \\end{aligned} \\] <p>(ii)</p> \\[ \\begin{aligned} m\\left( \\varlimsup\\limits_{ n \\to \\infty }E_{n} \\right)&amp;=m\\left( \\bigcap\\limits_{n=1}^{\\infty} \\bigcup\\limits_{m=n}^{\\infty} E_{m} \\right) =m\\left( \\lim\\limits_{ n \\to \\infty } \\bigcup\\limits_{m=n}^{\\infty} E_{m} \\right) \\\\ &amp;=\\lim\\limits_{ n \\to \\infty } m\\left( \\bigcup\\limits_{m=n}^{\\infty} E_{m} \\right) \\left( \\exists k_{0},s.t.m\\left( \\bigcup\\limits_{k=k_{0}}^{\\infty}E_{k} \\right)&lt;\\infty \\right) \\\\ &amp;\\geqslant \\varlimsup\\limits_{ n \\to \\infty }m(E_{n}) \\end{aligned} \\] <p>(iii)</p> <p>由(i)(ii)直接得出</p>","path":["周性伟-Ch2"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E5%91%A8%E6%80%A7%E4%BC%9F-Ch2/#11-20","level":2,"title":"11-20","text":"<p>[!question] Ch2 11 设 \\(A\\) 可测并且 \\(m(A \\triangle B) = 0\\), 求证: \\(B\\) 可测.</p> <p><code>Proof.</code></p> <p>\\(m(A\\Delta B)=m^{*}\\left( (A-B)\\bigcup(B-A) \\right)=0\\)，所以\\(m^{*}(A-B)=m^{*}(B-A)=0\\)，为零测集，所以两集合可测，再利用\\(A\\)可测，得到\\(A\\bigcap B=A-(A-B)\\)可测，\\(B=\\left( A\\bigcap B \\right)\\bigcup(B-A)\\)，所以\\(B\\)可测</p> <p>[!question] Ch1 12 设\\(0 &lt; m(E) &lt; \\infty\\). 求证: 有测度皆为 \\(m(E)\\) 的开集列\\(\\{G_n\\}_{n \\geqslant 1}\\), 使\\(m(E \\triangle G_n) \\to 0(n \\to \\infty)\\).</p> <p><code>Proof.</code></p> <p>[!question] Ch2 13 设 \\(E_1\\) 和 \\(E_2\\) 都可测, 求证: \\(m(E_1) + m(E_2) = m(E_1 \\cup E_2) + m(E_1 \\cap E_2)\\).</p> <p><code>Proof.</code></p> <p>利用集合关系构造两两不交的并可得</p> \\[ \\begin{aligned} m(E_{2})&amp;=m\\left( E_{2}\\bigcap E_{1} \\right)+m\\left( E_{2}\\bigcap E_{1}^{c} \\right)\\\\ m\\left( E_{1}\\bigcup E_{2} \\right)&amp;=m\\left(  E_{1} \\right)+m\\left( E_{2}\\bigcap E_{1}^{c} \\right)\\\\ \\implies m(E_1) + m(E_2) &amp;= m(E_1 \\cup E_2) + m(E_1 \\cap E_2) \\end{aligned} \\] <p>注：简单的利用集合关系即可</p> <p>[!question] Ch2 14 求证: \\(\\mathbb{R}\\) 中可测集全体有基数 \\(2^{c}\\).</p> <p><code>Proof.</code></p> <p>Step1. \\(\\mathbb{R}\\)中子集全体的基数为\\(2^{c}\\)，那么可测集全体的基数小于等于\\(2^{c}\\)</p> <p>Step2. 考虑Cantor集，测度为零(可测)但具有连续统势，它的子集全体的基数为\\(2^{c}\\)，那么可测集全体的基数大于等于\\(2^{c}\\)</p> <p>[!question] Ch2 15  (i) 若 \\(F\\) 是 \\([0, 1]\\) 中闭集且 \\(m(F) = 1\\). 试问是否一定 \\(F = [0, 1]\\)? (ii) 若 \\(G\\) 是 \\((0, 1)\\) 中开集且 \\(m(G) = 1\\). 试问是否一定 \\(G = (0, 1)\\)?</p> <p><code>Sol</code></p> <p>(i)一定</p> <p>若是不然，必存在一点\\(x_{0}\\in \\left( [0,1]-F \\right)\\)，再利用闭集的性质一定存在一个\\(\\varepsilon &gt; 0\\)，使得\\(V(x_{0},\\varepsilon)\\subset F^{c}\\bigcap[0,1],m\\left( [0,1]-F\\right)&gt;0\\)，由此导出矛盾：\\(m\\left( [0,1] \\right)=m\\left( F \\right)+m([0,1]-F)&gt;1\\)</p> <p>(ii)不一定</p> <p>只需要考虑Cantor集在\\([0,1]\\)的补集\\(G=[0,1]\\setminus C\\)，Cantor集是零测集所以G的测度为1，但是\\(G\\neq (0,1)\\)</p> <p>[!question] Ch2 16 若 \\(A \\bigcup B\\) 和 \\(A\\) 都可测, 试问 \\(B\\) 是否一定可测? 若其中 \\(m(A) = 0\\), 结论如何? 若 \\(A \\cap B = \\varnothing\\), 结论又如何?</p> <p><code>Sol.</code></p> <p>第一个命题不一定，反例为\\(A=[0,1],B\\)为\\([0,1]\\)中的不可测集(在课本中给出了构造方法)，那么\\(A\\bigcup B,A\\)可测，\\(B\\)不可测</p> <p>[!question] Ch2 17 设\\(E \\subset \\mathbf{R}, m(E) &gt; 0, 0 &lt; \\alpha &lt; 1\\). 求证: 有开区间\\(I\\)使\\(m(I \\cap E) &gt; \\alpha \\cdot m(I)\\).</p> <p><code>Proof.</code></p> <p>[!question] Ch2 18 设可测集 \\(E \\subset [0, 1]\\). 若有 \\(\\delta &gt; 0\\), 使对 \\([0, 1]\\) 中任何区间 \\((a, b)\\) 有 \\(m(E \\cap (a, b)) \\geqslant \\delta(b - a)\\) 求证: \\(m(E) = 1\\).</p> <p><code>Proof.</code></p> <p>[!question] Ch2 19 设 \\(E \\subset \\mathbf{R}, m(E) &gt; 0, [a, b]\\) 是有界区间, \\(\\varepsilon &gt; 0\\). 求证: 有有限个实数 \\(\\{x_k\\}_{1 \\leq k \\leq n}\\), 使 \\([a, b] - \\bigcup_{k=1}^n E_{x_k}\\) 的测度小于 \\(\\varepsilon\\), 其中 \\(E_{x_k} = \\{x + x_k : x \\in E\\}\\).</p> <p>[!question] Ch2 20 设 \\(\\{E_k\\}_{k \\geq 1}\\) 是 \\([0, 1]\\) 中测度皆为 1 的可测集列, 求证:</p> \\[m\\left(\\bigcap_{k=1}^\\infty E_k\\right) = 1.\\] <p><code>Proof.</code></p> <p>考虑利用次可加性，转换为并集求补：</p> \\[ \\begin{aligned} m\\left(\\bigcap_{k=1}^\\infty E_k\\right)&amp; = m\\left( [0,1] \\right) -m\\left( [0,1]-\\bigcap_{k=1}^\\infty E_k \\right) \\\\ &amp;=1-m\\left(\\bigcup\\limits_{k=1}^{\\infty} \\left( E_{k}^{c}\\bigcap[0,1] \\right) \\right) \\\\ &amp;\\geqslant 1-\\sum\\limits_{k=1}^{\\infty} m\\left( E_{k}^{c}\\bigcap[0,1] \\right)\\\\ &amp;=1 \\end{aligned} \\] <p>而\\(\\bigcap\\limits_{k=1}^{\\infty}E_{k}\\subset[0,1],m\\left( \\bigcap\\limits_{k=1}^{\\infty}E_{k} \\right)\\leqslant 1\\)，综上可知：\\(m\\left( \\bigcap\\limits_{k=1}^{\\infty}E_{k} \\right)=1\\)</p> <p>注：在实变函数中我们更倾向于使用并运算来替代交运算，因此本题也应当采用取补的方法，方便进行测度的运算.</p>","path":["周性伟-Ch2"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E5%91%A8%E6%80%A7%E4%BC%9F-Ch2/#21-30","level":2,"title":"21-30","text":"<p>[!question] Ch2 21 设 \\(\\{E_k\\}_{k \\geq 1}\\) 是 \\([0, 1]\\) 中的可测集列, 使得 \\(m(E_k) \\to 1 (k \\to \\infty)\\).  求证: 对任何 \\(0 &lt; \\lambda &lt; 1\\), 有子列 \\(\\{E_{k_n}\\}_{n \\geq 1}\\) 使 \\(m\\left(\\bigcap\\limits_{n=1}^\\infty E_{k_n}\\right) &gt; \\lambda\\).</p> <p><code>Proof.</code></p> <p>同20题考虑证明并集：\\(m\\left( (E_{k}^{c})\\bigcap[0,1] \\right)\\to 0(k\\to \\infty)\\)，那么\\(\\forall\\varepsilon=\\frac{1-\\lambda}{2^{i}}&gt;0.\\exists N,n&gt;N,m(E_{k_{n}})&lt; \\frac{1-\\lambda}{2^{i}}(i\\in Z^{+})\\)，</p> \\[ \\begin{aligned} m\\left(\\left( \\bigcap_{n=1}^\\infty E_{k_{n}} \\right)^{c}\\bigcap[0,1]\\right)&amp; = m\\left( \\bigcup\\limits_{n=1}^{\\infty} \\left( E_{k_{n}}^{c}\\bigcap[0,1] \\right)\\right) \\\\ &amp;\\leqslant \\sum\\limits_{n=1}^{\\infty} m\\left( E_{k_{n}}^{c}\\bigcap[0,1] \\right)\\\\ &amp;&lt;\\sum\\limits_{n=1}^{\\infty} \\frac{1-\\lambda}{2^{n}}=1-\\lambda \\end{aligned} \\] <p>那么可知\\(m\\left(\\bigcap\\limits_{n=1}^\\infty E_{k_n}\\right) &gt; \\lambda\\)</p> <p>[!question] Ch2 22 设 \\(\\{E_k\\}_{1 \\leqslant k \\leqslant n}\\) 是 \\([0, 1]\\) 中的 \\(n\\) 个可测集, 满足 \\(\\sum\\limits_{k=1}^n m(E_k) &gt; n - 1\\).  求证: \\(m\\left(\\bigcap\\limits_{k=1}^n E_k\\right) &gt; 0\\).</p> <p><code>Proof.</code></p> <p>仍然同上取补集</p> \\[ \\begin{aligned} m\\left(\\bigcap_{k=1}^n E_k\\right)&amp; = m\\left( [0,1] \\right) -m\\left( [0,1]-\\bigcap_{k=1}^n E_k \\right) \\\\ &amp;=1-m\\left(\\bigcup\\limits_{k=1}^{n} \\left( E_{k}^{c}\\bigcap[0,1] \\right) \\right) \\\\ &amp;\\geqslant 1-\\sum\\limits_{k=1}^{n} m\\left( E_{k}^{c}\\bigcap[0,1] \\right)\\\\ &amp;&gt;1-\\left[ n-\\sum\\limits_{k=1}^{n} m(E_{k}) \\right]\\\\ &amp;=0 \\end{aligned} \\] <p>[!question] Ch2 24 设 \\(m^*(E) &lt; \\infty\\). 试证下列 3 件事等价: (i) \\(E\\) 可测; (ii) 存在 \\(E\\) 的闭子集列 \\(\\{F_n\\}\\) 使 \\(m(F_n) \\to m^*(E)\\); (iii) 存在 \\(E\\) 的可测子集列 \\(\\{E_n\\}\\) 使 \\(m(E_n) \\to m^*(E)\\).</p> <p><code>Proof.</code></p> <p>\\((i)\\to(ii)\\)</p> <p>利用Th2.5.1，由\\(E\\)可测可知对于任意给定的\\(\\varepsilon&gt;0，\\)存在一个含于\\(E\\)闭集\\(F\\)使得\\(m^{*}(E-F)&lt;\\varepsilon\\)，那么取\\(\\varepsilon_{n}=\\frac{1}{n}\\)，有\\(m^{*}(E-F_{n})&lt; \\frac{1}{n}\\)，又\\(E-F_{n}\\)可测，可得\\(0&lt;m(E-F_{n})&lt; \\frac{1}{n}\\)，两边取极限\\(n\\to \\infty\\)，可证.</p> <p>\\((ii)\\to(iii)\\)</p> <p>闭集是可测的，所以取闭子集列即可.</p> <p>\\((iii)\\to(i)\\)</p> <p>由于\\(E_{n}\\subset E,m(E_{n})\\to m^{*}(E)\\)，那么有可测的定义有</p> \\[\\begin{aligned} m^{*}(E)&amp;=m^{*}\\left( E\\bigcap E_{n} \\right)+m^{*}\\left( E\\bigcap E_{n}^{c} \\right)\\\\ &amp;=m^{*}(E_{n})+m^{*}(E-E_{n}) \\end{aligned}\\] <p>可知\\(m^{*}(E-E_{n})\\to0,m^{*}\\left( E-\\bigcup\\limits_{n=1}^{\\infty}E_{n} \\right)\\leqslant m^{*}(E-E_{n})\\to 0\\)，因为外测度为0所以可测，考虑原集合可以表示为两个可测集的并.</p> <p>由于\\(E=\\left( \\bigcup\\limits_{n=1}^{\\infty}E_{n} \\right)\\bigcup \\left( E-\\bigcup\\limits_{n=1}^{\\infty}E_{n} \\right)\\)，所以可测.</p> <p>[!question] Ch2 25 设 \\(m^*(E) &lt; \\infty\\). 求证: 有 \\(G_\\delta\\) 集 \\(H\\), 使 \\(H \\supset E, m^*(E) = m(H)\\).</p> <p><code>Proof</code></p> <p>根据外测度性质，对于任意\\(\\frac{1}{n}\\)存在开集\\(G_{n}\\supset E,m^{*}(G_{n}-E)&lt; \\frac{1}{n}\\)</p> <p>构造\\(H=\\bigcap\\limits_{n=1}^{\\infty}G_{n},E\\subset H\\)，由外测度的单调性可知：</p> \\[ m^{*}(E)\\leqslant m^{*}(H)=m(H)\\leqslant m^{*}(G_{n})&lt;m^{*}(E)+ \\frac{1}{n} \\] <p>两边取极限可得\\(m(H)=m^{*}(E)\\)</p> <p>注：这是利用开集逼近的一个简单例子，并没有什么难度</p> <p>[!question] Ch2 26 设 \\(A \\bigcup B\\) 可测且 \\(m(A \\cup B) = m^*(A) + m^*(B) &lt; \\infty\\). 求证: \\(A\\) 和 \\(B\\) 都可测. </p> <p>[!tip]- Hint 取 \\(G_\\delta\\)集\\(H\\)使\\(H \\supset B, m(H) = m^*(B)\\). 此时可证\\((A \\cup B) \\cap H^c\\) 是\\(A\\)的可测子集, 其测度为\\(m^*(A)\\).</p> <p><code>Proof.</code></p> <p>直接利用2.25题的结论我们可以取一个\\(G_{\\delta}\\)集\\(H\\)使得\\(H\\supset B,m(H)=m^{*}(B)\\)，容易知道\\(\\left( A\\bigcup B \\right)\\bigcap H^{c}\\)也是可测的，而且它应当是\\(A\\)的子集，令\\(E=A\\bigcap H^{c}\\)，下证\\(m(E)=m^{*}(A)\\)</p> <p>我们知道\\(B\\subset \\left( A\\bigcup B \\right)\\bigcap H,m^{*}(B)\\leqslant m^{*}\\left( \\left( A\\bigcup B \\right)\\bigcap H \\right)\\leqslant m(H)=m^{*}(B)\\)，那么有\\(m^{*}(B)=m^{*}\\left( \\left( A\\bigcup B \\right)\\bigcap H \\right)\\)</p> \\[ \\begin{aligned} m^{*}(A)+m^{*}(B)&amp;=m\\left( A\\bigcup B \\right)\\\\ &amp;=m\\left( \\left( A\\bigcup B \\right) \\bigcap H\\right)+m\\left( \\left( A\\bigcup B \\right)\\bigcap H^{c} \\right)\\\\ &amp;=m^{*}(B)+m(E) \\end{aligned} \\] <p>即证\\(m^{*}(A)=m(E)\\)</p> <p>然后再考虑利用可测的等价条件：</p> <p>根据2.2我们可以找到一个开集\\(G\\)，使得\\(m(G)&lt;m^{*}(A)+\\varepsilon\\)</p> <p>并且我们有\\(E\\subset A\\subset G\\)，且\\(m(G-E)=m(G)-m(E)&lt;m^{*}(A)+\\varepsilon-m^{*}(A)=\\varepsilon\\)，可知\\(A\\)可测，同理可知\\(B\\)可测</p> <p>[!question] Ch2 27 构造不相交的集 \\(A\\) 和 \\(B\\) 使 \\(m^*(A \\cup B) &lt; m^*(A) + m^*(B)\\).</p> <p><code>Sol.</code></p> <p>当集合可测且两两不交时这个不等式取等那么我们直接考虑不可测集合：</p> <p>取\\(A\\)为\\([0,1]\\)中的不可测集合，\\(B\\)为其在\\([0,1]\\)中的补集，我们知道\\(A\\bigcup B\\)可测，那么根据次可加性有\\(m^{*}\\left( A\\bigcup B \\right)\\leqslant m^{*}(A)+m^{*}(B)\\)</p> <p>若是取等根据2.26可知\\(A,B\\)都可测，矛盾，所以只能取严格小于</p> <p>注：本题给出了一个结论就是外测度不一定满足次可加性</p> <p>[!question] Ch2 28 设 \\(E \\subset \\mathbf{R}, m(E) &gt; 0\\). 令</p> \\[E^* = \\{x \\in E : \\text{对任何 } \\delta &gt; 0 \\text{ 有 } m(E \\cap (x - \\delta, x + \\delta)) &gt; 0\\}.\\] <p>求证: \\(E^*\\) 可测且 \\(m(E^*) = m(E)\\).</p> <p><code>Proof.</code></p> <p>考虑证明\\(m^{*}(E-E^{*})=0\\)，那么就说明\\(E-E^{*}\\)是可测的</p> <p>\\(\\forall x \\in E-E^{*},\\exists\\delta_{x},s.t.m\\left( E\\bigcap(x-\\delta_{x},x+\\delta_{x}) \\right)=0\\)，利用选取有理点的技巧在\\((x-\\delta_{x},x+\\delta _{x})\\)中选取\\((r_{x},R_{x})\\subset(x-\\delta_{x},x+\\delta _{x})\\)，然后有\\(m\\left( E\\bigcap(r_{x},R_{x}) \\right)=0\\)</p> <p>并且容易知道\\(E-E^{*}=\\bigcup\\limits_{x \\in E-E^{*}}\\left( E\\bigcap(r_{x},R_{x}) \\right)\\)，并且为至多可数并，那么可得\\(\\forall x \\in E-E^{*},m\\left( E\\bigcap(r_{x},R_{x}) \\right)=0\\implies m(E-E^{*})=0\\)</p> <p>这里注意零测集一定是可测的，那么\\(E^{*}=E\\bigcap(E-E^{*})^{c}\\)也可测</p> <p>注：本题类似Ch1的13 14 52题，都使用到了在区间内取有理点构造至多可数并的技巧，可以看出这个技巧是相当重要的</p> <p>[!question] Ch2 29 设 \\(E \\subset \\mathbb{R}\\) 可测, \\(a\\) 和 \\(b\\) 是两个实数.  求证: \\(F = \\{ax + b : x \\in E\\}\\) 可测并且 \\(m(F) = |a| \\cdot m(E)\\).</p> <p><code>Proof.</code></p> <p><code>法1</code></p> <p>若是\\(a=0\\)，单点集结论显然，利用平移不变性也可以忽略\\(b\\)，即令\\(b=0\\)</p> <p>不妨设\\(a&gt;0\\)，若是\\(m(E)=\\infty\\),那么\\(m(F)=\\infty\\)，可知成立，那么取一开覆盖，不妨令\\(m(E)&lt;\\infty,\\exists \\left\\{ I_{k} \\right\\}_{k\\geqslant 1}\\supset E，s.t.\\sum\\limits_{i=1}^{\\infty}\\lvert I_{i} \\rvert&lt;m^{*}(E)+\\varepsilon\\)</p> <p>此时\\(\\bigcup\\limits_{i=1}^{\\infty}aI_{i}\\supset F,m^{*}(F)&lt;\\sum\\limits_{i=1}^{\\infty}\\lvert a \\rvert\\lvert I_{i} \\rvert=\\lvert a \\rvert m^{*}(E)+\\lvert a \\rvert\\varepsilon\\)</p> <p>可知\\(m^{*}(F)\\leqslant \\lvert a \\rvert m^{*}(E)\\)</p> <p>同理可知\\(m^{*}(E)\\leqslant \\frac{1}{\\lvert a \\rvert}m^{*}(F)\\)，综上可知：\\(m^{*}(F)=\\lvert a \\rvert m^{*}(E)\\)</p> <p>还需要说明\\(F\\)可测：</p> \\[ \\begin{aligned} m^{*}\\left( F\\bigcap A \\right)&amp;=m^{*}\\left( aE\\bigcap A \\right)=\\lvert a \\rvert m^{*}\\left( E\\bigcap \\frac{A}{a} \\right)\\\\ m^{*}\\left( F^{c}\\bigcap A \\right)&amp;=m^{*}\\left( aE^{c}\\bigcap A \\right)=\\lvert a \\rvert m^{*}\\left( E^{c}\\bigcap \\frac{A}{a} \\right)\\\\ m^{*}\\left( F\\bigcap A \\right)+m^{*}\\left( F^{c}\\bigcap A \\right)&amp;=\\lvert a \\rvert m^{*}\\left( \\frac{A}{a} \\right)=m^{*}(A) \\end{aligned} \\] <p>由此可知可测，证毕</p> <p><code>法2</code></p> <p>由于\\(E\\)可测，取一个开集\\(G\\supset E,m(G-E)&lt; \\frac{\\varepsilon}{a}\\)</p> <p>再利用上述外测度性质\\(m(aG-aE)&lt;\\varepsilon\\)，也就是\\(\\forall\\varepsilon&gt;0,\\exists aE+b\\)是开集，使得\\(m^{*}(aG+b-F)&lt;\\varepsilon\\)，那么可知\\(F\\)可测</p> <p>注：这主要是将证明可测进行了一个修改，不使用定义而是使用开集的逼近性质</p>","path":["周性伟-Ch2"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E5%91%A8%E6%80%A7%E4%BC%9F-Ch2/#31-40","level":2,"title":"31-40","text":"<p>[!question] Ch2 31 例 若 \\(E \\subset \\mathbf{R}, m(E) &gt; 0\\), 求证 0 是 \\(\\{x - y : x, y \\in E\\}\\) 的内点.</p> <p><code>Proof.</code></p> <p>由题 17, 存在开区间 \\((a, b)\\) 使 \\(m((a, b) \\cap E) &gt; \\frac{3}{4}(b - a)\\). 令 \\(F = (a, b) \\cap E\\). 可证 0 是 \\(H = \\{x - y : x, y \\in F\\}\\) 的内点. 因为不然就有 \\(z_n \\not\\in H\\) 使 \\(z_n \\to 0\\). 令 \\(F_n = \\{x + z_n : x \\in F\\}\\), 则 \\(F_n\\) 可测, \\(m(F_n) = m(F) &gt; \\frac{3}{4}(b - a)\\), 而且对一切 \\(n \\geq 1\\) 有 \\(F_n \\cap F = \\varnothing\\). 于是 \\(m(F_n \\cup F) &gt; \\frac{6}{4}(b - a)\\). 但对任何 \\(\\varepsilon &gt; 0\\), 当 \\(n\\) 充分大(\\(z_{n}\\to 0\\))时 \\(F_n \\cup F \\subset (a - \\varepsilon, b + \\varepsilon)\\). 由此得矛盾.</p> <p>下面是助教的讲义(有一些记号没有说明)：</p> <p>来自其他书的提示: </p> <p>Indeed, there exists an open interval I so that \\(m(E \\cap I) \\geq (9/10)m(I)\\). If we denote \\(E \\cap I\\) by \\(E_0\\), and suppose that the difference set of \\(E_0\\) does not contain an open interval around the origin, then for arbitrarily small a the sets \\(E_0\\) and \\(E_0 + a\\) are disjoint. From the fact that \\((E_0 \\cup (E_0 + a)) \\subseteq (I \\cup (I + a))\\) we get a contradiction, since the left-hand side has measure \\(2m(E_0)\\), while the right-hand side has measure only slightly larger than \\(m(I)\\).</p> <p>有了提示这个题没什么必要做. 取 \\(m(E \\cap I) \\geq (9/10)m(I)\\) (课本 Ex17, 老师上课讲过), 假设 0 不是 \\(E_0 - E_0\\) 的内点, 那么存在一列趋于 0 的数列 \\(y_n\\) 使得 \\(y_n \\notin E_0 - E_0\\), 那么 \\(E_0 \\cap y_n + E_0\\) 是空的, 根据可数可加性和平移不变性可得</p> \\[ \\begin{aligned} \\frac{9}{5}m(I) \\leqslant 2m(E_n) &amp;= m(E_n) + m(y_n + E_0) \\\\&amp;= m(E_0 \\cup y_n + E_0)\\\\ &amp;\\leqslant m(I \\cup y_n + I) \\\\&amp;= m(I) + |y_n| \\end{aligned}\\] <p>令\\(n\\)足够大使得\\(y_n &lt; \\frac{1}{5}m(I)\\)就能导出矛盾. 因此0是\\(E_0 - E_0\\)的内点, 后者含于 \\(E - E\\), 证毕</p> <p>[!question] Ch2 32 设 \\(m(A) &gt; 0, m(B) &gt; 0\\). 求证: \\(\\{a - b : a \\in A, b \\in B\\}\\) 及 \\(\\{a + b : a \\in A, b \\in B\\}\\) 都有内点.</p> <p>[!question] Ch2 33 设\\(m(E)&gt;0\\),而且只要\\(x,y\\in E\\),就有\\(\\frac x+y2\\in E\\),求证：\\(E\\)有内点.</p> <p>[!question] Ch2 34 (0,1)中的数\\(x\\)用十进制表示\\(,x_n\\)是其第\\(n\\)位小数.令\\(A_9=\\{x\\in(0,1):\\max\\{x_n\\}=9\\}.\\)求证：\\(m(A_9)=1.\\)</p> <p>[!question] Ch2 35 在题 34 中，若\\(A=\\{x\\in(0,1):\\{x_n\\}\\)中只有有限个 9\\(\\}\\),求证：\\(m(A)=0.\\)</p> <p>[!question] Ch2 36 设\\(m(E)&gt;0.\\)求证：\\(E\\)有不可测子集.</p> <p><code>Proof.</code></p> <p><code>法一</code></p> <p>下面是助教给出的一个解答:</p> <p>只证\\(E\\subset \\mathbb{R}\\)，在实变函数中没有本质区别，考虑一个等价关系\\(x\\sim y\\iff y-x \\in \\mathbb{Q}\\)，令\\(\\mathcal{N}\\)是\\(E\\)中所有互不相同的等价类中只选取一个元素放入\\(\\mathcal{N}\\)形成的集合，那么容易知道其中任意两个元素的差要么为0，要么为无理数(否则在同一个等价类中)，下面证明这个集合不可测.</p> <p>反证法，假设\\(\\mathcal{N}\\)可测，那么记所有的有理数为\\(\\left\\{ r_{n} \\right\\}\\)那么\\(\\bigcup\\limits_{n=1}^{\\infty}\\mathcal{N}+r_{n}\\supseteq E\\)(这是显然的，根据定义即可得到)，从而再利用测度的平移不变性，得到\\(m(\\mathcal{N})&gt; 0\\)，再根据2.31的结论我们知道0是内点，则有\\(r\\in \\left\\{ x-y|x,y\\in \\mathcal{N} \\right\\}\\)，但是我们根据上面的讨论知道任意两个元素之差不可能为非0的有理数，矛盾，所以不可测.</p> <p><code>法二</code></p> <p>完全可以仿照书中构造不可测集的方式做：</p> <p>Step 1 做截断</p> <p>\\(m(E)&gt;0,\\exists n,s.t.m\\left( E\\bigcap[-n,n] \\right)&gt;0\\)，\\(\\bigcup\\limits_{n=1}^{\\infty}\\left( E\\bigcap[-n,n] \\right)=E\\)</p> <p>记\\(A=E\\bigcap[-n,n],\\forall x \\in A,A(x)=\\left\\{ y \\in A,y-x  \\in \\mathbb{Q}\\right\\}\\)，那么也存在一个集合\\(F\\)使得\\(A=\\bigcup\\limits_{x\\in F}A(x)\\)</p> <p>Step 2 仿照构造方式</p> <p>就是选取等价类然后像上面那样构造集合就好了，我们知道这个\\(A(x_{i})\\)两两不交，那么可以构造下面的\\(F_{i}\\)，利用测度的平移不变性</p> <p>令\\(F_{i}=F_{r_{i}}\\)，其中\\(\\left\\{ r_{k} \\right\\}=[-2n,2n]\\bigcap \\mathbb{Q}\\)，可以知道\\(A\\subset \\bigcup\\limits_{i=1}^{\\infty}F_{i}\\subset[-3n,3n]\\)</p> <p>为什么选取\\(2n\\)呢?是因为\\(A=E\\bigcap[-n,n]\\)的长度最大为\\(2n\\)</p> <p>Step 3 利用不等式约束</p> <p>假设\\(F\\)可测，\\(m(F_{i})=m(F)\\)，由可测集的可数并也可测我们知道\\(\\bigcup_{i}F_{i}\\)也可测，并且可以用两两不交得到\\(m\\left( \\bigcup\\limits_{i=1}^{\\infty}F_{i} \\right)=\\sum\\limits_{i=1}^{\\infty}m(F_{i})\\)</p> \\[ 0&lt;m(A)\\leqslant m\\left( \\bigcup\\limits_{n=1}^{\\infty} \\mathcal{N}+r_{n} \\right)=\\sum\\limits_{n=1}^{\\infty} m(\\mathcal{N}+r_{n})\\leqslant 6n \\] <p>注：我们可以凭借这个命题给出一个很有用的推论，如果\\(A\\subset \\mathbb{R}\\)且它的任意子集都可测那么它一定是零测集.这个命题本身也是一个相当重要的结论，它的适用性很广便于我们从它出发构造反例，导出矛盾等</p> <p>[!question] Ch2 37 设\\(F\\)是[0,1]中不可测集.求证：有\\(0&lt;\\varepsilon&lt;1\\),使对[0,1]中任何满足\\(m(E)\\geqslant\\varepsilon\\)的可测集 \\(E,F\\bigcap E\\) 也是不可测集.</p> <p><code>Proof.</code></p> <p>反证，对于任何的\\(0&lt;\\varepsilon&lt;1\\)，总存在\\([0,1]\\)中的可测集\\(A,m(A)\\geqslant \\varepsilon\\)，但是\\(F\\bigcap A\\)是可测的，欲证\\(F\\)可测</p> <p>利用这个条件，分别取\\(\\varepsilon=1-\\frac{1}{n}\\)即可构造\\(E_{n},m(E_{n})\\geqslant 1- \\frac{1}{n}\\)，对于零测集显然交集也可测，\\(F\\bigcap E_{n}\\)可测，构造可测的并集\\(E=\\bigcup\\limits_{i=1}^{\\infty}E_{i},m(E)\\geqslant m(E_{n})=1-\\frac{1}{n}\\)，那么可知\\(m(E)=1\\)</p> <p>根据\\(\\bigcup\\limits_{n=1}^{\\infty} \\left( F\\bigcap E_{n} \\right)=F\\bigcap E\\)，可知\\(F\\bigcap E\\)可测，而\\(F\\bigcap([0,1]-E)\\subset[0,1]-E\\)，而\\(m([0,1]-E)=0\\)，零测集显然可测，那么根据集合关系\\(F=\\left( F\\bigcap E \\right)\\bigcup\\left( F\\left( \\bigcap[0,1]-E \\right) \\right)\\)，那么\\(F\\)可测与题设矛盾</p> <p>[!question] Ch2 38 设\\(f(x)\\)定义在\\(\\mathbb{R}\\)上，并且对任何可测集\\(E,f(E)\\)可测.求证：对任何零测集\\(Z,f(Z)\\)也是零测集.(提示：利用题 36.)</p> <p><code>Proof.</code></p> <p>反证，若是\\(m(f(Z))&gt;0\\)，必可找到一个不可测子集\\(X\\subset f(Z)\\)，那么\\(Z\\bigcap f^{-1}(X)\\)也是零测集，那么\\(f\\left( Z\\bigcap f^{-1}(X) \\right)=X\\)也是可测的，与题设矛盾</p> <p>[!question] Ch2 39 设\\(f(x)\\)在\\(\\mathbb{R}\\)上连续.求证：为使\\(f\\)把任何可测集变为可测集，充要条件是\\(f\\)把任何零测集变为零测集</p> <p><code>Proof.</code></p> <p>根据38，必要性成立</p> <p>充分性：</p> <p>设\\(f\\)可将零测集变为零测集，对于任何的可测集\\(E\\)，可分解为\\(F_{\\sigma}\\)集和零测集(记为\\(G\\))的并，\\(F_{\\sigma}=\\bigcup\\limits_{n=1}^{\\infty}F_{n}\\)，其中\\(F_{n}\\)是闭集</p> <p>$$ f(E)=f(F)\\bigcup f(G)=\\left( \\bigcup\\limits_{n=1}^{\\infty}  f(F_{n}) \\right)\\bigcup f(G) $$ 根据条件\\(f(G)\\)也是零测集，是可测的，现在只需要证明\\(f(F_{n})\\)也是可测的，考虑利用\\(f\\)的连续性，证明\\(F_{n}\\)是紧的，构造\\(F_{n_{i}}=F_{n}\\bigcap[i,i+1],F_{n}=\\bigcup\\limits_{i=-\\infty}^{\\infty}F_{n_{i}}\\)</p> <p>可知\\(\\bigcup\\limits_{n=1}^{\\infty}\\bigcup\\limits_{i=-\\infty}^{\\infty}F_{n_{i}}\\)可测(可数个闭集的并)，综上可知\\(f(E)\\)也是可测的</p>","path":["周性伟-Ch2"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E5%91%A8%E6%80%A7%E4%BC%9F-Ch2/#41-43","level":2,"title":"41-43","text":"<p>[!question] Ch2 42 设\\(0&lt;\\varepsilon&lt;1\\)，试构造\\([0,1]\\)中测度为\\(\\varepsilon\\)的完备疏集(提示：参考Cantor完备集的构造)</p> <p><code>Sol.</code></p> <p>仿照Cantor集的构造，在\\([0,1]\\)区间的中间取走长度为\\(\\frac{1-\\varepsilon}{3}\\)的开区间，再在剩下的2个区间中间取走长度\\(\\frac{1-\\varepsilon}{3^{2}}\\)的开区间...在\\(2^{n-1}\\)个区间中间取走长度为\\(\\frac{1-\\varepsilon}{3^{n}}\\)的开区间</p> <p>它的测度为\\(1-\\sum\\limits_{i=1}^{\\infty}(1-\\varepsilon)\\left( \\frac{1}{3} \\right)^{i}2^{i-1}=\\varepsilon\\)</p> <p>下面证明它是完备疏集</p> <p>由于可数多个闭集并仍然是闭集，只需要说明构造的集合(记为\\(C\\))是稀疏的且没有孤立点(完备)</p> <p>对于孤立点，考虑构造的集合中的每个区间端点都不会在构造过程中被取走，所以内部一定不含孤立点，对于端点则是必定有一侧稠密，显然不含有孤立点</p> <p>证明稀疏性：</p> <p>对于\\(\\mathbb{R}\\)上的任意一个开集也就是一个开区间，由于构造过程中每个子区间长度为\\(\\frac{1-\\varepsilon}{3^{n}}\\to 0\\)，无法容纳任何开区间(开集)，由外测度的单调性即可得到矛盾，所以等价的一定有某个非空开子集不于与\\(C\\)相交，即证稀疏.</p> <p>10.设 \\(\\{E_n\\}_{n \\geqslant 1}\\) 是可测集列,</p> <p>(i) 求证 \\(m\\left(\\underline{\\lim}_{n \\to \\infty} E_n\\right) \\leqslant \\overline{\\lim}_{n \\to \\infty} m(E_n)\\);</p> <p>(ii) 若有 \\(k_0\\) 使 \\(m\\left(\\bigcup_{k=k_0}^\\infty E_k\\right) &lt; \\infty\\), 求证:</p> \\[m\\left(\\overline{\\lim}_{n \\to \\infty} E_n\\right) \\geqslant \\overline{\\lim}_{n \\to \\infty} m(E_n);\\] <p>(iii) 若 \\(m\\left(\\bigcup_{k=1}^\\infty E_k\\right) &lt; \\infty\\) 且 \\(\\lim_{n \\to \\infty} E_n\\) 存在, 求证:</p> \\[m\\left(\\lim_{n \\to \\infty} E_n\\right) = \\lim_{n \\to \\infty} m(E_n).\\] <ol> <li> <p>设 \\(\\{E_k\\}_{k \\geq 1}\\) 是 \\([0, 1]\\) 中的可测集列, 使得 \\(m(E_k) \\to 1 (k \\to \\infty)\\). 求证: 对任何 \\(0 &lt; \\lambda &lt; 1\\), 有子列 \\(\\{E_{k_n}\\}_{n \\geq 1}\\) 使 \\(m\\left(\\bigcap_{n=1}^\\infty E_{k_n}\\right) &gt; \\lambda\\).</p> </li> <li> <p>设 \\(\\{E_k\\}_{1 \\leq k \\leq n}\\) 是 \\([0, 1]\\) 中的 \\(n\\) 个可测集, 满足 \\(\\sum_{k=1}^n m(E_k) &gt; n - 1\\). 求证: \\(m\\left(\\bigcap_{k=1}^n E_k\\right) &gt; 0\\).</p> </li> <li> <p>设 \\(\\{\\Lambda_\\chi\\}_{\\lambda \\in A}\\) 是一族区间, 求证: \\(E = \\bigcup_{\\lambda \\in A} I_\\lambda\\) 可测.</p> </li> <li> <p>设 \\(m^*(E) &lt; \\infty\\). 试证下列 3 件事等价:</p> </li> </ol> <p>(i) \\(E\\) 可测;</p> <p>(ii) 存在 \\(E\\) 的闭子集列 \\(\\{F_n\\}\\) 使 \\(m(F_n) \\to m^*(E)\\);</p> <p>(iii) 存在 \\(E\\) 的可测子集列 \\(\\{E_n\\}\\) 使 \\(m(E_n) \\to m^*(E)\\).</p> <ol> <li> <p>设 \\(m^*(E) &lt; \\infty\\). 求证: 有 \\(G_\\delta\\) 集 \\(H\\), 使 \\(H \\supset E, m^*(E) = m(H)\\).</p> </li> <li> <p>设 \\(A \\cup B\\) 可测且 \\(m(A \\cup B) = m^*(A) + m^*(B) &lt; \\infty\\). 求证: \\(A\\) 和 \\(B\\) 都可测. (提示: 取 \\(G_\\delta\\) 集 \\(H\\) 使 \\(H \\supset B, m(H) = m^*(B)\\). 此时可证 \\((A \\cup B) \\cap H^c\\) 是 \\(A\\) 的可测子集, 其测度为 \\(m^*(A)\\).)</p> </li> <li> <p>构造不相交的集 \\(A\\) 和 \\(B\\) 使 \\(m^*(A \\cup B) &lt; m^*(A) + m^*(B)\\).</p> </li> <li> <p>设 \\(E \\subset \\mathbf{R}, m(E) &gt; 0\\). 令</p> </li> </ol> \\[E^* = \\{x \\in E : \\text{对任何 } \\delta &gt; 0 \\text{ 有 } m(E \\cap (x - \\delta, x + \\delta)) &gt; 0\\}.\\] <p>求证: \\(E^*\\) 可测且 \\(m(E^*) = m(E)\\).</p> <ol> <li> <p>设 \\(E \\subset \\mathbf{R}\\) 可测, \\(a\\) 和 \\(b\\) 是两个实数. 求证: \\(F = \\{ax + b : x \\in E\\}\\) 可测并且 \\(m(F) = |a| \\cdot m(E)\\).</p> </li> <li> <p>设可测集 \\(E \\subset [0, \\infty), \\lambda &gt; 0\\). 求证: \\(E^\\lambda\\) 可测, 其中 \\(E^\\lambda = \\{x^\\lambda : x \\in E\\}\\).</p> </li> <li> <p>例 若 \\(E \\subset \\mathbf{R}, m(E) &gt; 0\\), 求证 0 是 \\(\\{x - y : x, y \\in E\\}\\) 的内点.</p> </li> </ol> <p>证明 由题 17, 存在开区间 \\((a, b)\\) 使 \\(m((a, b) \\cap E) &gt; \\frac{3}{4}(b - a)\\). 令 \\(F = (a, b) \\cap E\\). 可证 0 是 \\(H = \\{x - y : x, y \\in F\\}\\) 的内点. 因为不然就有 \\(z_n \\not\\in H\\) 使 \\(z_n \\to 0\\). 令 \\(F_n = \\{x + z_n : x \\in F\\}\\), 则 \\(F_n\\) 可测, \\(m(F_n) = m(F) &gt; \\frac{3}{4}(b - a)\\), 而且对一切 \\(n \\geq 1\\) 有 \\(F_n \\cap F = \\varnothing\\). 于是 \\(m(F_n \\cup F) &gt; \\frac{6}{4}(b - a)\\). 但对任何 \\(\\varepsilon &gt; 0\\), 当 \\(n\\) 充分大时 \\(F_n \\cup F \\subset (a - \\varepsilon, b + \\varepsilon)\\). 由此得矛盾.</p> <ol> <li>设 \\(m(A) &gt; 0, m(B) &gt; 0\\). 求证: \\(\\{a - b : a \\in A, b \\in B\\}\\) 及 \\(\\{a + b : a \\in A, b \\in B\\}\\) 都有内点.</li> </ol> <p>33.设\\(m(E)&gt;0\\),而且只要\\(x,y\\in E\\),就有\\(\\frac x+y2\\in E\\),求证：\\(E\\)有内点.</p> <p>34.(0,1)中的数\\(x\\)用十进制表示\\(,x_n\\)是其第\\(n\\)位小数.令\\(A_9=\\{x\\in(0,1):\\max\\{x_n\\}=9\\}.\\)求证：\\(m(A_9)=1.\\)</p> <p>35.在题 34 中，若\\(A=\\{x\\in(0,1):\\{x_n\\}\\)中只有有限个 9\\(\\}\\),求证：\\(m(A)=0.\\)</p> <p>36.设\\(m(E)&gt;0.\\)求证：\\(E\\)有不可测子集.</p> <p>37.设\\(F\\)是[0,1]中不可测集.求证：有\\(0&lt;\\varepsilon&lt;1\\),使对[0,1]中任何满足\\(m(E)\\geqslant\\varepsilon\\)的可测集 \\(E,F\\bigcap E\\) 也是不可测集.</p> <p>38 设\\(f(x)\\)定义在 R 上，并且对任何可测集\\(E,f(E)\\)可测.求证：对任何零测集\\(Z,f(Z)\\)也是零测集.(提示：利用题 36.)</p> <p>39.设\\(f(x)\\)在 R 上连续.求证：为使\\(f\\)把任何可测集变为可测集，充要条件是\\(f\\)把任何零测集变为零测集</p> <p>40.设\\(f(x)\\)在 R 上连续可微且\\(f^\\prime(x)&gt;0.\\)求证：当\\(E\\)可测时\\(,f^-1(E)\\)也可测. 41. 例 设\\(E\\subset[a,b]\\)可测\\(,\\{I_k\\}_1\\leqslant k\\leqslant n\\) 是\\([a,b]\\) 中 \\(n\\) 个开区间，并且 \\(m(I_k\\bigcap E)\\geqslant\\frac23m(I_k),1\\leqslant\\)</p> <p>\\(k\\leqslant n.\\) 求证：\\(m\\left(E\\bigcap\\left(\\bigcup_{k=1}^{n}I_{k}\\right)\\right)\\geqslant\\frac13m\\left(\\bigcup_{k=1}^{n}I_{k}\\right).\\)</p> <p>证明 不失一般性，设\\(I_k=(a_k,b_k)\\)满足下列三条件：(i) \\(a_1&lt;a_2&lt;\\cdots&lt;a_n;\\) (ii)\\(\\bigcup_k=1^nI_k=(a_1,b_n);(\\)iii)对任何\\(1&lt;k&lt;n,\\bigcup_s\\neq kI_s\\)不是开区间. 此时\\(I_1\\)仅与\\(I_2\\)有非空交，\\(I_n\\)仅与\\(I_n-1\\)有非空交，而对任何\\(1&lt;k&lt;n,I_k\\)仅与 \\(I_{k-1}\\)及\\(I_{k+1}\\)有非空交.下面对\\(n=3\\)来证，但其证法有一般性.此时</p> <p>\\(I_1=(I_1-I_2)\\bigcup(I_1\\bigcap I_2)\\triangleq A_1\\bigcup A_2\\), \\(I_2=(I_1\\bigcap I_2)\\bigcup(I_2-I_1-I_3)\\bigcup(I_2\\bigcap I_3)\\triangleq A_2\\bigcup A_3\\bigcup A_4\\), \\(I_3=(I_2\\bigcap I_3)\\bigcup(I_3-I_2)\\triangleq A_4\\bigcup A_5.\\) 其中\\(\\{A_k\\}_{1\\leqslant k\\leqslant5}\\)两两不相交且\\(\\bigcup_k=1^5A_k=\\bigcup_{k=1}^3I_k.\\)令 $\\(a_k=m(A_k),\\quad a_k^*=m(A_k\\bigcap E),\\quad1\\leqslant k\\leqslant5.\\)$ 由于\\(m(I_{k}\\bigcap E)\\geqslant\\frac{2}{3}m(I_{k})\\),从而由上面 3 个恒等式得 $\\(a_1^*+a_2^*=m(I_1\\bigcap E)\\geqslant\\frac{2}{3}m(I_1)=\\frac{2}{3}(a_1+a_2),\\)$ $\\(a_2^*+a_3^*+a_4^*=m(I_2\\bigcap E)\\geqslant\\frac{2}{3}m(I_2)=\\frac{2}{3}(a_2+a_3+a_4),\\)$ $\\(a_4^*+a_5^*=m(I_3\\bigcap E)\\geqslant\\frac{2}{3}m(I_3)=\\frac{2}{3}(a_4+a_5).\\)$ 由此易知 \\(2\\sum _{k= 1}^{5}a_{k}^{* }\\geqslant \\frac 23\\sum _{k= 1}^{5}a_{k}\\),即\\(m\\left(E\\bigcap\\bigcup_{k=1}^{3}I_{k}\\right)\\geqslant\\frac{1}{3}m\\left(\\bigcup_{k=1}^{3}I_{k}\\right).\\)</p>","path":["周性伟-Ch2"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/","level":1,"title":"第1章 集合与实数集","text":"<p>本章实际是一个预备知识篇(Preliminaries)，介绍基本的集合论概念和有关性质.</p> <p>[!tldr] 重点 + 集合相关的表示法和运算 + 集合表示的基本技巧 + 集合基数的比较 + Cantor集和其他重要集合的构造与应用 + \\(\\mathbb{R}^{n}\\)中的拓扑概念 + 基本的点集拓扑方法</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#_1","level":2,"title":"集合及其运算","text":"","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#_2","level":3,"title":"基本概念","text":"<p>基本的集合论知识在高中已经学过，这里不赘述.</p> <p>有一些基本的定理(或许称为性质更贴切)如下(证明留做习题)</p> <p>[!NOTE] Theorem 1.1.1 (1)对于任意的集合\\(A\\)，都有\\(A\\subset A\\) (2)若对集合\\(A,B,C\\)有\\(A\\subset B,B\\subset C\\)，则\\(A\\subset C\\)</p> <p><code>Proof.</code></p> <p>根据集合包含于的定义，任何集合自身的元素一定也属于自身；若是\\(A\\)中元素全部属于\\(B\\)，而\\(B\\)中的元素全部属于\\(C\\)，那么很容易知道\\(A\\)中的所有元素一定也是\\(C\\)的元素.(用定义说废话)</p> <p>定义了集合的种种关系之后，为了使它更加丰富还需要定义它的种种运算，也就是并差交补，还有比较新的对称差(定义上天然具有对偶的性质)，其中还会衍生出和通关系式和二元的De Morgan公式(很自然地推广到集族)</p> <p>注：主要的运算虽然只有并差交补，但是对称差有时也会提及作为一个简化的表示手法(简化交并运算)</p> <p>为了推广集合运算，就需要集族(集合\\(X\\)上的集族满足：集族上的每个元素都是\\(X\\)的子集)，一个生动的例子就是\\(\\mathbb{R}\\)上所有开区间就是\\(\\mathbb{R}\\)的集族.</p> <p>下面不加证明的列出一些定理(实际上都是运用相互包含关系证明集合相等)</p> <p>[!NOTE] Theorem 1.1.3(De Morgan) \\(\\left( \\bigcup\\limits_{\\lambda \\in \\Lambda}A_{\\lambda} \\right)^{c}=\\bigcap\\limits_{\\lambda\\in \\Lambda}A^{c}_{\\lambda},\\left( \\bigcap\\limits_{\\lambda \\in \\Lambda}A_{\\lambda} \\right)^{c}=\\bigcup\\limits_{\\lambda\\in \\Lambda}A^{c}_{\\lambda}\\)</p> <p>[!NOTE] Theorem 1.1.4 (1)\\(A\\Delta B=\\left( A\\bigcup B \\right)-\\left( A\\bigcap B \\right)\\) (2)\\(A\\Delta B=B\\Delta A\\)</p> <p>注：这里再额外给出一个常用的集合表达式，在很多题目的证明中会使用到这种分割的技巧(将一列集合转变为不交并的方法)：</p> \\[ B_{n}=A_{n}-\\bigcup\\limits_{i=1}^{n-1} A_{i} \\]","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#n","level":3,"title":"n维欧式空间","text":"<p>我们还需要一般的欧氏空间的定义，那么我们就需要定义距离(度量)以形成度量空间，在此之前是一个直积的定义(方便起见，直接定义\\(n\\)维的).</p> \\[ \\prod_{k=1}^{n} X_{k}=\\left\\{ \\left( x_{1},x_{2},\\dots,x_{n} \\right) :x_{k}\\in X_{k},1 \\leq k \\leq n \\right\\}  \\] <p>那么很自然地在上面定义加法和数乘，并利用2-范数定义Euclid距离</p> <p>定义出的距离将具有三大性质(不只有欧氏距离具有这些性质，这也说明距离的定义方式不唯一)：</p> <ul> <li>非负性</li> <li>对称性</li> <li>三角不等式</li> </ul> <p>[!tip] 赋范线性空间(泛函分析) 如果定义的一个度量满足以下三点 1. \\(\\forall x\\in \\mathbb{R}^{n},\\lvert x \\rvert \\geqslant 0 \\iff x=0,\\lvert x \\rvert=0\\); 2. \\(\\forall x\\in \\mathbb{R}^{n},\\lambda \\in \\mathbb{R},\\lvert \\lambda x \\rvert=\\lvert \\lambda \\rvert\\lvert x \\rvert\\); 3. \\(\\forall x,y\\in \\mathbb{R}^{n},\\lvert x+y \\rvert \\leqslant\\lvert x \\rvert+\\lvert y \\rvert\\).</p> <p>它就可以称为一个范数，空间\\(\\mathbb{R}^{n}\\)配备此范数后就构成了一个赋范线性空间，称为n维欧几里得空间</p> <p>Remark: 有了加法、数乘、欧氏距离后的\\(R^{n}\\)称为\\(n\\)维欧氏空间</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#_3","level":2,"title":"集合序列的极限","text":"<p>定义好\\(n\\)维欧式空间后很自然地会开始讨论极限，对于一般序列的极限，在数学分析中已经研究的比较清楚，那么为了将集合论语言应用于接下来的研究中，就需要利用集合论表示集合序列的极限.</p> <p>为了讨论方便起见，可以先考虑单调的集列，对于任意给定的集合序列我们可以构成两个不同的单调集列：</p> \\[ B_{n}=\\bigcup\\limits_{k=n}^{\\infty} A_{k},C_{n}=\\bigcap\\limits_{k=n}^{\\infty} A_{k} \\] <p>很自然的定义了单调性之后我们可以开始考虑极限问题(可以视作单调有界定理的启发)，然后就可以定义上下极限，并给出一个更为简单的刻画.</p> \\[ \\varlimsup\\limits_{ n \\to \\infty } A_{n}=\\bigcap\\limits_{n=1}^{\\infty} \\bigcup\\limits_{k=n}^{\\infty} A_{k},\\varliminf\\limits_{ n \\to \\infty } A_{n}=\\bigcup\\limits_{n=1}^{\\infty} \\bigcap\\limits_{k=n}^{\\infty} A_{k,} \\] <p>或许这里集合的表示方法比较抽象，这里可以参考一下杨力华和夏道行老师的教材，两本书都给出了比较详细的刻画，尤其是夏道行老师的书中直接给出的是下面将要给出的一个更为简单的等价刻画.</p> <p>当上下极限存在且相等时我们称极限存在，且极限就等于上极限(下极限)</p> <p>[!tip] 上下极限的一个等价刻画 上极限表示的是在集合列中无穷多次出现的元素，下极限表示的是只在有限多个集合中不出现的元素，容易从中看出下极限是上极限的一个子集. 还有一个比较关键的想法：可以将“并操作”视为数分中的“存在”，把“交操作”视为数分中的“任意”，这也是一种比较容易接受的理解方式.也为证明上述等价性提供了比较好的思路.</p> <p>注：我们在后续更经常在理解中使用这种等价刻画的形式，但是在严谨的证明中还是更多使用原本的集合论语言</p> <p>[!NOTE] Theorem 1.2.1 (1)(2)是上面的等价刻画，根据这种等价刻画很自然就会得到包含关系，以及下面的一个补充的性质 当\\(A_{n}\\)是单调递增或递减时有极限且极限为：</p> \\[\\lim\\limits_{ n \\to \\infty } A_{n}=\\left\\{ \\begin{matrix} \\bigcup\\limits_{n=1}^{\\infty} A_{n}&amp; \\left\\{ A_{n} \\right\\} \\text{单增}\\\\ \\\\ \\bigcap\\limits_{n=1}^{\\infty} A_{n}&amp; \\left\\{ A_{n} \\right\\} \\text{单减} \\end{matrix} \\right.\\] <p>证明就利用到了上下极限的定义和极限的定义</p> <p><code>Proof.</code></p> <p>方便起见只证明单调递增的情况，反方向同理可得，显而易见的\\(\\bigcup\\limits_{k=n}^{\\infty}A_{k}=\\bigcup\\limits_{k=1}^{\\infty}A_{k}\\)，\\(\\bigcap\\limits_{k=n}^{\\infty}A_{k}=A_{n}\\)</p> \\[ \\begin{aligned} \\varlimsup\\limits_{ n \\to \\infty } A_{n}&amp;=\\bigcap\\limits_{n=1}^{\\infty} \\bigcup\\limits_{k=n}^{\\infty} A_{k}=\\bigcap\\limits_{n=1}^{\\infty} \\bigcup\\limits_{k=1}^{\\infty} A_{k}=\\bigcup\\limits_{n=1}^{\\infty} A_{n}\\\\ \\varliminf\\limits_{ n \\to \\infty } A_{n}&amp;=\\bigcup\\limits_{n=1}^{\\infty} \\bigcap\\limits_{k=n}^{\\infty} A_{k}=\\bigcup\\limits_{n=1}^{\\infty} A_{n} \\end{aligned} \\]","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#_4","level":2,"title":"映射","text":"<p>主要还是回忆了基本的映射关系，不再赘述</p> <ul> <li>单射</li> <li>满射</li> <li>双射</li> <li>复合映射</li> <li>逆映射</li> </ul> <p>注1：尤其注意一下特征函数，虽然形式很简单但是在实分析中经常用到</p> <p>注2：还要留心映射与集合运算之间的关系：\\(f\\left( \\bigcup\\limits_{\\lambda}A_{\\lambda} \\right)=\\bigcup\\limits_{\\lambda}f(A_{\\lambda})\\)</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#_5","level":2,"title":"集合的等价、基数","text":"<p>这部分将分为四小节介绍 1. 基本定义 2. 有限集、无限集、可数集 3. 连续统势 4. 基数的比较</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#_6","level":3,"title":"基本定义","text":"<p>主要的定义是</p> <ul> <li>什么是等价<ul> <li>等价意味着存在一种双射关系，也是一种等价关系</li> <li>两两不交的各自等价的集合，并之后也是等价</li> </ul> </li> <li>什么是基数和势</li> </ul> <p>注：通过等价关系形成等价类的思想也值得熟悉一下，在后续的证明中也时常用到(分类可以说是一种常见的问题)</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#_7","level":3,"title":"有限集、无限集、可数集","text":"<p>集合分类：</p> <ul> <li>至多可数集<ul> <li>可数集</li> <li>有限集</li> </ul> </li> <li>不可数集</li> </ul> <p>一些比较重要的观念(定理)：</p> <ul> <li>可数集是基数最小的无限集(任意无限集可以选出可数子集)</li> <li>可数集的任一无限子集是可数集</li> <li>至多可数个可数集的并仍然是可数集(经典的集合构造，实际上是给出了一种可数排列方式，也就相应说明了可数)</li> <li>有理数全体是可数集</li> <li>\\([0,1]\\)是不可数集合以及不可数集合的构造</li> <li>至多可数集不破坏无限集的等价性(也就是原本等价的无限集并上至多可数集仍然等价)-杨力华：无限集的基数对可数增减的不变性</li> <li>不存在基数最大的集，因为子集全体的势永远大于原本的集合</li> </ul> <p>将重要的点提取出来就是下面的一个重要定理：</p> <p>[!tip] Theorem 1.4.3 1. 任一无限集必含有一个可数子集 2. 可数集的任一无限子集是可数集 3. 至多可数个可数集的并是可数集</p> <p>注：这个定理在本章用处很多，需要仔细的思考并体会意思，可以多积累有关用法和推论</p> <p><code>Proof.</code></p> <p>证明方法还是简单朴素的：</p> <ol> <li>只需要任意挑选出一个元素，并用余集还是一个无限集的性质</li> <li>利用可数集的下标即可排序</li> <li>也是一个排序的问题，可以将\\(A_{n}=\\left\\{ a_{1}^{n},a_{2}^{n},\\dots,a_{k}^{n}\\dots \\right\\}\\)改为按照\\(B_{n}=\\left\\{ a_{1}^{n},a_{2}^{n-1},\\dots,a_{n}^{1} \\right\\}\\)排列，变为了有限集合的并，这样就可以给出新的排序方式了</li> </ol> <p>注：注意证明可数性实际相当于给出一个集合与自然数集的一个双射也就是找到一种排序方式</p> <p>推论：有理数全体是可数集(\\(A_{n}=\\left\\{ \\frac{1}{n}, \\frac{2}{n},\\dots \\right\\}\\))</p> <p>注：无限个可数集的直积会破坏可数性(未必可数)，可以简单的给出一个反例，可数个\\(\\left\\{ 0,1 \\right\\}\\)做直积可以与二进制等同，可以用于表示\\((0,1)\\)区间上的一切数可知有连续统势，不可数.</p> <p>下面给出一个比较违背直觉的有关等势的定理：</p> <p>[!NOTE] Theorem 1.4.4 \\(A\\)为无限集，\\(B\\)为至多可数集，\\(A\\sim A\\bigcup B\\)</p> <p><code>Proof.</code></p> <p>比较简单，只要按照希尔伯特旅馆的做法平移一段就可以了</p> \\[ A=(A-A_{1})\\bigcup A_{1}\\sim (A-A_{1})\\bigcup\\left( A_{1}\\bigcup B \\right)=A\\bigcup B \\] <p>利用无限集中可以找到一个可数子集的性质和可数子集的可数并仍然为可数集(也就是将可数集当做桥梁其余不变)</p> <p>注：这也是一种实用的技巧，用可数无穷相互映射，其余不可数的部分相互抵消(恒等映射即可)</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#_8","level":3,"title":"连续统势","text":"<p>周性伟的定义是与\\([0,1]\\)区间等价的就具有连续统势，由此可以变换到任意区间甚至实数轴都具有连续统势</p> <p>有关连续统势的重要扩充：</p> <ul> <li>n元数列的势</li> <li>无限n元数列全体具有连续统势</li> <li>可数集的子集全体有连续统势(2元数列全体)</li> <li>连续统假设(这是比较重要的，但是涉及该假设的证明一般应当尽量避开)</li> </ul> <p>注：有关n元数列有连续统势的证明实际就是证明\\((0,1]\\)的无限小数和有限小数可以与n元数列一一映射，这就涉及到了进制的转换，也可以参考Zorich中的证明，写的也十分的详细.</p> <p>主要是利用这个等式\\(\\sum\\limits_{i=1}^{m} \\frac{k_{i}-1}{n^{i}}&lt; x\\leqslant \\sum\\limits_{i=1}^{m-1} \\frac{k_{i}-1}{n^{i}}+ \\frac{k_{m}}{n^{m}}\\)，趋于无穷时就有\\(x= \\sum\\limits_{i=1}^{\\infty} \\frac{a_{i}}{n^{i}}\\)</p> <p>注：一维连续函数也具有连续统势，连续函数被其在有理点的取值唯一确定，那么只需要把\\(f\\)在有理数上的取值写成一个数列就可以得到连续函数全体到\\(\\mathbb{R}\\)的可数直积的单射，所以连续函数的数目要小于等于连续统，反之因为任何一个实数对应一个常值函数，所以连续统小于等于连续函数数目，即证.</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#_9","level":3,"title":"基数的比较","text":"<p>主定理：Bernstein定理，证明的方法也比较多样，这里摘取一个周性伟书中利用等价的方法：</p> <p>[!NOTE] Bernstein定理 若\\(\\overset{=}{A}\\leqslant \\overset{=}{B},\\overset{=}{B}\\leqslant \\overset{=}{A}\\),则\\(\\overset{=}{A}=\\overset{=}{B}\\)</p> <p><code>Proof.</code></p> <p>[!NOTE] Lemma  设\\(A_{0},A_{1},A_{2}\\)是三个集合满足\\(A_{0}\\supset A_{1}\\supset A_{2}\\)，若是\\(A_{0}\\sim A_{2}\\)，则也有\\(A_{0}\\sim A_{1}\\)</p> <p>证明这个引理只需要利用递推关系即可</p> <p>有了这个引理我们就可以比较简单的证明Bernstein定理了：</p> \\[ \\begin{aligned} \\overset{=}{A}\\leqslant \\overset{=}{B}&amp;\\implies A\\sim B_{1}\\\\ \\overset{=}{B}\\leqslant \\overset{=}{A}&amp;\\implies B\\sim A_{1}\\implies B_{1}\\sim A_{2}\\\\ A\\sim A_{2} &amp;\\implies A\\sim A_{1} \\implies A\\sim B \\end{aligned} \\] <p>注：这个定理显然相当重要，也是证明基数相当的重要手段：证明两个集合分别与另一个集合的子集等价，类似于证明相等时分别证明大于等于和小于等于一样</p> <p>比较精炼的证明也可以参考Folland，采用了一种“链条式”的证明方法，笔者曾经在初次阅读时被绕晕过</p> <p>还有一个关于基数的重要命题(定理)是不存在基数最大的集\\(\\mu&lt;2^{\\mu}\\)(难点在于证明不等价，使用到的构造是罗素悖论中使用过的，也就是从A到A的集族映射记为\\(f\\)，\\(A^{*}=\\left\\{ x \\in A,x\\not\\in f(x) \\right\\}\\))，这样讨论就会得出矛盾了.</p> <p>注：关于基数的比较，也可以参考Folland通过\\(A,B\\)之间的单射和满射关系定义基数的序关系，通过证明单射和满射证明基数大小关系也是一种常见思路</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#mathbbrn","level":2,"title":"\\(\\mathbb{R}^{n}\\)中的拓扑","text":"<p>本节对\\(\\mathbb{R}^{n}\\) 中点集建立拓扑性质.拓扑学的英文为Topology,原意为地志学.在数学中，拓扑性质是指集合在连续变换下不变的性质.连续的概念必须由邻域、距离等概念来刻画,后者是极限概念的基础.本书中,\\(\\mathbb{R}^{n}\\)中点集的拓扑性质可以理解为与距离概念相关的性质,即邻域、开集、闭集等概念的性质.</p> <p>主要由以下几个部分组成</p> <ul> <li>邻域</li> <li>\\(\\mathbb{R}^{n}\\)中的开集和闭集</li> <li>\\(\\mathbb{R}^{n}\\)中的开集</li> <li>\\(\\mathbb{R}^{n}\\)中集的内点、内核、附着点和闭包</li> <li>聚点、导集、孤立点及完备集</li> <li>疏集与稠集</li> <li>\\(\\mathbb{R}^{n}\\)中的完备集、Cantor完备集与Cantor函数</li> <li>\\(\\mathbb{R}^{n}\\)中的长方体</li> <li>\\(\\mathbb{R}^{n}\\)上的连续函数、点与集的距离</li> <li>开覆盖、紧集</li> </ul>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#_10","level":3,"title":"邻域","text":"<p>若\\(x \\in \\mathbb{R}^{n},\\varepsilon&gt;0\\)</p> \\[ V(x,\\varepsilon)=\\left\\{ y \\in \\mathbb{R}^{n},d(x,y)&lt;\\varepsilon \\right\\}  \\] <p>称为\\(x\\)的\\(\\varepsilon\\)邻域，若是更进一步有\\(E \\in \\mathbb{R}^{n },\\exists\\varepsilon&gt;0,s.t.V(x,\\varepsilon)\\subset E\\)</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#mathbbrn_1","level":3,"title":"\\(\\mathbb{R}^{n}\\)中的开集和闭集","text":"<p>有关开集和闭集的定义和性质必须牢固掌握：</p> <p>若是\\(G\\subset \\mathbb{R}^{n},G\\)是其每一点的邻域，则\\(G\\)为开集，开集的补集称为闭集</p> <p>[!NOTE] Theorem 1.5.2  (1) \\(\\mathbb{R}^{n},\\emptyset\\)为开集  (2) 任意两个开集的交为开集  (3) 任意一族开集的并为开集</p> <p>注：通常两个意味着有限个，</p> <p>同理可以得到闭集相关的定理</p> <p>[!NOTE] Theorem 1.5.3  (1) \\(\\mathbb{R}^{n},\\emptyset\\)为闭集  (2) 任意两个闭集的并为闭集  (3) 任意一族闭集的交为闭集</p> <p>闭集存在一个重要的等价刻画：</p> <p>[!tip] Theorem 1.5.4 \\(F\\subset \\mathbb{R}^{n}\\iff \\forall \\left\\{ x_{k} \\right\\}\\in F,x_{k }\\to x,x\\in F\\)</p> <p><code>Proof.</code></p> <p>使用反证法找到开邻域即可，另一边则是证明\\(F^{c}\\)不为开集，这是一种常用的手法，由于开集使用集合语言描述比较方便而且直接，在证明闭集的过程中往往考虑证明其的补集不为开集</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#mathbbrn_2","level":3,"title":"\\(\\mathbb{R}^{n}\\)中的开集","text":"<p>显然实数轴上的开区间是开集，从直觉上来想一维的开集应当是许多个开区间组成的，这就是下面构成区间定义构建的动机</p> <p>设\\(G\\)是\\(R\\)中的开集，\\((a,b)\\)是开区间，若是\\((a,b)\\subset G\\)但\\(a\\not\\in G,b\\not\\in G\\)，则\\((a,b)\\)称为\\(G\\)的一个构成区间，注意\\(a,b\\)可以为\\(\\infty\\)</p> <p>为了更加明确开集是由构成区间构成的这一点，我们应当可以分两步证明： 1. 开集中的每一点都属于该集合的一个构成区间 2. 开集是至多可数个两两不相交的开区间的并</p> <p>下面的几节更多的是定义的记忆和理解，只有对定义非常熟悉才能在证明的时候不至于手忙脚乱.</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#mathbbrn_3","level":3,"title":"\\(\\mathbb{R}^{n}\\)中集的内点、内核、附着点和闭包","text":"<p>设\\(E\\subset \\mathbb{R}^{n},x \\in \\mathbb{R}^{n}\\)</p> <ul> <li>内点：\\(E\\)是\\(x\\)的邻域，\\(x\\)是\\(E\\)的内点</li> <li>内核(内部)\\(E^{\\circ}\\)：\\(E\\)的内点全体</li> <li>附着点(触点)：\\(x\\)的任一邻域与\\(E\\)有非空交</li> <li>闭包：\\(E\\)的附着点全体记为\\(\\overline{E}\\)</li> </ul> <p>由定义可得以下性质</p> <ul> <li>若是\\(x\\in \\overline{E}\\implies\\)有\\(E\\)中点列\\(\\left\\{ x_{k} \\right\\},x_{k}\\to x\\)(利用邻域的任意性取\\(V\\left( x, \\frac{1}{n} \\right)\\)即可)</li> <li>\\(E^{\\circ}\\)是开集，\\(E^{\\circ}\\subset E\\)，且是\\(E\\)中最大的开集</li> <li>\\(\\overline{E}\\)是闭集，\\(E\\subset  \\overline{E}\\)，且是\\(E\\)中最小的闭集</li> </ul> <p>推论：\\(E=E^{\\circ}\\iff E\\)是开集，\\(E= \\overline{E}\\iff E\\)是闭集</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#_11","level":3,"title":"聚点、导集、孤立点及完备集","text":"<p>在附着点的基础上提出聚点的概念：任何邻域除去自身外与\\(E\\)有非空交称为聚点，聚点全体称为导集\\(E'\\)，若是\\(x\\in E\\)但不是聚点，就称为孤立点，没有孤立点的闭集称为完备集</p> <p>注：完备集的定义容易被忽视，这里额外加粗</p> <p>根据定义将给出下面的性质</p> <ul> <li>\\(x\\in E'\\iff E\\)中存在点列\\(\\left\\{ x_{k} \\right\\}\\)，使\\(x_{k}\\neq x\\)且\\(x_{k}\\to x\\)</li> <li>对任何\\(E\\subset \\mathbb{R}^{n}\\)，\\(\\overline{E}=E\\bigcup E'\\)</li> </ul> <p>注：\\(E\\)并上是为了加入孤立点，这也变相给出了一个推论\\(\\overline{E}=E=E'\\)可以推出\\(E\\)是完备集</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#_12","level":3,"title":"疏集与稠集","text":"<p>这也是很重要的但是容易被遗忘的定义：</p> <p>设\\(E\\subset \\mathbb{R}^{n}\\)，若是\\(\\mathbb{R}^{n}\\)中任何非空开集必有非空开子集与\\(E\\)不相交，则\\(E\\)称为疏集，若\\(\\mathbb{R}^{n}\\)中任何非空开集与\\(E\\)有非空交，则\\(E\\)称为稠集</p> <p>这个定义可能略微有点抽象，这里用例子加以说明：整数全体是\\(\\mathbb{R}\\)中疏集，有理数全体是\\(\\mathbb{R}\\)中稠集</p> <p>下面给出有关的定理：</p> <p>[!NOTE] Theorem 1.5.10 (1) \\(E\\)是疏集\\(\\iff(\\overline{E})^{\\circ}=\\emptyset\\) (2) \\(E\\)是稠集\\(\\iff  \\overline{E}=\\mathbb{R}^{n}\\)</p> <p>通常若是有\\(A\\subset B, \\overline{A} \\supset B\\)，\\(A\\)也称为\\(B\\)的稠子集，例如\\((0,1)\\)中的有理数全体为\\((0,1)\\)的稠子集</p> <p>这里的资料确实比较少也不是特别重点的内容但还是要注意不要忽略</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#mathbbrncantorcantor","level":3,"title":"\\(\\mathbb{R}^{n}\\)中的完备集、Cantor完备集与Cantor函数","text":"<p>设\\(F\\)是\\(\\mathbb{R}\\)中的完备集，由定义\\(F\\)是闭集，\\(F^{c}\\)是开集那么可以利用构成区间得到\\(F^{c}=\\bigcup\\limits_{i=1}^{\\infty}(a_{i},b_{i})\\)，且区间两两不交，且没有孤立点也就是两个区间之间没有公共端点，反之也就是开区间列两两不交且无公共端点则\\(F\\)为完备集，也就是下面的定理</p> <p>[!NOTE] Theorem 1.5.11 \\(\\mathbb{R}\\)中的集合\\(F\\)是完备集当且仅当\\(F^{c}=\\mathbb{R}-F\\)是至多可数个两两不交且无公共端点的开区间的并</p> <p>下面给出在本章中乃至实变函数中都非常重要的一个集合——Cantor集的构造</p> <p>在\\(\\mathbb{R}\\)中的Cantor集的构造非常简单：简单来说就是将\\([0,1]\\)区间三等分取走中间的部分，下一步是将剩余的两个区间也三等分取走中间的部分，以此类推即可，这也我们在第n步时就可以得到\\(2^{n}\\)个\\(\\frac{1}{3^{n}}\\)长度的区间，显然它是趋于零的，再在区间上定义一个函数\\(f(x)= \\frac{2k-1}{2^{n+1}}\\)，这个函数是单调递增的</p> <p>这里应当声明一下记号，因为在后续的证明和陈述中常常会用到：</p> <p>取走的开集\\(G=\\bigcup \\left\\{ I_{n,k}:1\\leqslant k\\leqslant 2^{n-1},n\\geqslant 1 \\right\\}\\)，其中\\(\\left\\{ I_{n,k} \\right\\}\\)是两两不相交且无公共端点的开区间族，而且它们都不以\\(0,1\\)为端点，那么可以得到</p> \\[ C=R-\\left[ (-\\infty,0)\\bigcup G \\bigcup(1,\\infty) \\right] =[0,1]-G \\] <p>是一个完备集，它称为Cantor完备集</p> <p>注：\\(G\\)中所有开区间的长度为\\(\\sum\\limits_{k=1}^{\\infty} \\frac{2^{k-1}}{3^{n}}=1\\)</p> <p>容易得到以下性质：</p> <p>(1) Cantor完备集没有内点 (2)\\(G\\)是\\([0,1]\\)中稠子集，即\\(\\overline{G}=[0,1]\\)等价地，任何\\((a,b)\\subset[0,1]\\)其内含有\\(G\\)中点</p> <p>似乎从直觉上看，Cantor完备集的点没有多少，也就是基数应当不大似乎是可数个，但实际不然，Cantor完备集有连续统势：这个证明只需要利用到先前证明的n元数列全体具有连续统势，利用Cantor完备集的构造方法就可以给出一个\\([0,1]\\)上的点到全体三元数列的一个完全一一映射了</p> <p>下面再来考虑函数的性质，首先容易知道它是单调递增的，我们可以对它进行延拓：</p> \\[ g(1)=1,g(x)=\\inf\\left\\{ f(y):y&gt;x,y \\in G \\right\\} ,0 \\leqslant x&lt;1 \\] <p>很明显\\(g\\)也是单增的函数，并且\\(0 \\leqslant g(x)\\leqslant 1\\)，此外当\\(x \\in G\\)时有\\(g=f\\)，它也是\\(\\left[ 0,1 \\right]\\)上的稠子集，可知它连续</p> <p>总结一下就是：</p> <p>[!NOTE] Cantor函数</p> \\[\\begin{aligned} f(0)=&amp;0, f(1)=1\\\\  f(x)=&amp; \\frac{2k-1}{2^{n}},x \\in I_{n,k}, 1\\leqslant k \\leqslant 2^{n-1},n \\geqslant 1 \\end{aligned} \\] <p>容易知道该函数单增连续</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#mathbbrn_4","level":3,"title":"\\(\\mathbb{R}^{n}\\)中的长方体","text":"<p>既然在\\(\\mathbb{R}\\)上我们使用开区间作为构成单元去覆盖逼近一切集合，在\\(\\mathbb{R}^{n}\\)上我们就可以考虑开区间的并——半开方体(开长方体、闭长方体一样)</p> <p>我们容易得到任意一个边长为\\(\\lambda\\)的方体应当都可以表示为有限个边长为\\(\\frac{\\lambda}{2}\\)的方体的并</p> <p>进而有\\(\\mathbb{R}^{n}\\)中任一开集都是可数个两两不交的半开方体的并，证明依靠上面的分割性质，不断缩小方体的边长实现极限的逼近(可达)</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#mathbbrn_5","level":3,"title":"\\(\\mathbb{R}^{n}\\)上的连续函数、点与集的距离","text":"<p>连续函数的定义在数分中已有记载，但是在集合上的连续还是稍微说明</p> <p>设\\(D\\subset \\mathbb{R}^{n},f:D \\to \\mathbb{R},x \\in D\\)，若是\\(\\lim\\limits_{ \\substack{y\\to x\\\\y \\in D}}=f(x)\\)，则称\\(f\\)沿\\(D\\)在\\(x\\)上连续</p> <p>下面有一个定理给出连续的充要条件：</p> <p>[!NOTE] Theorem \\(f\\)是\\(\\mathbb{R}^{n}\\)上的实值函数，则为使\\(f\\)在\\(\\mathbb{R}^{n}\\)上连续，充要条件是对任何实数\\(\\alpha\\)，集\\(\\left\\{ x:f(x)&gt;\\alpha \\right\\},\\left\\{ x:f(x)&lt;\\alpha \\right\\}\\)都是开集</p> <p>注1：这与可测函数的定义有些类似，注意二者证明中的相同点</p> <p>注2：连续函数实际有一个偏拓扑的定义：开集的原像是开集</p> <p>再给出距离函数的定义，记号同上</p> \\[ d(x,D)=\\inf\\left\\{ d(x,y):y \\in D \\right\\}  \\] <p>称为\\(x\\)与\\(D\\)的距离</p> <p>根据三角不等式可以得到引理：\\(\\forall x,y \\in \\mathbb{R}^{n}\\)，有\\(\\lvert d(x,D)-d(y,D) \\rvert\\leqslant d(x,y)\\)</p> <p>注意观察，相当于是Lipschitz条件，所以显然可以得到一致连续</p> <p>下面则是将实数理论从\\(\\mathbb{R}\\to \\mathbb{R}^{n}\\)的过程：</p> <p>[!tip] Bolzano-Weierstrass定理 \\(\\mathbb{R}^{n}\\)中任一有界点列有收敛子列，特别的，\\(\\mathbb{R}^{n}\\)中任一有界无限点列至少有一个聚点</p> <p>证明只需要对每一个维度的坐标使用一维的聚点定理，将下标的范围一直迭代嵌套即可.</p> <p>再补充一个与距离函数有关的定理</p> <p>[!NOTE] Theorem 1.5.18 若\\(F\\subset \\mathbb{R}^{n}\\)是闭集，\\(x \\in \\mathbb{R}^{n}\\)则有\\(y \\in F\\)使得\\(d(x,y)=d(x,F)\\).于是当\\(x\\not\\in F\\implies d(x,F)&gt;0\\)</p> <p>证明可以利用取子列和有界性带来的B-W定理找到聚点，再根据闭集的等价刻画找到收敛点.</p> <p>[!NOTE] 闭集套定理 设\\(\\left\\{ F_{k} \\right\\}_{k\\geqslant 1}\\)是\\(\\mathbb{R}^{n}\\)中一列单减的非空有界闭集，则\\(\\bigcap\\limits_{k=1}^{\\infty}F_{k}\\neq \\emptyset\\)</p> <p>注：无界的反例很容易举比如\\(\\left[ k,+\\infty \\right]\\)</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E5%AE%9E%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0%20%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E6%95%B0%E9%9B%86/#_13","level":3,"title":"开覆盖、紧集","text":"<p>之所以将开覆盖和紧集放在一起是因为，紧集的定义中含有了开覆盖，并且涉及到开覆盖的题目往往需要说明集合是紧集，而如果含有有界闭(在\\(\\mathbb{R}^{n}\\)中这与紧集等价)的条件，往往也会使用到相关的定义作为证明的方法.</p> <p>所谓开覆盖就是\\(\\mathbb{R}^{n}\\)中的一族开集满足\\(E\\subset \\bigcup \\left\\{ G_{\\lambda}:\\lambda\\in\\Lambda \\right\\}\\)，则\\(\\left\\{ G_{\\lambda} \\right\\}\\)称为\\(E\\)的一个开覆盖，若是\\(E\\)的任一开覆盖存在有限子覆盖(有限个开集)仍构成\\(E\\)的一个开覆盖我们就称\\(E\\)为紧集.</p> <p>下面这个定理在数分中已经证明过这里只给出结果：</p> <p>[!tip] Theorem 1.5.20 \\(\\mathbb{R}^{n}\\)中的集合为紧集\\(\\iff\\)它是有界闭集</p> <p>如果是紧集的话，加上连续性条件将会得到数分中应当称为连续映射的优良结果：</p> <p>[!tip] Theorem 1.5.21 \\(F\\subset \\mathbb{R}^{n}\\)是紧集，\\(f\\)是沿\\(F\\)连续的函数，则： (1)\\(f\\)在\\(F\\)上有界并能达到最大和最小值 (2)\\(f\\)在\\(F\\)上一致连续，即对任何\\(\\varepsilon&gt;0\\)，有\\(\\delta&gt;0\\)使</p> \\[\\lvert f(x)-f(y) \\rvert &lt;\\varepsilon,d(x,y)&lt;\\delta,x,y\\in F\\] <p>注：有关这些性质更详尽的解释和适用的空间可以在点集拓扑中学到</p>","path":["第1章 集合与实数集"],"tags":[]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/","level":1,"title":"数学分析课堂笔记","text":"<p>主要存放学习实分析时阅读教材的笔记包括课程笔记和读书笔记</p>","path":["Analysis","Mathematical Analysis","Lecture Notes","数学分析课堂笔记"],"tags":["Analysis"]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/#reference","level":2,"title":"Reference","text":"<ul> <li>《数学分析》 上、中、下册 南开大学</li> <li>《数学分析》 陈纪修 复旦大学</li> <li>《数学分析教程》 史济怀 中国科学技术大学</li> <li>《数学分析》 卓里奇 </li> <li>《Principles of Mathematical Analysis》 Rudin</li> <li>《数学分析习题课讲义》 谢惠民</li> <li>《数学分析中的典型问题与方法》 裴礼文</li> </ul>","path":["Analysis","Mathematical Analysis","Lecture Notes","数学分析课堂笔记"],"tags":["Analysis"]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/#_2","level":2,"title":"课程笔记","text":"","path":["Analysis","Mathematical Analysis","Lecture Notes","数学分析课堂笔记"],"tags":["Analysis"]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86(%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90)/","level":1,"title":"预备知识(数学分析)","text":"","path":["Analysis","Mathematical Analysis","Lecture Notes","预备知识(数学分析)"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86(%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90)/#_2","level":2,"title":"实数、集合和函数","text":"","path":["Analysis","Mathematical Analysis","Lecture Notes","预备知识(数学分析)"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86(%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90)/#_3","level":3,"title":"实数","text":"<p>“数学分析”的研究对象是实函数(Real Valued Functions)，即自变量和函数值均为实数的函数（南开大学的数学分析课本将关于实数的定义和实数理论的更严格证明留待第六章）</p> <p>主要强调两点： 1. 数轴（今后经常将实数轴上的点和实数等同起来，不加区分） 2. 稠密性(density) 有理数和无理数在实数中稠密，也就是说任何两个不同的实数之间一定存在一个有理数（无理数）</p> <p>关于稠密性也可以采用下列的方法来理解（以有理数为例）</p> <p>Density of Rational Number 1.\\(\\forall a,b \\in \\mathbb{R},if\\ a&lt;b,\\exists r \\in \\mathbb{Q},s.t.a&lt;r&lt;b\\) 2.\\(\\forall a\\in \\mathbb{R},\\epsilon&gt;0,\\exists r\\in \\mathbb{Q},s.t.|a-r|&lt;\\epsilon\\)</p>","path":["Analysis","Mathematical Analysis","Lecture Notes","预备知识(数学分析)"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86(%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90)/#_4","level":3,"title":"集合","text":"<p>几个数集\\(\\mathbb{R},\\mathbb{Q},\\mathbb{Z},\\mathbb{N},\\mathbb{N}^*\\)</p> <p>还有一种常见的数集是区间（Interval），与之相关的还有一个重要的概念是邻域，我们将开区间\\((x_{0}-\\delta,x_{0}+\\delta)\\) 为\\(x_{0}\\)的邻域，记为\\(B_{\\delta}(x_{0})\\) ,若要去掉\\(x_{0}\\)自身，则称为\\(x_{0}\\)的空心邻域，记为\\(\\mathring{B}_{\\delta}(x_{0})\\)</p> <p>最大最小值的记号：\\(max ; min\\) ,max是maximum的缩写，min是minimum的缩写</p> <p>上界和下界的定义</p> <p>差集的概念和记号</p> <p>Definition difference</p> \\[ x\\in A\\setminus B \\iff x\\in A\\ but\\ x\\notin B \\]","path":["Analysis","Mathematical Analysis","Lecture Notes","预备知识(数学分析)"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86(%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90)/#_5","level":3,"title":"函数","text":"<ol> <li>单射：\\(\\forall x_{1},x_{2}\\in X,x_{1}\\neq x_{2},f(x_{1})\\neq f(x_{2})\\)</li> <li>单调函数</li> <li>奇函数和偶函数</li> <li>周期函数</li> <li>有界函数与无界函数</li> <li>反函数（需要用到一一对应的概念）</li> <li>复合函数</li> </ol>","path":["Analysis","Mathematical Analysis","Lecture Notes","预备知识(数学分析)"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86(%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90)/#_6","level":2,"title":"初等函数","text":"<ol> <li>常数函数</li> <li>幂函数</li> <li>指数函数</li> <li>对数函数</li> <li>三角函数</li> <li>反三角函数</li> </ol>","path":["Analysis","Mathematical Analysis","Lecture Notes","预备知识(数学分析)"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86(%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90)/#_7","level":2,"title":"分情形定义的函数","text":"<p>以下是常见的一些分情形定义的函数的例子，常常用于构造命题的反例</p> <p>Example 1 绝对值函数</p> \\[ f(x)=|x|=\\left\\{ \\begin{matrix}  &amp; -x, &amp; x&lt;0 \\\\  &amp; x, &amp; x\\ge 0 \\end{matrix} \\right. \\] <p>Example 2 符号函数</p> \\[ sgn\\ x=\\left\\{ \\begin{matrix}  &amp; -1, &amp; x&lt;0 \\\\  &amp; 0, &amp; x=0 \\\\  &amp; 1, &amp; x&gt;0  \\end{matrix} \\right. \\] <p>Example 3 取整函数（高斯函数）</p> \\[ f(x)=[x]=n,n\\le x&lt;n+1 \\] <p>Example 4 特征函数（示性函数）</p> \\[ \\chi _{A}(x)=\\left\\{ \\begin{matrix}  &amp; 1, &amp; x\\in A \\\\  &amp; 0, &amp; x\\not\\in A \\\\ \\end{matrix} \\right. \\] <p>函数\\(\\chi_{A}(x)\\)称为数集A的特征函数</p> <p>Example 5 Dirichllet函数 在特征函数\\(\\chi_{A}(x)\\)中，令\\(A=\\mathbb{Q}\\) $$ D(x)=\\chi_{Q}(x)=\\left{ \\begin{matrix}  &amp; 1, &amp; x\\in \\mathbb{Q} \\  &amp; 0, &amp; x\\not\\in\\bar{Q} \\end{matrix} \\right. $$ and \\(D(x)=sgn\\ (R(x))\\)</p> <p>Example 6 Riemann函数</p> \\[ R(x)=\\left\\{ \\begin{matrix}  &amp; \\frac{1}{q}, &amp; x= \\frac{p}{q},(p,q)=1,q&gt;0 \\\\  &amp; 0, &amp; x\\not\\in Q \\end{matrix} \\right. \\]","path":["Analysis","Mathematical Analysis","Lecture Notes","预备知识(数学分析)"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86(%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90)/#_8","level":2,"title":"平面曲线","text":"<p>确定一条平面曲线的方法有很多，</p> <ul> <li>隐函数方程</li> <li>参数方程</li> <li>极坐标方程</li> </ul> <p>为了对接下来章节运用的放缩技巧有一些基本的认识，我们最好在预备知识里增加一些基本的不等式内容（均值不等式和柯西不等式），包括如何进行逻辑上的否定（对偶法则）. 接下来的这一部分来自于《谢惠民数学分析习题课讲义》</p>","path":["Analysis","Mathematical Analysis","Lecture Notes","预备知识(数学分析)"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86(%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90)/#_9","level":2,"title":"简单不等式","text":"","path":["Analysis","Mathematical Analysis","Lecture Notes","预备知识(数学分析)"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86(%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90)/#bernoulli-inequality","level":3,"title":"Bernoulli Inequality","text":"<p>[!NOTE] Bernoulli Inequality(基础版本) 设\\(h&gt;-1,n\\in N_{+}\\),则成立不等式\\((1+h)^{n}\\ge 1+nh\\),\\(n&gt;1\\)时的取等条件是\\(h=0\\).</p> <p><code>Proof</code></p> <p>\\(n=1\\)和\\(h=0\\)时不等式显然成立 讨论\\(n&gt;1,h\\neq 0\\)的情况：</p> \\[ (1+h)^{n}-1=h\\left[ 1+(1+h)+\\dots+(1+h)^{n-1} \\right] &gt;nh \\] <p><code>Generalization</code></p> <ol> <li>\\(-2\\le h\\le -1\\)时，不等式仍然成立</li> <li>\\(h\\ge 0\\)时，有新的不等式\\((1+h)^n\\ge \\frac{n(n-1)}{2}h^{2}\\)</li> <li>\\(\\alpha&gt;-1(i=1,2\\dots n)\\)且同号，成立\\(\\prod_{i=1}^{n}(1+\\alpha_{i})\\ge 1+\\sum\\limits_{i=1}^{n}\\alpha_{i}\\)</li> </ol>","path":["Analysis","Mathematical Analysis","Lecture Notes","预备知识(数学分析)"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86(%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90)/#_10","level":3,"title":"基本不等式","text":"<p>[!NOTE] AN-GN Inequality 设\\(a_{1},a_{2},\\dots,a_{n}\\)是\\(n\\)个非负实数，则成立\\(\\frac{a_{1}+a_{2}+\\dots+a_{n}}{n}\\ge\\sqrt[n]{ \\prod_{i=1}^{n}a_{i} }\\) 等号成立的充分必要条件是\\(a_{1}=a_{2}=\\dots=a_{n}\\)</p> <p><code>Proof is easy</code></p>","path":["Analysis","Mathematical Analysis","Lecture Notes","预备知识(数学分析)"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86(%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90)/#cauchy-inequality","level":3,"title":"Cauchy Inequality","text":"<p>[!NOTE] Cauchy Inequality 实数 \\(a_{1},a_{2},\\dots,a_{n};b_{1},b_{2},\\dots,b_{n}\\)有：\\(\\left\\lvert  \\sum\\limits_{i=1}^{n}a_{i}b_{i}  \\right\\rvert \\le\\sqrt{ \\sum\\limits_{i=1}^{n}a_{i}^{2} }\\sqrt{ \\sum\\limits_{i=1}^{n}b_{i}^{2} }\\)，取等条件是互相成比例</p> <p><code>Proof is easy</code></p>","path":["Analysis","Mathematical Analysis","Lecture Notes","预备知识(数学分析)"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90(Lecture%20Notes)/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86(%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90)/#inequalities-about-n","level":3,"title":"Inequalities about \\(n!\\)","text":"<p>[!NOTE] Inequalities about \\(n!\\) + \\(n!&lt;\\left( \\frac{n+1}{2} \\right)^{n}\\) + \\(n!&lt;\\left( \\frac{n+2}{\\sqrt{ 6 }} \\right)^{n}\\)</p>","path":["Analysis","Mathematical Analysis","Lecture Notes","预备知识(数学分析)"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/","level":1,"title":"初等概率论(Elementary Probability Theory)","text":"","path":["初等概率论(Elementary Probability Theory)"],"tags":["Analysis","Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Combinatorial%20Analysis/","level":1,"title":"Chapter 1 :Combinatorial Analysis","text":"<p>OK,this is the first chapter in the probability theory, we will review some definition and theorems we have learned in our high school. To make a good preparition for the future, I suggest you can find some not so easy problems to solve and test yourself(like the question in the Ross or any others).</p> <p>The first part is about counting. We only give a quick look.</p>","path":["Chapter 1 :Combinatorial Analysis"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Combinatorial%20Analysis/#counting","level":2,"title":"Counting","text":"","path":["Chapter 1 :Combinatorial Analysis"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Combinatorial%20Analysis/#basic-counting-principles","level":3,"title":"Basic Counting Principles","text":"<p>Theorem 1.1 (Pigeonhole principle  Dirichllet, 1834) If \\(n\\) items are to be put into \\(m\\) containers, with \\(n &gt; m\\), then at least one container must contain more than one item.</p> <p>Remark 1.1.1 More general Pigeonhole principle is \\(\\left\\{ 1,2,\\dots n \\right\\}\\) can't equiponent with \\(\\left\\{ 1,2\\dots n+m \\right\\}\\) More explainations you can find in Real Analysis by Royden.</p> <p>Corollary 1.2 If \\(n\\) items are to be put into \\(m\\) containers with \\(n &gt; m\\), then at least one container must contain at least \\(⌈n/m⌉\\) items.</p> <p>Remark 1.2.1 Recall that ⌈·⌉ is a ceiling function, meaning that for any \\(x ∈ \\mathbb{R}\\), ⌈x⌉ = inf{\\(n ∈ \\mathbb{Z}|n ≥ x\\)}.  ⌊x⌋ = sup{\\(n ∈ \\mathbb{Z}|n ≤ x\\)} is a floor function.</p> <p><code>Proof</code></p> <p>use the contradiction, and we also use this function in mathematical analysis.</p> <p>We first argue that for any \\(x ∈ \\mathbb{R}\\), \\(⌈x⌉ &lt; x + 1\\). If not, there exists \\(x_0 ∈ \\mathbb{R}\\) with \\(⌈x_0⌉ ≥ x_0 + 1\\), then \\(⌈x_0⌉ − 1\\) is a smaller integer satisfying the definition of ceiling function, which is a contradiction.</p> <p>We prove the corollary by contradiction. Assume that all containers contain at most \\(⌈n/m⌉ − 1\\) items. Then the total number of items is at most \\(m(⌈n/m⌉ − 1) &lt; m(n/m) = n\\), which contradicts with the fact that there are n items. </p> <p>Proposition 1.3 If r experiments are to be performed sequentially and the first experiment can be performed in \\(n_1\\) ways,...    the \\(r^{th}\\) experiment in \\(n_r\\) ways, then there are \\(\\prod\\limits_{i=1}^r  n_i\\) ways to perform the \\(r\\) experiments.</p> <p>The second part is Permutions.</p>","path":["Chapter 1 :Combinatorial Analysis"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Combinatorial%20Analysis/#permutations","level":2,"title":"Permutations","text":"<p>Definition 1.4 (Permutation) An ordered ranking of \\(n \\in \\mathbb{N}\\) distinct elements is called a permutation.</p> <p>Proposition 1.5 There are \\(n(n − 1)· · · 1\\) permutations of \\(n \\in \\mathbb{N}\\) distinct elements.</p> <p><code>Proof</code></p> <p>Just by Basic Counting Principles</p> <p>Remark 1.6 We use the notation \\(n!\\) (read as “n factorial\") to represent \\(n(n−1)···1\\).  By convention, 0! = 1.</p>","path":["Chapter 1 :Combinatorial Analysis"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Combinatorial%20Analysis/#permutationswith-indistinguishable-items","level":3,"title":"Permutations(with indistinguishable items)","text":"<p>Motivation example How many different letter arrangements can be formed from the letters PEPPER?</p> <p><code>Solution</code></p> <p>There are \\(6!\\) permutations if \\(P’s\\) and \\(E’s\\) are distinguished from one another, that is, doing permutation for \\(P_1E_1P_2P_3E_2R\\). However, for one arrangement, say \\(P_1P_2E_1E_2P_3R\\), one can permute P’s among themselves and E’s among themselves, and obtain the same arrangement. Hence, \\(3!2!\\) permutations have the same form. Therefore, there are \\(\\frac{6!}{(3!2!)}\\) letter arrangements.</p> <p>Generalization: In general, for n objects, out of which \\(n_1\\) are alike, \\(n_2\\) are alike,. . . , n~r~ are alike. Then there are \\(\\dfrac{n!}{n_1!n_2!···n_r!}\\) different permutations.</p> <p>After permutation, we can talk combinations more easily.</p>","path":["Chapter 1 :Combinatorial Analysis"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Combinatorial%20Analysis/#combinations","level":2,"title":"Combinations","text":"<p>Definition 1.7 (Combination) A combination is an unordered collection of k items among  \\(n\\in \\mathbb{N}\\) elements (\\(k ≤ n\\)).</p> <p>Proposition 1.8 The number of combinations of k items among  \\(n\\in \\mathbb{N}\\) elements (\\(k ≤ n\\)) is denoted by \\(\\binom{n}{k}\\)  (read as \"n choose k\") and it is equal to \\(\\binom{n}{k}=\\frac{n!}{(n-k)!k!}\\)</p> <p>An example used often Consider a set of \\(n\\) antennas of which m are defective, and \\(n − m\\) are functional. Assume that all of the defectives and all of the functionals are considered indistinguishable. How many linear orderings are there in which no two defectives are consecutive?</p> <p><code>Solution</code></p> <p>We can line up n-m functional antennas. </p> <p>(use 1 stands fo the functional and 0 stands for the space between the next to)</p> <p>like this 0 1 0 1 0 1 0 1 0 1 0 1 0</p> <p>So obviously, there are \\(\\binom{n-m+1}{m}\\) possible orderings.</p>","path":["Chapter 1 :Combinatorial Analysis"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Combinatorial%20Analysis/#combinatorial-identities","level":3,"title":"Combinatorial identities","text":"<p>Identity I \\(\\binom{n}{k}=\\binom{n}{n-k}\\) ,for any \\(n\\), \\(k\\) \\(\\in\\) \\(\\mathbb{N}\\) and \\(k\\le n\\).</p> <p>Identity II \\(\\binom{n+1}{k+1}=\\binom{n}{k}+\\binom{n}{k+1}\\) ,for any \\(n, k\\) \\(\\in\\) \\(\\mathbb{N}\\) and \\(k\\le n\\).</p> <p><code>Proof</code></p> <p>Algebraic verification is OK.</p> <p>We will use a combinatorial argument. </p> <p>Consider a set S = {s~1~, . . . , s~n+1~ } , combinations of k+1 elements among n+1 can be divided as follows: </p> <p>(1) combinations containg \\(s_1\\), there are \\(\\binom{n}{k}\\) such combinations; </p> <p>(2) there are \\(\\binom{n}{k+1}\\) combinations without \\(s_1\\).</p>","path":["Chapter 1 :Combinatorial Analysis"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Combinatorial%20Analysis/#multinomials","level":2,"title":"Multinomials","text":"","path":["Chapter 1 :Combinatorial Analysis"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Combinatorial%20Analysis/#binomials","level":3,"title":"Binomials","text":"<p>Theorem 1.9 ([[The Binomial theorem]]) For all \\(x, y\\) \\(\\in\\) \\(\\mathbb{R}\\) and  \\(n\\in \\mathbb{N}\\), \\((x+y)^n=\\sum\\limits_{k=0}^{n}\\binom{n}{k}x^ky^{n-k}\\)</p> <p><code>Proof is easy</code></p> <p>May be we can use a selection from {\\(x_1,y_1\\)}  {\\(x_2,y_2\\)} ...{\\(x_n,y_n\\)} </p> <p>The term \\(x^ky^{n-k}\\) corresponds to a choice of a group of \\(k\\) from n values \\(x_1, x_2,...,x_n\\), there are \\(\\binom{n}{k}\\) such terms. </p> <p>The generalization of binomia. Consider the expansion of \\((x_1+x_2+···+x_r)^n\\)  From the basic counting rule, the coefficient for \\(x_1^{n_1}···x_r^{n_r}\\) is \\(\\binom{n}{n-n_1}\\binom{n-n_1}{n_2}···\\binom{n-n_1-···n_{r-1}}{n_r}=\\dfrac{n!}{n_!!n_2!···n_r!}\\) </p> <p>Remark 1.10 One hidden fact is that \\(n_1,...,n_r\\)  satisfies \\(n_1+···+n_r=n\\)</p> <p>Theorem 1.11 (The multinomial theorem) We define \\(\\binom{n}{n_1,n_2,···,n_r}:=\\frac{n!}{n_1!n_2!···n_r!}\\),then we have the multinomial expansion</p> \\[ (x_1+x_2+···+x_r)^n=\\sum_{(n_1,...,n_r):n_1+···n_r=n}^{}\\binom{n}{n_1,n_2,...,n_r} x_1^{n_1}x_2^{n_2}···x_r^{n_r} \\] <p>Proposition 1.12 There are \\(\\binom{n+r-1}{r-1}\\) distinct nonnegative integer-valued vectors \\((n_1, n_2, . . . , n_r)\\) satisfying \\(n_1 + · · · + n_r= n\\)</p> <p><code>Proof</code></p> <p>Instead,we discuss the number of positive solutions of \\(y_1+···+y_r=n+r\\) </p> <p>(by letting \\(y_i=n_i+1\\))</p> <p>Choose \\(r-1\\) out of \\(n+r-1\\) spaces.</p> <p>Remark 1.12.1 If we exchage the word \"nonnegative\" to the \"positive\" What's the answer? Obviously, the answer is \\(\\binom{n-1}{r-1}\\)</p> <p>Remark 1.13 In the Chapter 1, I don't write the motivations wholely , because this chapter we have learn quite a lot in the senior high school , but in the chapters after that ,I will write some useful motivations and cases which I think is helpful.</p>","path":["Chapter 1 :Combinatorial Analysis"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/","level":1,"title":"Chapter 2 :Sets, Axioms of Probability","text":"<p>Now, let's begin the formal elementary probability theory's study. Normally, we will establish the fundamental framework by showing the axioms of probability. Before doing this, We must ensure that you have a certain understanding of basic sets and set operations.</p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#sets","level":2,"title":"Sets","text":"<p>Motivations</p> <ul> <li> <p>the sex of a newborn child</p> </li> <li> <p>flipping two coins</p> </li> <li> <p>tossing two coins </p> </li> <li> <p>etc</p> </li> </ul> <p>We can't answer the above questions but know all the possibilities—— In other word , it called Sample Space</p> <p>Definition 2.1 (Sample Space) A random experiment is a phenomenon whose outcome is not predictable with certainty, but the set of all possible coutcomes is known. The set of all possible outcomes is known as the sample space of the experiment and is denoted by \\(\\mathcal{S}\\). Any item \\(ω ∈ \\mathcal{S}\\) is called a sample point.</p> <p>Remark 2.2 \\(\\mathcal{S}\\) can be finite,countably infinite,uncountably infinite`</p> <p>We may think deeper after  learning more Real Analysis.</p> <p>Cases(previous experiments)</p> <ul> <li>S={boy,girl} finite</li> <li>S={(head, head), (head, tail), (tail, head), (tail,tail)} finite</li> <li>S={(i, j) : i, j = 1, 2, 3, 4, 5, 6} finite</li> </ul> <p>Every course seems to give an introduce to naive set theory as an begining? This course isn't a expectation.</p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#subsetsuperset","level":3,"title":"Subset/Superset","text":"<p>Definition 2.3 If every point of A belongs to B, then A is contained or included in B and A is a subset of B, while B is a superset of A.</p> <p>Symbolically,\\(A\\subset B,B \\supset A\\) </p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#event","level":3,"title":"Event","text":"<p>Definition 2.4 An event \\(E\\) is a set consisting of possible outcomes of the experiment that satisfy a given property. Thus, \\(E\\) is a subset of \\(\\mathcal{S}\\). If the outcome of the experiment is contained in \\(E\\), then we say that \\(E\\) has been realized or that \\(E\\) has occurred.</p> <p>Remark 2.5</p> <ul> <li>\\(S:\\) the sure event</li> <li>\\(\\emptyset :\\) the impossible event</li> </ul> <p>Still use the cases mentioned before, the newborn child is a girl means \\(E\\)={girl}.</p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#operations-relations-and-notations","level":3,"title":"Operations, Relations and Notations","text":"","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#union","level":4,"title":"Union","text":"<p>The union \\(E ∪ F\\) of two sets \\(E, F\\) is the set of points that belong to at least one of them. Symbolically,\\(E\\cup F\\)={ \\(\\omega | \\omega\\in E \\ or \\ \\omega \\in F\\) } \\(E\\cup F\\) is realized if either \\(E\\) or \\(F\\) occurs.</p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#intersection","level":4,"title":"Intersection","text":"<p>The intersection \\(E ∩ F( or EF)\\) of two sets \\(E, F\\) is the set of points that belong to both of them.  Symbolically,\\(EF\\)={\\(\\omega | \\omega\\in E \\ and \\ \\omega \\in F\\) }  \\(EF\\) is realized if \\(E\\) and \\(F\\) both occur.</p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#countable-unionintersection","level":4,"title":"Countable union/intersection","text":"<p>\\(\\{E_i\\}_{i\\ge 1}\\) is a countable sequence of events.</p> <ul> <li>The union of these events denoted \\(\\bigcup\\limits_{i=1}^{\\infty}E_i\\) is defined to be the  event which consists of all outcomes that are in at least one event \\(E_i\\) ,\\(i=1,2...,\\infty\\) \\(\\omega \\in \\bigcup\\limits_{1}^{\\infty}E_i\\Longleftrightarrow \\exists i \\ s.t. \\omega \\in E_i\\) </li> <li>The intersection of these events denoted \\(\\bigcap\\limits_{i=1}^{\\infty}E_i\\) is defined to be the  event which consists of all outcomes that are in all of  the events \\(E_i\\) ,\\(i=1,2...,\\infty\\) \\(\\omega \\in \\bigcap\\limits_{1}^{\\infty}E_i\\Longleftrightarrow  \\omega \\in E_i \\ \\forall \\ i\\) </li> </ul>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#mutually-exclusive","level":4,"title":"Mutually exclusive","text":"<p>\\(E,F\\) are mutually exclusive if  \\(E\\cap  F= \\emptyset\\) \\(E\\) and \\(F\\) can not both occur at the same time.</p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#complement","level":4,"title":"Complement","text":"<p>For a set \\(E \\subset S\\) ,the complement of \\(E\\) is denoted by \\(E^c\\) and is the set of points that do not belong to \\(E\\). Symbolically,\\(E^c=\\{ \\omega \\in S|\\omega \\notin E\\}\\) \\(E\\cup E^c=S,E \\cap E^c=\\emptyset,(E^c)^c=E\\) </p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#difference","level":4,"title":"Difference","text":"<p>For events E, F, \\(E\\setminus F\\) is the set of points that belong to E but not to F.  Symbolically,\\(E\\setminus F=\\{\\omega| \\omega \\in E\\ and \\ \\omega \\notin F\\}\\) \\(E\\setminus F =E\\setminus(E\\cap F),E^c=S\\setminus E\\) </p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#symmetric-difference","level":4,"title":"Symmetric difference","text":"<p>\\(E \\bigtriangleup F\\) is  the set of points that belong to exactly one of them. Symbolically,\\(E \\bigtriangleup F =\\{  \\omega| \\omega \\in E\\setminus F \\ or \\ \\omega \\in F\\setminus E\\}\\) </p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#venn-diagram","level":4,"title":"Venn diagram","text":"<p>\\(\\mathcal{S}\\):a large rectangle events \\(E,F\\)... :represented by circles events of interests: shading the appropriate regions of the diagram`</p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#laws-on-sets","level":3,"title":"Laws on sets","text":"","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#commutativity","level":4,"title":"Commutativity","text":"<p>\\(E\\cup F=F \\cup E \\  and \\ E \\cap F=F \\cap E\\) </p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#associativity","level":4,"title":"Associativity","text":"<p>\\(E \\cup(F\\cup G)=(E\\cup F)\\cup G \\ and \\ E\\cap(F \\cap G)=(E\\cap F) \\cap G\\) </p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#distributivity","level":4,"title":"Distributivity","text":"<p>\\(E \\cup(F\\cap G)=(E\\cup F)\\cap (E\\cup G) \\ and \\ E\\cap(F \\cup G)=(E\\cap F) \\cup (E \\cap G)\\) </p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#transitivity","level":4,"title":"Transitivity","text":"<p>If \\(E \\subset F \\ and\\ F \\subset G\\) ,then \\(E \\subset G\\)</p> <p>After them, there is also a very important law in the theory operations.</p> <p>Proposition 2.5 (De Morgan’s laws) \\((1)(\\bigcup\\limits_{i=1}^{n}E_i)^c=\\bigcap\\limits_{i=1}^{n}E_i^c\\) \\((2)(\\bigcap\\limits_{i=1}^{n}E_i)^c=\\bigcup\\limits_{i=1}^{n}E_i^c\\) </p> <p><code>Proof</code></p> <p>It suffices to show (1) since if (1) holds , then we consider \\((\\bigcup\\limits_{i=1}^{n}E_i^c)^c=\\bigcap\\limits_{i=1}^{n}(E_i^c)^c=\\bigcap\\limits_{i=1}^{n}E_i\\) </p> <p>We get (2) by applying complement to both sides.</p> <p><code>So we only need to proof (1)</code></p> <p>\\(\\subset\\)</p> <p>\\(\\omega \\notin \\bigcup_{i=1}^{n}E_i\\)  , For any \\(\\omega \\notin E_i \\to\\omega \\in E_i^c \\  for \\ all \\ i\\) </p> <p>\\(s.t. \\ \\omega \\in \\bigcap_{i=1}^{n}E_i^c\\)</p> <p>\\(\\supset\\)</p> <p>\\(\\omega \\in \\bigcap_{i=1}^{n}E_i^c\\) , For any i , \\(\\omega \\notin E_i \\to \\omega \\notin \\bigcup_{i=1}^{n}E_i\\),\\(\\omega \\in (\\bigcup_{i=1}^{n}E_i)^c \\  \\forall \\ i\\) </p> <p>\\(s.t. \\ \\omega \\in (\\bigcup_{i=1}^{n}E_i)^c\\)</p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#axioms-of-probability","level":2,"title":"Axioms of Probability","text":"<p>Remark 2.6 This part is not the content in this class, just to know,you can read more about this in Real Analysis(Royden) if you want.</p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#-algebra-and-measurable-space","level":3,"title":"σ-algebra and Measurable space","text":"<p>Definition 2.7 (σ-algebra) A σ-algebra A ⊂ P(S) is a family of sets over S satisfying the following properties: +  \\(\\emptyset \\in \\mathcal{A}\\) + \\(\\mathcal{A}\\) is closed under complementation: If \\(E \\in \\mathcal{A}\\) , then \\(E^c \\in \\mathcal{A}\\) , \\(\\mathcal{A}\\) is closed under countable union:if \\((E_i)_{i\\ge1}\\)is a countable sequence of sets in \\(\\mathcal{A}\\) ( \\(E_i\\in \\mathcal{A}\\ for \\ i\\in N^*)\\), then \\(\\bigcup_{i=1}^{\\infty}E_i\\in \\mathcal{A}\\) </p> <p>Definition 2.8 (Measurable space) Let us consider a random experiment with sample space \\(S\\) endowed with \\(\\sigma - algebra \\ \\mathcal{A}\\), \\((S,\\mathcal{A})\\) is called a measurable space and elements of \\(\\mathcal{A}\\) are called events.</p> <p>Under this is the most important part in this chapter——Axioms of Probability</p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#axioms","level":3,"title":"Axioms","text":"<p>Definition 2.9 (Probability, Kolmogorov, 1933) Let \\((S, \\mathcal{A})\\) be a measurable space of events. A probability measure is a real-valued function mapping  \\(\\mathcal{P} : \\mathcal{A} → \\mathcal{R}\\) satisfying:</p> <ul> <li>for any event \\(E\\in \\mathcal{A},\\mathcal{P}\\in(E)\\ge0\\) (nonnegativity)</li> <li>\\(\\mathcal{P}(S)=1\\)</li> <li>for any countably infinite sequence of events \\((E_i)_{i\\ge1}\\) that are mutually exclusive,</li> </ul> \\[ \\mathcal{P}(\\bigcup_{i=1}^{\\infty}E_i)=\\sum_{i=1}^{\\infty}\\mathcal{P}(E_i)\\notag  \\] <p>(\\(\\sigma\\)-additivity or countable addtivity) Then \\((S,\\mathcal{A},\\mathcal{P})\\) is called a probability space.</p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#properties-of-probability","level":2,"title":"Properties of probability","text":"","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#some-properties","level":3,"title":"Some properties","text":"<p>Remark 2.10 We write down all the proofs because we first learn the rigorous parts of probability theory, in the chapters after this, I will omit some.</p> <p>Property 1  (Probability of the impossible event)</p> \\[ P(\\emptyset)=0\\notag \\] <p><code>Proof</code></p> <p>Let\\(\\ E_1=S\\) ,\\(E_i=\\emptyset \\ for\\ all \\ i\\ge2\\), \\(\\{ E_i\\}_{i=1}^{\\infty} \\ is \\ a \\ mutually \\ exclusive \\ sequence\\)</p> \\[ \\begin{aligned}  \\ P\\left( \\bigcup_{i=1}^{\\infty}E_i \\right)&amp;=P(S) \\notag  \\\\ &amp;\\overset{(3)}{=}\\sum_{i=1}^{\\infty}P(E_i)=P(S)+\\sum_{i=2}^{\\infty}P(\\emptyset)\\notag  \\end{aligned} \\] \\[ \\sum_{i=2}^{\\infty}P(\\emptyset)=0 \\overset{(1)}{\\to} \\   P(\\emptyset)=0\\notag  \\] <p>Property 2  (Probability of a finite union of mutually exclusive events) For any finite sequence of events \\(E_1,...,E_n\\in \\mathcal{A}\\) that are mutually exclusive (that is, \\(E_i\\cap E_j=\\emptyset \\ if \\ i \\neq j\\)),</p> \\[ P(\\bigcup_{i=1}^{n}E_i)=\\sum_{i=1}^{n}P(E_i)\\notag  \\] <p><code>Proof</code></p> <p>Let \\(E_k=\\emptyset\\)  for all \\(k&gt;n\\) \\(\\{E_i\\}_{i=1}^{\\infty}\\) countable, mutually exclusive</p> \\[ \\begin{align} P(\\bigcup_{i=1}^{\\infty}E_i)=P(\\bigcup_{i=1}^{n}E_i) &amp;\\overset{(3)}\\notag {=}\\sum_{i=1}^{\\infty}P(E_i)\\notag  \\\\&amp;=\\sum_{i=1}^{n}P(E_i)+\\sum_{i=n+1}^{\\infty}P(\\emptyset)\\notag  \\\\&amp;=\\sum_{i=1}^{n}P(E_i)\\notag  \\end{align} \\] <p>Property 3  (Probability of included events)</p> <p>For any two events \\(E, F \\in A\\),</p> \\[ E \\subset F \\Rightarrow P(E)\\le  P(F).\\notag  \\] <p><code>Proof</code></p> \\[ E\\subset F \\ F=E\\cup (F\\setminus E)\\notag  \\\\P(F)=P(E)+{\\color{Blue}P(F\\setminus E)\\overset{(1)}{\\ge}0}\\notag  \\\\P(F)\\ge P(E)\\notag  \\] <p>Property 4 For any event \\(E\\in \\mathcal{A}\\),</p> \\[ P(E)\\le 1\\notag  \\] <p><code>Proof</code></p> \\[ E\\subset S \\ \\overset{Property\\ 3}{\\Rightarrow}P(E)\\le 1\\notag  \\] <p>Property 5  (Law of total probability) Let \\(F\\in \\mathcal{A}\\) be an event and \\((E_i)_{i\\ge 1}\\) be a countable partition of the sample space \\(S\\) (that is, \\(\\bigcup_{i=1}^{\\infty}E_i=S\\  and \\ E_i\\cap E_j=\\emptyset \\ for \\ i \\neq j\\)),</p> \\[ P(F)=\\sum_{i=1}^{\\infty}P(F\\cap E_i)\\notag  \\] <p><code>Proof</code></p> \\[ \\begin{align} P(F)&amp;=P(F\\cap S)\\notag  \\\\&amp;=P(F\\cap (\\bigcup_{i=1}^{\\infty}E_i))\\notag  \\\\&amp;=P(\\bigcup_{i=1}^{\\infty}F\\cap E_i)\\notag  \\\\&amp;\\overset{(3)}{=}\\sum_{i=1}^{\\infty}P(F\\cap E_i)\\notag  \\end{align} \\] \\[ because \\ \\{ F\\cap E_i\\}_{i=1}^{\\infty}\\ is \\ mutually \\ exclusive \\ sequence\\notag  \\] <p>Property 6  (Probability of the complement) For any event \\(E\\in \\mathcal{A}\\),</p> \\[ P(E^c)=1-P(E)\\notag  \\] <p><code>Proof</code></p> \\[ 1\\overset{(2)}{=}P(S)=P(E\\cup E^c)\\overset{property 2}{=}P(E)+P(E^c)\\notag  \\] <p>Property 7 (Probability of the union of 2 events) For any two events \\(E,F\\in \\mathcal{A}\\),</p> \\[ P(E\\cup F)=P(E)+P(F)-P(E\\cap F)\\notag \\] <p><code>Proof</code></p> \\[ \\begin{align} F&amp;=(F\\cap E)\\cup(F\\cap E^c)\\notag  \\\\(F\\cap E)\\cup(F\\cap E^c) \\ &amp;is \\ mutually \\ exclusive\\notag \\\\ P(F)&amp;=P(F\\cap E)+{\\color{Red}P(F\\cap E^c)}\\notag  \\\\from \\ E\\cup F&amp;=E\\cup (F\\cap E^c)\\notag  \\\\P(E\\cup F)&amp;=P(E)+{\\color{Red}P(F\\cap E^c)}\\notag \\\\  &amp;=P(E)+P(F)-P(E\\cap F)\\notag  \\end{align} \\] <p>The identity below is a very famous trick(when I'm in high school, I am amazed by it).</p> <p>Property 8  (Inclusion-Exclusion Identity/Poincaré’s formula) For any two events \\(E,F\\in \\mathcal{A}\\),</p> \\[ P(\\bigcup_{i=1}^{n}E_i)=\\sum_{k=1}^{n}(-1)^{k-1}\\sum_{1\\le i_1 &lt; ...&lt; i_k\\le n}P(E_{i_1}\\cap...\\cap E_{i_k})\\notag  \\] <p>where \\(\\sum\\limits_{1\\le i_1&lt;...&lt;i_k\\le n}\\) means the sum for all subsets of \\((1,...,n)\\) of size k.</p> <p><code>Proof</code></p> <p>By induction is easy.</p> <p>Property 9 For events \\(E,F\\)</p> \\[ P(E\\cup F)\\le P(E)+P(F)\\notag  \\] <p><code>Proof</code></p> \\[ \\begin{align} P(E\\cup F)&amp;=P(E)+P(F)-P(E\\cap F)\\notag  \\\\&amp;\\le P(E)+P(F)\\notag  \\end{align} \\] <p>Property 10  (A generalization)</p> <p>For a finite sequence of events \\(E_1,...,E_n,\\)</p> \\[ P(\\bigcup_{i=1}^{n}E_i)\\le \\sum_{i=1}^{n}P(E_i)=P(E_i)+...+P(E_n)\\notag  \\] <p><code>Proof</code></p> \\[ \\begin{align} P(\\bigcup_{i=1}^{\\infty}E_i)&amp;=P(E_1\\cup(\\bigcup_{i=2}^{\\infty}E_i))\\notag  \\\\&amp;\\le P(E_1)+P(\\bigcup_{i=2}^{\\infty}E_i)\\notag  \\end{align} \\] <p>Property 11  (Boole’s Inequality) For a countable infinite sequence of events \\(\\{E_i\\}_{i\\ge1}\\)</p> \\[ P(\\bigcup_{i=1}^{\\infty}E_i)\\le\\sum_{i=1}^{\\infty}P(E_i)\\notag \\] <p><code>Proof</code></p> <p>We construct a new sequence of events \\(\\{F_i\\}_{i=1}^{\\infty}\\) mutually exclusive.</p> \\[ \\begin{align} Make \\ F_1=E_1 \\ \\ F_2=E_2 \\setminus E_1\\notag  \\ &amp; \\ F_k=E_k \\setminus \\bigcup_{i=1}^{k-1}E_i \\ (k\\ge2)\\notag  \\\\\\bigcup_{i=1}^{n}E_i=\\bigcup_{i=1}^{n}F_i,&amp; \\notag \\bigcup_{i=1}^{\\infty}E_i=\\bigcup_{i=1}^{\\infty}F_i\\notag  \\\\Obviously,the \\ \\{ F_i\\}_{i=1}^{\\infty}\\ &amp;are\\ mutually \\ exclusive\\notag \\\\  P(\\bigcup_{i=1}^{\\infty}E_i)&amp;=P(\\bigcup_{i=1}^{\\infty}F_i)\\notag  \\\\&amp;=\\sum_{i=1}^{\\infty}P(F_i)\\notag  \\\\&amp;\\overset{F_k \\subset E_k}{\\le}\\sum_{i=1}^{\\infty}P(E_i)\\notag  \\end{align} \\] <p>$$ \\color{Blue}Motivation \\  example:Infinitely \\ large \\ urn \\ and\\ infinite\\ balls $$</p> <p>Suppose we have an infinitely large urn, and an infinite collection of balls labeled   as number 1, 2, 3, and so on. Consider an experiment as follows:</p> <ul> <li>At 1 minute to 12pm, balls numbered 1 through 10 are placed in the urn    and ball number 1 is withdrawn;</li> <li>At \\(\\frac{1}{2}\\) to 12pm, balls numbered 11 through 20 are placed in the urn and    ball number 2 withdrawn;</li> <li>At \\(\\frac{1}{4}\\) to 12pm, balls numbered 21 through 30 are placed in the urn and    ball number 3 withdrawn;</li> <li>...</li> </ul> <p>and so on.How many balls are there in the urn at 12pm ? (the answer is 0 and why?)  If we place the 1 to 10 balls and withdraw 10,place the 11 to 20 balls and withdraw 20,there are infinite balls(contrast two situations).</p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#continuity-property","level":3,"title":"Continuity property","text":"<p>Definition 2.11 (Increasing/Decreasing sequences) A sequence of events \\(\\{E_n,n\\ge1\\}\\) is said to be an increasing sequence if</p> \\[ E_1\\subset E_2...\\subset E_n\\subset ...,\\notag  \\] <p>and we define a new event { \\(\\lim\\limits_{n\\to \\infty}E_n \\ by \\ \\lim\\limits_{n\\to \\infty}E_n=\\bigcup\\limits_{n=1}^{\\infty}E_n\\) }  A sequence of events \\(\\{E_n,n\\ge1\\}\\) is said to be an increasing sequence if</p> \\[ E_1\\supset E_2...\\supset E_n\\supset ...,\\notag  \\] <p>and we define a new event \\({\\lim\\limits_{n\\to \\infty}}E_n \\ by \\ \\lim\\limits_{n\\to \\infty}E_n=\\bigcap\\limits_{n=1}^{\\infty}E_n\\)</p> <p>Proposition 2.12 (Continuity property) If \\(\\{E_n,n\\ge1\\}\\) is either an increasing or a decreasing sequence, then</p> \\[ \\lim_{n\\to\\infty}P(E_n)=P(\\lim_{n\\to\\infty }E_n)\\notag  \\] <p><code>Proof</code></p> <p>It suffices to discuss the increasing case since if ,</p> <p>\\(\\{E_n \\ n\\ge1\\}\\)is decreasing the \\(\\{E_n^c \\ n\\ge1 \\}\\) is increasing.</p> \\[ \\begin{align} \\lim_{n\\to\\infty}P(E_n^c)\\overset{increasing}{=}P(\\lim_{n\\to\\infty}E_n^c)=P(\\bigcup_{n=1}^{\\infty}E_n^c)=P((\\bigcap_{n=1}^{\\infty}E_n)^c)=1-P(\\bigcap_{n=1}^{\\infty}E_n)\\notag  \\\\\\lim_{n\\to\\infty}P(E_n^c)=1-\\lim_{n\\to\\infty}P(E_n)=1-P(\\lim_{n\\to\\infty}E_n)=1-P(\\bigcap_{n=1}^{\\infty}E_n)\\notag  \\\\\\lim_{n\\to\\infty}P(E_n)=P(\\lim_{n\\to\\infty}E_n) \\notag \\\\ \\end{align} \\] <p>Now we prove the result for increasing \\(E_n\\) ,we do the same construction before.</p> \\[ \\begin{align} F_n&amp;=E_n\\setminus\\bigcup_{i=1}^{n-1}E_i=E_n\\setminus E_{n-1}\\notag \\\\ RHS&amp;=P(\\lim_{n\\to\\infty}E_n)=P(\\bigcup_{i=1}^{\\infty}E_i)=P(\\bigcup_{i=1}^\\infty F_i)\\notag  \\\\&amp;=\\sum_{i=1}^{\\infty}P(F_i)=\\lim_{n\\to\\infty}\\sum_{i=1}^{n}P(F_i)\\notag  \\\\&amp;=\\lim_{n\\to\\infty}P(\\bigcup_{i=1}^{n}F_i)=\\lim_{n\\to\\infty}P(\\bigcup_{i=1}^{n}E_i)=\\lim_{n\\to\\infty}P(E_n)\\notag  \\end{align} \\] <p>Now let's focus on original example. We change the ball withdrawn to randomly.</p> <p>We consider the ball number 1. Let \\(E_n\\) be the event that ball 1 is still in the urn after the \\(n^{th}\\) withdraw.</p> \\[ \\begin{align}  E_1\\subset E_2\\subset E_3\\ &amp;is \\ decreasing\\notag  \\\\ P(ball \\ 1 \\ is\\ in \\ the \\ urn\\ at\\ 12pm)&amp;=P(\\bigcap_{n=1}^{\\infty}E_n)\\notag  \\\\&amp;=\\lim_{n\\to\\infty}P(E_n)\\notag  \\\\&amp;=\\lim_{n\\to\\infty}\\frac{9}{10}·\\frac{18}{19}\\notag ···=\\lim_{n\\to\\infty}\\prod_{k=1}^{n}\\frac{9k}{9k+1}\\notag  \\\\&amp;=\\lim_{n\\to\\infty}exp(\\sum_{k=1}^{n}ln\\frac{9k}{9k+1})\\notag  \\\\&amp;=0\\ \\ \\ \\notag  (ln\\frac{9k}{9k+1}\\sim-\\frac{1}{9k+1})\\notag  \\end{align} \\] <p>The discussion for other balls is the same . So we can get the conclusion.</p> \\[ \\begin{align} &amp;\\ \\ \\ \\ \\ P(the\\ urn \\ is\\ not\\ empty\\ at \\ 12pm)\\notag  \\\\&amp;=P(there\\ is \\ at\\ least\\ one\\ ball\\ in\\ the\\ urn\\ at\\ 12pm)\\notag  \\\\&amp;=P(\\bigcup_{n=1}^{\\infty}F_n)\\ \\ (where\\ F_n ={ball\\ number\\ n \\ is\\ in\\ the\\ urn\\ at\\ 12pm)}\\notag  \\\\&amp;\\overset{Boole's\\ Inequality}{\\le}\\sum_{n=1}^{\\infty}P(F_n)\\notag  \\\\&amp;\\overset{Axiom \\ 1}{=}0\\notag  \\end{align} \\]","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#uniform-probability-measure","level":2,"title":"Uniform probability measure","text":"<p><code>We first study finite sample space</code></p> <p>Definition 2.9 (uniform probability measure)  Let \\(S\\) be a finite sample space \\(S = \\{\\omega_1,...,\\omega_n\\}\\) with \\(|S|=n\\in N,n\\ge1\\) and \\((S,P(S),P)\\) be a probability space. Probability measure \\(P\\) is said to be uniform if all outcomes \\(\\omega_i\\) in the sample space are equally likely to occur,that is,\\(P(\\{\\omega_i\\})=\\alpha\\) for \\(i=1,...,n,\\) with \\(\\alpha\\ge 0\\) .</p> <p>Properties</p> <p>Let \\((S,P(S),P)\\) be a probability space with uniform probability measure \\(P\\) on a finite sample space \\(S=\\{ \\omega_1,...,\\omega _n\\}\\). Then</p> \\[ \\begin{align}   &amp;(1)P(\\{\\omega_i\\})=\\frac{1}{n},for \\ i =1,...,n.\\notag    \\\\&amp;(2)For\\ any\\ event\\ E,P(E)=\\frac{|E|}{|S|}\\notag    \\end{align} \\] <p><code>Proof</code></p> \\[ \\begin{align} &amp;(1)S=\\{\\omega_1\\}\\cup\\{\\omega_2\\}···\\cup\\{\\omega_n\\}\\notag \\\\ &amp;1=P(S)=P(\\bigcup_{i=1}^{n}\\omega_i)=\\sum_{i=1}^{n}P(\\omega_i)=n\\alpha&amp;\\notag \\\\ &amp;\\alpha=\\frac{1}{n}\\notag \\\\ &amp;(2)P(E)=P(\\bigcup_{i\\in(1,...,n)\\ \\omega_i\\in E}\\{\\omega_i\\})=\\sum_{i\\in(1,2...n)\\ \\omega_i\\in E} P(\\{\\omega_i\\})\\notag  \\\\&amp;=\\frac{|E|\\frac{1}{n}}{n·\\frac{1}{n}}=\\frac{|E|}{n}\\notag  \\end{align} \\]","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#interesting-examples","level":2,"title":"Interesting Examples","text":"","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#poker-problem","level":3,"title":"Poker Problem","text":"<p>In the game of bridge, the entire deck of 52 cards is dealt out to 4 players. What is the probability that + one of the players receives all 13 spades; + each player receives 1 ace?</p> <p><code>Solution</code></p> <p>\\(S=\\{all \\ possibel\\ distribution\\ to \\ 4\\ players\\}\\) \\(|S|=\\binom{52}{13,13,13,13}\\)</p> \\[ \\begin{align} 1.E&amp;=\\{one\\ of\\ the\\ players\\ get\\ all\\ 13\\ spades\\}\\notag  \\\\&amp;=\\bigcup_{i=1}^{4}\\{player\\ i \\ gets\\ all\\ 13\\ spades\\}\\notag  \\\\&amp;=\\sum_{i=1}^{4}P(player\\ i\\ gets\\ 13 \\ spades)\\notag  \\\\&amp;=4\\frac{\\binom{39}{13,13,13}}{\\binom{52}{13,13,13,13}}\\notag  \\\\2.F&amp;=\\{each\\ player\\ gets\\ one\\ ace\\}\\notag  \\\\&amp;P(F)=\\frac{|F|}{|S|}=\\frac{4\\binom{48}{12,12,12,12}}{\\binom{52}{13,13,13,13}}\\notag \\\\ \\end{align} \\]","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#birthday-problem","level":3,"title":"Birthday Problem","text":"<p>Recall that Pigeonhole principle tells us that among 366 people, there are at least 2 people celebrating their birthday on the same day (we ignore the Feb. 29 case). Now we want to study for n people, what is the probability that no two of them celebrate their birthday on the same day? How large need n be so that this probability is less than \\(\\frac{1}{2}\\) ?</p> <p><code>Solution</code></p> <p>For n people,\\(S=\\{all \\ possibel\\ birthday\\ of  \\ n\\ people\\}\\) </p> <p>\\(|S|=365^n\\)</p> \\[ \\begin{align} &amp;\\ \\ \\ \\ \\ \\  P(no\\ two\\ of\\ them\\ have\\ the\\ same\\ birthday)\\notag  \\\\&amp;=\\frac{365·364···(365-n+)}{365^n}&lt;\\frac{1}{2}\\ \\ when \\ n\\ge23\\notag  \\\\&amp;when\\ n=100,the \\ probability&gt;\\frac{3\\times10^6}{3\\times10^6+1}\\notag  \\end{align} \\]","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%A6%82%E7%8E%87%E8%AE%BA/Sets,%20Axioms%20of%20Probability/#matching-problem","level":3,"title":"Matching Problem","text":"<p>Suppose that each of N men at a party throw his hat into the center of the room. The hats are first mixed up, and then each man randomly selects a hat. What is the probability that none of the men selects his own hat?</p> <p><code>Solution</code></p> <p>We analysis the complement event at least one man selects his own hats </p> <p>Let \\(E_i=the \\ i^{th}\\ man\\ selects\\ his\\ own\\ hats\\)</p> \\[ \\begin{align} P(\\bigcup_{i}^{N}E_i)&amp;=\\sum_{i=1}^{N}P(E_i)-\\sum_{1\\le i_1\\le i_2...\\le \\notag N}P(E_{i_1}E_{i_2}...)+...+(-1)^{N+1}P(E_1..E_N)\\notag  \\end{align} \\] <p>Note that  \\(E_{i_1}E_{i_2}..E_{i_n}\\) represents the event that \\(i_1^{th}...i_{n}^{th}\\) men get their own hats</p> \\[ \\begin{align} P(E_{i_1}E_{i_2}..E_{i_n})&amp;=\\frac{(N-n)!}{N!}\\notag  \\\\\\sum_{1\\le i_1&lt;i_2...&lt;i_N\\le N }P(E_{i_1}E_{i_2}..E_{i_n})&amp;=\\binom{N}{n}\\frac{(N-n)!}\\notag {N!}\\frac{1}{N!}=\\frac{1}{n!}\\notag  \\\\P(\\bigcup_{i=1}^{N}E_i)&amp;=1-\\frac{1}{2!}+\\frac{1}{3!}+...+(-1)^{N+1}\\frac{1}{N!}\\notag  \\\\&amp;=\\sum_{k=1}^{N}(-1)^{k+1}\\frac{1}{k!}\\notag  \\end{align} \\] <p>the probability that no one selects his own hat is </p> \\[ \\begin{align} 1-P(\\bigcup_{i=1}^{N}E_i)&amp;=1-\\sum_{k=1}^{N}(-1)^{k+1}\\frac{1}{k!}\\notag \\\\  &amp;=\\sum_{k=0}^{N}(-1)^k\\frac{1}{k!}\\overset{N\\to\\infty}{\\to}e^{-1} \\notag  \\end{align} \\] <p>Recall the Talor expansion of  \\(e^x=\\sum_{k=0}^{\\infty}\\frac{x^k}{k!}\\) When N is large the probability is close to \\(e^{-1}\\approx0.3679\\)</p>","path":["Chapter 2 :Sets, Axioms of Probability"],"tags":["Probability Theory"]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/","level":1,"title":"Functional Analysis(Lecture)","text":"<p>[!tldr] 课程简介 所属大学：南开大学 主讲教师：李磊(Li Lei) 先修要求：数学分析 + 高等代数 + 实变函数(Optional) 课程难度：⭐⭐⭐ 预计学时：200h 给分情况：⭐⭐⭐⭐⭐ 考试难度：⭐⭐ 修读时间：25 Fall</p> <p>[!tip] Major and foundational results four pillars of functional analysis: + the Hahn-Banach theorem + the open mapping theorem + the closed graph theorem + the uniform boundedness pinciple(Banach-Steinhaus theorem)</p> <p>由于讲义是按照全英文书写的，因此这里的笔记也基本是英文，中文部分基本上是依据其他的书籍资料进行的一个补充，或者是作者按照自己的理解增加的注释</p> <p>老师的讲义实际上是两学期的内容，分为两个部分，第一个部分讲解泛函分析的基础知识，从TVS到Banach空间，Hilbert空间和一些基本的大定理，第二部分则更加专注于更高级的内容，如Banach代数、算子代数等，以及作者所研究过的一些结果</p> <ul> <li>References<ul> <li>Conway: A course in abstract analysis</li> <li>Brezis</li> <li>Peter Lax</li> <li>张恭庆 泛函分析讲义(上)</li> </ul> </li> </ul>","path":["Functional Analysis(Lecture)"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/#lecture-contents","level":2,"title":"Lecture Contents","text":"","path":["Functional Analysis(Lecture)"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/#part-1-basic-theory","level":3,"title":"Part 1 Basic Theory","text":"<p>Functional_Analysis-Preliminaries(Lecture)</p> <p>Banach Spaces</p> <p>Hilbert Spaces</p> <p>Continuous linear operators</p> <p>Some big thorems</p>","path":["Functional Analysis(Lecture)"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Banach%20Spaces/","level":1,"title":"Banach Spaces","text":"<p>[!tldr] Outline + Normed spaces + Banach spaces + Seperable Banach spaces + Completeness and Compactness in Banach spaces</p> <p>泛函分析的基础就是下面所提到的赋范空间，在一个向量空间上赋以一个范数，因此称为赋范空间(Normed space)，这是泛函分析中最为基本的研究对象，我们将完备性引入其中得到Banach空间</p> <p>[!tip] 补充 也可以参考张恭庆的《泛函分析》一书，其中详细讲述了这一类空间是如何加强条件而产生的，由准范数的定义出发定义\\(F^{*}\\)空间，进而完备化定义\\(Frechet\\)空间，再添加齐次性使得准范数加强为范数，诱导出下面的赋范线性空间(\\(B^{*}\\)空间)，完备化后就是本章要重点讲述的\\(Banach\\)空间</p> <p>[!cite] 注：拓扑向量空间 而拓扑向量空间(Topological Vector Space, TVS)则是泛函分析的基本研究对象，是指带有拓扑的向量空间，这样的拓扑对无限维向量空间有不同选择，而有限维实或复向量空间上符合Hausdorff条件的拓扑向量空间结构唯一，需要注意TVS是对赋范空间的推广，它允许使用比范数诱导的拓扑更弱，更一般的拓扑(有些TVS的拓扑不能被任何度量诱导)，因此有更加一般的性质！</p> <p>比较重要的拓扑向量空间的例子就是Banach空间和Hilbert空间，它们是满足额外条件的拓扑向量空间，而大致的包含关系是这样的：</p> <p>内积空间\\(\\subset\\)赋范空间\\(\\subset\\)可度量化的TVS\\(\\subset\\)拓扑向量空间</p> <p>下面先介绍赋范(线性)空间</p>","path":["Banach Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Banach%20Spaces/#normed-spaces","level":2,"title":"Normed spaces","text":"<p>所谓的“赋范”就是指给空间赋以一个范数，那么就应当先给出范数的定义：</p> <p>[!NOTE] Definition(norm) Let \\(E\\) be a vector space over the field \\(\\mathbb{K}=\\mathbb{R}\\ or\\ \\mathbb{C}\\), and let a function \\(\\lVert \\cdot \\rVert: E\\to \\mathbb{R}_{+}:=[0,\\infty)\\) is a norm if the following 3 conditions are satisfied: 1. \\(\\lVert x \\rVert \\geqslant 0\\) for all \\(x\\in E\\) and \\(\\lVert x \\rVert = 0\\iff x=0\\) 2. \\(\\lVert \\lambda x \\rVert =\\lvert \\lambda \\rvert\\lVert x \\rVert\\) for all \\(\\lambda\\in \\mathbb{K}\\) and \\(x\\in E\\) 3. \\(\\lVert x+y \\rVert \\leqslant \\lVert x \\rVert + \\lVert y \\rVert\\) for all \\(x,y\\in E\\) (Triangle inequality)</p> <p>and we call \\((E,\\lVert \\cdot \\rVert)\\) a normed(vector) space</p> <p>A norm will induce a metric \\(d\\) and it's defined by</p> \\[ d(x,y)=\\lVert x-y \\rVert ,\\forall x,y,z\\in E \\] <p>这是非常显然的，度量就是两个向量差的范数，所以有了范数就一定有度量和距离的概念</p> <p>[!warning] Remark：LCS and TVS Some terms may be used later: locally convex space(LCS for short), topological vector spaces(TVS) We note that \\(\\mathbb{K}=\\mathbb{C}\\ or\\ \\mathbb{R}\\), so we should consider \\(\\overline{x}y\\not\\neq x \\overline{y}\\)</p> <p>We should know some about topological vector spaces(TVS). You can find more about TVS in [拓扑向量空间(TVS)]</p> <p>给出一些简单范数的例子(证明只需要根据定义check)</p> <p>[!example] 范数例子 1. 欧式范数 在有限维的向量空间上定义一组基，定义范数(\\(\\lVert \\cdot \\rVert : E\\to[0,+\\infty)\\))为：</p> \\[\\lVert x \\rVert _{2}:= \\left( \\sum\\limits_{i=1}^{n} \\lvert x_{i} \\rvert ^{2} \\right) ^{ \\frac{1}{2}},\\forall x=\\sum\\limits_{i=1}^{n} x_{i}e_{i}\\in E\\] <ol> <li>\\(p\\)范数 对于\\(1\\leqslant p &lt; \\infty\\)，定义在\\(\\mathbb{K}^{n}\\)上的范数为</li> </ol> \\[\\lVert x \\rVert _{p}=\\left( \\sum\\limits_{i=1}^{n} \\lvert x_{i} \\rvert ^{p} \\right)^{\\frac{1}{p}}\\] <p>比较特别的是无穷范数\\(\\lVert x \\rVert_{\\infty}=\\max\\limits_{1\\leqslant i \\leqslant n}\\lvert x_{i} \\rvert\\)，事实上这只是针对于序列的，关于函数空间也有相应的\\(p\\)范数会在后续定义</p> <ol> <li>Frobenius norm or Hilbert-Schmidt norm 定义矩阵函数：\\(M_{mn}\\to[0,+\\infty)\\)如下：</li> </ol> \\[\\lVert A \\rVert =\\left( \\sum\\limits_{i=1}^{m} \\sum\\limits_{j=1}^{n} \\lvert a_{ij} \\rvert ^{2} \\right)^{\\frac{1}{2}},\\forall A=(a_{ij}){1\\leqslant i \\leqslant m, 1\\leqslant j \\leqslant n}\\in M_{mn}\\] <p>下面给出一些关于\\(l_{\\infty}\\)的子空间的例子</p> <p>[!example] important normed subspaces of \\(l_{\\infty}\\) (1) \\(c=\\left\\{ (x_{n})_{n=1}^{\\infty}:\\lim\\limits_{ n \\to \\infty }x_{n}\\ exists \\right\\}\\) (2) \\(c_{0}=\\left\\{ (x_{n})_{n=1}^{\\infty}:\\lim\\limits_{ n \\to \\infty }x_{n}=0 \\right\\}\\) (3) \\(c_{00}=\\left\\{ (x_{n})_{n=1}^{\\infty}:x_{n}=0 \\right\\}\\) \\(x_{n}=0\\) for all but at most finitely many \\(n\\)</p> <p>其中第一个就是一个极限存在的数列，第二个就是一个极限是0的数列，第三个则是一个至多有有限多个项能够取到0的极限为0的数列</p> <p>有一个不那么显然的范数判断留作习题，请参考Exercises 2.1 8</p> <p>实际上在上面关于\\(p\\)范数的三角不等式性质证明中我们需要两个著名的不等式(\\(H \\ddot{o} lder\\) inequality and Minkowski inequality)，在此citing with proof，后续不再赘述</p> <p>[!tip] Theorem(\\(H\\ddot{o}lder\\)'s inequality) Here use \\(\\mu\\) as a positive measure and a set \\(\\Omega\\), let \\(1&lt;p&lt;\\infty\\). For any \\(f\\in L^{p}(\\Omega,\\mu)\\) and \\(g\\in L^{q}(\\Omega,\\mu)\\), where \\(\\frac{1}{p}+ \\frac{1}{q}=1\\), we have \\(fg\\in L^{1}(\\Omega,\\mu)\\) and</p> \\[\\lVert fg \\rVert _{1}=\\int_{\\Omega}\\lvert fg \\rvert d \\mu \\leqslant \\left( \\int_{\\Omega}\\lvert f \\rvert ^{p} d\\mu \\right)^{\\frac{1}{p}}\\left( \\int_{\\Omega}\\lvert g \\rvert ^{q}d\\mu \\right)^{\\frac{1}{q}}=\\lVert f \\rVert _{p}\\lVert g \\rVert _{q}\\] <p><code>Proof.</code></p> <p>Step 1</p> <p>Consider a convex function \\(\\varphi(t) = \\frac{t^{p}}{p}+ \\frac{1}{q}-t,t\\in[0,\\infty)\\), so its minimum \\(\\varphi(1) =0\\) when \\(t=1\\), we can get \\(\\frac{t^{p}}{p}+ \\frac{1}{q}\\geqslant t,\\forall t\\in[0,\\infty)\\). Let \\(t=uv^{-\\frac{q}{p}}\\) for any \\(u,v\\geqslant 0\\) and one can derive that \\(uv \\leqslant \\frac{u^{p}}{p}+ \\frac{v^{q}}{q}\\)</p> <p>Step 2</p> <p>Setting \\(u= \\frac{\\lvert f(t) \\rvert}{\\lVert f \\rVert_{p}},v= \\frac{\\lvert g(t) \\rvert}{\\lVert g \\rVert_{q}}\\)(Obviously we should assume they are greater than zero) we derive that</p> \\[ \\frac{\\lvert f(t)g(t) \\rvert }{\\lVert f \\rVert _{p}\\lVert g \\rVert _{q}}\\leqslant \\frac{\\lvert f(t) \\rvert ^{p}}{p\\lVert f \\rVert _{p}^{p}}+ \\frac{\\lvert g(t) \\rvert ^{q}}{q\\lVert g \\rVert _{q}^{q}},\\forall t\\in\\Omega \\] <p>Hence</p> \\[ \\frac{\\int_{\\Omega} \\lvert fg \\rvert d\\mu }{\\lVert f \\rVert _{p}\\lVert g \\rVert _{q}}\\leqslant \\frac{1}{p} \\frac{\\int_{\\Omega}\\lvert f\\rvert ^{p}d\\mu}{\\lVert f \\rVert _{p}^{p}}+ \\frac{1}{q} \\frac{\\int_{\\Omega}\\lvert g\\rvert ^{q}d\\mu}{\\lVert g \\rVert _{q}^{q}}= \\frac{1}{p}+ \\frac{1}{q}=1 \\] <p>So we get it.</p> <p>[!tip] Theorem(Minkowski inequality) Let \\(\\mu\\) be a positive measure on a set \\(\\Omega\\)，\\(1\\leqslant p &lt; \\infty\\) and \\(f,g\\in L^{p}(\\Omega,\\mu)\\). We have</p> \\[\\lVert f+g \\rVert _{p}\\leqslant \\lVert f \\rVert _{p}+\\lVert g \\rVert _{p}\\] <p>that is,</p> \\[\\left( \\int_{\\Omega}\\lvert f+g \\rvert ^{p}d\\mu \\right)^{\\frac{1}{p}}\\leqslant\\left( \\int_{\\Omega}\\lvert f \\rvert ^{p}d\\mu \\right)^{ \\frac{1}{p}}+\\left( \\int_{\\Omega}\\lvert g \\rvert ^{p} d\\mu\\right)^{\\frac{1}{p}}\\] <p><code>Proof.</code></p> <p>稍微陈述一下证明脉络：做一个拆分然后使用\\(H \\ddot{o} lder\\)不等式进行放缩</p> <p>Very easy.</p> \\[ \\begin{aligned} \\lVert f+g \\rVert _{p}^{p}&amp;=\\int_{\\Omega}\\lvert f+ g\\rvert^{p}d\\mu=\\int_{\\Omega}\\lvert f+g \\rvert ^{p-1}\\lvert f+g \\rvert d\\mu\\\\ &amp;\\leqslant\\int_{\\Omega}\\lvert f+g \\rvert ^{p-1}(\\lvert f \\rvert +\\lvert g \\rvert )d\\mu\\\\ &amp;\\overset{H \\ddot{o} lder \\ Inequality}{\\leqslant}\\lVert \\lvert f+g \\rvert ^{p-1} \\rVert _{q}\\lVert f \\rVert _{p}+\\lVert \\lvert f+g \\rvert ^{p-1} \\rVert _{q}\\lVert g \\rVert _{p}\\left( q= \\frac{p}{p-1} \\right)\\\\ &amp;=\\lVert \\lvert f+g \\rvert ^{p-1} \\rVert _{q}(\\lVert f \\rVert _{p}+\\lVert g \\rVert _{p})\\\\ &amp;=\\lVert f+g \\rVert ^{p-1}_{p}(\\lVert f \\rVert _{p}+\\lVert g \\rVert _{p})\\\\ \\lVert f+g \\rVert _{p}&amp;\\leqslant\\lVert f \\rVert _{p}+\\lVert g \\rVert _{p} \\end{aligned} \\] <p>定义了范数（Norm）的向量空间称为赋范空间(Normed Space，或赋范线性空间)</p> <p>在泛函分析中，我们主要研究这类空间。其中，最基本且最早被深入研究的一类是实数域或复数域上的完备赋范空间，这类空间被称为Banach空间。另一个重要的例子是Hilbert空间，它是一种特殊的 Banach 空间(准确的说是完备的内积空间)，其范数由一个内积所诱导</p> <p>由于我们上面所介绍的范数和对应的空间都是针对于序列的，因此我们不免想要专门抽象出一个空间来进行表示，我们希望它能够将已有的范数概念推广到无穷维的序列上(推广至无穷也正是泛函分析这一学科研究的核心内容)，序列空间正是作为有限维向量空间\\(\\mathbb{K}^{n}\\)在无限维情况下的自然抽象和推广，为无限维背景下研究收敛性、完备性、连续性提供了基础的模型</p> <p>下面介绍一下Sequence spaces(序列空间)的内容，在泛函分析及其他领域中，序列空间就是一个向量空间，元素为实数或复数，等价地是一个函数空间(\\(\\mathbb{N}(\\mathbb{Z})\\to \\mathbb{K}\\))，所有的函数集自然与可能的元素在\\(\\mathbb{K}\\)中的无限序列集相对应，并且在逐点加法与数乘运算中构成一个向量空间</p> <p>那么关于上面的序列空间，我们仍然需要为它配备一个范数，这就引出了\\(\\ell_{p}\\)空间，它很好继承了有限维情况下结构良好的\\(p\\)范数的性质，又兼具无穷求和有限的性质，便于进行分析，保证了范数的有界性，并且它也是完备的(Banach空间)</p> <p>给出\\(\\ell_{p}\\)空间的定义：</p> <p>[!NOTE] Definiotion(\\(l_{p}\\) space) Let \\(I\\) be a set and \\(1\\leqslant p &lt; \\infty\\) and \\(l_{p}(I)\\) to be the set of all functions \\(x:I\\to \\mathbb{K}\\) s.t.</p> \\[\\sum\\limits_{i\\in I}\\lvert x(i) \\rvert^{p}:=\\lim\\limits_{ F\\in \\mathcal{F} }\\lvert x(i) \\rvert ^{p}&lt;\\infty   \\] <p>where \\(\\mathcal{F}\\) is the direct family of finite subsets of \\(I\\) ordered by set inclusion</p> <p>实际上\\(\\ell^{p}\\)空间是\\(L^{p}\\)空间在计数测度的一种特殊情况</p> <p>The most important sequence spaces in analysis are the ⁠⁠ spaces, consisting of the ⁠⁠power summable sequences, with the ⁠⁠-norm. These are special cases of ⁠Lp spaces for the counting measure on the set of natural numbers. Other important classes of sequences like convergent sequences or null sequences form sequence spaces, respectively denoted ⁠⁠ and ⁠⁠, with the sup norm. Any sequence space can also be equipped with the topology of pointwise convergence, under which it becomes a special kind of Fréchet spacecalled FK-space.</p> <p>关于\\(L^{p}\\)空间的内容可以参考实分析教材或是wikipedia，相关的博客香蕉空间的撰写也很有意思，列在下面(老师的讲义中也有这一部分，所以不重复叙述了)</p> <p>[!tip] Generation(\\(L^{p}\\) space) 设\\((X,\\mathcal{A},\\mu)\\)为测度空间，\\(f:X\\to \\mathbb{K}\\)为可测函数，\\(p\\in[0,+\\infty]\\)，则\\(f\\)的\\(L^{p}\\)范数(\\(p-\\)范数)，记为\\(\\lVert f \\rVert_{p}\\in[0,+\\infty]\\)，定义如下</p> \\[\\lVert f \\rVert _{p}=\\left( \\int_{X}\\lvert f \\rvert ^{p}d\\mu \\right)^{\\frac{1}{p}}\\] <p>其中的积分为Lebesgue积分，若是\\(p=\\infty\\)，将\\(\\lVert f \\rVert_{\\infty}\\)定义为对于几乎所有\\(x\\in X\\)成立的最小上确界(essential)，当\\(\\mu(X)&gt;0\\)，称作\\(\\lvert f \\rvert\\)的本质上确界(essential supremum)，此时\\(L^{\\infty}\\)范数也称为一致范数</p> \\[ess\\ \\sup\\ f = inf\\left\\{ \\beta:\\lvert f(t) \\rvert \\leqslant \\beta\\ \\mu-a.e. \\right\\}  \\] <p>\\(\\ell^{p}\\)是取\\(X=\\mathbb{Z}_{&gt;0}\\)并采用计数测度而得到的\\(L^{p}\\)空间，其元素可视为形如\\(x=(x_{1},x_{2},\\dots)\\)并使得范数\\(\\lVert x \\rVert_{p}=\\left( \\sum\\limits_{i=1}^{\\infty}\\lvert x_{i} \\rvert ^{p}\\right) ^{\\frac{1}{p}}\\)有限的实数列</p> <p>essential supremum的定义是很好用的，它说明\\(ess\\ \\sup(f-g)=0\\)等价于两函数相差一个零测集，可以视作等价，记为\\([f]\\)或是简单的\\(f\\)表示在\\(\\Omega\\)上只与\\(f\\)相差一个零测集的可测函数的等价类</p> <p>关于\\(L^{p}(\\Omega,\\mu)\\)是\\(p\\)范数下的赋范线性空间的证明留做习题</p> <p>再给出一个比较特殊情况的\\(p\\)范数，就是在连续的函数空间\\(C[a,b]\\)(real or complex valued continuous functions defined on the closed interval \\([a,b]\\))中:</p> \\[ \\lVert f \\rVert _{p}=\\left( \\int_{a}^{b} \\lvert f(t) \\rvert ^{p} \\, dt  \\right) ^{\\frac{1}{p}} \\] <p>显而易见，\\(\\lVert f \\rVert_{\\infty}=\\max\\limits_{t\\in[a,b]}\\lvert f(t) \\rvert\\)，这就是原本在一般测度空间\\((X,\\mathcal{A},\\mu)\\)和Lebesgue积分下\\(p\\)范数的特殊化，将测度空间定义在闭区间上，测度即为区间长度(连续性)，根据连续函数积分的定理，其上Lebesgue积分值与Riemann积分相同，因此可以直接使用R积分</p> <p>[!cite] 一些术语 BV(Bounded Variation)即有界变差</p> <p>[!tip] Theorem Let \\(E,F\\) be two normed spaces. A linear operator \\(T\\) from \\(E\\) into \\(F\\) is continuous with respect to the norm topology of \\(E\\) and \\(F\\) if and only if for any sequence \\((x_{n})_{n\\in \\mathbb{N}}\\) in \\(E\\)</p> \\[x_{n}\\to 0\\ in \\ E \\implies Tx_{n}\\to 0\\ in\\ F\\] <p>这个定理回答了赋范线性空间下如何判断线性算子连续性的问题，当且仅当它在零点处是序列连续的，这个定理成立的关键就是线性算子的线性性和赋范空间的平移不变性</p> <p>给出范数等价的定义</p> <p>[!NOTE] Definition(equivalent of norms) Two norms \\(\\lVert \\cdot \\rVert_{1},\\lVert \\cdot \\rVert_{2}\\) defined on a vector space \\(E\\) are equivalent if there are constants \\(\\alpha,\\beta&gt;0\\) such that </p> \\[\\alpha \\lVert x \\rVert_{1}\\leqslant \\lVert x \\rVert_{2}\\leqslant \\beta \\lVert x \\rVert _{1}\\] <p>in this case, we write \\(\\lVert \\cdot \\rVert_{1}\\sim \\lVert \\cdot \\rVert_{2}\\)</p> <p>关于norm topology的定义可以参考wikipedia，简单来说就是拓扑诱导生成度量，而度量产生拓扑(一个满足相应条件的集族)，范数拓扑就可以简单理解为所有开球的任意并集构成的集合，而开球族可以利用球心和半径定义(实际上是拓扑基的定义)</p> <p>用范数拓扑的语言来写范数等价性条件就是：</p> <p>[!NOTE] Proposition(equivalent of norms) Two norms \\(\\lVert \\cdot \\rVert_{1},\\lVert \\cdot \\rVert_{2}\\) defined on a vector space \\(E\\) are equivalent if and only if they define the same norm topology on \\(E\\)</p> <p>实际上对于有限维向量空间\\(E\\)而言，任意两个范数是等价的，也就是说只有一种范数拓扑定义在\\(E\\)上</p> <p>再给出赋范线性空间等价的定义</p> <p>[!NOTE] Definition(equivalent of normed spaces) Two normed spaces \\(E\\) and \\(F\\) are equivalent(resp. isometrically isomorphic) if there is a bijective linear map \\(T:E\\to F\\) such that both \\(T\\) and \\(T^{-1}\\) are continuous(resp. isometries)</p>","path":["Banach Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Banach%20Spaces/#exercises-21","level":2,"title":"Exercises 2.1","text":"<p>[!question] (1) If \\(E\\) is a linear space on which is given a mapping \\(p: E \\to [0, \\infty)\\) with the properties: (a) \\(p(x) = 0 \\iff x = 0\\); (b) \\(p(\\lambda x) = |\\lambda|p(x)\\) for any \\(x \\in E\\) and \\(\\lambda \\in \\mathbb{K}\\). Prove that \\(p\\) is a norm if and only if \\(U_E := \\{x \\in E : p(x) \\le 1\\}\\) is convex.</p> <p>纯定义，Gemini3写的</p> <p><code>Proof.</code></p> <p>First, assume \\(p\\) is a norm. Then \\(p\\) satisfies the triangle inequality \\(p(x+y) \\le p(x) + p(y)\\). Let \\(x, y \\in U_E\\) and \\(t \\in [0, 1]\\). We have \\(p(x) \\le 1\\) and \\(p(y) \\le 1\\).</p> \\[p(tx + (1-t)y) \\le p(tx) + p((1-t)y) = |t|p(x) + |1-t|p(y)\\] <p>Since \\(t \\in [0, 1]\\), this equals \\(t p(x) + (1-t)p(y) \\le t(1) + (1-t)(1) = 1\\). Thus \\(tx + (1-t)y \\in U_E\\), so \\(U_E\\) is convex.</p> <p>Conversely, assume \\(U_E\\) is convex. We must show the triangle inequality \\(p(x+y) \\le p(x) + p(y)\\) to prove \\(p\\) is a norm.</p> <p>Let \\(x, y \\in E\\) be non-zero vectors (the zero case is trivial). As following:</p> \\[ \\begin{aligned} \\frac{p(x)}{p(x)+p(y)} \\frac{x}{p(x)}+\\frac{p(y)}{p(x)+p(y)} \\frac{y}{p(y)}&amp; = \\frac{x+y}{p(x)+p(y)}\\\\ p\\left( \\frac{x+y}{p(x)+p(y)} \\right)&amp;\\leqslant 1\\\\ p(x+y)\\leqslant p(x)+&amp;p(y) \\end{aligned} \\] <p>Thus \\(p\\) is a norm.</p> <p>[!question] (2) Prove that the norm topology defined by a norm \\(\\|\\cdot\\|\\) of a normed space \\(E\\) is a vector topology.</p> <p>需要熟知向量拓扑和范数拓扑的定义，由范数生成的拓扑一定是一个向量拓扑，所以每一个赋范空间都是一个</p> <p><code>Proof.</code></p> <p>A topology on a vector space is a vector topology if vector addition and scalar multiplication are continuous mappings.</p> <ol> <li>Continuity of addition \\((x, y) \\mapsto x+y\\):</li> </ol> <p>We need to show that if \\(x_n \\to x\\) and \\(y_n \\to y\\) in the norm topology, then \\(x_n + y_n \\to x + y\\). Using the triangle inequality:</p> \\[\\|(x_n + y_n) - (x + y)\\| = \\|(x_n - x) + (y_n - y)\\| \\le \\|x_n - x\\| + \\|y_n - y\\|\\] <p>Since \\(\\|x_n - x\\| \\to 0\\) and \\(\\|y_n - y\\| \\to 0\\), the right side converges to 0. Thus \\(x_n + y_n \\to x + y\\).</p> <ol> <li>Continuity of scalar multiplication \\((\\lambda, x) \\mapsto \\lambda x\\):</li> </ol> <p>We need to show that if \\(\\lambda_n \\to \\lambda\\) in \\(\\mathbb{K}\\) and \\(x_n \\to x\\) in \\(E\\), then \\(\\lambda_n x_n \\to \\lambda x\\).</p> <p>Consider the difference:</p> \\[\\begin{aligned} \\|\\lambda_n x_n - \\lambda x\\| = \\|\\lambda_n x_n - \\lambda_n x + \\lambda_n x - \\lambda x\\| &amp;= \\|\\lambda_n(x_n - x) + (\\lambda_n - \\lambda)x\\|\\\\ &amp;\\le |\\lambda_n| \\|x_n - x\\| + |\\lambda_n - \\lambda| \\|x\\| \\end{aligned}\\] <p>Since the sequence \\(\\lambda_n\\) is convergent, it is bounded, so there exists \\(M &gt; 0\\) such that \\(|\\lambda_n| \\le M\\) for all \\(n\\).</p> \\[\\|\\lambda_n x_n - \\lambda x\\| \\le M \\|x_n - x\\| + |\\lambda_n - \\lambda| \\|x\\|\\] <p>As \\(n \\to \\infty\\), \\(\\|x_n - x\\| \\to 0\\) and \\(|\\lambda_n - \\lambda| \\to 0\\), so the entire expression converges to 0. Thus the norm topology is a vector topology.</p> <p>[!question] (3) Prove that the norm function is continuous with respect to the norm topology, that is, \\(x_n \\to x\\) in \\(E \\implies \\|x_n\\| \\to \\|x\\|\\) in \\(\\mathbb{R}\\).</p> <p>范数函数关于它所生成的拓扑是连续的，有点废话，实际上算是Lipschitz连续</p> <p><code>Proof.</code></p> <p>From the triangle inequality, we have \\(\\|x_n\\| = \\|x_n - x + x\\| \\le \\|x_n - x\\| + \\|x\\|\\), which implies \\(\\|x_n\\| - \\|x\\| \\le \\|x_n - x\\|\\). Similarly, \\(\\|x\\| = \\|x - x_n + x_n\\| \\le \\|x - x_n\\| + \\|x_n\\|\\), which implies \\(\\|x\\| - \\|x_n\\| \\le \\|x_n - x\\|\\). Combining these gives the reverse triangle inequality:</p> <p>\\(| \\|x_n\\| - \\|x\\| | \\le \\|x_n - x\\|\\)</p> <p>If \\(x_n \\to x\\) in \\(E\\), then by definition \\(\\|x_n - x\\| \\to 0\\). Therefore, \\(| \\|x_n\\| - \\|x\\| | \\to 0\\), which means \\(\\|x_n\\| \\to \\|x\\|\\) in \\(\\mathbb{R}\\).</p> <p>[!question] (4) Convergent sequence in a normed space is a bounded sequence.</p> <p>纯无聊，这是数学分析的定义问题</p> <p><code>Proof.</code></p> <p>Let \\((x_n)\\) be a convergent sequence in a normed space \\(E\\) with limit \\(x\\). By the definition of convergence, taking \\(\\epsilon = 1\\), there exists a natural number \\(N\\) such that for all \\(n &gt; N\\), \\(\\|x_n - x\\| &lt; 1\\). For these \\(n &gt; N\\), using the triangle inequality:</p> \\[\\|x_n\\| = \\|x_n - x + x\\| \\le \\|x_n - x\\| + \\|x\\| &lt; 1 + \\|x\\|\\] <p>Let \\(M = \\max\\{\\|x_1\\|, \\|x_2\\|, \\dots, \\|x_N\\|, 1 + \\|x\\|\\}\\). Then \\(\\|x_n\\| \\le M\\) for all \\(n \\in \\mathbb{N}\\). Thus, the sequence is bounded.</p> <p>[!question] (5) Let \\(E\\) be a normed space and \\(x_0, y_0\\) in \\(E\\) such that \\(\\|x_0 + y_0\\| = \\|x_0\\| + \\|y_0\\|\\). Prove that for all \\(\\lambda, \\mu \\ge 0\\), \\(\\|\\lambda x_0 + \\mu y_0\\| = \\lambda\\|x_0\\| + \\mu\\|y_0\\|\\).</p> <p>仍然非常简单</p> <p><code>Proof.</code></p> <p>不妨假设 \\(\\lambda \\le \\mu\\) (如果 \\(\\lambda &gt; \\mu\\)，则交换 \\(x_0\\) 和 \\(y_0\\) 的位置即可，证明是对称的)</p> \\[ \\begin{aligned} \\lVert \\lambda x_{0}+\\mu y_{0} \\rVert &amp; = \\lVert \\mu(x_{0}+y_{0})-(\\mu-\\lambda)x_{0} \\rVert \\\\ &amp;\\geqslant \\mu \\lVert x_{0}+y_{0} \\rVert -(\\mu-\\lambda) \\lVert x_{0} \\rVert\\\\ &amp;=\\mu \\lVert x_{0} \\rVert +\\mu \\lVert y_{0} \\rVert -(\\mu-\\lambda)\\lVert x_{0} \\rVert\\\\ &amp;=\\lambda \\lVert x_{0} \\rVert +\\mu \\lVert y_{0} \\rVert  \\end{aligned} \\] <p>Conversely, by the triangle inequality:</p> \\[\\|\\lambda x_0 + \\mu y_0\\| \\le \\|\\lambda x_0\\| + \\|\\mu y_0\\| = \\lambda \\|x_0\\| + \\mu \\|y_0\\|\\] <p>Since the quantity is bounded both above and below by \\(\\lambda \\|x_0\\| + \\mu \\|y_0\\|\\), equality holds.</p> <p>[!question] (6) Let \\(T\\) be a continuous one-to-one linear operator from a normed space \\(E_1\\) onto a normed space \\(E_2\\). Prove that \\(T^{-1}\\) is a linear operator. If \\(T^{-1}\\) is continuous then \\(T\\) is said to be a topological isomorphism from \\(E_1\\) onto \\(E_2\\); and \\(E_1\\) is said to be topologically isomorphic to \\(E_2\\). In this case, there exist positive numbers \\(\\alpha, \\beta &gt; 0\\) such that \\(\\alpha \\|x\\| \\le \\|Tx\\| \\le \\beta \\|x\\|\\).</p> <p>直接计算\\(T^{-1}\\)是线性的</p> <p><code>Proof.</code></p> <p>First, we prove \\(T^{-1}: E_2 \\to E_1\\) is linear. Let \\(u, v \\in E_2\\) and \\(k \\in \\mathbb{K}\\). Since \\(T\\) is onto, there exist unique \\(x, y \\in E_1\\) such that \\(Tx = u\\) and \\(Ty = v\\), implying \\(x = T^{-1}u\\) and \\(y = T^{-1}v\\). \\(T(x + y) = Tx + Ty = u + v\\). Applying \\(T^{-1}\\) to both sides: \\(T^{-1}(u + v) = x + y = T^{-1}u + T^{-1}v\\). Similarly, \\(T(kx) = kTx = ku\\). Applying \\(T^{-1}\\): \\(T^{-1}(ku) = kx = kT^{-1}u\\). Thus \\(T^{-1}\\) is linear.</p> <p>Now assume \\(T^{-1}\\) is continuous. Since \\(T\\) is a continuous linear operator, it is bounded. Thus, there exists \\(\\beta &gt; 0\\) such that \\(\\|Tx\\| \\le \\beta \\|x\\|\\) for all \\(x \\in E_1\\). This provides the upper bound. Since \\(T^{-1}\\) is a continuous linear operator, it is bounded. Thus there exists a constant \\(C &gt; 0\\) such that \\(\\|T^{-1}y\\| \\le C\\|y\\|\\) for all \\(y \\in E_2\\). Let \\(y = Tx\\). Then \\(\\|x\\| \\le C\\|Tx\\|\\). This implies \\(\\|Tx\\| \\ge \\frac{1}{C}\\|x\\|\\). Let \\(\\alpha = \\frac{1}{C}\\). Since \\(C &gt; 0\\), \\(\\alpha &gt; 0\\). Combining these inequalities, we get \\(\\alpha \\|x\\| \\le \\|Tx\\| \\le \\beta \\|x\\|\\).</p> <p>[!question] (7) Let \\(\\mathcal{P}\\) be the vector space of polynomials defined on \\([0, 1]\\). Since \\(\\mathcal{P}\\) is a linear subspace of \\(C[0, 1]\\), it has the sup-norm \\(\\|\\cdot\\|_\\infty\\). And since \\(\\mathcal{P}\\) is a linear subspace of \\(L^1[0, 1]\\), it has another norm \\(\\|\\cdot\\|_1\\). Show that \\(\\|\\cdot\\|_\\infty\\) and \\(\\|\\cdot\\|_1\\) are not equivalent on \\(\\mathcal{P}\\).</p> <p>直接反证法即可</p> <p><code>Proof.</code></p> <p>Suppose on the contrary that \\(\\|\\cdot\\|_\\infty\\) and \\(\\|\\cdot\\|_1\\) are equivalent. Then there exist positive numbers \\(\\alpha, \\beta &gt; 0\\) such that</p> \\[ \\alpha\\|f\\|_1 \\leq \\|f\\|_\\infty \\leq \\beta\\|f\\|_1, \\quad \\forall f \\in \\mathcal{P} \\] <p>Let \\(f_n\\) be the polynomial \\(f_n(t) = t^n\\) (\\(\\forall t \\in [0, 1]\\)). Then we have</p> \\[ \\|f_n\\|_\\infty = 1, \\quad \\|f_n\\|_1 = \\frac{1}{n+1}. \\] <p>On other hand, \\(\\|f_n\\|_1 \\geq \\frac{1}{\\beta}\\|f_n\\|_\\infty = \\frac{1}{\\beta}\\), which is a contradiction. </p> <p>[!question] (8) Let \\(a &gt; 0\\). On \\(C[0,1]\\), we consider two norms: \\(\\left\\Vert \\cdot \\right\\Vert_\\infty\\) and</p> \\[ \\left\\Vert f \\right\\Vert_0 = a \\int_0^1 |f(t)| dt, \\quad \\forall f \\in C[0,1]. \\] <p>Prove that \\(\\left\\Vert f \\right\\Vert = \\min\\{\\left\\Vert f \\right\\Vert_\\infty, \\left\\Vert f \\right\\Vert_0\\}\\) is a norm on \\(C[0,1]\\) if and only if \\(a \\leq 1\\).</p> <p><code>Proof.</code></p> <p>按照范数的定义验证:</p> <p>(1)非负性</p> <p>显然由于 \\(\\left\\Vert f \\right\\Vert_{\\infty}, \\left\\Vert f \\right\\Vert_{0} \\geq 0\\)，\\(\\left\\Vert f \\right\\Vert \\geq 0\\)，并且\\(\\left\\| f \\right\\|= \\min\\{\\left\\Vert f \\right\\Vert_\\infty, \\left\\Vert f \\right\\Vert_0\\} =0\\)当且仅当其中至少一个范数取\\(0\\)时成立，而根据范数的定义，此时\\(f=0\\)取等号。</p> <p>(2)齐次性</p> <p>对任意 \\(\\lambda \\in \\mathbb{R}\\)，有</p> \\[\\left\\Vert \\lambda f \\right\\Vert = \\min\\{\\left\\Vert \\lambda f \\right\\Vert_\\infty, \\left\\Vert \\lambda f \\right\\Vert_0\\} = |\\lambda| \\min\\{\\left\\Vert f \\right\\Vert_\\infty, \\left\\Vert f \\right\\Vert_0\\} = |\\lambda| \\left\\Vert f \\right\\Vert.\\] <p>(3)三角不等式</p> <p>充分性：当\\(a \\leq 1\\)时，有</p> <p>$\\(\\left\\Vert f \\right\\Vert_0 = a \\int_0^1 |f(t)| dt \\leq a \\cdot 1 \\cdot \\left\\Vert f \\right\\Vert_\\infty \\leq \\left\\Vert f \\right\\Vert_\\infty,\\)$      综上，有\\(\\left\\| f \\right\\| = \\min\\{\\left\\| f \\right\\|_\\infty, \\left\\| f \\right\\|_0\\} = \\left\\| f \\right\\|_0\\).</p> <p>必要性：考虑举反例，当\\(a &gt; 1\\)时， 取\\(f,g \\in C[0,1]\\)，定义如下(先列出，大小关系后续讨论)</p> \\[f(x)\\equiv \\varepsilon,\\forall x\\in[0,1]\\] <p>$$</p> <p>g(x)=\\left{ \\begin{matrix}</p> <p>&amp;n&amp;x=0 \\</p> <p>&amp;linear &amp; x\\in(0, \\frac{1}{n}) \\</p> <p>&amp;0&amp;x\\geq \\frac{1}{n}</p> <p>\\end{matrix} \\right.</p> <p>$$</p> <p>那么有\\(\\lVert f \\rVert=\\min\\left\\{ \\varepsilon,a\\varepsilon \\right\\}=\\varepsilon(a&gt;1),\\lVert g \\rVert=\\min\\left\\{ n, \\frac{a}{2} \\right\\}= \\frac{a}{2}\\)</p> <p>$$ \\lVert f+g \\rVert =\\min\\left{ n+\\varepsilon,a\\varepsilon+ \\frac{a}{2} \\right}= a\\varepsilon+ \\frac{a}{2} &gt;\\varepsilon+ \\frac{a}{2}=\\lVert f \\rVert +\\lVert g \\rVert</p> <p>$$</p> <p>综上需要满足不等式组：</p> <p>$$\\left{ \\begin{matrix}</p> <p>&amp;n &gt; \\frac{a}{2} \\</p> <p>&amp;n+\\varepsilon &gt; a\\varepsilon + \\frac{a}{2}</p> <p>\\end{matrix} \\right.</p> <p>$$</p> <p>直接取\\(n=4a,\\varepsilon =\\frac{1}{n}\\)即可满足上述不等式组(\\(4a+\\frac{1}{4a}&gt; \\frac{1}{4}+\\frac{a}{2}\\))，因此三角不等式不成立.</p> <p>[!question] (9) Let \\(1 &lt; p &lt; \\infty\\) and \\(G = \\{(\\xi_n)_{n \\in \\mathbb{N}} \\in \\ell_p : \\sum_{n=1}^\\infty \\xi_n = 0\\}\\). Prove that \\(G \\subseteq \\ell_p\\) is not closed.</p> <p><code>Proof.</code></p> <p>要证明 \\(G\\) 不闭，只需找到一个序列 \\(\\{x^{(k)}\\} \\subset G\\)，使得它在 \\(\\ell_p\\) 范数下收敛于某个元素 \\(x\\)，但 \\(x \\notin G\\)。 考虑 \\(\\ell_p\\) 中的元素 \\(e_1 = (1, 0, 0, \\dots)\\)。显然 \\(\\sum_{n=1}^\\infty (e_1)_n = 1 \\neq 0\\)，所以 \\(e_1 \\notin G\\)。</p> <p>我们构造序列 \\(x^{(k)} \\in \\ell_p\\) 如下：</p> \\[x^{(k)} = (1, \\underbrace{-\\frac{1}{k}, -\\frac{1}{k}, \\dots, -\\frac{1}{k}}_{k \\text{ 个}}, 0, 0, \\dots)\\] <p>也就是说，第 1 项是 1，第 2 到 \\(k+1\\) 项是 \\(-1/k\\)，其余项为 0。验证 \\(x^{(k)} \\in G\\)：</p> \\[\\sum_{n=1}^\\infty x^{(k)}_n = 1 + \\sum_{j=1}^k (-\\frac{1}{k}) = 1 - 1 = 0\\] <p>所以 \\(x^{(k)} \\in G\\)。现在计算 \\(\\|x^{(k)} - e_1\\|_p\\)：\\(x^{(k)} - e_1 = (0, -\\frac{1}{k}, \\dots, -\\frac{1}{k}, 0, \\dots)\\)</p> \\[\\|x^{(k)} - e_1\\|_p = \\left( \\sum_{j=1}^k \\left| -\\frac{1}{k} \\right|^p \\right)^{1/p} = \\left( k \\cdot \\frac{1}{k^p} \\right)^{1/p} = (k^{1-p})^{1/p} = k^{\\frac{1}{p} - 1}\\] <p>由于 \\(1 &lt; p &lt; \\infty\\)，所以 \\(\\frac{1}{p} - 1 &lt; 0\\)。因此，当 \\(k \\to \\infty\\) 时，\\(\\|x^{(k)} - e_1\\|_p \\to 0\\)。这说明 \\(e_1\\) 是 \\(G\\) 的一个极限点，但 \\(e_1 \\notin G\\)。因此 \\(G\\) 不是闭集。</p> <p>[!question] (10) Is the set of all polynomials open in \\(C[-1, 1]\\)?</p> <p><code>Sol.</code></p> <p>不是。设 \\(P\\) 是 \\(C[-1, 1]\\) 中所有多项式构成的集合。\\(P\\) 是 \\(C[-1, 1]\\) 的一个真子空间（根据魏尔斯特拉斯逼近定理，\\(P\\) 在 \\(C[-1, 1]\\) 中稠密，但也存在非多项式的连续函数，例如 \\(f(x) = |x|\\) 或 \\(e^{|x|}\\)，故 \\(P \\neq C[-1, 1]\\)）。如果在赋范空间中一个线性子空间是开集，那么它必须包含一个原点的邻域（开球）。根据第 (11) 题的结论，任何包含开球的线性子空间必然是整个空间。由于 \\(P \\neq C[-1, 1]\\)，所以 \\(P\\) 不包含任何开球，因此 \\(P\\) 不是开集。事实上，真子空间的内部一定是空集。</p> <p>[!question] (11) Let \\(E\\) be normed space. Find all linear subspaces \\(E_0 \\subseteq E\\) which contain a ball.</p> <p>主要是说这件事：任何包含开球的线性子空间必然是整个空间</p> <p><code>Sol.</code></p> <p>唯一的这样的子空间是 \\(E\\) 本身（即 \\(E_0 = E\\)）</p> <p>证明如下：</p> <p>假设 \\(E_0\\) 是 \\(E\\) 的线性子空间，且包含一个开球 \\(B(x_0, r) = \\{x \\in E : \\|x - x_0\\| &lt; r\\} \\subseteq E_0\\)。由于 \\(E_0\\) 是子空间，它包含 \\(-x_0\\)。根据子空间的加法封闭性，对于任意 \\(z \\in B(x_0, r)\\)，有 \\(z - x_0 \\in E_0\\)。注意到 \\(B(x_0, r) - x_0 = B(0, r)\\)。这意味着原点周围的开球 \\(B(0, r) = \\{y \\in E : \\|y\\| &lt; r\\}\\) 包含在 \\(E_0\\) 中。</p> <p>对于 \\(E\\) 中任意非零元素 \\(x \\in E\\)，我们可以对其进行缩放：令 \\(y = \\frac{r}{2\\|x\\|} x\\)。显然 \\(\\|y\\| = \\frac{r}{2\\|x\\|} \\|x\\| = \\frac{r}{2} &lt; r\\)，所以 \\(y \\in B(0, r) \\subseteq E_0\\)。由于 \\(E_0\\) 是线性空间，它对数乘封闭，所以 \\(x = \\frac{2\\|x\\|}{r} y\\) 必定也属于 \\(E_0\\)。对于 \\(x=0\\)，显然 \\(0 \\in E_0\\)。因此，对于任意 \\(x \\in E\\)，都有 \\(x \\in E_0\\)，即 \\(E \\subseteq E_0\\)。综上所述，\\(E_0 = E\\)。</p> <p>[!question] (12) Given any \\(1 &lt; p &lt; \\infty\\), find an element \\(a\\) such that \\(a \\in \\ell_p\\) but \\(a \\notin \\ell_q\\) for all \\(1 \\le q \\le p\\).</p> <p>解答： 题目中要求 \\(a \\notin \\ell_q\\) for all \\(1 \\le q \\le p\\) 包含 \\(q=p\\) 的情况，这是不可能的，因为若 \\(a \\in \\ell_p\\)，则 \\(a\\) 必然属于 \\(\\ell_p\\)。推测题目意图是寻找 \\(a \\in \\ell_p\\) 但对于所有 \\(1 \\le q &lt; p\\)，\\(a \\notin \\ell_q\\)。 构造如下元素 \\(a = (a_n)_{n \\in \\mathbb{N}}\\)： 令 \\(a_n = \\frac{1}{n^{1/p} (\\ln(n+1))^{2/p}}\\)。 1. 验证 \\(a \\in \\ell_p\\)： \\(\\sum_{n=1}^\\infty |a_n|^p = \\sum_{n=1}^\\infty \\frac{1}{n (\\ln(n+1))^2}\\)。 由于积分 \\(\\int_1^\\infty \\frac{dx}{x (\\ln x)^2}\\) 收敛，该级数收敛。所以 \\(a \\in \\ell_p\\)。 2. 验证对于 \\(1 \\le q &lt; p\\)，有 \\(a \\notin \\ell_q\\)： 考虑 \\(|a_n|^q = \\frac{1}{n^{q/p} (\\ln(n+1))^{2q/p}}\\)。 由于 \\(q &lt; p\\)，则指数 \\(\\alpha = q/p &lt; 1\\)。 对于级数 \\(\\sum \\frac{1}{n^\\alpha (\\ln n)^\\beta}\\)，当 \\(\\alpha &lt; 1\\) 时，无论 \\(\\beta\\) 为何值，级数均发散（与 \\(1/n\\) 比较，分子项趋于无穷或分母增长慢于 \\(n\\)）。 具体来说，由于 \\(q/p &lt; 1\\)，当 \\(n\\) 充分大时，\\(\\frac{1}{n^{q/p} (\\ln(n+1))^{2q/p}} &gt; \\frac{1}{n}\\)。 由调和级数发散可知 \\(\\sum |a_n|^q\\) 发散。 因此，该元素 \\(a\\) 满足条件（在 \\(q &lt; p\\) 的修正理解下）。</p> <p>[!question] (13) Show that if \\((E, \\|\\cdot\\|_E)\\) is a normed space, \\(W\\) is a vector space and \\(T: W \\to E\\) is a linear bijection, then</p> \\[ \\|x\\|_W := \\|Tx\\|_E, \\quad \\forall x \\in W \\] <p>defines a norm on \\(W\\).</p> <p>解答： 我们需要验证 \\(\\|\\cdot\\|_W\\) 满足范数的三条公理： 1. 非负性与正定性： 对于任意 \\(x \\in W\\)，\\(\\|x\\|_W = \\|Tx\\|_E \\ge 0\\)（因为 \\(\\|\\cdot\\|_E\\) 是范数）。 若 \\(\\|x\\|_W = 0\\)，则 \\(\\|Tx\\|_E = 0\\)。由 \\(\\|\\cdot\\|_E\\) 的正定性可知 \\(Tx = 0_E\\)。由于 \\(T\\) 是双射（特别是单射），\\(Tx = 0 \\implies x = 0_W\\)。 2. 齐次性： 对于任意 \\(x \\in W\\) 和标量 \\(\\lambda\\)， \\(\\|\\lambda x\\|_W = \\|T(\\lambda x)\\|_E\\)。 由 \\(T\\) 的线性性，\\(T(\\lambda x) = \\lambda Tx\\)。 所以 \\(\\|\\lambda x\\|_W = \\|\\lambda Tx\\|_E = |\\lambda| \\|Tx\\|_E = |\\lambda| \\|x\\|_W\\)。 3. 三角不等式： 对于任意 \\(x, y \\in W\\)， \\(\\|x + y\\|_W = \\|T(x + y)\\|_E\\)。 由 \\(T\\) 的线性性，\\(T(x + y) = Tx + Ty\\)。 利用 \\(\\|\\cdot\\|_E\\) 的三角不等式： \\(\\|Tx + Ty\\|_E \\le \\|Tx\\|_E + \\|Ty\\|_E = \\|x\\|_W + \\|y\\|_W\\)。 即 \\(\\|x+y\\|_W \\le \\|x\\|_W + \\|y\\|_W\\)。 综上，\\(\\|\\cdot\\|_W\\) 定义了 \\(W\\) 上的一个范数。</p> <p>[!question] (14) Suppose that \\(U\\) is an open subspace of a normed space \\(E\\), show that \\(U = E\\).</p> <p>(11)题的变式</p> <p><code>Proof.</code></p> <p>因为 \\(U\\) 是 \\(E\\) 的子空间，所以 \\(0 \\in U\\)。因为 \\(U\\) 是开集，所以存在一个 \\(r &gt; 0\\) 使得原点的开球 \\(B(0, r) \\subset U\\)。这意味着 \\(U\\) 是一个包含球的线性子空间。直接引用第 (11) 题的结论，任何包含球的线性子空间必定等于整个空间。所以 \\(U = E\\)。</p> <p>[!question] (15) If \\(E\\) is a normed space and \\(M\\) is a closed linear subspace of \\(E\\), show that</p> \\[ \\|[x]\\|_{E/M} = \\inf_{u \\in M} \\|x + u\\| \\] <p>defines a norm on the quotient space \\(E/M\\).</p> <p>解答：</p> <p>我们需要验证商范数的三条公理：</p> <ol> <li>非负性与正定性：</li> </ol> <p>显然 \\(\\|[x]\\|_{E/M} = \\inf_{u \\in M} \\|x+u\\| \\ge 0\\)。 若 \\([x] = [0]\\)（即 \\(x \\in M\\)），则取 \\(u = -x \\in M\\)，得 \\(\\|x+u\\| = 0\\)，故范数为 0。 反之，若 \\(\\|[x]\\|_{E/M} = 0\\)，即 \\(\\inf_{u \\in M} \\|x+u\\| = 0\\)。这意味着存在序列 \\(\\{u_n\\} \\subset M\\) 使得 \\(\\|x - (-u_n)\\| \\to 0\\)。这表明 \\(x\\) 是 \\(M\\) 的一个极限点。因为 \\(M\\) 是闭子空间，所以 \\(x \\in M\\)，即 \\([x] = [0]\\)。</p> <ol> <li>齐次性：</li> </ol> <p>对于 \\(\\lambda \\neq 0\\)： \\(\\|[\\lambda x]\\| = \\inf_{u \\in M} \\|\\lambda x + u\\| = \\inf_{u \\in M} \\|\\lambda (x + \\frac{u}{\\lambda})\\|\\)。 令 \\(v = u/\\lambda\\)。当 \\(u\\) 遍历 \\(M\\) 时，由于 \\(M\\) 是子空间，\\(v\\) 也遍历 \\(M\\)。 \\(= \\inf_{v \\in M} |\\lambda| \\|x + v\\| = |\\lambda| \\inf_{v \\in M} \\|x + v\\| = |\\lambda| \\|[x]\\|\\)。 对于 \\(\\lambda = 0\\)，等式显然成立。</p> <ol> <li>三角不等式：</li> </ol> <p>设 \\([x], [y] \\in E/M\\)。 \\(\\|[x+y]\\| = \\inf_{w \\in M} \\|x + y + w\\|\\)。 对于任意 \\(\\epsilon &gt; 0\\)，根据下确界定义，存在 \\(u \\in M\\) 和 \\(v \\in M\\) 使得： \\(\\|x+u\\| &lt; \\|[x]\\| + \\epsilon/2\\) 且 \\(\\|y+v\\| &lt; \\|[y]\\| + \\epsilon/2\\)。 令 \\(w = u + v\\)，则 \\(w \\in M\\)。 \\(\\|[x+y]\\| \\le \\|x + y + u + v\\| \\le \\|x+u\\| + \\|y+v\\| &lt; \\|[x]\\| + \\|[y]\\| + \\epsilon\\)。 由于 \\(\\epsilon\\) 是任意的，所以 \\(\\|[x+y]\\| \\le \\|[x]\\| + \\|[y]\\|\\)。 综上，定义的是一个范数。</p>","path":["Banach Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Banach%20Spaces/#banach-spaces_1","level":2,"title":"Banach spaces","text":"<p>主要知道Cauchy列和Banach空间是什么就可以了</p> <p>[!abstract] Definition: 柯西列与 Banach 空间</p> <p>柯西列 (Cauchy Sequence) 设 \\((x_n)\\) 是赋范空间 \\(E\\) 中的一个序列。如果对于任意给定的 \\(\\varepsilon &gt; 0\\)，都存在一个正整数 \\(N\\)，使得当 \\(m, n &gt; N\\) 时，都有 \\(\\|x_m - x_n\\| &lt; \\varepsilon\\)，则称该序列为柯西列。</p> <p>Banach 空间 (Banach Space) 如果赋范空间 \\(E\\) 中的每一个柯西列都收敛于 \\(E\\) 中的某一点（即空间是完备的），则称 \\(E\\) 为 Banach 空间。</p> <p>[!example] Example 2.2.2: 柯西列不一定收敛 (反例) 这是一个非常经典的例子，说明完备性不是理所当然的。</p> <p>考虑空间 \\(C[0,1]\\)（闭区间上的连续函数），装备 \\(1\\)-范数 \\(\\|f\\|_1 = \\int_0^1 |f(t)| dt\\)。</p> <p>我们构造一个序列 \\((f_n)_{n \\ge 2}\\)，图形上看，它是一个在 \\(t=1/2\\) 处越来越陡峭的折线： $$ f_n(t) = \\begin{cases}  0, &amp; 0 \\le t \\le \\frac{1}{2} - \\frac{1}{n} \\ 1 - n(\\frac{1}{2} - t), &amp; \\frac{1}{2} - \\frac{1}{n} \\le t \\le \\frac{1}{2} \\ 1, &amp; \\frac{1}{2} &lt; t \\le 1 \\end{cases} $$</p> <ol> <li>它是柯西列</li> </ol> <p>对于 \\(n &gt; m \\ge 2\\)，函数 \\(f_n\\) 和 \\(f_m\\) 的差异仅存在于区间 \\([\\frac{1}{2} - \\frac{1}{m}, \\frac{1}{2}]\\) 上。直接计算积分：  $$ |f_n - f_m|1 = \\int_0^1 |f_n(t) - f_m(t)| dt = \\int $$ 当 }{2}-\\frac{1}{m}}^{\\frac{1}{2}} |f_n(t) - f_m(t)| dt \\le \\frac{1}{m\\(m \\to \\infty\\) 时，该值趋于 0，因此它是 \\(1\\)-范数下的柯西列。</p> <ol> <li>它在空间中不收敛</li> </ol> <p>假设该序列在 \\(C[0,1]\\) 中收敛于某个连续函数 \\(f\\)。通过对误差 \\(\\|f_n - f\\|_1\\) 的分析，令 \\(n \\to \\infty\\)，我们发现极限函数必须几乎处处满足：</p> \\[ f(t) = \\begin{cases} 0, &amp; 0 \\le t &lt; 1/2 \\\\ 1, &amp; 1/2 \\le t \\le 1 \\end{cases} \\] <p>这是一个阶跃函数，显然是不连续的。因此极限 \\(f \\notin C[0,1]\\)。</p> <p>结论：\\((C[0,1], \\|\\cdot\\|_1)\\) 不是 Banach 空间。</p> <p>注：如果换成上确界范数 \\(\\|\\cdot\\|_\\infty\\)，它就是 Banach 空间，因为一致极限保持连续性</p> <p>[!example] 一个基本且重要的练习(Example 2.2.7) If \\(1\\leqslant p \\leqslant \\infty\\), then \\(l^{p}\\), \\(L^{p}[a,b]\\) are Banach spaces under the corresponding \\(p-\\)norms \\(\\lVert \\cdot \\rVert _p\\) for \\(1\\leqslant p\\leqslant \\infty\\)</p> <p><code>Proof.</code></p> <p>(a)If \\(1\\leqslant p &lt;\\infty\\), \\(l^{p}\\) is a Banach space</p> <p>For any Cauchy sequence, \\(x_{n}=(\\xi_{k}^{(n)})_{k=1}^{\\infty}\\in l^{p}\\)</p> <p>By definition, we have \\(\\forall\\varepsilon&gt;0,\\exists N\\) if \\(m,n&gt;N,\\lvert x_{m}-x_{n} \\rvert=\\left( \\sum\\limits_{k=1}^{\\infty}\\lvert \\xi_{k}^{(n)}-\\xi_{k}^{(m)} \\rvert^{p} \\right) ^{\\frac{1}{p}}&lt;\\varepsilon\\)</p> <p>We can use the convergence that \\((\\xi_{k}^{(n)})_{n\\in \\mathbb{N}}\\implies \\xi_{k}\\)</p> \\[ \\left( \\sum\\limits_{k=1}^{k_{0}} \\lvert \\xi_{k}^{(n)}-\\xi_{k}^{(m)} \\rvert ^{p} \\right)^{\\frac{1}{p}}&lt;\\varepsilon,\\forall n,m\\geqslant N \\] <p>Just let \\(m\\to \\infty\\), we get</p> \\[ \\left( \\sum\\limits_{k=1}^{k_{0}} \\lvert \\xi_{k}^{(n)}-\\xi_{k} \\rvert ^{p} \\right)^{\\frac{1}{p}}\\leqslant\\varepsilon,\\forall n\\geqslant N,\\forall k_{0}\\in \\mathbb{N} \\] <p>Put \\(x=(\\xi_{k})_{k\\in \\mathbb{N}}\\), we derive that</p> \\[ \\begin{aligned} \\left( \\sum\\limits_{k=1}^{k_{0}} \\lvert \\xi_{k} \\rvert ^{p} \\right)^{\\frac{1}{p}}&amp;\\leqslant \\left( \\sum\\limits_{k=1}^{k_{0}} \\lvert \\xi_{k}-\\xi_{k}^{(N)} \\rvert ^{p} \\right)^{\\frac{1}{p}}+\\left( \\sum\\limits_{k=1}^{k_{0}} \\lvert \\xi_{k}^{(N)} \\rvert ^{p} \\right)^{\\frac{1}{p}}&lt;\\varepsilon+\\lVert X_{N} \\rVert _{p}&lt;+\\infty\\\\ \\lVert x \\rVert _{p}&amp;\\leqslant \\varepsilon+\\lVert x_{N} \\rVert _{p} \\end{aligned} \\] <p>(b)Similarly, we can prove that \\(l_{\\infty}\\) is a Banach space</p> <p>Now turn to \\(L^{p}\\) space</p> <p>(c)\\(L^{p}[a,b]\\) is a Banach space when \\(1\\leqslant p &lt;\\infty\\)</p> <p>Let \\((f_{n})_{n\\in \\mathbb{N}}\\) be any Cauchy sequence in \\(L^{p}[a,b]\\). For any \\(\\varepsilon&gt;0\\), there exists \\(N\\in \\mathbb{N}\\) s.t.</p> \\[ \\lVert f_{n}-f_{m} \\rVert _{p}&lt;\\varepsilon,\\forall n,m\\geqslant N \\] <p>Obviously, we can choose a subsequence \\((f_{n_{k}})_{k\\in \\mathbb{N}}\\) s.t.</p> \\[ \\lVert f_{n_{k+1}}-f_{n_{k}} \\rVert _{p}&lt; \\frac{1}{2^{k}},\\forall k\\in \\mathbb{N} \\] <p>So we can naturally get \\(\\sum\\limits_{k=1}^{\\infty}\\lVert f_{n_{k+1}}-f_{n_{k}} \\rVert &lt; 1\\), let</p> \\[ g_{m}(t)=\\lvert f_{n_{1}} (t)\\rvert + \\sum\\limits_{k=1}^{m} \\lvert f_{n_{k+1}}(t)-f_{n_{k}}(t) \\rvert ,\\forall t\\in[a,b]  \\] <p>So</p> \\[ \\begin{aligned} \\lVert g_{m} \\rVert _{p}&amp;\\leqslant \\lVert f_{n_{1}} \\rVert _{p}+\\sum\\limits_{k=1}^{m} \\lVert f_{n_{k+1}}-f_{n_{k}} \\rVert _{p}\\\\ &amp;&lt;\\lVert f_{n_{1}} \\rVert _{p}+1,\\forall m= 1,2\\dots \\end{aligned} \\] <p>Note \\(g_{m}(t)\\) is positive and increasing, let \\(g_{0}(t)=\\lim\\limits_{ m \\to \\infty }g_{m}(t)\\)</p> \\[ \\begin{aligned} \\int_{a}^{b}\\lvert g_{0} \\rvert ^{p}  \\, dt &amp;=\\int_{a}^{b} \\mathop{\\lim \\inf }\\limits_{m\\to \\infty }\\lvert g_{m} \\rvert ^{p}\\, dt\\\\ &amp;\\leqslant \\mathop{\\lim\\inf}\\limits_{m\\to \\infty}\\int_{a}^{b} \\lvert g_{m} \\rvert ^{p} \\, dt\\\\ &amp;=\\lim\\limits_{ m \\to \\infty } \\lVert g_{m} \\rVert _{p}^{p}\\\\ &amp;\\leqslant (\\lVert f_{n_{1}} \\rVert _{p}+1)^{p} \\end{aligned} \\] <p>So \\(g_{0}\\in L^{p}[a,b]\\) and</p> \\[ g_{0}(t)=\\lvert f_{n_{1}}(t) \\rvert+\\sum\\limits_{k=1}^{\\infty} \\lvert f_{n_{k+1}}(t)-f_{n_{k}}(t) \\rvert   \\] <p>converges to a finite positive number a.e. on \\([a,b]\\), therefore the series</p> <p>$$ f(t):= f_{n_{1}}(t)+\\sum\\limits_{k=1}^{\\infty} \\lvert f_{n_{k+1}}(t)-f_{n_{k}}(t) \\rvert $$ converges to a finite(real or complex) number a.e. on \\([a,b]\\). And \\(\\lvert f \\rvert \\leqslant g_{0}\\), we have \\(f\\in L^{p}[a,b]\\). It follows from</p> \\[ \\begin{aligned} \\lVert f-f_{n_{m}} \\rVert _{p}&amp;=\\left\\lVert  f-\\left( f_{n_{1}}+\\sum\\limits_{k=1}^{m} (f_{n_{k+1}}-f_{n_{k}}) \\right)  \\right\\rVert _{p}\\\\ &amp;=\\left\\lVert  \\sum\\limits_{k=m+1}^{\\infty} (f_{n_{k+1}}-f_{n_{k}})  \\right\\rVert _{p}\\\\ &amp;\\leqslant   \\sum\\limits_{k=m+1}^{\\infty} \\left\\lVert(f_{n_{k+1}}-f_{n_{k}})  \\right\\rVert _{p}\\\\ &amp;\\leqslant \\frac{1}{2^{m}} \\end{aligned} \\] <p>that \\(f_{n_{m}}\\to f\\)</p> <p>(d)\\(L^{\\infty}[a,b]\\) is a Banach space</p> <p>Suppose that \\((f_n)_{n\\in\\mathbb{N}}\\) is a Cauchy sequence in \\(L^\\infty[a,b]\\). For any \\(k \\in \\mathbb{N}\\), there exists \\(N_k &gt; 0\\) such that</p> \\[ \\|f_n - f_m\\| &lt; \\frac{1}{k}, \\quad \\forall n, m \\ge N_k. \\] <p>We can find a measurable subset \\(E_k\\) of zero measure such that</p> \\[ \\sup_{[a,b]\\setminus E_k} |f_m(t) - f_n(t)| &lt; \\frac{1}{k}, \\quad \\forall n, m \\ge N_k. \\quad (2.5) \\] <p>Let \\(E = \\bigcup_{k=1}^\\infty E_k\\), which has zero measure. We have</p> \\[ |f_m(t) - f_n(t)| \\to 0 \\quad \\text{uniformly for all } t \\in [a,b] \\setminus E. \\] <p>By the completeness of \\(\\mathbb{K}\\), the limit \\(f(t) = \\lim_n f_n(t)\\) exists for all \\(t \\in [a,b] \\setminus E\\). Setting \\(f = 0\\) on \\(E\\), we see that \\(f_n(t) \\to f(t)\\) a.e. on \\([a,b]\\), and thus \\(f\\) is measurable. Letting \\(m \\to \\infty\\) in (2.5), we have</p> \\[ \\sup_{[a,b]\\setminus E_k} |f(t) - f_n(t)| \\le \\frac{1}{k}, \\quad \\forall n \\ge N_k, \\quad (2.6) \\] <p>which shows that \\(f - f_n \\in L^\\infty[a,b]\\) for any \\(n \\ge N_k\\). Consequently, \\(f \\in L^\\infty[a,b]\\). It follows from (2.6) that</p> \\[ \\|f(t) - f_n(t)\\|_\\infty \\le \\frac{1}{k}, \\quad \\forall n \\ge N_k, \\] <p>which proves that \\(f = \\lim_n f_n\\) in \\(L^\\infty[a,b]\\). </p> <p>[!abstract] Proposition 2.2.5: 维数与完备性的关系</p> <p>定理：不存在具有可数维数（指 Hamel 基是可数的）的无限维 Banach 空间</p> <p>证明逻辑：</p> <p>假设空间 \\(E\\) 有可数基 \\(\\{x_1, x_2, \\dots\\}\\)，定义有限维闭子空间 \\(E_n = \\text{span}\\{x_1, \\dots, x_n\\}\\)</p> <p>显然 \\(E = \\bigcup_{n=1}^\\infty E_n\\)。根据 Baire Category Theorem（贝尔纲定理），Banach 空间不能写成可数个无处稠密集合的并。因此，至少有一个 \\(E_{n_0}\\) 包含一个开球。线性子空间如果包含开球，它必须等于整个空间。即 \\(E = E_{n_0}\\)。这推导出 \\(E\\) 是有限维的，产生矛盾。</p> <p>推论 (Example 2.2.6)： *   \\(c_{00}\\)（有限支集序列）有可数基，所以它不是 Banach 空间。 *   \\(P[a,b]\\)（多项式空间）有可数基，所以它也不是 Banach 空间。</p> <p>[!info] Finite Dimensional Spaces (有限维相关性质)</p> <p>Proposition 2.2.9：每一个有限维赋范空间都是完备的 *   因为有限维空间同构于 \\(\\mathbb{K}^n\\)，而欧几里得空间是完备的</p> <p>Proposition 2.2.10：赋范空间的每一个有限维子空间都是闭的 *   有限维子空间自身是完备的，完备子空间在 Hausdorff 空间中必然是闭集</p> <p>[!example] 反例 *   多项式空间 \\(P\\) 在 \\(C[0,1]\\) 中不是闭的（因为根据 Weierstrass 定理，多项式可以逼近非多项式的连续函数，如 \\(e^t\\)） *   \\(c_{00}\\) 在 \\(\\ell_\\infty\\) 中不是闭的（可以逼近无限项非零的序列，如 \\(1, 1/2, 1/3 \\dots\\)）</p>","path":["Banach Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Banach%20Spaces/#exercises-22","level":2,"title":"Exercises 2.2","text":"<p>[!question] HW2-1 Let \\(P\\) be the vector space of polynomials definded on \\([0,1]\\). It has two norms \\(\\lVert \\cdot \\rVert_{\\infty}\\)​ and \\(\\lVert \\cdot \\rVert_{1}\\)​ . Show that the two norms are not equivalent.</p> <p><code>Proof.</code></p> <p>只需要找到一个反例多项式函数\\(f\\)使得\\(\\lVert f \\rVert_{\\infty}\\leqslant C\\lVert f \\rVert_{1}\\)不成立即可</p> <p>不妨设\\(f(x)=x^{n}\\)</p> <p>那么有\\(\\lVert f \\rVert_{\\infty}=\\max\\limits_{x\\in[0,1]}\\lvert f(x) \\rvert=1,\\lVert f \\rVert_{1}=\\int_{0}^{1} \\lvert f(x) \\rvert \\, dx= \\frac{1}{n+1}\\)</p> <p>对于任意的固定常数\\(C\\)，总有\\(n+1&gt;C\\)时使得\\(\\lVert f \\rVert_{\\infty}\\leqslant C\\lVert f \\rVert_{1}\\)不成立，因此两个范数显然不等价</p> <p>[!question] HW2-2 If \\((E,\\lVert \\cdot \\rVert _{E}​)\\) is a normed space, \\(W\\) is a vector space and \\(T:W\\to E\\) is a linear bijection, then</p> \\[\\lVert x \\rVert _{W}=\\lVert Tx \\rVert _{E}\\] <p>define a norm on \\(W\\)</p> <p>题目应当是验证这是一个范数，我们按照定义验证三条性质：</p> <p>(1)正定性</p> \\[ 0=\\lVert x \\rVert _{W}=\\lVert Tx \\rVert _{E}\\implies Tx=0\\implies x=0 \\] <p>后一个推论是因为\\(T\\)是一个双射，并且\\(\\lVert x \\rVert_{W}=\\lVert Tx \\rVert_{E}\\geqslant 0\\)</p> <p>(2)正齐次性</p> \\[ \\lVert ax \\rVert _{W}=\\lVert T(ax) \\rVert _{E}=\\lvert a \\rvert \\lVert Tx \\rVert _{E}=\\lvert a \\rvert \\lVert x \\rVert _{W} \\] <p>(3)三角不等式</p> \\[ \\begin{aligned} \\lVert x+y \\rVert _{W}&amp;=\\lVert T(x+y) \\rVert _{E}=\\lVert Tx+Ty \\rVert _{E}\\\\ &amp;\\leqslant\\lVert Tx \\rVert _{E}+\\lVert Ty \\rVert _{E}\\\\ &amp;=\\lVert x \\rVert _{W}+\\lVert y \\rVert _{W} \\end{aligned} \\] <p>前两个小节实际上只是讲述了基本的Banach空间的定义和一些基本内容的回顾，下面两个小节则是正式开始围绕Banach空间的性质进行讨论：可分性和完备性、紧性</p>","path":["Banach Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Banach%20Spaces/#seperable-banach-spaces","level":2,"title":"Seperable Banach spaces","text":"","path":["Banach Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Banach%20Spaces/#separability","level":3,"title":"可分性 (Separability)","text":"<p>[!NOTE] Definition 2.3.1 (可分性 / Separability) 一个赋范空间 \\(E\\) 被称为 可分的 (separable)，如果它包含一个可数的 (countable) 且在范数意义下稠密的 (dense) 子集 \\(M\\)。否则，\\(E\\) 被称为 不可分的。</p> <ul> <li>直观理解：如果一个空间是可分的，说明空间中的任意元素都可以被一个（固定的）可数集中的元素以任意精度逼近。</li> </ul> <p>[!example] 常见 Banach 空间的可分性判定</p> 空间 可分性 稠密子集构造思路 / 不可分理由 \\(c_0\\) ✅ 可分 具有有理数坐标的有限项序列（尾部为0）。 \\(c\\) ✅ 可分 最终常数为有理数，且前有限项为有理数的序列。 \\(C[a,b]\\) ✅ 可分 有理系数多项式集合 (Weierstrass 逼近定理)。 \\(\\ell^p\\) \\((1 \\le p &lt; \\infty)\\) ✅ 可分 具有有理数坐标的有限项序列（尾部为0）。 \\(L^p[a,b]\\) \\((1 \\le p &lt; \\infty)\\) ✅ 可分 有理系数多项式集合（经过三步逼近）。 \\(\\ell^\\infty\\) ❌ 不可分 存在不可数个彼此距离为 1 的点（0-1序列）。 \\(L^\\infty[a,b]\\) ❌ 不可分 存在不可数个彼此距离为 1 的函数（特征函数）。 <p>[!summary] 证明思路归纳 (Proof Sketches)</p> <p>1. 序列空间与有限逼近 (\\(c, c_0, \\ell^p\\)) *   核心思想：截断 + 有理化。 *   逻辑：对于收敛序列或 \\(p\\)-级数收敛的序列，其“尾部”趋于 0。先将无穷项截断为有限项 \\(N\\)，再将这有限项坐标用有理数 \\(r_i\\) 逼近。 *   构造：\\(M = \\{(r_1, \\dots, r_N, 0, \\dots) : r_i \\in \\mathbb{Q}\\}\\)。</p> <p>2. 函数空间与多项式逼近 (\\(C[a,b], L^p\\)) *   \\(C[a,b]\\)：直接利用 Weierstrass 逼近定理，有理系数多项式在一致范数下稠密。 *   \\(L^p[a,b]\\)：采用三步逼近法：    1.  \\(L^p\\) 函数 \\(\\xrightarrow{截断}\\) 有界且支集有限的函数。    2.  有界可测函数 \\(\\xrightarrow{Lusin定理}\\) 连续函数。    3.  连续函数 \\(\\xrightarrow{Weierstrass}\\) 有理系数多项式。</p> <p>3. 不可分的计数反例 (\\(\\ell^\\infty, L^\\infty\\)) *   核心思想：构造一个不可数集，其中任意两点距离 \\(\\ge 1\\)。 *   \\(\\ell^\\infty\\)：取 \\(A = \\{ (\\xi_n) : \\xi_n \\in \\{0, 1\\} \\}\\)（不可数）。对于 \\(x \\neq y \\in A\\)，\\(\\|x-y\\|_\\infty = 1\\)。 *   \\(L^\\infty[a,b]\\)：取特征函数系 \\(\\{\\mathbf{1}_{[a, t]} : t \\in [a, b]\\}\\)（不可数）。对于 \\(t \\neq s\\)，\\(\\|\\mathbf{1}_{[a, t]} - \\mathbf{1}_{[a, s]}\\|_\\infty = 1\\)。 *   推论：若存在稠密子集，则在以这些点为心、半径为 \\(1/3\\) 的互不相交的球中，每个球里至少要有一个稠密集的点。球不可数 \\(\\implies\\) 稠密集不可数。</p> <p>[!NOTE] Definition 2.3.3 (Schauder 基) 设 \\((e_n)_{n \\in \\mathbb{N}}\\) 是 Banach 空间 \\(E\\) 中的单位向量序列（\\(\\|e_n\\|=1\\)）。如果对于 \\(E\\) 中的任意元素 \\(x\\)，都存在唯一的标量序列 \\(\\alpha_n\\) 使得：</p> \\[ x = \\sum_{n=1}^\\infty \\alpha_n e_n \\quad (\\text{即 } \\lim_{n\\to\\infty} \\left\\|x - \\sum_{i=1}^n \\alpha_i e_i\\right\\| = 0) \\] <p>则称 \\((e_n)\\) 为 \\(E\\) 的一个 Schauder 基。显然，Schauder 基是线性无关的。</p> <p>[!tip] Theorem 2.3.4 (Schauder 基与可分性) 如果一个 Banach 空间 \\(E\\) 拥有 Schauder 基，则 \\(E\\) 是可分的。</p> <p><code>Proof Sketch.</code></p> <ol> <li> <p>构造：考虑所有由基向量组成的有限线性组合，且系数限制为有理数（若 \\(\\mathbb{K}=\\mathbb{C}\\) 则为实部虚部均为有理数）：     $$ M = \\left{ \\sum_{i=1}^n r_i e_i : r_i \\in \\mathbb{Q}, n \\in \\mathbb{N} \\right} $$</p> </li> <li> <p>可数性：\\(M\\) 是可数集的可数并，因此是可数的。</p> </li> <li>稠密性：对于任意 \\(x = \\sum \\alpha_i e_i\\)，其部分和 \\(S_n\\) 收敛于 \\(x\\)。我们只需用有理数 \\(r_i\\) 逼近标量 \\(\\alpha_i\\)，即可证明 \\(M\\) 中的元素可以任意逼近 \\(x\\)。</li> </ol>","path":["Banach Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Banach%20Spaces/#exercise-23","level":2,"title":"Exercise 2.3","text":"<p>[!question] HW3-1 Show that a Banach space \\(V\\) is separable if and only if</p> \\[V=\\overline{\\bigcup\\limits_{n=1}^{\\infty} V_{n}}\\] <p>where \\((V_{n})_{n\\in \\mathbb{N}}\\) are finite dimensional subspace of \\(V\\)</p> <p><code>Proof.</code></p> <p>\\(\\implies\\)</p> <p>证明：如果\\(V\\)是可分的，那么有\\(V=\\overline{\\bigcup\\limits_{n=1}^{\\infty}V_{n}}\\)</p> <p>由于\\(V\\)是可分的Banach空间，那么它一定包含一个可数稠密子集，我们将其记为\\(D=\\left\\{ d_{1},d_{2},\\dots,d_{n},\\dots \\right\\}\\)，然后考虑定义\\(V\\)上有限维子空间\\(V_{n}\\)</p> \\[ V_{n}=span\\left\\{ d_{1},d_{2},\\dots,d_{n} \\right\\}  \\] <p>令\\(U=\\bigcup\\limits_{n=1}^{\\infty} V_{n}\\)，那么\\(U=span(D)\\)，也就是说\\(U\\)是由\\(D\\)张成的\\(V\\)上的子空间</p> <p>下面证明\\(\\overline{U}=V\\)即可，这是显然的，因为\\(U=span(D)\\implies D\\subset U\\subset V\\)，但是\\(D\\)在\\(V\\)上稠密，所以根据稠密子集的定义，\\(V\\)上任意一点\\(x_{0}\\)均存在\\(D\\)中子列收敛到该点，并且\\(D\\subset U\\)，所以子列也含于\\(U\\)中，那么\\(x_{0}\\in  \\overline{U}\\)，由此即得\\(V\\subset  \\overline{U}\\)，并且因为\\(V\\)是闭的，综合两个等式即得\\(V=\\overline{U}= \\overline{\\bigcup\\limits_{n=1}^{\\infty}V_{n}}\\)</p> <p>\\(\\impliedby\\)</p> <p>证明：如果\\(V= \\overline{\\bigcup\\limits_{n=1}^{\\infty}V_{n}}\\)，则\\(V\\)是可分的</p> <p>考虑利用定义证明，只需要在其中找到一个可数稠密子集即可，由于\\(V_{n}\\)是有限维赋范空间，我们知道是可分的，因此可以在每个\\(V_{n}\\)内找到一个可数稠密子集记为\\(D_{n}\\)</p> <p>考虑\\(\\bigcup\\limits_{n=1}^{\\infty}D_{n}=D\\)，我们想要证明它是\\(V\\)中可数稠密的子集，由于\\(D\\)是可数集的可数并，因此仍然可数，下面说明\\(D\\)在\\(V\\)内稠密即可：</p> <p>换句话说，就是要说明\\(\\forall x\\in V,\\varepsilon&gt;0,\\exists d\\in D,s.t.\\lVert x-d \\rVert&lt;\\varepsilon\\)</p> <p>因为\\(V=\\overline{\\bigcup\\limits_{n=1}^{\\infty}V_{n}}\\)，令\\(U=\\bigcup\\limits_{n=1}^{\\infty}V_{n}\\)，取\\(x\\in V= \\overline{U}\\)，因此存在\\(x_{1}\\in U\\)，使得\\(\\lVert x_{1}-x \\rVert&lt; \\frac{\\varepsilon}{2}\\)，那么必有\\(x_{1}\\in V_{N}\\)，并且\\(D_{N}\\subset V_{N}\\)，且稠密，那么存在\\(x_{2}\\in D_{N}\\)，使得\\(\\lVert x_{2}-x_{1} \\rVert&lt; \\frac{\\varepsilon}{2}\\)</p> <p>利用三角不等式即得：</p> \\[ \\lVert x-x_{2} \\rVert =\\lVert x-x_{1}+x_{1}-x_{2} \\rVert \\leqslant \\lVert x-x_{1} \\rVert +\\lVert x_{1}-x_{2} \\rVert &lt;\\varepsilon \\] <p>因此\\(D\\)在\\(V\\)中稠密，可知\\(V\\)可分</p> <p>[!question] (1) Let \\(\\mathbf{e}_k\\) be the scalar sequence whose only nonzero term is '1' in the \\(k\\)th coordinate. Show that \\(\\{e_k : k = 1, 2, \\dots\\}\\) is a Schauder basis of the Banach space \\((c_0, \\|\\cdot\\|_\\infty)\\).</p> <p>根据定义进行验证即可</p> <p><code>Proof.</code></p> <p>对于任意 \\(x = (\\xi_1, \\xi_2, \\dots) \\in c_0\\)，根据 \\(c_0\\) 的定义，我们有 \\(\\lim\\limits_{k\\to\\infty} \\xi_k = 0\\)。考虑级数 \\(\\sum_{k=1}^\\infty \\xi_k e_k\\) 的部分和序列 \\((s_n)\\)，其中 \\(s_n = \\sum_{k=1}^n \\xi_k e_k = (\\xi_1, \\xi_2, \\dots, \\xi_n, 0, 0, \\dots)\\)</p> <p>计算 \\(x\\) 与 \\(s_n\\) 的距离：</p> \\[ \\|x - s_n\\|_\\infty = \\|(0, \\dots, 0, \\xi_{n+1}, \\xi_{n+2}, \\dots)\\|_\\infty = \\sup_{k &gt; n} |\\xi_k| \\] <p>由于 \\(\\xi_k \\to 0\\)，即 \\(\\forall \\varepsilon &gt; 0, \\exists N\\) 使得 \\(k &gt; N \\implies |\\xi_k| &lt; \\varepsilon\\)。因此，当 \\(n \\to \\infty\\) 时，\\(\\sup\\limits_{k &gt; n} |\\xi_k| \\to 0\\)。这意味着 \\(x = \\sum_{k=1}^\\infty \\xi_k e_k\\) 在范数意义下收敛</p> <p>根据定义还需要说明唯一性，假设 \\(x = \\sum_{k=1}^\\infty \\alpha_k e_k\\)。由坐标泛函的连续性（或直接比较坐标），第 \\(k\\) 个坐标必须相等，即 \\(\\alpha_k = \\xi_k\\)</p> <p>综上，\\(\\{e_k\\}\\) 是 \\(c_0\\) 的 Schauder 基。</p> <p>[!question] (2) Let \\(\\mathbf{e}_k\\) be the scalar sequence whose only nonzero term is '1' in the \\(k\\)th coordinate, and let \\(\\mathbf{e} = (1, 1, \\dots)\\) with all coordinates '1'. Show that \\(\\{e_k : k = 1, 2, \\dots\\} \\cup \\{e\\}\\) is a Schauder basis of the Banach space \\((c, \\|\\cdot\\|_\\infty)\\).</p> <p><code>Proof.</code></p> <p>对于任意 \\(x = (\\xi_k) \\in c\\)，由于序列收敛，设 \\(\\lim_{k\\to\\infty} \\xi_k = l\\)。 我们需要证明 \\(x\\) 可以唯一表示为 \\(l\\mathbf{e} + \\sum_{k=1}^\\infty (\\xi_k - l)e_k\\)。 考察向量 \\(y = x - l\\mathbf{e} = (\\xi_1 - l, \\xi_2 - l, \\dots)\\)。 由于 \\(\\xi_k \\to l\\)，所以 \\(y\\) 的分量趋于 0，即 \\(y \\in c_0\\)。 根据 Problem 1 的结论，\\(y\\) 可以唯一表示为 \\(c_0\\) 的基 \\(\\{e_k\\}\\) 的线性组合： $$ y = \\sum_{k=1}^\\infty (\\xi_k - l) e_k $$ 代回 \\(x\\)，我们得到展开式： $$ x = l\\mathbf{e} + \\sum_{k=1}^\\infty (\\xi_k - l) e_k $$ 下面验证收敛性（其实由 \\(c_0\\) 的结论已得，这里写明）： $$ \\left| x - \\left( l\\mathbf{e} + \\sum_{k=1}^n (\\xi_k - l)e_k \\right) \\right|\\infty = \\left| \\sum^\\infty (\\xi_k - l)e_k \\right|\\infty = \\sup |\\xi_k - l| $$ 因 \\(\\xi_k \\to l\\)，当 \\(n \\to \\infty\\) 时上式趋于 0。</p> <p>唯一性：设 \\(x = \\alpha \\mathbf{e} + \\sum_{k=1}^\\infty \\alpha_k e_k\\)。对两边取极限（\\(k \\to \\infty\\)），由于 \\(e_k\\) 的项趋于 0，可知 \\(\\lim x = \\alpha \\cdot 1 + 0\\)，故 \\(\\alpha = l\\)。剩下的部分即归结为 \\(c_0\\) 中系数的唯一性，得 \\(\\alpha_k = \\xi_k - l\\)。</p> <p>[!question] (3) Let \\(\\mathbf{e}_k\\) be the scalar sequence whose only nonzero term is '1' in the \\(k\\)th coordinate. Show that \\(\\{e_k : k = 1, 2, \\dots\\}\\) is a Schauder basis of the Banach space \\((\\ell_p, \\|\\cdot\\|_p)\\) when \\(1 \\le p &lt; +\\infty\\).</p> <p><code>Proof.</code></p> <p>设 \\(x = (\\xi_k) \\in \\ell_p\\)，这意味着 \\(\\sum_{k=1}^\\infty |\\xi_k|^p &lt; \\infty\\)。考虑部分和 \\(s_n = \\sum_{k=1}^n \\xi_k e_k\\)。考察误差的范数：</p> \\[ \\|x - s_n\\|_p = \\left\\| \\left( 0, \\dots, 0, \\xi_{n+1}, \\xi_{n+2}, \\dots \\right) \\right\\|_p = \\left( \\sum_{k=n+1}^\\infty |\\xi_k|^p \\right)^{1/p} \\] <p>由于级数 \\(\\sum |\\xi_k|^p\\) 收敛，其尾部和（Tail sum）当 \\(n \\to \\infty\\) 时必趋于 0。即 \\(\\lim\\limits_{n \\to \\infty} \\|x - s_n\\|_p = 0\\)。因此 \\(x = \\sum_{k=1}^\\infty \\xi_k e_k\\)。唯一性同理，由坐标对应直接得到。</p> <p>[!question] (4) Does the Banach space \\((\\ell_\\infty, \\|\\cdot\\|_\\infty)\\) have a Schauder basis?</p> <p><code>Answer.</code></p> <p>No. \\((\\ell_\\infty, \\|\\cdot\\|_\\infty)\\) does not have a Schauder basis.</p> <p><code>Reasoning.</code></p> <p>根据 Theorem 2.3.4 (Schauder 基与可分性)，如果一个 Banach 空间拥有 Schauder 基，那么它必须是可分的 (Separable)。回顾之前的笔记（Example 2.3.2 (iii)），我们已经证明了 \\(\\ell_\\infty\\) 是不可分的（因为存在不可数个距离为 1 的元素，无法被可数稠密子集逼近）。由于 \\(\\ell_\\infty\\) 不可分，因此它不可能拥有 Schauder 基。</p>","path":["Banach Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Banach%20Spaces/#completeness-and-compactness-in-banach-spaces","level":2,"title":"Completeness and Compactness in Banach spaces","text":"<p>先给出级数收敛的相关定义，在此不赘述(不知道的可以参考数学分析)，重新指出只是为了方便下面的叙述罢了，因为柯西列在Banach空间中收敛，仍然有柯西收敛原理成立，至于绝对收敛定义仍然同数学分析一样，下面让我们进入本节的正题——完备性</p>","path":["Banach Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Banach%20Spaces/#_1","level":3,"title":"完备性","text":"<p>[!info] 补充定义：完备性 (Completeness) 一个赋范空间 \\((E, \\|\\cdot\\|)\\) 被称为完备的（即 Banach 空间），如果 \\(E\\) 中的每一个柯西列 (Cauchy sequence) 都收敛于 \\(E\\) 中的某一点。</p> <p>[!abstract] Theorem 2.4.4 一个赋范空间 \\(E\\) 是完备的，当且仅当 \\(E\\) 中的每一个绝对收敛 (absolutely convergent) 的级数都在 \\(E\\) 中收敛。</p> <p><code>Proof.</code></p> <p>证明的难点在于从“绝对收敛级数收敛”推导出“空间完备”。我们需要证明任意一个柯西列 \\((x_n)\\) 都收敛。思路是构造一个收敛极快的子列，将其转化为级数问题。</p> <p>首先，由于 \\((x_n)\\) 是柯西列，我们可以选取一个子列 \\((x_{n_k})\\)，使得相邻项极其接近。具体来说，对于每一个 \\(k\\)，选取足够大的下标，使得： $$ |x_{n_k} - x_{n_{k-1}}| &lt; \\frac{1}{2^k}, \\quad \\forall k \\ge 2 $$</p> <p>[!tip] 技巧：构造裂项级数 (Telescoping Series) 我们考虑由该子列相邻项之差构成的级数： $$ x_{n_1} + \\sum_{k=2}^{\\infty} (x_{n_k} - x_{n_{k-1}}) $$ 注意到，这个级数的前 \\(m\\) 项部分和 \\(S_m\\) 恰好就是子列的第 \\(m\\) 项： $$ S_m = x_{n_1} + (x_{n_2} - x_{n_1}) + \\dots + (x_{n_m} - x_{n_{m-1}}) = x_{n_m} $$</p> <p>接下来验证该级数是否绝对收敛。根据我们在选取子列时的构造： $$ \\sum_{k=2}^{\\infty} |x_{n_k} - x_{n_{k-1}}| &lt; \\sum_{k=2}^{\\infty} \\frac{1}{2^k} = \\frac{1}{2} &lt; \\infty $$ 既然级数绝对收敛，根据定理的假设，该级数在 \\(E\\) 中收敛。</p> <p>设级数的和为 \\(x\\)。根据“级数和”的定义，就是部分和序列的极限，因此我们得到了子列的收敛性： $$ x = \\lim_{m \\to \\infty} S_m = \\lim_{m \\to \\infty} x_{n_m} $$</p> <p>[!success] 结论：从子列收敛到原序列收敛 我们现在有一个柯西列 \\((x_n)\\)，且它有一个收敛于 \\(x\\) 的子列 \\((x_{n_k})\\)。利用三角不等式： $$ |x_n - x| \\le |x_n - x_{n_k}| + |x_{n_k} - x| $$ *   当 \\(n, n_k\\) 足够大时，第一项因柯西列性质趋于 0。 *   第二项因于列收敛趋于 0。</p> <p>因此 \\(\\lim\\limits_{n \\to \\infty} x_n = x\\)。即任意柯西列都收敛，空间完备。</p> <p>我们需要知道任何赋范空间都可以扩张成一个Banach空间（完备赋范空间）</p> <p>[!abstract] Theorem 2.4.5 (完备化定理) 设 \\(E\\) 是一个赋范空间，总是存在一个 Banach 空间 \\(\\tilde{E}\\) 和一个从 \\(E\\) 到 \\(\\tilde{E}\\) 的等距映射 \\(T\\)，使得 \\(T(E)\\) 是 \\(\\tilde{E}\\) 的稠密子空间。</p> <p>换句话说，\\(\\tilde{E}\\) 是 \\(E\\) 的完备化。此外，在等距同构的意义下，\\(E\\) 的完备化 \\(\\tilde{E}\\) 是唯一的。</p> <p><code>Proof Sketch.</code></p> <p>构造思路类似于从有理数构造实数。我们考虑 \\(E\\) 中所有柯西列构成的向量空间 \\(\\mathcal{E}\\)，并定义等价关系：如果两个柯西列的差趋于 0，则视为等价。商空间 \\(\\tilde{E} = \\mathcal{E} / \\sim\\) 在商范数下构成 Banach 空间。最后，原空间 \\(E\\) 可以通过常数序列自然地、等距地嵌入到 \\(\\tilde{E}\\) 中，并且构成稠密子空间。</p> <p>[!example] Example 2.4.6 (典型完备化例子) *   (a) 装备 \\(p\\)-范数 (\\(1 \\le p &lt; \\infty\\)) 的 \\(C[a, b]\\) 不是完备的，其完备化是 \\(L^p[a, b]\\)。 *   (b) 有限支集序列空间 \\(c_{00}\\) 的完备化是趋于 0 的序列空间 \\(c_0\\)。 *   (c) 多项式空间 \\(P[0, 1]\\) 在上确界范数下的完备化是连续函数空间 \\(C[0, 1]\\)。</p> <p>在有限维赋范空间中，有界闭集必定是紧集（Heine-Borel 性质）。但在无穷维空间中这一性质不再成立。Riesz 引理正是处理无穷维空间几何结构、描述这种差异的重要工具。</p> <p>[!abstract] Theorem 2.4.7 (Riesz 引理) 设 \\(Y\\) 是赋范空间 \\(E\\) 的闭真子空间（即 \\(Y \\neq E\\)），且 \\(0 &lt; \\alpha &lt; 1\\)。则存在范数为 1 的元素 \\(x_\\alpha \\in E\\)，使得它到子空间 \\(Y\\) 的距离大于 \\(\\alpha\\)，即： $$ |x_\\alpha - y| &gt; \\alpha, \\quad \\forall y \\in Y $$</p> <p><code>Proof.</code></p> <p>因为 \\(Y\\) 是真子空间，我们可以取 \\(x \\in E \\setminus Y\\)。设 \\(d = \\inf\\{\\|x - y\\| : y \\in Y\\}\\) 为 \\(x\\) 到 \\(Y\\) 的距离。由于 \\(Y\\) 是闭集，故 \\(d &gt; 0\\)。</p> <p>因为 \\(d &lt; d\\alpha^{-1}\\)，根据下确界定义，存在 \\(y_0 \\in Y\\) 使得 \\(\\|x - y_0\\| &lt; d\\alpha^{-1}\\)。我们令 \\(x_\\alpha = \\frac{x - y_0}{\\|x - y_0\\|}\\)，显然 \\(\\|x_\\alpha\\| = 1\\)。 对于任意 \\(y \\in Y\\)，考察距离 \\(\\|x_\\alpha - y\\|\\)： $$ |x_\\alpha - y| = \\left| \\frac{x - y_0}{|x - y_0|} - y \\right| = \\frac{1}{|x - y_0|} | x - \\underbrace{(y_0 + |x - y_0|y)}_{\\in Y} | $$ 注意括号内的部分仍属于 \\(Y\\)，因此其与 \\(x\\) 的距离至少为 \\(d\\)。从而我们得到 </p> \\[\\|x_\\alpha - y\\| \\ge \\frac{d}{\\|x - y_0\\|} &gt; \\frac{d}{d\\alpha^{-1}} = \\alpha\\] <p>[!abstract] Theorem 2.4.8 (无穷维空间的单位球非紧) 设 \\(E\\) 是无穷维赋范空间。则其单位球 \\(U_E := \\{x \\in E : \\|x\\| \\le 1\\}\\) 和单位球面 \\(S_E := \\{x \\in E : \\|x\\| = 1\\}\\) 都不是紧集。</p> <p><code>Proof.</code></p> <p>我们要构造一个没有收敛子列的序列。任取 \\(x_1 \\in S_E\\)。由于 \\(E\\) 是无穷维的，\\(span\\{x_1\\}\\) 是一个有限维的真子空间（也就是闭真子空间）。应用 Riesz 引理（取 \\(\\alpha = 3/4\\)），存在 \\(x_2 \\in S_E\\) 使得 \\(\\|x_2 - x_1\\| \\ge 3/4\\)。</p> <p>归纳地，假设已选取 \\(x_1, \\dots, x_n\\)。考虑闭真子空间 \\(Y_n = span\\{x_1, \\dots, x_n\\}\\)。再次应用 Riesz 引理，存在 \\(x_{n+1} \\in S_E\\) 使得对于所有 \\(y \\in Y_n\\) 都有 \\(\\|x_{n+1} - y\\| \\ge 3/4\\)。</p> <p>如此得到的序列 \\((x_n)\\) 满足：当 \\(n \\neq m\\) 时，\\(\\|x_n - x_m\\| \\ge 3/4\\)。该序列显然不是柯西列，因此没有任何收敛子列。故 \\(S_E\\) 和 \\(U_E\\) 不紧。</p> <p>Banach 不动点定理是分析学中构造解和证明唯一性的核心工具。</p> <p>[!abstract] Theorem 2.4.9 (Banach 不动点定理 / 压缩映射原理) 设 \\(K\\) 是 Banach 空间 \\(E\\) 的非空闭子集，\\(\\varphi: K \\to K\\) 是一个压缩映射，即存在常数 \\(0 &lt; \\rho &lt; 1\\) 使得： $$ |\\varphi(x) - \\varphi(y)| \\le \\rho|x - y|, \\quad \\forall x, y \\in K $$ 则 \\(\\varphi\\) 在 \\(K\\) 中有且仅有一个不动点，即存在唯一的 \\(z_0 \\in K\\) 使得 \\(\\varphi(z_0) = z_0\\)。</p> <p><code>Proof.</code></p> <p>存在性：任取 \\(x_0 \\in K\\)，定义迭代序列 \\(x_{n+1} = \\varphi(x_n)\\)。考察相邻项距离，利用压缩性质可得 \\(\\|x_{n+1} - x_n\\| \\le \\rho^n\\|x_1 - x_0\\|\\)。对于任意 \\(m &gt; n\\)，利用三角不等式和几何级数求和：</p> \\[ \\|x_m - x_n\\| \\le \\sum_{i=n}^{m-1} \\|x_{i+1} - x_i\\| \\le \\left(\\sum_{i=n}^{m-1} \\rho^i\\right) \\|x_1 - x_0\\| \\le \\frac{\\rho^n}{1-\\rho}\\|x_1 - x_0\\| \\] <p>当 \\(n \\to \\infty\\) 时右端趋于 0，故 \\((x_n)\\) 是柯西列。因 \\(E\\) 完备且 \\(K\\) 闭，设 \\(x_n \\to z_0 \\in K\\)。由压缩性质知 \\(\\varphi\\) 连续，故 \\(z_0 = \\lim x_{n+1} = \\lim \\varphi(x_n) = \\varphi(z_0)\\)。</p> <p>唯一性：假设也有 \\(u \\in K\\) 使得 \\(\\varphi(u) = u\\)。则 \\(\\|u - z_0\\| = \\|\\varphi(u) - \\varphi(z_0)\\| \\le \\rho\\|u - z_0\\|\\)。因为 \\(\\rho &lt; 1\\)，这迫使 \\(\\|u - z_0\\| = 0\\)，即 \\(u = z_0\\)。</p>","path":["Banach Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Banach%20Spaces/#exercise-24","level":2,"title":"Exercise 2.4","text":"<p>[!question] HW3-2 Show that Theorem 2.4.9 need not hold if</p> \\[\\left|\\varphi(x)-\\varphi(y)\\right|&lt;\\left|x-y\\right|\\] <p>But the result does still hold under this weakened condition if \\(K\\) is compact</p> <p><code>Proof.</code></p> <p>[!cite]- Theorem 2.4.9(Banach Fixed Point Theorem) Let \\(K\\) be a nonempty closed subset of a Banach space \\(E\\) and \\(\\varphi:K\\to K\\) a constraction, that is, there exists a constant \\(0&lt; \\rho&lt;1\\) such that</p> \\[\\lVert \\varphi(x)-\\varphi(y) \\rVert \\leqslant \\rho \\lVert x-y \\rVert , \\forall x,y\\in K\\] <p>Then \\(\\varphi\\) has a unique fixed point in \\(K\\), that is, there exists a unique \\(z_{0}\\in K\\) such that \\(\\varphi(z_{0})=z_{0}\\) </p> <p>\\(\\mathbf{Counter\\ Example:}\\)</p> <p>考虑\\(f(x)=x+ \\frac{1}{x},E=\\mathbb{R},K=[1,+\\infty]\\)</p> <p>那么显然对\\(x\\geqslant 1,f(x)=x + \\frac{1}{x}\\geqslant 1\\in K,f(x):K\\to K\\)</p> <p>再利用拉格朗日中值定理：</p> \\[ \\lvert f(x)-f(y) \\rvert =\\lvert f'(\\xi) \\rvert \\lvert x-y \\rvert,f'(\\xi)= 1- \\frac{1}{\\xi^{2}}&lt;1 ,x,y\\in K \\] <p>满足条件，但是其不存在不动点，反证：</p> \\[ x+ \\frac{1}{x}=x\\implies \\frac{1}{x}=0 \\] <p>不存在这样的\\(x\\)</p> <p>下面说明在紧性条件下，减弱条件也可以推出不动点存在：</p> <p>修改命题条件为假设\\(K\\)为\\(Banach\\)空间\\(E\\)中的非空紧集，且\\(\\varphi:K\\to K\\)，并且满足</p> \\[ \\lVert \\varphi(x)-\\varphi(y) \\rVert &lt;\\lVert x-y \\rVert ,\\forall x,y\\in K,x\\neq y \\] <p>我们需要证明其有不动点</p> <p>构造函数\\(f(x):K\\to \\mathbb{R}\\)</p> \\[ f(x)=\\lVert x-\\varphi(x) \\rVert  \\] <p>根据\\(Lipschitz\\)条件可知\\(\\varphi\\)连续，那么\\(f\\)也是连续函数，利用紧性可知，其极小值存在，不妨设在\\(x_{0}\\)处取到，即\\(f(x_{0})=\\min\\limits_{x\\in K}f(x)\\)</p> <p>下面说明\\(x_{0}\\)为不动点，也就是要说明\\(f(x_{0})=0\\)，反证\\(f(x_{0})=\\delta &gt;0\\)，再考虑\\(\\varphi(x_{0})\\in K\\)</p> \\[ f(\\varphi(x_{0}))=\\lVert \\varphi(x_{0})-\\varphi(\\varphi(x_{0})) \\rVert &lt;\\lVert \\varphi(x_{0})-x_{0} \\rVert =f(x_{0}) \\] <p>与\\(f(x_{0})\\)的极小性矛盾，因此\\(f(x_{0})=0\\)，即证不动点存在(唯一性是显然的)</p> <p>[!tip] 紧集如何弥补收缩条件弱化所带来的不足 原定理成立的核心是完备性和收缩性，因此可以保证\\(\\lVert x_{n}-x_{n-1} \\rVert\\)为柯西列，但是如果只是单纯的非减条件，可能会使得原本的数列收敛速度不够快，无法导出柯西列，因此结论可能不成立，那么这时候引入紧性就可以提供额外的拓扑结构，其作用体现在以下两点： 1. 保证连续函数的最小值存在（极值定理） 2. 利用距离严格递减性证明最小值必为零（反证法） </p>","path":["Banach Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Continuous%20linear%20operators/","level":1,"title":"Continuous linear operators","text":"<p>注：笔者原本打算的是直接扔下这份讲义去阅读Brezis的FA and PDEs，但是阅读了第一章发现他的写法似乎有些clear，但是问题在于我读起来又不是很clear于是回归这份讲义想先了解一个overview然后再回去读Brezis，然后惊奇的发现这一章的内容正是我阅读Brezis时欠缺的部分，于是速通之</p>","path":["Continuous linear operators"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Continuous%20linear%20operators/#basic-definitions-and-properties","level":2,"title":"Basic definitions and properties","text":"<p>给出赋范空间的单位闭球的概念：</p> <p>[!NOTE] closed unit ball of \\(E\\) For a normed space \\(E\\), let</p> \\[U_{E}:= \\left\\{ x\\in E:\\lVert x \\rVert \\leqslant 1 \\right\\} \\] <p>be the closed unit ball of \\(E\\)</p> <p>那么很自然的我们会使用缩放的闭球定义集合\\(A\\)在\\(E\\)中(赋范)有界，也就是说\\(A\\subseteq kU_{E}\\)，换句话说\\(\\lVert a \\rVert\\leqslant k&lt;+\\infty,\\forall a\\in A\\)</p> <p>我们考虑线性算子\\(T:E\\to F\\)：\\(T(\\alpha x+\\beta y)=\\alpha Tx+\\beta Ty\\)，其中\\(E,F\\)均为赋范空间</p> <p>显然我们可以得到以下等价结论：</p> <p>[!cite] Theorem(有界性和连续性) 假设\\(T\\)是一个线性算子，\\(T:E\\to F\\)</p> <ol> <li>\\(T\\) is Lipschitz continuous</li> <li>\\(T\\) is countinuous</li> <li>\\(T\\) is coutinuous at \\(0\\)</li> <li>\\(T(U_{E})\\) is bounded in \\(F\\)</li> <li>\\(T\\) sends bounded sets to bounded sets</li> <li>\\(\\exists k&gt;0\\), s.t. \\(\\lVert Tx \\rVert\\leqslant k \\lVert x \\rVert,\\forall x\\in E\\)</li> </ol> <p><code>Proof.</code></p> <p>前三条\\(1\\to 2 \\to 3\\)是显然的</p> <p>\\(3\\to 4\\)，思路是利用定义证明\\(T(U_{E})\\subset kB_{F}\\)先定义\\(B_{F}\\)是关于\\(F\\)的在0点处的单位球邻域\\(B_{F}=\\left\\{ y\\in F|\\lVert y \\rVert\\leqslant 1 \\right\\}\\)，利用条件，因为\\(T(0)=0\\)，结合0点处连续性得到有\\(E中\\)一个邻域\\(V\\)使得\\(TV\\subseteq B_{F}\\)，并且利用0是\\(V\\)的内点，可以得到\\(\\exists\\lambda&gt;0\\)，\\(\\lambda U_{E}\\subset V\\)：</p> \\[ \\lambda TU_{E}=T(\\lambda U_{E})\\subset TV\\subset B_{F} \\] <p>那么有\\(T(U_{E})\\subset \\frac{1}{\\lambda}U_{F}\\)，因此\\(TU_{E}\\)在\\(F\\)中有界</p> <p>\\(4\\to 5\\)，\\(A\\subseteq kU_{E}\\)，那么有\\(TA\\subset T(kU_{E})=kT(U_{E})\\)对于一个有界集的子集，显然有界</p> <p>\\(5\\to 6\\)，取\\(E\\)中单位球\\(U_{E}\\)作为有界集，那么根据条件可以得到\\(T(U_{E})\\)是有界的，即存在一个常数\\(k\\)，使得\\(T(U_{E})\\subset kU_{F}\\)，或者说\\(\\lVert Tx \\rVert \\leqslant k\\)，考虑\\(\\forall x\\in E\\setminus \\left\\{ 0 \\right\\}\\)，有\\(\\frac{x}{\\lVert x \\rVert }\\in U_{E}\\)，显然：</p> \\[ \\left\\lVert  T\\left( \\frac{x}{\\lVert x \\rVert } \\right)  \\right\\rVert  \\leqslant k\\implies \\lVert Tx \\rVert \\leqslant k\\lVert x \\rVert  \\] <p>对于\\(x=0\\)是显然成立的</p> <p>\\(6 \\to 1\\)实际也是显然的</p> <p>我们可以得到\\(\\lVert Tx-Ty \\rVert =\\lVert T(x-y) \\rVert \\leqslant k\\lVert x-y \\rVert\\)得到Lipschitz连续</p> <p>综上得证结论成立！</p> <p>然后是一个自然的结论：</p> <p>[!NOTE] Lemma 假设\\(T\\)是一个连续线性算子，若是有\\(\\lVert T \\rVert:=\\sup \\left\\{ \\lVert Tx \\rVert:x\\in E,\\lVert x \\rVert\\leqslant 1 \\right\\}\\)，我们有：</p> \\[ \\begin{aligned} \\lVert T \\rVert &amp;=\\sup \\left\\{ \\frac{\\lVert Tx \\rVert }{\\lVert x \\rVert }:0\\neq x\\in E \\right\\}\\\\ &amp;=\\sup \\left\\{ \\lVert Tx \\rVert :x\\in E,\\lVert x \\rVert =1 \\right\\}\\\\ &amp;=\\sup \\left\\{ \\lVert Tx \\rVert :x\\in E,\\lVert x \\rVert &lt; 1 \\right\\} &lt;+\\infty\\\\ \\lVert Tx \\rVert &amp;\\leqslant\\lVert T \\rVert \\lVert x \\rVert ,\\forall x\\in E\\\\ \\lVert T \\rVert &amp;=\\inf \\left\\{ k&gt;0: \\lVert Tx \\rVert \\leqslant k\\lVert x \\rVert ,\\forall x\\in E \\right\\}  \\end{aligned} \\] <p><code>Proof.</code></p> <p>显然我们可以得到\\(\\lVert T \\rVert&lt;+\\infty\\)，前三条的证明手法就是证明大于等于和小于等于两个方向，从而取等，都比较容易，留作习题</p> <p>最后一行会稍微麻烦一点，我们先定义等式右边的集合为\\(K\\)，那么我们的目标就变成了证明\\(\\lVert T \\rVert=\\inf K\\)只需要利用倒二的等式，马上得到\\(\\lVert T \\rVert\\in K\\)那么\\(\\inf K\\leqslant \\lVert T \\rVert\\)</p> <p>利用定义可以知道\\(\\lVert Tx \\rVert \\leqslant k\\lVert x \\rVert,\\forall x\\in E\\)，结合第一行的等式：</p> \\[ \\lVert T \\rVert =\\sup \\left\\{ \\frac{\\lVert Tx \\rVert }{\\lVert x \\rVert },x\\neq 0 \\right\\} \\implies \\lVert T \\rVert \\leqslant k,\\forall k\\in K\\implies \\lVert T \\rVert \\leqslant \\inf K \\] <p>结合两个不等式即得结论</p> <p>关于两个赋范空间之间的线性算子\\(T\\)，如果有\\(T\\)将norm balls(或者说有界集)映射为norm balls(或者有界集)，我们就称其为有界算子(或者局部有界算子)，由前面的定理可以得到，有界集\\(A\\)的像集\\(TA\\)的直径要小于\\(A\\)的\\(\\lVert T \\rVert\\)倍</p> <p>下面给出有界线性算子构成的集合的记号，对于\\(E,F\\)两个赋范空间，使用\\(B(E,F)\\)来记录所有的从\\(E\\)到\\(F\\)的有界线性算子，如果是同一个空间，有\\(B(E)=B(E,E)\\)</p> <p>[!NOTE] Lemma(有界线性算子构成赋范空间) \\(B(E,F)\\)通过给予算子范数\\(\\lVert T \\rVert=\\sup\\limits_{\\lVert x \\rVert\\leqslant 1}\\lVert Tx \\rVert\\)构成一个赋范空间</p> <p>证明只需要按照赋范空间的定义验证三条性质即可，然后探索这个算子范数我们可以得到一个等价的定义：</p> <p>[!note] Lemma(算子范数等价定义) \\(H,K\\) are Hilbert spaces and \\(T\\in B(H,K)\\). Then</p> \\[\\lVert T \\rVert =\\sup \\left\\{ \\lvert \\langle Th,k\\rangle \\rvert : h\\in U_{H},k\\in U_{K}  \\right\\} \\] <p><code>Proof.</code></p> <p>只需要使用Cauchy-Schwarz不等式，即可得到：</p> \\[ \\lvert \\langle Th,k\\rangle \\rvert \\leqslant \\lVert Th \\rVert \\lVert k \\rVert \\leqslant \\lVert T \\rVert \\lVert h \\rVert \\lVert k \\rVert \\leqslant \\lVert T \\rVert   \\] <p>因为\\(h\\in U_{H},k\\in U_{K}\\)，反方向等式的求取我们利用归一化的方法，若是\\(h\\in U_{H},Th\\neq 0\\)，我们有\\(\\frac{Th}{\\lVert Th \\rVert}\\in U_{K}\\)</p> \\[ \\lVert Th \\rVert= \\frac{\\langle Th,Th\\rangle}{\\lVert Th \\rVert }= \\left\\lvert  \\langle Th, \\frac{Th}{\\lVert Th \\rVert }\\rangle  \\right\\rvert  \\] <p>所以我们有\\(\\lVert Th \\rVert\\in \\left\\{ \\lvert \\langle Th,k \\rangle \\rvert \\right\\}\\)，即：</p> \\[ \\lVert T \\rVert =\\sup\\limits_{h\\in U_{H}}\\lVert Th \\rVert \\leqslant \\sup \\left\\{ \\lvert \\langle Th,k\\rangle \\rvert : h\\in U_{H},k\\in U_{K}  \\right\\}  \\leqslant \\lVert T \\rVert  \\]","path":["Continuous linear operators"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Continuous%20linear%20operators/#exercise-41","level":2,"title":"Exercise 4.1","text":"<p>[!question] (1) Let \\((\\alpha_{i,j})_{i,j\\in\\mathbb{N}}\\) be an infinite matrix with</p> \\[ K := (\\sum_{i,j=1}^{\\infty} |\\alpha_{i,j}|^2)^{1/2} &lt; \\infty. \\] <p>Define a linear operator \\(T\\) on \\(\\ell^2\\) by \\(T((\\xi_n)_{n\\in\\mathbb{N}}) = (\\eta_n)_{n\\in\\mathbb{N}}\\), where</p> \\[ \\eta_n = \\sum_{j=1}^{\\infty} \\alpha_{n,j}\\xi_j, \\quad n=1, 2, \\dots \\] <p>Show that \\(T\\) is a bounded linear operator on \\(\\ell^2\\).</p> <p><code>Proof.</code></p> <p>[!question] (2) Let \\((\\alpha_{i,j})_{i,j\\in\\mathbb{N}}\\) be an infinite matrix such that</p> \\[ \\alpha_1 = \\sup_j \\sum_{i=1}^{\\infty} |\\alpha_{i,j}| &lt; \\infty \\] <p>and</p> \\[ \\alpha_\\infty = \\sup_i \\sum_{j=1}^{\\infty} |\\alpha_{i,j}| &lt; \\infty. \\] <p>Show that there exists an operator \\(T\\) on \\(\\ell^2\\) such that</p> \\[ \\langle Te_j, e_i \\rangle = \\alpha_{i,j} \\quad \\text{and} \\quad \\|T\\|^2 \\le \\alpha_1 \\alpha_\\infty. \\]","path":["Continuous linear operators"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Continuous%20linear%20operators/#proof-explanation","level":3,"title":"Proof &amp; Explanation","text":"<p>Proof.</p> <p>我们需要证明该矩阵定义的算子 \\(T\\) 在 \\(\\ell^2\\) 上是有界的，并估计其范数。这就需要用到 Schur 测试（Schur's Test）的思想。 设 \\(x = (x_j) \\in \\ell^2\\)，考虑 \\((Tx)_i = \\sum_{j=1}^{\\infty} \\alpha_{i,j} x_j\\)。 利用柯西-施瓦茨不等式，我们将各项拆分为 \\(\\sqrt{|\\alpha_{i,j}|} \\cdot \\sqrt{|\\alpha_{i,j}|} |x_j|\\)： $$ |(Tx)i|^2 = \\left| \\sum| |x_j|^2 \\right) $$ 由题设，}^{\\infty} \\alpha_{i,j} x_j \\right|^2 \\le \\left( \\sum_{j=1}^{\\infty} |\\alpha_{i,j}| \\right) \\left( \\sum_{j=1}^{\\infty} |\\alpha_{i,j\\(\\sum_{j=1}^{\\infty} |\\alpha_{i,j}| \\le \\alpha_\\infty\\)，故： $$ |(Tx)i|^2 \\le \\alpha\\infty \\sum_{j=1}^{\\infty} |\\alpha_{i,j}| |x_j|^2 $$ 现在对 \\(i\\) 求和以计算范数 \\(\\|Tx\\|^2\\)： $$ |Tx|^2 = \\sum_{i=1}^{\\infty} |(Tx)i|^2 \\le \\alpha\\infty \\sum_{i=1}^{\\infty} \\sum_{j=1}^{\\infty} |\\alpha_{i,j}| |x_j|^2 $$ 利用非负项级数求和次序的可交换性（Tonelli定理）： $$ |Tx|^2 \\le \\alpha_\\infty \\sum_{j=1}^{\\infty} |x_j|^2 \\left( \\sum_{i=1}^{\\infty} |\\alpha_{i,j}| \\right) $$ 由题设，列和 \\(\\sum_{i=1}^{\\infty} |\\alpha_{i,j}| \\le \\alpha_1\\)，代入得： $$ |Tx|^2 \\le \\alpha_\\infty \\sum_{j=1}^{\\infty} |x_j|^2 \\alpha_1 = \\alpha_1 \\alpha_\\infty |x|^2 $$ 即 \\(\\|Tx\\| \\le \\sqrt{\\alpha_1 \\alpha_\\infty} \\|x\\|\\)。 因为算子有界，所以 \\(T\\) 是 \\(\\ell^2\\) 上良好定义的算子。由于 \\(Te_j\\) 对应矩阵的第 \\(j\\) 列，\\(\\langle Te_j, e_i \\rangle\\) 即为矩阵第 \\(i\\) 行第 \\(j\\) 列的元素 \\(\\alpha_{i,j}\\)。且我们已证明 \\(\\|T\\|^2 \\le \\alpha_1 \\alpha_\\infty\\)。</p> <p>解析： 这是著名的 Schur 测试。 *   \\(\\alpha_1\\) 是矩阵列模长和的上界。 *   \\(\\alpha_\\infty\\) 是矩阵行模长和的上界。 这个定理告诉我们，只要行和与列和都受控，这个无穷矩阵就定义了一个 \\(\\ell^2\\) 上的有界算子，其范数由这两个上界的几何平均值控制。</p> <p>[!question] (3) Let \\((e_n)_{n\\in\\mathbb{N}}\\) be the usual basis of \\(\\ell^2\\) and \\((\\alpha_n)_{n\\in\\mathbb{N}}\\) be a sequence of scalars. Show that there is a bounded linear operator \\(T\\) on \\(\\ell^2\\) such that \\(Te_n = \\alpha_n e_n\\) for all \\(n \\in \\mathbb{N}\\) if and only if \\((\\alpha_n)_{n\\in\\mathbb{N}}\\) is bounded. This operator is called a diagonal operator.</p>","path":["Continuous linear operators"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Continuous%20linear%20operators/#proof-explanation_1","level":3,"title":"Proof &amp; Explanation","text":"<p>Proof.</p> <p>充分性 (\\(\\Leftarrow\\))： 假设序列 \\((\\alpha_n)\\) 有界，即存在 \\(M &gt; 0\\) 使得对所有 \\(n\\) 都有 \\(|\\alpha_n| \\le M\\)。 对于任意 \\(x = \\sum x_n e_n \\in \\ell^2\\)，根据 \\(T\\) 的线性性和定义，\\(Tx = \\sum_{n=1}^{\\infty} \\alpha_n x_n e_n\\)。 计算其范数： $$ |Tx|^2 = \\sum_{n=1}^{\\infty} |\\alpha_n x_n|^2 = \\sum_{n=1}^{\\infty} |\\alpha_n|^2 |x_n|^2 \\le M^2 \\sum_{n=1}^{\\infty} |x_n|^2 = M^2 |x|^2 $$ 因此 \\(\\|Tx\\| \\le M \\|x\\|\\)，即 \\(T\\) 是有界算子。</p> <p>必要性 (\\(\\Rightarrow\\))： 假设 \\(T\\) 是有界算子，即存在常数 \\(C\\) 使得 \\(\\|T\\| \\le C\\)。 对于任意 \\(n \\in \\mathbb{N}\\)，考察基向量 \\(e_n\\)（\\(\\|e_n\\|=1\\)）： $$ Te_n = \\alpha_n e_n $$ 对两边取范数： $$ |Te_n| = |\\alpha_n e_n| = |\\alpha_n| |e_n| = |\\alpha_n| $$ 根据算子有界性定义，\\(\\|Te_n\\| \\le \\|T\\| \\|e_n\\| = \\|T\\|\\)。 因此，对于所有 \\(n\\)，都有 \\(|\\alpha_n| \\le \\|T\\|\\)。这表明序列 \\((\\alpha_n)\\) 必须是有界的。</p> <p>解析： 这是对角算子最基本的性质。 *   对角算子就像是把空间的每个坐标轴拉伸或压缩了 \\(\\alpha_n\\) 倍。 *   如果想要整个变换是“有限的”（有界），那么所有坐标轴的拉伸倍数 \\(\\alpha_n\\) 不能无限大，必须有一个统一的天花板（上界）。</p>","path":["Continuous linear operators"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Continuous%20linear%20operators/#4-problem-statement","level":3,"title":"(4) Problem Statement","text":"<p>[!question] (4) Let \\(\\varphi(x,t) : [0,1] \\times [0,1] \\to [0,\\infty)\\) be a continuous function such that</p> \\[ \\frac{\\partial \\varphi}{\\partial x} : [0,1] \\times [0,1] \\to [0,\\infty) \\] <p>exists and is continuous. Prove that the operator \\(T : C[0,1] \\to C[0,1]\\) defined by</p> \\[ Tf(x) = \\int_0^1 \\varphi(x,t)f(t)dt \\] <p>is linear and continuous, with \\(\\|T\\| = \\int_0^1 \\varphi(1,t)dt\\).</p>","path":["Continuous linear operators"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Continuous%20linear%20operators/#proof-explanation_2","level":3,"title":"Proof &amp; Explanation","text":"<p>Proof.</p> <p>1. 线性性 (Linearity) 积分运算本身是线性的，因此对于 \\(f, g \\in C[0,1]\\) 和标量 \\(\\alpha, \\beta\\)，显然有 \\(T(\\alpha f + \\beta g) = \\alpha Tf + \\beta Tg\\)。</p> <p>2. 连续性 (Continuity) 与范数上界 算子 \\(T\\) 的范数定义为 \\(\\|T\\| = \\sup_{\\|f\\|_\\infty \\le 1} \\|Tf\\|_\\infty\\)。 对于任意 \\(x \\in [0,1]\\)： $$ |Tf(x)| = \\left| \\int_0^1 \\varphi(x,t)f(t) dt \\right| \\le \\int_0^1 |\\varphi(x,t)| |f(t)| dt $$ 题目已知 \\(\\varphi(x,t) \\ge 0\\)，故 \\(|\\varphi(x,t)| = \\varphi(x,t)\\)。且 \\(|f(t)| \\le \\|f\\|_\\infty\\)。 $$ |Tf(x)| \\le |f|_\\infty \\int_0^1 \\varphi(x,t) dt $$ 令 \\(g(x) = \\int_0^1 \\varphi(x,t) dt\\)。 由于已知 \\(\\frac{\\partial \\varphi}{\\partial x} \\ge 0\\)，我们可以推导 \\(g(x)\\) 的单调性： $$ g'(x) = \\int_0^1 \\frac{\\partial \\varphi}{\\partial x}(x,t) dt \\ge 0 $$ 因此，\\(g(x)\\) 在 \\([0,1]\\) 上是单调递增（或非减）的。 于是 \\(\\sup_{x \\in [0,1]} g(x) = g(1) = \\int_0^1 \\varphi(1,t) dt\\)。</p> <p>回到范数估计： $$ |Tf|\\infty = \\sup |Tf(x)| \\le |f|_\\infty \\cdot g(1) $$ 这证明了 \\(T\\) 是有界的（连续的），且 \\(\\|T\\| \\le \\int_0^1 \\varphi(1,t) dt\\)。</p> <p>3. 范数下界 (Lower Bound) 为了证明等号成立，我们取常数函数 \\(f_0(t) \\equiv 1\\)。显然 \\(f_0 \\in C[0,1]\\) 且 \\(\\|f_0\\|_\\infty = 1\\)。 计算 \\(Tf_0\\)： $$ (Tf_0)(x) = \\int_0^1 \\varphi(x,t) \\cdot 1 dt = \\int_0^1 \\varphi(x,t) dt = g(x) $$ 计算其范数： $$ |Tf_0|\\infty = \\sup) $$ 根据算子范数定义： $$ |T| \\ge \\frac{|Tf_0|}{|f_0|} = g(1) = \\int_0^1 \\varphi(1,t) dt $$} |g(x)| = g(1) \\quad (\\text{因为 } g(x) \\ge 0 \\text{ 且单调递增</p> <p>[!question] (5)HW6-1 Let \\(1\\leqslant p &lt;\\infty\\) and \\(T:\\ell_{\\infty}\\to L^{p}[0,1]\\) be defined by</p> <p>$$ T(x_{1},x_{2},\\dots)= \\sum\\limits_{n=1}^{\\infty} x_{n}\\chi_{\\left[  \\frac{1}{2^{n}}, \\frac{1}{2^{n-1}} \\right]} $$ Prove that \\(T\\) is a linear and continuous operator, and calculate \\(\\lVert T \\rVert\\)</p> <p><code>Proof.</code></p> <p>[!cite] \\(\\ell_{\\infty}\\)的含义 这里的\\(\\ell_{\\infty}\\)是序列空间，它包含所有有界的实数（或复数）序列。也就是说，如果\\(x = (x_1, x_2, \\dots) \\in \\ell_{\\infty}\\)，那么存在一个常数\\(M\\)，使得对于所有的\\(n\\)，都有\\(|x_n| \\le M\\)。</p> <p>先假定\\(x=(x_{n})_{n=1}^{\\infty},y=(y_{n})_{n=1}^{\\infty}\\in \\ell_{\\infty},\\alpha,\\beta\\in \\mathbb{K}\\)，并且有\\(t\\in[0,1]\\)，线性性证明如下：</p> \\[ \\begin{aligned} T(\\alpha x+\\beta y)(t)&amp;=\\sum\\limits_{n=1}^{\\infty}(\\alpha x_{n}+\\beta y_{n})\\chi_{\\left[  \\frac{1}{2^{n}}, \\frac{1}{2^{n-1}} \\right]}(t)\\\\ &amp;=\\alpha\\sum\\limits_{n=1}^{\\infty} x_{n}\\chi_{\\left[  \\frac{1}{2^{n}}, \\frac{1}{2^{n-1}} \\right]}(t)+\\beta\\sum\\limits_{n=1}^{\\infty} y_{n}\\chi_{\\left[  \\frac{1}{2^{n}}, \\frac{1}{2^{n-1}} \\right]}(t)\\\\ &amp;=\\alpha Tx(t)+\\beta Ty(t) \\end{aligned} \\] <p>由于赋范空间中连续性和有界性的等价性，我们考虑有界性证明如下：</p> <p>假设\\(x\\in \\ell_{\\infty}\\)那么因为特征函数支撑集互不相交有：</p> \\[ \\left\\lvert \\sum\\limits_{n=1}^{\\infty} x_{n}\\chi_{\\left[  \\frac{1}{2^{n}}, \\frac{1}{2^{n-1}} \\right]} \\right\\rvert ^{p}=\\sum\\limits_{n=1}^{\\infty}\\lvert x_{n} \\rvert ^{p}\\chi_{\\left[  \\frac{1}{2^{n}}, \\frac{1}{2^{n-1}} \\right]} \\] <p>代入可知：</p> \\[ \\begin{aligned} \\|Tx\\|_p &amp;= \\left( \\int_0^1 \\sum\\limits_{n=1}^{\\infty} |x_n|^p \\chi_{\\left[  \\frac{1}{2^{n}}, \\frac{1}{2^{n-1}} \\right]}  dt \\right)^{\\frac{1}{p}} = \\left( \\sum\\limits_{n=1}^{\\infty} |x_n|^p \\frac{1}{2^n} \\right)^{\\frac{1}{p}}\\\\ &amp;\\leqslant \\left( \\sum\\limits_{n=1}^{\\infty} \\|x\\|_\\infty^p \\frac{1}{2^n} \\right)^{\\frac{1}{p}} \\\\ &amp;= \\|x\\|_\\infty \\left(\\sum\\limits_{n=1}^{\\infty} \\frac{1}{2^n} \\right)^{\\frac{1}{p}} \\\\ &amp;= \\|x\\|_\\infty\\\\ &amp;&lt; +\\infty \\end{aligned} \\] <p>这证明了 \\(\\|Tx\\|_p \\le \\|x\\|_\\infty\\)，所以算子是有界的，且\\(\\|T\\| \\le 1\\)</p> <p>取\\(z_n = (1, 1, \\dots, 1, 0, 0, \\dots)\\)，前\\(n\\)项是 1，后面全是0，显然，\\(\\|z_n\\|_\\infty = 1\\)并且\\(Tz_n = \\chi_{[\\frac{1}{2^n}, 1]}\\)。</p> \\[ \\|Tz_n\\|_p = \\left( 1 - \\frac{1}{2^n} \\right)^{\\frac{1}{p}} \\] <p>根据上面的\\(\\lVert T \\rVert \\leqslant 1\\)有：</p> \\[ \\left( 1 - \\frac{1}{2^n} \\right)^{\\frac{1}{p}} \\leqslant \\|T\\| \\cdot 1 \\] <p>对上述不等式，令 \\(n \\to \\infty\\)，马上有\\(\\lVert T \\rVert\\geqslant 1\\)，结合两个不等式有\\(\\lVert T \\rVert=1\\)</p> <p>[!question] (6)HW6-2 Consider the linear operators \\(A_n\\) and \\(B_n\\) on \\(\\ell^2\\) defined by</p> \\[ A_n(x) = \\left(\\frac{x_1}{n}, \\frac{x_2}{2n}, \\dots\\right), \\quad B_n(x) = (0, \\dots, 0, x_{n+1}, x_{n+2}, \\dots) \\] <p>for all \\(x = (x_1, x_2, \\dots) \\in \\ell^2\\). </p> <p>Prove that \\(\\|A_n\\| \\to 0\\) and \\(B_n(x) \\to 0\\) for all \\(x \\in \\ell^2\\), but that \\((B_n)_{n \\in \\mathbb{N}}\\) does not converge to 0 in the operator norm.</p> <p><code>Proof.</code></p> <p>先考虑\\(A_{n}\\)，那么\\(\\forall x=(x_{n})_{n=1}^{\\infty}\\in \\ell^{2}\\)，根据范数定义有：</p> \\[ \\begin{aligned} \\lVert A_{n}(x) \\rVert ^{2}=\\sum\\limits_{k=1}^{\\infty} \\left\\lvert  \\frac{x_{k}}{kn}  \\right\\rvert ^{2}&amp;= \\frac{1}{n^{2}}\\sum\\limits_{k=1}^{\\infty}  \\frac{\\lvert x_{k} \\rvert ^{2}}{k^{2}}\\leqslant \\frac{1}{n^{2}}\\lVert x \\rVert ^{2}\\\\ \\lVert A_{n} \\rVert&amp; \\leqslant \\frac{1}{n} \\end{aligned} \\] <p>令\\(n\\to \\infty\\)显然为0</p> <p>再考虑\\(B_{n}\\)，对于任意固定的 \\(x \\in \\ell^2\\)，根据范数定义有：</p> \\[ \\|B_n(x)\\| = \\left( \\sum_{k=n+1}^{\\infty} |x_k|^2 \\right)^{\\frac{1}{2}}\\leqslant \\lVert x \\rVert  \\] <p>\\(n\\to \\infty\\)时，有\\(B_n(x) \\to 0\\)，并且\\(\\lVert B_{n} \\rVert \\leqslant 1\\)</p> <p>对于固定的\\(n\\)我们可以找到一个\\(x=(0,\\dots,0,1,0,\\dots)\\)，前面\\(n\\)个0，\\(B_{n}(e_{n+1})=e_{n+1}\\)，所以有：</p> \\[ 1=\\lVert e_{n+1} \\rVert =\\lVert B_{n}(e_{n+1}) \\rVert \\leqslant \\lVert B_{n} \\rVert \\lVert e_{n+1} \\rVert =\\lVert B_{n} \\rVert  \\] <p>因此有\\(\\lVert B_{n} \\rVert=1\\)不收敛于0</p>","path":["Continuous linear operators"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Continuous%20linear%20operators/#continuous-linear-functionals","level":2,"title":"Continuous linear functionals","text":"<p>向量空间\\(X\\)上的线性泛函也就是线性映射：\\(f:X\\to \\mathbb{K}(\\mathbb{R} /\\mathbb{C})\\)</p> <p>[!tip] 不连续线性泛函 在任意的无穷维赋范空间\\((E,\\lVert \\cdot \\rVert)\\)都有不连续的线性泛函</p> <p>下面给出(拓扑)对偶空间 dual space(或者共轭空间 conjugate space)的定义，一个拓扑向量空间\\(X\\)上所有的连续线性泛函构成的向量空间记为\\(X^{*}\\)</p> <p>然后我们在赋范空间上考虑对偶空间：</p> <p>[!NOTE] Definition(Banach dual space) \\(E\\) is a normed space, we call \\(E^{*}=B(X,\\mathbb{K})\\) the Banach dual space of \\(E\\) when it's equipped with the dual norm</p> \\[\\lVert f \\rVert =\\sup\\limits_{\\lVert x \\rVert \\leqslant 1}\\lvert f(x) \\rvert ,\\forall f\\in X^{*}\\] <p>[!tip] Banach-Alaoglu's Theorem 考虑赋范空间\\(E\\)，那么对偶单位球\\(U_{E^{*}}\\)在弱拓扑下紧</p>","path":["Continuous linear operators"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Continuous%20linear%20operators/#examples-of-dual-spaces","level":2,"title":"Examples of dual spaces","text":"","path":["Continuous linear operators"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Continuous%20linear%20operators/#adjoint-of-hilbert-space-operators","level":2,"title":"Adjoint of Hilbert space operators","text":"","path":["Continuous linear operators"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Continuous%20linear%20operators/#exercise-43","level":2,"title":"Exercise 4.3","text":"<p>[!question] (1)HW7-1 Suppose that \\(\\Omega\\) is a \\(\\sigma-\\)finite measure space and \\(y\\in L^{\\infty}(\\Omega)\\). Let \\(T\\) be the multiplication operator \\(Tx(t)=y(t)x(t)\\) for all \\(x\\in L^{2}(\\Omega)\\) and \\(t\\in \\Omega\\). Compute \\(T^{*}\\)</p> <p><code>Sol.</code></p> <p>我们根据定义知道：\\(\\langle x,T^{*}z\\rangle=\\langle Tx,z\\rangle,\\forall x,z\\in L^{2}(\\Omega)\\)</p> <p>根据内积定义：</p> \\[ \\begin{aligned} \\langle Tx,z\\rangle&amp;=\\int_{\\Omega}Tx (t)\\overline{z(t)}dt\\\\ &amp;=\\int_{\\Omega}y(t)x(t) \\overline{z(t)}dt\\\\ &amp;=\\int_{\\Omega}x(t) \\overline{\\overline{y(t)}z(t)}dt\\\\ \\langle x,T^{*}z\\rangle &amp;=\\int_{\\Omega}x(t) \\overline{T^{*}z(t)}dt\\\\ \\int_{\\Omega}x(t) \\overline{\\overline{y(t)}z(t)}dt&amp;=\\int_{\\Omega}x(t) \\overline{T^{*}z(t)}dt \\end{aligned} \\] <p>即有\\(T^{*}z(t)= \\overline{y(t)}z(t)\\)，因此\\(T^{*}\\)是乘以复共轭函数\\(\\overline{y}\\)的乘法算子</p> <p>[!question] (3)HW7-2 Let \\(\\varphi:[0,1]\\to \\mathbb{R}\\) be a continuous function and \\(T:L^{2}[a,b]\\to L^{2}[0,1]\\) defined by</p> \\[ Tf(x)=\\varphi(x)\\int_{0}^{1} \\varphi(t)f(t) \\, dt ,\\forall x\\in[a,b] \\] <p>Prove that \\(T\\) is self-adjoint and positive.</p> <p><code>Proof.</code></p> <p>先证明自伴算子：</p> \\[ \\begin{aligned} \\langle Tf, g \\rangle &amp;= \\int_0^1 (Tf)(x) \\overline{g(x)} \\, dx \\\\ &amp;= \\int_0^1 \\left( \\varphi(x) \\int_0^1 \\varphi(t)f(t) \\, dt \\right) \\overline{g(x)} \\, dx \\\\ &amp;= \\left( \\int_0^1 \\varphi(t)f(t) \\, dt \\right) \\left( \\int_0^1 \\varphi(x)\\overline{g(x)} \\, dx \\right) \\end{aligned} \\] <p>由于 \\(\\varphi\\) 是实函数，即 \\(\\varphi(t) = \\overline{\\varphi(t)}\\)</p> \\[ \\begin{aligned} \\langle f, Tg \\rangle &amp;= \\int_0^1 f(x) \\overline{(Tg)(x)} \\, dx \\\\ &amp;= \\int_0^1 f(x) \\overline{\\left( \\varphi(x) \\int_0^1 \\varphi(t)g(t) \\, dt \\right)} \\, dx \\\\ &amp;= \\int_0^1 f(x)\\varphi(x) \\left( \\overline{\\int_0^1 \\varphi(t)g(t) \\, dt} \\right) \\, dx \\\\ &amp;= \\left( \\int_0^1 f(x)\\varphi(x) \\, dx \\right) \\left( \\int_0^1 \\varphi(t)\\overline{g(t)} \\, dt \\right) \\end{aligned} \\] <p>因此 \\(\\langle Tf, g \\rangle = \\langle f, Tg \\rangle\\)，即 \\(T\\) 是自伴算子</p> <p>要证明 \\(T\\) 是正算子，需证明对于任意 \\(f \\in L^2[0, 1]\\)，都有：</p> \\[ \\langle Tf, f \\rangle \\geq 0 \\] <p>根据定义展开即可：</p> \\[ \\begin{aligned} \\langle Tf, f \\rangle &amp;= \\int_0^1 (Tf)(x) \\overline{f(x)} \\, dx \\\\ &amp;= \\int_0^1 \\left[ \\varphi(x) \\int_0^1 \\varphi(t)f(t) \\, dt \\right] \\overline{f(x)} \\, dx \\\\ &amp;= \\left( \\int_0^1 \\varphi(t)f(t) \\, dt \\right) \\left( \\int_0^1 \\varphi(x)\\overline{f(x)} \\, dx \\right) \\end{aligned} \\] <p>设复数 \\(A = \\int_0^1 \\varphi(t)f(t) \\, dt\\)，由于 \\(\\varphi\\) 是实函数，第二个积分项实际上是 \\(A\\) 的复共轭：</p> \\[ \\overline{A} = \\overline{\\int_0^1 \\varphi(x)f(x) \\, dx} = \\int_0^1 \\varphi(x)\\overline{f(x)} \\, dx \\] <p>因此：</p> \\[ \\langle Tf, f \\rangle = A \\cdot \\overline{A} = |A|^2 \\geq 0 \\] <p>所以 \\(T\\) 是正算子</p>","path":["Continuous linear operators"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Continuous%20linear%20operators/#projections-on-hilbert-spaces","level":2,"title":"Projections on Hilbert spaces","text":"","path":["Continuous linear operators"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Functional_Analysis-Preliminaries(Lecture)/","level":1,"title":"绪论","text":"<p>[!tldr] Outline + Zorn's lemma + Vector spaces + Metric spaces + Topological spaces + Topological Vector Spaces</p> <p>声明：关于本书中所采用的\\(\\mathbb{K}\\)，指代\\(\\mathbb{R}\\)或\\(\\mathbb{C}\\)</p>","path":["绪论"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Functional_Analysis-Preliminaries(Lecture)/#zorns-lemma","level":2,"title":"Zorn's lemma","text":"<p>我们先给出二元关系的定义：</p> <p>假设我们有一个非空集合\\(I\\)，那么将\\(I\\)上的二元关系\\(\\preceq\\)定义为\\(I\\times I\\)的一个子集，如果\\((x,y)\\in\\preceq\\)，那么记作\\(x\\preceq y\\)</p> <p>在二元关系的基础上满足额外的三条性质则称其偏序，给出偏序的定义：</p> <p>二元关系满足：</p> <ul> <li>Reflexive \\(\\forall x.x\\preceq x\\)</li> <li>Antisymmetry if \\(x\\preceq y, y\\preceq x\\)，then \\(x=y\\)</li> <li>Transitivity if \\(x\\preceq y, y\\preceq z\\), then \\(x\\preceq z\\)</li> </ul> <p>则称其为偏序，显然集合的包含关系是一个偏序，额外补充Direct Partial Ordering(定向偏序)的定义，这是一个具有特定性质的偏序关系：对于\\(I\\)中任意两个元素\\(x,y\\)，存在\\(I\\)中元素\\(z\\)使得\\(x\\preceq z,y\\preceq z\\)</p> <p>[!example] 字典序，lexicographical order 对于\\(\\mathbb{R}^{2}\\)上的一个偏序定义如下：</p> <p>如果\\(x_{1}&lt;x_{2}\\)或者在\\(x_{1}=x_{2},y_{1}\\leqslant y_{2}\\)，那么称为\\((x_{1},y_{1})\\preceq (x_{2},y_{2})\\)</p> <p>为了下面阐述Zorn引理，我们还需要一些特殊概念：</p> <ul> <li>上界(Upper bound) \\(\\forall y\\in Y,y\\preceq b(b\\in X)\\)记作\\(Y\\preceq b\\)，\\(b\\)称为\\(Y\\)的上界</li> <li>上确界(Supremum) 参考数学分析</li> <li>极大元(Maximal element) 如果\\(z\\preceq a\\implies z=a\\)，即\\(X\\)中不存在严格大于\\(z\\)的元素</li> <li>链(Chain) \\(X\\)的子集\\(C\\)如果满足其中任何两个元素均可比较(\\(a\\preceq b,b\\preceq a\\))，称为链(或者全序子集)</li> </ul> <p>下面就是本节最重要的内容：</p> <p>[!tip] Zorn's Lemma  Let \\((X, \\preceq)\\) be a partially ordered set such that every nonempty chain \\(C \\subseteq X\\) admits an upper bound (in \\(X\\)). Then \\(X\\) has a maximal element.</p> <p>等价形式：</p> <p>[!tip] Axiom of Choice  Let \\(I\\) and \\(X\\) be two nonempty sets and, for each element \\(i \\in I\\), let \\(X_i \\subseteq X\\) be a nonempty subset. Then there exists a map \\(g : I \\to X\\) such that \\(g(i) \\in X_i\\) for every \\(i \\in I\\).</p> <p>Note that both Theorems 1.1.8 and 1.1.9 are axioms in the ZFC set theory system. One cannot prove or disprove any one of them (by other axioms in ZFC). However, they are equivalent.</p> <p>\\(\\mathbf{Remark:}\\)The Axiom of Choice is equivalent to Zorn's Lemma. In other words, we can derive either one from the other.</p> <p>实际上并不只有Zorn引理和选择公理等价，还有良序原理(Well-Ordering Principle)，豪斯多夫极大性原理(Hausdorff Maximality Principle)，具体的证明链参考Folland, Real Analysis</p>","path":["绪论"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Functional_Analysis-Preliminaries(Lecture)/#vector-spaces","level":2,"title":"Vector spaces","text":"<p>基本上是照抄了一下高代的定义，大多数正常的数学系/统计系学生都不会忘记向量空间的定义，在此不赘述(加法和数乘运算的8条性质)</p> <p>给出一些例子(很多记号后续也会使用)</p> <p>[!example] elementary examples (a) \\(\\mathbb{K}^{n}\\)，\\(n\\)元的向量空间 (b) \\(\\mathbb{K}^{\\mathbb{N}}=\\left\\{ (x_{1},\\dots,x_{n},\\dots): x_{i}\\in \\mathbb{K},\\forall i\\in \\mathbb{N} \\right\\}\\) 无穷维向量空间 (c) \\(\\mathbb{C}[0,1]\\)：所有的定义在\\([0,1]\\)上的\\(\\mathbb{K}-valued\\)函数 (d) 定义在矩阵上的向量空间\\(M_{n}(\\mathbb{K})\\)</p> <p>如果向量空间内部非空子集仍然满足加法和数乘的封闭，称其为子空间</p> <p>本节唯一新的定义就是\\(Hamel\\)基：</p> <p>A subset \\(B\\) of a vector space \\(X\\) is called a Hamel basis for \\(X\\) if \\(B\\) is linearly independent and spans \\(X\\). In this case, every element \\(x\\in X\\) can be written uniquely as a finite linear combination \\(x=\\sum\\limits_{i=1}^{k}\\lambda_{i}b_{i}\\) for some scalars \\(\\lambda_{1},\\dots,\\lambda_{k}\\) and some basic vectors \\(b_{1},\\dots,b_{k}\\) from \\(B\\)</p> <p>我们需要思考\\(Hamel\\)基与我们在高等代数中学习的基有什么不同？实际上就是没有区别，之所以记为\\(Hamel\\)基只是因为在泛函分析中还存在Schauder基/Hilbert基(拓扑基/Topological Basis)，可以应用于无限维空间，而\\(Hamel\\)基只适用于有限维空间</p> <p>\\(\\mathbf{R emark:}\\)任何非零向量空间\\(X\\)都有\\(Hamel\\)基(对于无穷维仍然成立)</p>","path":["绪论"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Functional_Analysis-Preliminaries(Lecture)/#exercises-12","level":2,"title":"Exercises 1.2","text":"<p>(1) If \\(X\\) is a vector space over \\(\\mathbb{K}\\) and \\(M\\) is a subspace of \\(X\\) define an equivalent relation on \\(X\\) by</p> \\[ x \\sim y \\iff x - y \\in M. \\] <p>The quotient space \\(X/M\\) is the set of all equivalent classes</p> \\[ [x] = \\{x + m : m \\in M\\} \\] <p>for \\(x \\in X\\). Show that this is a vector space over \\(\\mathbb{K}\\) if we define</p> \\[ [x] + [y] = [x + y], \\quad \\lambda[x] = [\\lambda x], \\quad \\forall x, y \\in X, \\lambda \\in \\mathbb{K}, \\] <p>and the quotient \\(Q : x \\in V \\mapsto [x] \\in X/M\\) is linear.</p> <p><code>Proof.</code></p> <p>我们可以利用\\(M\\)是子空间，所以有：</p> \\[ \\begin{aligned} {[x]}+[y]&amp;=x+M+y+M=x+y+M=[x+y]\\\\ \\lambda[x]&amp;=\\lambda x+\\lambda M=\\lambda x+M=[\\lambda x] \\end{aligned} \\] <p>所以是向量空间</p> <p>商映射的线性性：</p> <p>对于任意 \\(x, y \\in X\\)</p> \\[ \\begin{aligned} Q(x + y) &amp;= [x + y]  \\\\ &amp;= [x] + [y]   \\\\ &amp;= Q(x) + Q(y)  \\end{aligned} \\] <p>对于任意 \\(x \\in X\\) 和 \\(\\lambda \\in \\mathbb{K}\\)</p> \\[ \\begin{aligned} Q(\\lambda x) &amp;= [\\lambda x]  \\\\ &amp;= \\lambda [x]  \\\\ &amp;= \\lambda Q(x)  \\end{aligned} \\] <p>(2) Let \\(Z\\) be a linearly independent subset of a vector space \\(X\\). Show that \\(X\\) has a Hamel basis containing \\(Z\\).</p> <p><code>Proof.</code></p> <p>由于\\(Z\\)是\\(X\\)上线性独立子集，令\\(P\\)作为\\(X\\)上所有包含\\(Z\\)的线性独立子集的集合，使用集合包含关系定义\\(P\\)上的一个偏序关系，那么显而易见的\\(P\\)内任意全序子集一定有上界，根据Zorn引理可知\\(P\\)有最大元，记为\\(M\\)，也就是有最大的线性独立子集包含\\(Z\\)，并且它的基可以生成整个空间，否则可以找到\\(x_{0} \\not\\in M\\)，与\\(M\\)组合出额外的线性独立子集，与\\(M\\)是最大元矛盾，即证一定有\\(X\\)上一组\\(Hamel\\)基包含\\(Z\\)</p> <p>(3) In Example 1.2.2, show that if \\(\\mathbb{K} = \\mathbb{R}\\) then every continuous real-valued function \\(f\\) with \\(\\int_0^1 f(x) \\, dx = 0\\) vanishes somewhere in \\([0, 1]\\).</p> <p>[!example] Example 1.2.2 The set</p> \\[\\left\\{ f\\in C[0,1]:\\int_{0}^{1} f(t) \\, dt =0 \\right\\} \\] <p>is a linear subspace of \\(C[0,1]\\)</p> <p><code>Proof.</code></p> <p>直接使用积分中值定理可知\\(f\\in C[a,b]\\)，\\(\\exists c\\in(a,b)\\)使得：</p> \\[ \\int_{a}^{b} f(x) \\, dx=f(c)(1-0)=0\\implies f(c)=0 \\]","path":["绪论"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Functional_Analysis-Preliminaries(Lecture)/#metric-spaces","level":2,"title":"Metric spaces","text":"<p>度量空间是一种很宽泛的定义，只需要定义一个集合上的距离函数，满足非负性，对称性，三角不等式即可，然后我们就可以将配备这种距离函数的集合称为度量空间</p>","path":["绪论"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Functional_Analysis-Preliminaries(Lecture)/#exercises-13","level":2,"title":"Exercises 1.3","text":"<p>[!question] (1) Show that if \\(d\\) is a metric on\\(X\\), then so is \\(\\widetilde{d}\\), where</p> \\[ \\widetilde{d}(x,y) = \\frac{d(x,y)}{1+d(x,y)}, \\quad \\forall x,y \\in X. \\] <p><code>Proof.</code></p> <p>我们需要验证\\(\\widetilde{d}\\)满足度量的三个性质：非负性与恒等性、对称性、三角不等式</p> <p>1. 非负性与恒等性</p> <p>由于\\(d\\)是度量，对于任意\\(x,y \\in X\\)，有\\(d(x,y) \\ge 0\\)。因此\\(\\widetilde{d}(x,y) = \\frac{d(x,y)}{1+d(x,y)} \\ge 0\\)</p> <p>此外，\\(\\widetilde{d}(x,y) = 0 \\iff \\frac{d(x,y)}{1+d(x,y)} = 0 \\iff d(x,y) = 0\\)</p> <p>因为\\(d\\)是度量，所以\\(d(x,y)=0 \\iff x=y\\)。故\\(\\widetilde{d}(x,y)=0 \\iff x=y\\)</p> <p>2. 对称性</p> <p>由于\\(d(x,y) = d(y,x)\\)，直接可得：</p> \\[ \\widetilde{d}(x,y) = \\frac{d(x,y)}{1+d(x,y)} = \\frac{d(y,x)}{1+d(y,x)} = \\widetilde{d}(y,x). \\] <p>3. 三角不等式</p> <p>考虑函数\\(f(t) = \\frac{t}{1+t} = 1 - \\frac{1}{1+t}\\)。因为\\(f'(t) = \\frac{1}{(1+t)^2} &gt; 0\\)，所以\\(f(t)\\)在\\([0, \\infty)\\)上是单调递增函数，对于任意\\(x, y, z \\in X\\)，由\\(d\\)的三角不等式知\\(d(x,y) \\le d(x,z) + d(z,y)\\)</p> <p>利用\\(f(t)\\)的单调性：</p> \\[ \\widetilde{d}(x,y) = f(d(x,y)) \\le f(d(x,z) + d(z,y)) = \\frac{d(x,z) + d(z,y)}{1 + d(x,z) + d(z,y)} \\] <p>将上式右边拆分：</p> \\[ \\frac{d(x,z) + d(z,y)}{1 + d(x,z) + d(z,y)} = \\frac{d(x,z)}{1 + d(x,z) + d(z,y)} + \\frac{d(z,y)}{1 + d(x,z) + d(z,y)} \\] <p>由于分母变小分数值变大有：</p> \\[ \\frac{d(x,z)}{1 + d(x,z) + d(z,y)} \\le \\frac{d(x,z)}{1 + d(x,z)} = \\widetilde{d}(x,z) \\] <p>同理： $$ \\frac{d(z,y)}{1 + d(x,z) + d(z,y)} \\le \\frac{d(z,y)}{1 + d(z,y)} = \\widetilde{d}(z,y) $$</p> <p>综上所述，\\(\\widetilde{d}(x,y) \\le \\widetilde{d}(x,z) + \\widetilde{d}(z,y)\\)</p> <p>因此，\\(\\widetilde{d}\\)是\\(X\\)上的度量</p> <p>[!question] (2) If \\((X, d_X)\\) and \\((Y, d_Y)\\) are metric spaces, show that \\((X \\times Y, \\rho_s)\\) is a metric space, where \\(\\rho_s\\) is any one of the metrics defined by</p> \\[ \\rho_s((x_1, y_1), (x_2, y_2)) = \\begin{cases} [d_X(x_1, x_2)^s + d_Y(y_1, y_2)^s]^{\\frac{1}{s}}, &amp; \\text{if } 1 \\le s &lt; \\infty, \\\\ \\\\ \\max \\{d_1(x_1, x_2), d_2(y_1, y_2)\\}, &amp; \\text{if } s = \\infty. \\end{cases} \\] <p>Furthermore, if \\(X, Y\\) are separable, show that \\((X \\times Y, \\rho_s)\\) is separable.</p> <p><code>Proof.</code></p> <p>根据题意我们的目标是证明\\((X \\times Y, \\rho_s)\\)是度量空间及可分性</p> <p>第一部分：证明它是度量空间</p> <p>需要证明\\(\\rho_s\\)满足三角不等式（非负性和对称性由\\(d_X, d_Y\\)的性质及范数定义显然成立）：</p> <p>令\\(u = (x_1, y_1)\\), \\(v = (x_2, y_2)\\), \\(w = (x_3, y_3)\\)为\\(X \\times Y\\)中的点。</p> <p>情形 1: \\(1 \\le s &lt; \\infty\\) \\(\\rho_s\\)的形式类似于\\(\\mathbb{R}^2\\)上的\\(l_s\\)范数。 根据\\(d_X\\)和\\(d_Y\\)的三角不等式： $$ d_X(x_1, x_3) \\le d_X(x_1, x_2) + d_X(x_2, x_3) $$ $$ d_Y(y_1, y_3) \\le d_Y(y_1, y_2) + d_Y(y_2, y_3) $$ 我们需要证明\\(\\rho_s(u, w) \\le \\rho_s(u, v) + \\rho_s(v, w)\\)。 令\\(A = (d_X(x_1, x_2), d_Y(y_1, y_2))\\)，\\(B = (d_X(x_2, x_3), d_Y(y_2, y_3))\\)。 根据闵可夫斯基不等式（Minkowski inequality）对于\\(\\mathbb{R}^2\\)上的\\(s\\)-范数\\(\\|(a,b)\\|_s = (a^s+b^s)^{1/s}\\)： $$ |A + B|_s \\le |A|_s + |B|_s $$ 这即是三角不等式成立的保证。</p> <p>情形 2: \\(s = \\infty\\) \\(\\rho_\\infty(u, w) = \\max\\{d_X(x_1, x_3), d_Y(y_1, y_3)\\}\\)。 利用\\(d_X(x_1, x_3) \\le d_X(x_1, x_2) + d_X(x_2, x_3) \\le \\rho_\\infty(u, v) + \\rho_\\infty(v, w)\\)。 同理\\(d_Y(y_1, y_3) \\le \\rho_\\infty(u, v) + \\rho_\\infty(v, w)\\)。 两者的最大值自然也满足该不等式。</p> <p>第二部分：证明可分性</p> <p>定义： 一个度量空间是可分的，如果它包含一个可数的稠密子集。</p> <p>证明： 设\\(X\\)和\\(Y\\)是可分的。 令\\(A = \\{a_1, a_2, \\dots\\}\\)是\\(X\\)中的可数稠密子集。 令\\(B = \\{b_1, b_2, \\dots\\}\\)是\\(Y\\)中的可数稠密子集。 考虑乘积集合\\(S = A \\times B = \\{(a_i, b_j) : a_i \\in A, b_j \\in B\\}\\)。 由于\\(A, B\\)可数，它们的笛卡尔积\\(S\\)也是可数的。</p> <p>我们需要证明\\(S\\)在\\((X \\times Y, \\rho_s)\\)中稠密。</p> <p>对于任意\\((x, y) \\in X \\times Y\\)和任意\\(\\epsilon &gt; 0\\)：</p> <ol> <li>因为\\(A\\)稠密，存在\\(a_i \\in A\\)使得\\(d_X(x, a_i) &lt; \\delta\\)。</li> <li>因为\\(B\\)稠密，存在\\(b_j \\in B\\)使得\\(d_Y(y, b_j) &lt; \\delta\\)。</li> </ol> <p>我们来选取合适的\\(\\delta\\)。 当\\(1 \\le s &lt; \\infty\\)时： $$ \\rho_s((x,y), (a_i, b_j)) = [d_X(x, a_i)^s + d_Y(y, b_j)^s]^{1/s} &lt; [\\delta^s + \\delta^s]^{1/s} = \\delta \\cdot 2^{1/s} $$ 取\\(\\delta = \\frac{\\epsilon}{2^{1/s}}\\)，则\\(\\rho_s &lt; \\epsilon\\)。</p> <p>当\\(s = \\infty\\)时： $$ \\rho_\\infty((x,y), (a_i, b_j)) = \\max{d_X(x, a_i), d_Y(y, b_j)} &lt; \\max{\\delta, \\delta} = \\delta $$ 取\\(\\delta = \\epsilon\\)，则\\(\\rho_\\infty &lt; \\epsilon\\)。</p> <p>由此可见，对于任意\\((x, y)\\)和\\(\\epsilon\\)，都能在\\(S\\)中找到点使其距离小于\\(\\epsilon\\)。故\\(S\\)是稠密的。 因为\\(S\\)是可数稠密子集，所以\\((X \\times Y, \\rho_s)\\)是可分的。</p>","path":["绪论"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Functional_Analysis-Preliminaries(Lecture)/#topological-spaces","level":2,"title":"Topological spaces","text":"<p>关于Box topology和Product topology的问题可以参考MSE上的一个回答：Why are box topology and product topology different on infinite products of topological spaces?</p> <p>我们需要知道的仅仅是乘积拓扑是能够相容的最弱的拓扑，而与之相对应的是商拓扑是最强的拓扑</p>","path":["绪论"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Functional_Analysis-Preliminaries(Lecture)/#exercise-14","level":2,"title":"Exercise 1.4","text":"<p>[!question] (1) Suppose that \\((F_\\lambda)_{\\lambda \\in \\Lambda}\\) is a family of closed subsets of a compact metric space \\(X\\) with the property that the intersection of any finite number of the sets has non-empty intersection. Show that \\(\\bigcap_{\\lambda \\in \\Lambda} F_\\lambda\\) is non-empty.</p> <p>一个比较简单的利用反证法证明的逻辑训练</p> <p><code>Proof.</code></p> <p>Suppose on the contrary that \\(\\bigcap_{\\lambda \\in \\Lambda} F_\\lambda\\) is empty. Then</p> \\[X = X \\setminus \\bigcap_{\\lambda \\in \\Lambda} F_\\lambda = \\bigcup_{\\lambda \\in \\Lambda} X \\setminus F_\\lambda.\\] <p>So \\(\\{X \\setminus F_\\alpha\\}_{\\alpha \\in \\Lambda}\\) is an open cover of \\(X\\). Since \\(X\\) is compact, there is finite subcover,</p> \\[X = \\bigcup_{j=1}^n X \\setminus F_{\\lambda_j} = X \\setminus \\bigcap_{j=1}^n F_{\\lambda_j};\\] <p>this implies that \\(\\bigcap_{j=1}^n F_{\\lambda_j} = \\emptyset\\), but this contradicts the assumption that such an intersection is always non-empty. </p> <p>[!question] (2) Give an example in which non-equivalent metrics define the same topology.</p> <p><code>Sol.</code></p> <p>考虑实数集 \\(X = \\mathbb{R}\\)。</p> <ul> <li>度量 \\(d_1\\) (标准欧几里得度量):     $\\(d_1(x, y) = |x - y|\\)$</li> <li>度量 \\(d_2\\) (有界度量):     $\\(d_2(x, y) = \\frac{|x - y|}{1 + |x - y|}\\)$     (或者简单的 \\(d_2(x, y) = \\min\\{1, |x - y|\\}\\))</li> </ul> <p>为什么它们定义了相同的拓扑？因为拓扑只关心“局部”发生了什么，当 \\(|x - y| \\to 0\\) 时，分母 \\(1 + |x - y| \\approx 1\\)，所以 \\(d_2(x, y) \\approx |x - y| = d_1(x, y)\\)。</p> <p>这意味着：</p> <ol> <li>如果在 \\(d_1\\) 意义下 \\(x_n \\to x\\)，那么在 \\(d_2\\) 意义下也有 \\(x_n \\to x\\)。</li> <li>反之亦然。</li> </ol> <p>收敛性一样，开集也就一样。</p> <p>为什么它们“不等价”（非强等价）？</p> <ul> <li>\\(d_1\\) 是无界的：两点间距离可以无限大（比如 \\(1\\) 和 \\(10000\\)）。</li> <li>\\(d_2\\) 是有界的：任意两点间距离永远小于 1。</li> <li>你无法找到一个常数 \\(C\\)，使得 \\(|x - y| \\le C \\cdot \\frac{|x - y|}{1 + |x - y|}\\) 对所有 \\(x, y\\) 成立（当 \\(|x-y|\\) 很大时，左边趋向无穷，右边趋向 \\(C\\)）。</li> </ul>","path":["绪论"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Functional_Analysis-Preliminaries(Lecture)/#topological-vector-spaces","level":2,"title":"Topological Vector Spaces","text":"<p>这部分比较重要，我将额外开一个小文章记录(这类在大多数教科书中总是提及的基本概念都会采取这种形式，以便于在其他文章中直接援引)</p> <p>[[拓扑向量空间(TVS)]]</p> <p>实际上就是一个向量空间赋予一个向量拓扑，构成一个二元组\\((X,\\mathcal{T})\\)即可</p>","path":["绪论"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Functional_Analysis-Preliminaries(Lecture)/#exercises-15","level":2,"title":"Exercises 1.5","text":"","path":["绪论"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Hilbert%20Spaces/","level":1,"title":"Hilbert Spaces","text":"<p>[!tldr] Outline + Basic properties + Best approximation + Orthogonal Decomposition + Orthonormal basis</p> <p>第三章主要研究的是Hilbert空间，也就是完备内积空间，第二章是为向量空间配备了范数(长度)，这一章则是通过引入内积为其添加了角度和投影的概念，使得空间的几何结构更加接近我们熟悉的\\(\\mathbb{R}^{n}\\)，从而我们可以通过使用内积来同时表示长度和角度</p> <p>我们将主要围绕内积的定义和基本性质，引申出Hilbert空间，然后介绍重要的不等式工具Cauchy-Schwarz不等式，平行四边形定理，再利用几何直观来解决最近点的问题(最优逼近定理)，再然后开始介绍Hilbert空间最为重要的一个工具——投影，引出正交补和正交分解定理，既然有了正交就会开始思考利用正交关系构建一组基来表示空间的所有元素，所以最后会讨论正交规范基的概念以及空间同构的内容</p>","path":["Hilbert Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Hilbert%20Spaces/#basic-properties","level":2,"title":"Basic properties","text":"<p>这一节的核心就是定义内积，然后引出Hilbert空间的定义和判定的手段：</p> <p>显然你应当熟悉所谓内积的四条性质以便于验证</p> <p>[!NOTE] Definition (Inner Product) Let \\(E\\) be a vector space over \\(\\mathbb{K}\\). A function $$ \\langle \\cdot, \\cdot \\rangle : E \\times E \\to \\mathbb{K} $$ is said to be an inner product of \\(E\\) if</p> <ol> <li>\\(\\langle x, x \\rangle \\ge 0\\) for all \\(x \\in E\\); and \\(\\langle x, x \\rangle = 0\\) if and only if \\(x = 0\\);</li> <li>\\(\\langle x, y \\rangle = \\overline{\\langle y, x \\rangle}\\) for all \\(x, y \\in E\\);</li> <li>\\(\\langle \\lambda x, y \\rangle = \\lambda \\langle x, y \\rangle\\) for all \\(x, y \\in E\\);</li> <li>\\(\\langle x + y, z \\rangle = \\langle x, z \\rangle + \\langle y, z \\rangle\\) for all \\(x, y, z \\in E\\).</li> </ol> <p>We call \\((E, \\langle \\cdot, \\cdot \\rangle)\\) a real or complex inner product space when the underlying field \\(\\mathbb{K} = \\mathbb{R}\\) or \\(\\mathbb{C}\\), respectively.</p> <p>关于内积的定义可以看作主要由下述性质构成：</p> <ul> <li>正定性</li> <li>共轭对称性</li> <li>对第一变元的线性，实际上对于第二变元是共轭线性的也就是\\(\\langle x,\\lambda y\\rangle= \\overline{\\lambda}\\langle x,y\\rangle\\)</li> </ul> <p>[!NOTE] Definition(Hilbert空间) 通过内积诱导的范数\\(\\lVert x \\rVert=\\sqrt{ \\langle x,x\\rangle }\\)，如果内积空间在该范数下完备则称其为Hilbert空间</p> <p>注：容易知道\\(\\lVert \\cdot \\rVert\\)满足范数的三条性质，并且将\\(E\\)的范数拓扑也称为内积拓扑</p> <p>我们接下来会讨论Cauchy-Schwartz不等式，实际上在数学分析和高等代数中就经常使用，这同样是内积空间中最著名的不等式，它建立了内积与范数（长度）之间的联系</p> <p>[!abstract] Theorem Cauchy-Schwarz inequality Let \\((E, \\langle \\cdot, \\cdot \\rangle)\\) be an inner product space. It holds that</p> \\[ |\\langle x, y \\rangle| \\le \\sqrt{\\langle x, x \\rangle} \\sqrt{\\langle y, y \\rangle}, \\quad \\forall x, y \\in E. \\] <p>The equality holds if and only if \\(x = \\lambda y\\) for some \\(\\lambda \\in \\mathbb{K}\\) or \\(y = 0\\).</p> <p>证明手法可以采用非常经典的引入参数构造二次型和判别式方法，主要是利用内积的正定性质然后移项即可，在此不赘述了</p> <p>再给出内积的连续性概念</p> <p>[!NOTE] Continuity of inner product Let \\(x_{n},y_{n},x,y\\) be elements of an inner product space \\(E\\), \\(n=1,2,\\dots\\) and </p> \\[x_{n}\\to x,y_{n} \\to y\\] <p>in the associated norm topology. Then</p> \\[\\langle x_{n} , y_{n} \\rangle \\to \\langle x,y \\rangle \\] <p><code>Proof.</code></p> \\[ \\begin{aligned} \\lvert \\langle x,y\\rangle-\\langle x_{n},y_{n}\\rangle \\rvert&amp;\\leqslant  \\lvert \\langle x,y\\rangle-\\langle x,y_{n}\\rangle \\rvert+\\lvert \\langle x,y_{n}\\rangle-\\langle x_{n},y_{n}\\rangle \\rvert\\\\ &amp;\\leqslant \\lVert x \\rVert \\lVert y-y_{n} \\rVert + \\lVert x-x_{n} \\rVert \\lVert y_{n} \\rVert \\\\ &amp; \\leqslant \\lVert x \\rVert \\lVert y-y_{n} \\rVert +C\\lVert x-x_{n} \\rVert  \\end{aligned} \\] <p>因此可以很容易得到\\(n\\to \\infty,\\lvert \\langle x,y\\rangle-\\langle x_{n},y_{n}\\rangle \\rvert\\to 0\\)</p> <p>下面给出能够判断一个空间是否由内积定义的重要定理——平行四边形定理</p> <p>[!tip] Paralletlogram Law A norm \\(\\lVert \\cdot \\rVert\\) of a vector space \\(E\\) is defined through an inner product on \\(E\\), if and only if ,</p> \\[\\lVert x+y \\rVert ^{2}+\\lVert x-y \\rVert ^{2}=2(\\lVert x \\rVert ^{2}+\\lVert y \\rVert ^{2}),\\forall x,y\\in E\\] <p><code>Proof.</code></p> <p>方向一：\\((\\Rightarrow)\\) 若范数由内积定义</p> <p>这是显然的。直接利用内积展开范数定义 \\(\\|x\\|^2 = \\langle x, x \\rangle\\)： $$ \\begin{aligned} |x+y|^2 &amp;= \\langle x+y, x+y \\rangle = |x|^2 + \\langle x, y \\rangle + \\langle y, x \\rangle + |y|^2 \\ |x-y|^2 &amp;= \\langle x-y, x-y \\rangle = |x|^2 - \\langle x, y \\rangle - \\langle y, x \\rangle + |y|^2 \\end{aligned} $$ 两式相加，交叉项抵消，立刻得到 \\(2(\\|x\\|^2 + \\|y\\|^2)\\)。</p> <p>方向二：\\((\\Leftarrow)\\) 若范数满足平行四边形法则</p> <p>我们需要构造一个内积 \\(\\langle \\cdot, \\cdot \\rangle\\)，并验证它满足内积的四条公理。</p> <ol> <li>构造内积：极化恒等式 (Polarization Identity)</li> </ol> <p>我们需要通过范数来反解出内积的表达式。</p> <p>[!note] 观察：如何“拼凑”出内积？ 情形 A：若 \\(\\mathbb{K} = \\mathbb{R}\\) (实数域) 由方向一的展开式可知： \\(\\|x+y\\|^2 - \\|x-y\\|^2 = 2\\langle x, y \\rangle + 2\\langle y, x \\rangle = 4\\langle x, y \\rangle\\) (利用实内积对称性)。 于是我们可以定义： $$ \\langle x, y \\rangle = \\frac{1}{4} (|x+y|^2 - |x-y|^2) \\quad (3.2) $$</p> <p>情形 B：若 \\(\\mathbb{K} = \\mathbb{C}\\) (复数域) 复数情形稍微复杂，因为 \\(\\langle y, x \\rangle = \\overline{\\langle x, y \\rangle}\\)。我们利用 \\(i^k\\) 的技巧。 考虑展开式： \\(\\|x + i^k y\\|^2 = \\|x\\|^2 + i^k \\langle y, x \\rangle + i^{-k} \\langle x, y \\rangle + \\|y\\|^2\\)。 对 \\(k=0, 1, 2, 3\\) 求和，并乘以 \\(i^k\\)： $$ \\sum_{k=0}^3 i^k |x + i^k y|^2 = \\sum_{k=0}^3 i^k (|x|^2 + |y|^2) + \\langle y, x \\rangle \\sum_{k=0}^3 i^{2k} + \\langle x, y \\rangle \\sum_{k=0}^3 i^0 $$ 利用 \\(\\sum_{k=0}^3 i^k = 0\\) 和 \\(\\sum_{k=0}^3 i^{2k} = 1-1+1-1=0\\)，只剩下最后一项\\(4\\langle x, y \\rangle\\)：</p> <p>于是，我们定义复空间上的内积为： $$ \\langle x, y \\rangle = \\frac{1}{4} \\sum_{k=0}^3 i^k |x + i^k y|^2 \\quad (3.3) $$ 这两个公式 (3.2) 和 (3.3) 被称为 极化恒等式。</p> <ol> <li>验证构造出的函数是内积</li> </ol> <p>下面我们以复数情形为例进行验证（实数情形是复数的一部分，且更简单）。</p> <p>为了方便验证，我们将复内积拆解为实部和虚部。观察 (3.3) 式：</p> <ul> <li>\\(k=0, 2\\) (实部项): \\(\\frac{1}{4}(\\|x+y\\|^2 - \\|x-y\\|^2)\\)。</li> <li>\\(k=1, 3\\) (虚部项): \\(\\frac{i}{4}(\\|x+iy\\|^2 - \\|x-iy\\|^2)\\)。</li> </ul> <p>记实部函数为 \\(\\text{Re}\\langle x, y \\rangle\\)：</p> \\[ \\text{Re}\\langle x, y \\rangle = \\frac{1}{4}(\\|x+y\\|^2 - \\|x-y\\|^2) \\quad (3.4) \\] <p>利用 \\(\\|ix \\pm y\\| = \\|i(x \\mp iy)\\| = \\|x \\mp iy\\|\\)，我们可以把 (3.3) 重写为：</p> \\[ \\langle x, y \\rangle = \\text{Re}\\langle x, y \\rangle - i \\text{Re}\\langle ix, y \\rangle \\quad (3.5) \\] <p>第一步：验证可加性 (Additivity)</p> <p>这是最难的一步。我们需要证明 \\(\\langle x+z, y \\rangle = \\langle x, y \\rangle + \\langle z, y \\rangle\\)。只需证明实部满足可加性即可。</p> <p>考察 \\(\\text{Re}\\langle x+z, y \\rangle + \\text{Re}\\langle x-z, y \\rangle\\)：</p> \\[ \\begin{aligned} \\dots &amp;= \\frac{1}{4} ( \\underbrace{\\|x+z+y\\|^2 + \\|x-z+y\\|^2}_{\\text{对 } (x+y) \\text{ 和 } z \\text{ 用平行四边形法则}} ) - \\frac{1}{4} ( \\underbrace{\\|x+z-y\\|^2 + \\|x-z-y\\|^2}_{\\text{对 } (x-y) \\text{ 和 } z \\text{ 用平行四边形法则}} ) \\\\ &amp;= \\frac{1}{4} ( 2\\|x+y\\|^2 + 2\\|z\\|^2 ) - \\frac{1}{4} ( 2\\|x-y\\|^2 + 2\\|z\\|^2 ) \\\\ &amp;= \\frac{1}{2} ( \\|x+y\\|^2 - \\|x-y\\|^2 ) \\\\ &amp;= 2 \\text{Re}\\langle x, y \\rangle \\quad (3.6) \\end{aligned} \\] <p>即我们得到了：</p> \\[ \\text{Re}\\langle x+z, y \\rangle + \\text{Re}\\langle x-z, y \\rangle = 2\\text{Re}\\langle x, y \\rangle \\] <p>在此式中，令 \\(z=x\\)，则 \\(\\text{Re}\\langle 2x, y \\rangle + \\text{Re}\\langle 0, y \\rangle = 2\\text{Re}\\langle x, y \\rangle\\)。由于 \\(\\text{Re}\\langle 0, y \\rangle = \\frac{1}{4}(\\|y\\|^2 - \\|-y\\|^2) = 0\\)，故： $$ \\text{Re}\\langle 2x, y \\rangle = 2\\text{Re}\\langle x, y \\rangle $$ 现在，利用这个性质回到 (3.6)。令 \\(u = x+z, v = x-z\\)，则 \\(x = \\frac{u+v}{2}, z = \\frac{u-v}{2}\\)。</p> <p>代入 (3.6) 式（或者如书中操作，将 \\(x\\) 替换为 \\(\\frac{1}{2}(x+z)\\)，将 \\(z\\) 替换为 \\(\\frac{1}{2}(x-z)\\)）：</p> \\[ \\text{Re}\\langle x, y \\rangle + \\text{Re}\\langle z, y \\rangle = 2\\text{Re}\\langle \\frac{x+z}{2}, y \\rangle = \\text{Re}\\langle x+z, y \\rangle \\quad (3.8) \\] <p>这证明了实部对第一个变量是可加的。结合 (3.5)，整体函数 \\(\\langle \\cdot, \\cdot \\rangle\\) 满足可加性</p> \\[ \\langle x+z, y \\rangle = \\langle x, y \\rangle + \\langle z, y \\rangle \\] <p>第二步：验证齐次性 (Homogeneity)</p> <p>我们需要证明 \\(\\langle \\alpha x, y \\rangle = \\alpha \\langle x, y \\rangle\\)</p> <ol> <li>整数与有理数：     由可加性，显然 \\(\\langle nx, y \\rangle = n\\langle x, y \\rangle\\) 对 \\(n \\in \\mathbb{N}\\) 成立，进而推广到 \\(n \\in \\mathbb{Z}\\)，再推广到 \\(\\alpha \\in \\mathbb{Q}\\)</li> <li>实数：     由于范数函数 \\(\\|\\cdot\\|\\) 是连续的，由 (3.3) 定义的内积函数也是连续的     利用连续性，从 \\(\\mathbb{Q}\\) 推广到 \\(\\mathbb{R}\\)：     $$ \\langle \\alpha x, y \\rangle = \\alpha \\langle x, y \\rangle, \\quad \\forall \\alpha \\in \\mathbb{R} $$</li> <li> <p>复数 (虚数单位 \\(i\\))：     我们还需要验证 \\(\\langle ix, y \\rangle = i\\langle x, y \\rangle\\)     利用定义 (3.5)：</p> \\[ \\begin{aligned} \\langle ix, y \\rangle &amp;= \\text{Re}\\langle ix, y \\rangle - i \\text{Re}\\langle i(ix), y \\rangle \\\\ &amp;= \\text{Re}\\langle ix, y \\rangle - i \\text{Re}\\langle -x, y \\rangle \\\\ &amp;= \\text{Re}\\langle ix, y \\rangle + i \\text{Re}\\langle x, y \\rangle \\end{aligned} \\] <p>另一方面： $$ i\\langle x, y \\rangle = i(\\text{Re}\\langle x, y \\rangle - i \\text{Re}\\langle ix, y \\rangle) = i \\text{Re}\\langle x, y \\rangle + \\text{Re}\\langle ix, y \\rangle $$ 两者相等！因此 \\(\\langle \\alpha x, y \\rangle = \\alpha \\langle x, y \\rangle\\) 对所有 \\(\\alpha \\in \\mathbb{C}\\) 成立</p> </li> </ol> <p>第三步：验证正定性与共轭对称 *   正定性：     \\(\\langle x, x \\rangle = \\frac{1}{4} \\sum_{k=0}^3 i^k \\|x + i^k x\\|^2 = \\frac{1}{4} (\\|2x\\|^2 + i\\|x(1+i)\\|^2 - \\|0\\|^2 - i\\|x(1-i)\\|^2) = \\|x\\|^2\\)     显然 \\(\\ge 0\\)，且等于 0 当且仅当 \\(x=0\\) *   共轭对称：     \\(\\langle x, y \\rangle = \\overline{\\langle y, x \\rangle}\\) 是由范数对称性 \\(\\|x+y\\|=\\|y+x\\|\\) 直接得到的平凡结果</p>","path":["Hilbert Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Hilbert%20Spaces/#exercise-31","level":2,"title":"Exercise 3.1","text":"<p>[!question] (6)HW4-1 Let \\(H\\) be an inner product space. (a) If \\(a,b\\in H\\setminus \\left\\{ 0 \\right\\}\\), and if \\(a'= \\frac{a}{\\lVert a \\rVert^{2}}\\) and \\(b'= \\frac{b}{\\lVert b \\rVert^{2}}\\), then</p> \\[\\lVert a'-b' \\rVert = \\frac{\\lVert a-b \\rVert }{\\lVert a \\rVert \\lVert b \\rVert }.\\] <p>(b) Prove the Ptolemaic inequality</p> \\[\\lVert a-c \\rVert \\lVert b-d \\rVert \\leqslant \\lVert a-b \\rVert \\lVert c-d \\rVert +\\lVert b-c \\rVert \\lVert a-d \\rVert \\] <p>for all \\(a,b,c,d\\in H\\)</p> <p><code>Proof.</code></p> <p>(a) $$ \\begin{aligned} \\lVert a'-b' \\rVert ^{2}&amp;= \\left\\lVert  \\frac{a}{\\lVert a \\rVert ^{2}}- \\frac{b}{\\lVert b \\rVert ^{2}}  \\right\\rVert ^{2}\\ &amp;= \\left\\lVert  \\frac{a\\lVert b \\rVert ^{2}-b\\lVert a \\rVert ^{2}}{\\lVert a \\rVert ^{2}\\lVert b \\rVert ^{2}  }\\right\\rVert ^{2}\\ &amp;= \\frac{1}{(\\lVert a \\rVert ^{2}\\lVert b \\rVert ^{2})^{2}}\\langle a\\lVert b \\rVert ^{2}-b\\lVert a \\rVert ^{2},a\\lVert b \\rVert ^{2}-b\\lVert a \\rVert ^{2}\\rangle\\ &amp;= \\frac{1}{(\\lVert a \\rVert ^{2}\\lVert b \\rVert ^{2})^{2}} \\lVert a \\rVert ^{2} \\lVert b \\rVert ^{2} \\left( \\lVert b \\rVert ^{2}+\\lVert a \\rVert ^{2} -\\langle a,b\\rangle -\\langle b,a\\rangle\\right) \\ \\lVert a-b \\rVert ^{2}&amp;=\\langle a-b,a-b\\rangle \\ &amp;=\\lVert a \\rVert ^{2}+\\lVert b \\rVert ^{2}-\\langle a,b\\rangle -\\langle b,a\\rangle\\ \\lVert a'-b' \\rVert ^{2}&amp;=  \\frac{\\lVert a-b \\rVert ^{2}}{\\lVert a \\rVert ^{2}\\lVert b \\rVert ^{2}}\\ \\lVert a'-b' \\rVert &amp;= \\frac{\\lVert a-b \\rVert }{\\lVert a \\rVert \\lVert b \\rVert } \\end{aligned} $$</p> <p>(b)</p> <p>不妨同时除以\\(\\lVert a-d \\rVert\\lVert b-d \\rVert\\lVert c-d \\rVert\\)原本的不等式简化为：</p> \\[  \\frac{\\lVert a-c \\rVert}{\\lVert a-d \\rVert \\lVert c-d \\rVert }  \\leqslant  \\frac{\\lVert a-b \\rVert}{\\lVert a-d \\rVert \\lVert b-d \\rVert } + \\frac{\\lVert b-c \\rVert}{\\lVert b-d \\rVert \\lVert c-d \\rVert }  \\] <p>再做一步显化以使用(a)的结论</p> \\[ \\begin{aligned}  \\frac{\\lVert (a-d)-(c-d) \\rVert}{\\lVert a-d \\rVert \\lVert c-d \\rVert }  &amp;\\leqslant  \\frac{\\lVert (a-d)-(b-d) \\rVert}{\\lVert a-d \\rVert \\lVert b-d \\rVert } + \\frac{\\lVert (b-d)-(c-d) \\rVert}{\\lVert b-d \\rVert \\lVert c-d \\rVert } \\\\  \\iff\\lVert (a-d)'-(c-d)' \\rVert &amp;\\leqslant \\lVert (a-d)'-(b-d)' \\rVert +\\lVert (b-d)'-(c-d)' \\rVert \\\\ \\end{aligned} \\] <p>第二个不等式根据三角不等式是显然的，因此可以逆推回去，得证</p> <p>[!question] (8)HW4-2 If \\(H\\) is a Hilbert space and \\(M\\) is a closed subspace of \\(H\\), show that \\(H \\texttt{/} M\\) is also a Hilbert space.</p> <p>我们应当先知道赋范空间的商范数如何定义，可以参考planetmath</p> <p>[!cite] quotient norm Let \\(V\\) be a normed vector space with norm \\(\\lVert \\cdot \\rVert\\). Let \\(M\\) be a closed subspace of \\(V\\) and \\(V / M\\) the quotient vector space. The norm \\(\\lVert \\cdot \\rVert\\) induces a norm \\(\\lVert \\cdot \\rVert_{V / M}\\) in \\(V / M\\), called the quotient norm, given by</p> <p>$$\\lVert v+M \\rVert {V / M}:= \\inf\\limits\\lVert v+m \\rVert $$ }\\lVert u \\rVert =\\inf\\limits_{m\\in M\\(\\mathbf{Theorem}\\)-\\(\\lVert \\cdot \\rVert_{V / M}\\) is a norm in \\(V / M\\) iff \\(M\\) is closed in \\(V\\)</p> <p>\\(\\mathbf{Method 1}\\)</p> <p>只需要模仿上述定义，给出商范数</p> \\[ \\lVert [x] \\rVert _{H / M}= \\inf\\limits_{u\\in M}\\lVert x+u \\rVert  \\] <p>再说明这个范数符合平行四边形定则即可说明可定义内积在\\(H/ M\\)上</p> <p>\\(\\mathbf{Method2}\\)</p> <p>根据定义，我们想要证明\\(H / M\\)是希尔伯特空间，需要证明两点</p> <ul> <li>\\(H / M\\)上的范数\\(\\lVert \\cdot \\rVert\\)是由一个内积诱导的</li> <li>\\(H / M\\)关于这个范数是完备的</li> </ul> <p>我们考虑利用正交补空间，先将\\(H\\)分解为\\(M\\)和它的正交补\\(M^{\\perp}\\)的直和(正交分解定理)</p> \\[ H=M\\oplus M^{\\perp} \\] <p>即\\(\\forall a\\in H,\\exists!m\\in M,m^{\\perp}\\in M^{\\perp},s.t.a=m+m^{\\perp}\\)</p> <p>然后我们想要说明\\(H/ M\\)和\\(M^{\\perp}\\)是等距同构的，并且我们知道存在唯一的投影\\(P_{M}\\)可以将\\(H\\)中向量映射到\\(M\\)上</p> <p>定义一个映射\\(T:H /M\\to M^{\\perp},T([a])=m^{\\perp}\\)其中\\(a=m+m^{\\perp}\\)，实际上是投影</p> <p>首先证明它是同构，若是有\\(Tx=Ty\\implies x-y=m_{x}-m_{y}\\in M\\)，在同一个等价类内，即\\([x]=[y]\\)，因此其为单射，由正交分解可知满射，因此同构</p> <p>再证明等距</p> \\[ \\begin{aligned} \\lVert [x]-[y] \\rVert&amp;=\\lVert [x-y] \\rVert \\\\ &amp;=\\inf\\limits_{m\\in M}\\lVert (x-y)+m \\rVert\\\\ &amp;= \\inf\\limits_{m'\\in M}\\lVert m^{\\perp}_{x-y}+m' \\rVert(m'=m_{x-y}+m\\in M)\\\\ &amp;=\\lVert m^{\\perp}_{x-y} \\rVert \\\\ &amp;=\\lVert T(x-y) \\rVert\\\\ &amp;=\\lVert Tx-Ty \\rVert  \\end{aligned} \\] <p>由此即得\\(T\\)为等距同构</p> <p>由于\\(M^{\\perp}\\)是\\(H\\)的闭合子空间，因此它也是完备的内积空间(继承内积)，所以仍然是Hilbert空间，再利用等距同构，\\(H /M\\)继承了\\(M^{\\perp}\\)的完备性和内积(可以利用\\(T^{-1}\\)定义\\(H /M\\)上的内积)，因此\\(H /M\\)是完备的内积空间，是Hilbert空间</p>","path":["Hilbert Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Hilbert%20Spaces/#best-approximation","level":2,"title":"Best approximation","text":"<p>我们还想要研究关于最小距离的概念，利用几何的观点先给出最优逼近的定义：</p> <p>[!NOTE] Definition(Best approximation) The distance from \\(x\\) to \\(B\\) is defined as \\(d(x,B)=\\inf\\limits_{y\\in B}d(x,y)\\)，if there is an \\(\\tilde{x}\\in B\\) such that \\(d(x, \\tilde{x})=d(x,B)\\), we call \\(\\tilde{x}\\) is a best approximation of \\(x\\) in \\(X\\) from \\(B\\), or a best approximate element.</p> <p>下面给出最优逼近定理，在Hilbert空间中选取一个闭凸子集，在补集中选取任意一点，我们一定能够在闭凸子集中选取到其的最优逼近元</p> <p>[!tip] Theorem Let \\(B\\) be a nonempty closed convex subset of a Hilbert space \\(H\\). Let \\(x\\in H\\setminus B\\). Then there exists a unique \\(\\tilde{x}\\) in \\(B\\) such that</p> \\[\\lVert x-\\tilde{x} \\rVert =d(x,B)=\\inf\\limits_{y\\in B}\\lVert x-y \\rVert \\] <p>并且有等价条件：</p> <ul> <li>\\(\\lVert x- \\tilde{x} \\rVert=d(x,B)\\)</li> <li>\\(\\mathrm{Re}(x- \\tilde{x},b - \\tilde{x})\\leqslant 0,\\forall b\\in B\\)</li> <li>\\(\\mathrm{Re}(x-b,\\tilde{x}-b)\\geqslant 0,\\forall b\\in B\\)</li> </ul> <p>注：显然当域\\(\\mathbb{K}=\\mathbb{R}\\)时，结论会变得简单，可以去除\\(\\mathrm{Re}\\)</p> <p>推论：若是我们有两个任意的点\\(x,y\\in H\\)，那么假设\\(\\tilde{x},\\tilde{y}\\)是\\(x,y\\)在\\(B\\)的最优逼近元，相应的有</p> \\[\\lVert \\tilde{x}-\\tilde{y} \\rVert \\leqslant \\lvert x-y \\rvert\\] <p>再定义投影：</p> <p>[!NOTE] Definition (Projection Map) 设 \\(B\\) 是 Hilbert 空间 \\(H\\) 中的一个非空闭凸子集。定义 投影映射 \\(P_B : H \\to B\\)，将任意 \\(x \\in H\\) 映射为 \\(P_B(x) = \\tilde{x}\\)，其中 \\(\\tilde{x}\\) 是 \\(x\\) 在 \\(B\\) 中的 (唯一) 最佳逼近元素。</p> <p>[!TIP] Corollary (投影的连续性) Hilbert 空间 \\(H\\) 中非空闭凸子集上的投影映射 \\(P_B\\) 是连续的。事实上，\\(P_B\\) 是一个压缩映射 (contraction)，即满足：</p> \\[ \\|P_B x - P_B y\\| \\le \\|x - y\\|, \\quad \\forall x, y \\in H \\] <p><code>Proof.</code></p> <p>要证明投影是压缩的，我们需要利用投影元素的变分特征不等式（Variational Characterization）。</p> <p>回顾最佳逼近元素的性质：\\(u = P_B x\\) 当且仅当 \\(\\text{Re}\\langle x - u, z - u \\rangle \\le 0\\) 对所有 \\(z \\in B\\) 成立。</p> <p>现在设 \\(x, y \\in H\\)，并记 \\(u = P_B x, v = P_B y\\)。由于 \\(u, v \\in B\\)（凸集），我们可以分别将 \\(v\\) 代入 \\(x\\) 的不等式，将 \\(u\\) 代入 \\(y\\) 的不等式：</p> <ol> <li>\\(\\text{Re}\\langle x - u, v - u \\rangle \\le 0\\)</li> <li>\\(\\text{Re}\\langle y - v, u - v \\rangle \\le 0\\)</li> </ol> <p>将两个不等式相加：</p> \\[ \\text{Re}\\langle x - u, v - u \\rangle + \\text{Re}\\langle y - v, u - v \\rangle \\le 0 \\] <p>调整项的符号（利用内积线性）：</p> <p>$$ \\text{Re}\\langle u - x, u - v \\rangle + \\text{Re}\\langle y - v, u - v \\rangle \\le 0 $$ $$ \\text{Re}\\langle (u - x) + (y - v), u - v \\rangle \\le 0 $$ $$ \\text{Re}\\langle (u - v) - (x - y), u - v \\rangle \\le 0 $$ 展开内积： $$ |u - v|^2 - \\text{Re}\\langle x - y, u - v \\rangle \\le 0 $$ 即： $$ |u - v|^2 \\le \\text{Re}\\langle x - y, u - v \\rangle $$ 由 Cauchy-Schwarz 不等式，\\(\\text{Re}\\langle x - y, u - v \\rangle \\le |\\langle x - y, u - v \\rangle| \\le \\|x - y\\| \\|u - v\\|\\)。 因此： $$ |u - v|^2 \\le |x - y| |u - v| $$ 消去一个 \\(\\|u - v\\|\\)（若为0则显然成立），得： $$ |u - v| \\le |x - y| $$ 即 \\(\\|P_B x - P_B y\\| \\le \\|x - y\\|\\)。证毕。</p>","path":["Hilbert Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Hilbert%20Spaces/#exercise-32","level":2,"title":"Exercise 3.2","text":"<p>[!question] (4)HW5-1 Show that the projection map \\(P_{B}\\) of a nonempty closed convex subset of a Hilbert space \\(H\\) is linear if and only if \\(B\\) is a vector subspace of \\(H\\).</p> <p><code>Proof.</code></p> <p>\\(\\implies\\)</p> <p>假设\\(B\\)是\\(H\\)的一个非空闭凸子集，并且投影映射\\(P_{B}:H\\to B\\)是线性的，我们要证明\\(B\\)是\\(H\\)的向量子空间</p> <p>由于\\(P_{B}\\)是线性的，根据凸性知道投影唯一，那么根据线性映射的性质\\(P_{B}(0)=0\\)，那么可知\\(0\\in B\\)，还需证明封闭性，先说明加法封闭，\\(\\forall x,y\\in B\\)，\\(P_{B}(x+y)=x+y\\in B\\)，再来说明数乘封闭，\\(\\forall x\\in B,\\alpha\\in \\mathbb{K}\\)，那么有\\(P_{B}(x)=x\\)，利用线性性马上得到\\(P_{B}(\\alpha x)=\\alpha P_{B}(x)=\\alpha x\\)</p> <p>由此可知，\\(B\\)是\\(H\\)的一个向量子空间</p> <p>\\(\\impliedby\\)</p> <p>假设\\(B\\)是\\(H\\)的一个闭凸向量子空间，利用正交分解，\\(H=B\\oplus B^{\\perp}\\)，那么有对于任意的\\(x\\in H\\)，有唯一的\\(b\\in B,z\\in B^{\\perp}\\)使得\\(x=b+z,P_{B}(x)=b\\)</p> <p>下面来说明线性性：</p> <p>\\(\\forall x_{1},x_{2}\\in H,\\alpha\\in \\mathbb{K},x_{1}=b_{1}+z_{1},x_{2}=b_{2}+z_{2},b_{i}\\in B,z_{i}\\in B^{\\perp}\\)，那么有\\(P_{B}(x_{1})=b_{1},P_{B}(x_{2})=b_{2}\\)，并且有\\(x_{1}+x_{2}=(b_{1}+b_{2})+(z_{1}+z_{2})\\)，利用向量子空间的性质，我们知道\\(b_{1}+b_{2}\\in B,z_{1}+z_{2}\\in B^{\\perp}\\)，那么根据映射\\(P_{B}(x_{1}+x_{2})=b_{1}+b_{2}=P_{B}(x_{1})+P_{B}(x_{2})\\)</p> <p>同理有\\(P_{B}(\\alpha x_{1})=\\alpha b_{1}=\\alpha P_{B}(x_{1})\\)，综上可知线性</p> <p>结合两边得知：\\(P_{B}\\)是线性的当且仅当\\(B\\)是\\(H\\)的一个向量子空间</p>","path":["Hilbert Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Hilbert%20Spaces/#orthogonal-decomposition","level":2,"title":"Orthogonal Decomposition","text":"<p>下面研究内积空间非常重要的一个性质，也就是当内积为0的情况下称为正交的情形</p> <p>[!NOTE] Definition orthogonal 假设\\(X\\)是一个内积空间 (a) 若满足\\(\\langle x,y\\rangle=0\\)，两个\\(X\\)中元素\\(x,y\\)被称为正交可以记作\\(x\\perp y\\) (b) 若是有\\(\\forall y\\in S,x\\perp y\\implies x\\perp S\\)，将元素与集合正交的概念扩展到两个集合正交即\\(\\forall x\\in S_{1},y\\in S_{2}\\)，称两个集合正交 (c) 给出正交补的概念，若是\\(x\\in X,x^{\\perp}=\\left\\{ y\\in X:\\langle x,y\\rangle=0 \\right\\}\\)，相应的可以给出正交补空间的概念，\\(S^{\\perp}=\\left\\{ y\\in X:\\langle x, y\\rangle =0 ,\\forall x\\in S \\right\\}\\)，将\\(S^{\\perp}\\)记为\\(S\\)的正交补</p> <p>根据正交的定义显然我们知道对于正交的两个元素有\\(\\lVert x+y \\rVert^{2}=\\lVert x \\rVert^{2}+\\lVert y \\rVert^{2}\\)，反向也成立如果\\(\\mathbb{K}=\\mathbb{R}\\)</p>","path":["Hilbert Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Hilbert%20Spaces/#_1","level":3,"title":"关于正交补的性质","text":"<p>首先需要明确，对于内积空间中的任意子集 S，其正交补 \\(S^{\\perp}\\) 具有非常优良的数学性质。即便 S 本身不具备线性结构，其正交补 \\(S^{\\perp}\\) 也永远是该空间的一个闭子空间。此外，一个集合与其正交补的交集非常简单，即 \\(S \\cap S^{\\perp} = {0}\\)，因为若一个向量与自身正交，由内积的正定性可知该向量必为 0。</p> <p>在包含关系方面，正交补表现出某种“逆转”特性：如果 \\(S \\subseteq S_{1}\\)，那么 \\(S_{1}^{\\perp} \\subseteq S^{\\perp}\\)。同时，任何集合都包含在其双正交补中，即 \\(S \\subseteq S^{\\perp\\perp}\\)</p> <p>下面是一些正交补的性质：</p> <p>[!tip] 正交补的性质 设 \\(S\\) 和 \\(S_1\\) 是内积空间 \\(X\\) 的子集（注意：不一定是子空间）。</p> <ol> <li>\\(S^\\perp\\) 是 \\(X\\) 的闭子空间，且 \\(S \\cap S^\\perp = \\{0\\}\\)。</li> <li>\\(S \\subseteq S^{\\perp\\perp}\\)。</li> <li>包含关系反转：若 \\(S \\subseteq S_1\\)，则 \\(S_1^\\perp \\subseteq S^\\perp\\)。</li> <li>三次正交等于一次正交：\\(S^\\perp = S^{\\perp\\perp\\perp}\\)。</li> </ol>","path":["Hilbert Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Hilbert%20Spaces/#_2","level":3,"title":"正交分解定理","text":"<p>我们希望能够通过正交关系对于空间进行一个划分，这就引出了我们本节最重要的正交分解定理</p> <p>[!tip] Orthogonal Decomposition Theorem If \\(M\\) is a closed subspace of a Hilbert space \\(H\\), then </p> \\[H=M\\oplus M^{\\perp}\\] <p>and \\(M=M^{\\perp\\perp}\\)</p> <p>注：正交分解定理的证明深度依赖于Hilbert空间中的最佳逼近理论。根据定理 3.3.5，如果\\(M\\)是Hilbert空间\\(H\\)的一个闭子空间，那么对于空间中任意给定的向量 \\(x\\)，元素 \\(y\\) 是 \\(x\\) 在 \\(M\\) 中的最佳逼近元（即满足距离最小化），当且仅当\\((x - y) \\perp M\\)</p> <p>这一几何特征至关重要，它意味着我们可以将任意向量\\(x\\)拆解为一个位于子空间 \\(M\\) 内的分量\\(y\\)，以及一个与该子空间完全正交的分量 \\((x - y)\\)。这个 \\(y\\) 也被正式称为\\(x\\)在闭子空间 \\(M\\) 上的投影</p> <p>正交分解定理揭示了闭子空间及其正交补如何共同“张开”整个 Hilbert 空间。</p> <ol> <li>直和分解的实现：对于 \\(H\\) 中的任意元素 \\(x\\)，由于 \\(M\\) 是闭子空间，根据最佳逼近定理存在唯一的 \\(y \\in M\\) 使得它离 \\(x\\) 最近。令 \\(z = x - y\\)，根据前述的最佳逼近几何特征，\\(z\\) 必然属于 \\(M^{\\perp}\\)。因此，我们可以得到表达式 \\(x = y + z\\)。因为 \\(M \\cap M^{\\perp} = {0}\\)，这种将 \\(x\\) 分解为 \\(M\\) 元与 \\(M^{\\perp}\\) 元之和的方式是唯一的，故有 \\(H = M \\oplus M^{\\perp}\\)。</li> <li>双正交补恒等式：定理进一步指出，对于闭子空间，恒有 \\(M = M^{\\perp\\perp}\\)。虽然已知 \\(M \\subseteq M^{\\perp\\perp}\\) 总是成立，但反向包含的证明需要用到分解思想：设 \\(z \\in M^{\\perp\\perp}\\)，由于 M 是闭的，我们可以将其分解为 \\(z = z_{1} + z_{2}\\)，其中 \\(z_{1} \\in M\\) 且 \\(z_{2} \\in M^{\\perp}\\)。由于 \\(z\\) 和 \\(z_{1}\\) 都属于 \\(M^{\\perp\\perp}\\)，那么它们的差 \\(z_{2}\\) 也必须属于 \\(M^{\\perp\\perp}\\)。由于 \\(z_{2}\\) 同时属于 \\(M^{\\perp}\\) 和 \\(M^{\\perp\\perp}\\)，它只能是 0。这证明了 \\(z = z_{1} \\in M\\)，从而确立了等式。</li> </ol> <p>注：若是\\(H=M+N\\)并且\\(M\\subset N^{\\perp}\\)，那么\\(M=N^{\\perp}\\)，该结论可以采用反证法进行证明，假如\\(x\\in N^{\\perp}\\)并且\\(x\\not\\in M\\)，那么显然我们有\\(x=y+z,y\\in M,z\\in N\\)，那么我们有\\(x\\)和\\(z\\)的内积为0，得到\\(z=0\\)那么就是\\(x=y\\)与原先假设矛盾</p> <p>下面再给出正交性质和最优逼近结合的一个性质展现：</p> <p>[!abstract] Theorem (闭子空间上的最佳逼近) 设 \\(M\\) 是 Hilbert 空间 \\(H\\) 的一个闭子空间，且 \\(x \\in H\\)。\\(x\\) 在 \\(M\\) 中的最佳逼近元是唯一的元素 \\(y \\in M\\)，满足条件：</p> \\[ (x - y) \\perp M \\] <p>也就是说，误差向量 \\(x - y\\) 必须垂直于子空间 \\(M\\)。</p> <p>注：直观理解就是，如果你想在一个平面 \\(M\\) 上找一点 \\(y\\) 离平面外的点 \\(x\\) 最近，那么连线 \\(x-y\\) 必须垂直于这个平面。如果连线是斜的，你总可以在平面上移动 \\(y\\) 使得距离更近</p>","path":["Hilbert Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Hilbert%20Spaces/#exercise-33","level":2,"title":"Exercise 3.3","text":"<p>[!question] (4)HW5-2 For the Hilbert space \\(L^{2}[0,1]\\), let</p> \\[M=\\left\\{ f\\in L^{2}[0,1]: \\int_{0}^{1} f(t) \\, dt =0 \\right\\} \\] <p>Determine \\(M^{\\perp}\\). For \\(f_{0}(x)=\\exp(x)\\), determine \\(d(f_{0},M)\\).</p> <p><code>Proof.</code></p> <p>根据\\(L^{2}\\)空间的定义可知，\\(M\\)所包含的就是所有与函数\\(g(t)=1\\)正交的函数集合，根据正交补的性质我们知道\\(M=\\left\\{ g \\right\\}^{\\perp}\\implies M^{\\perp}=(\\left\\{ g \\right\\}^{\\perp})^{\\perp}=\\left\\{ g \\right\\}\\)，而\\(g(t)=1\\)所张成的空间即为常数函数空间\\(g'(t)=c\\)</p> <p>再来计算\\(d(f_{0},M)\\)</p> \\[ d(f_{0},M)=d(f_{0},\\left\\{ 1 \\right\\} ^{\\perp})=\\lvert \\langle f_{0},1 \\rangle \\rvert =\\int_{0}^{1} e^{x} \\, dx =e-1 \\] <p>[!question] (5)HW5-3 Show that if \\(\\langle x,y\\rangle=0\\) if and only if  (i) \\(\\lVert x+\\alpha y \\rVert \\geqslant \\lVert x \\rVert\\) for every \\(\\alpha\\in \\mathbb{K}\\) or  (ii) \\(\\lVert x+\\alpha y \\rVert=\\lVert x-\\alpha y \\rVert\\) for every \\(\\alpha\\in \\mathbb{K}\\)</p> <p><code>Proof.</code></p> <p>(i)</p> \\[ \\lVert x+\\alpha y \\rVert ^{2}=\\langle x+\\alpha y,x+\\alpha y\\rangle=\\lVert x \\rVert ^{2}+2\\mathrm{Re}[\\alpha\\langle x,y\\rangle]+\\lvert a \\rvert ^{2}\\lVert y \\rVert ^{2} \\] <p>必要性，当\\(\\langle x,y\\rangle=0\\)时是显然的，可以得到\\(\\lVert x+\\alpha y \\rVert^{2}=\\lVert x \\rVert^{2}+\\lvert a \\rvert^{2}\\lVert y \\rVert^{2}\\geqslant\\lVert x \\rVert^{2}\\)</p> <p>充分性，如果\\(\\lVert x+\\alpha y \\rVert\\geqslant \\lVert x \\rVert\\)对于任意的\\(\\alpha\\in \\mathbb{K}\\)均成立，若是\\(\\langle x,y\\rangle\\neq0\\)，那么显然可以通过取\\(\\alpha= \\frac{-2\\mathrm{Re[\\langle x,y\\rangle]}}{\\lVert y \\rVert^{2}}\\in \\mathbb{R}\\)使得\\(2\\alpha \\mathrm{Re}[\\langle x,y\\rangle]+\\lvert a \\rvert^{2}\\lVert y \\rVert^{2}&lt; 0\\)，与条件矛盾，由此得出必须有\\(\\mathrm{Re}[\\langle x,y\\rangle]=0\\)，再取\\(\\alpha=i\\beta\\)，可以类似的得到矛盾，由此可知\\(\\mathrm{Im}[\\langle x,y\\rangle]=0\\)，由此\\(\\langle x,y\\rangle=0\\)</p> <p>(ii)</p> \\[ \\lVert x-\\alpha y \\rVert ^{2}=\\langle x-\\alpha y,x-\\alpha y\\rangle=\\lVert x \\rVert ^{2}-2\\mathrm{Re}[\\alpha\\langle x,y\\rangle]+\\lvert a \\rvert ^{2}\\lVert y \\rVert ^{2} \\] <p>必要性，同(i)可知，当\\(\\langle x,y\\rangle=0\\)时是显然的</p> <p>充分性，直接做差取等即得</p> \\[ -2\\mathrm{Re}[\\alpha\\langle x,y\\rangle]=2\\mathrm{Re}[\\alpha\\langle x,y\\rangle] \\] <p>如果\\(\\mathbb{K}=\\mathbb{R}\\)，那么已经可以得到\\(\\langle x,y\\rangle=0\\)，如果\\(\\mathbb{K}=\\mathbb{C}\\)，需要额外使用\\(\\alpha=1,\\alpha=i\\)得到实部和虚部均为\\(0\\)，即\\(\\langle x,y\\rangle=0\\)</p>","path":["Hilbert Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Hilbert%20Spaces/#orthonormal-basis","level":2,"title":"Orthonormal basis","text":"","path":["Hilbert Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Hilbert%20Spaces/#exercise-34","level":2,"title":"Exercise 3.4","text":"","path":["Hilbert Spaces"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Some%20big%20thorems/","level":1,"title":"Some big thorems","text":"<p>[!tldr] Outline + Hahn-Banach Extension Theorem + Continuous linear functionals of a TVS + Seperation Theorems + Uniform Boundness Principle + Open Mapping Theorem and Closed Graph Theorem</p>","path":["Some big thorems"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Some%20big%20thorems/#hahn-banach-extension-theorem","level":2,"title":"Hahn-Banach Extension Theorem","text":"<p>泛函分析中最为重要的定理，没有之一，所以必须要很好的掌握</p> <p>[!tip] Hahn-Banach Extension Theorem \\(M\\) is a subspace of a normed space \\(E\\), \\(f\\) is a continuous functional on \\(M\\). Then \\(f\\) can be extended to a continuous linear functional \\(g\\) on \\(E\\) with \\(\\lVert g \\rVert=\\lVert f \\rVert\\)</p> <p><code>Proof.</code></p> <p>证明思路如下，先考虑\\(f=0\\)的平凡情况，然后下面是非零情形的证明：</p> <p><code>Step 1</code> 统一实数和复数的桥梁</p> <p>先考虑实数情况，定义\\(f\\)的实部：\\(u=\\mathrm{Re}f= \\frac{f+\\overline{f}}{2}\\)，那么很自然的我们会考虑将虚部也按照实部表示：</p> \\[ \\mathrm{Im}f=-\\mathrm{Re}f(ix)= \\frac{f- \\overline{f}}{2i}\\implies f(x)=u(x)-iu(ix) \\] <p>那么我们现在只需要说明实数成立的Hahn-Banach延拓定理即可，复数可以根据上面的变换式推出</p> <p><code>Step 2</code> 证明范数相等</p> <p>显然的会有\\(\\lVert u \\rVert\\leqslant \\lVert f \\rVert\\)，另一边我们可以考虑构造序列\\((x_{n})_{n\\in \\mathbb{N}}\\in M\\)，使得\\(\\lVert x_{n} \\rVert\\leqslant 1\\)，并且还有\\(0\\neq \\lvert f(x_{n}) \\rvert \\to \\lVert f \\rVert\\)，构造一个\\(y_{n}= \\frac{\\overline{f(x_{n})}}{\\lvert f(x_{n}) \\rvert}x_{n}\\)，那么也有\\(\\lVert y_{n} \\rVert\\leqslant 1\\)，并且容易得到\\(f(y_{n})=\\lvert f(x_{n}) \\rvert\\to \\lVert f \\rVert\\)，由于必然大于0，那么显然是实数，由此可知，\\(u(y_{n})\\to \\lVert f \\rVert\\)，根据泛函范数的定义我们知道，\\(\\lVert f \\rVert\\leqslant \\lVert u \\rVert\\)，结合两边立得\\(\\lVert u \\rVert=\\lVert f \\rVert\\)</p> <p>为了方便起见下面都假设\\(\\mathbb{K}=\\mathbb{R},\\lVert f \\rVert=1\\)</p> <p><code>Step 3</code> 延拓到\\(M\\)与某点的赋范空间</p> <p>\\(\\forall x_{0}\\notin M\\)，将\\(f\\)延拓到\\(M_{0}=span\\left\\{ M,x_{0} \\right\\},\\lVert f_{0} \\rVert_{M_{0}}=\\lVert f \\rVert_{M}\\)，我们令\\(f_{0}(x_{0})=r_{0}\\)</p> <p>我们可以通过定义得到\\(f_{0}(x+\\alpha y)=f(x)+\\alpha r_{0}\\)，所以显然有\\(\\lVert f_{0} \\rVert \\geqslant \\lVert f \\rVert\\)，那么我们需要构造一个\\(r_{0}\\)使得\\(\\lVert f_{0} \\rVert=\\lVert f \\rVert=1\\)，换句话说就是\\(\\lvert f(x)+\\alpha r_{0} \\rvert\\leqslant \\lVert x+\\alpha r_{0} \\rVert\\)</p> <p>然后两边同时除以\\(\\lvert \\alpha \\rvert\\)即可得到：</p> \\[ -f\\left( \\frac{x}{\\alpha} \\right)-\\left\\lVert  \\frac{x}{\\alpha}+x_{0}  \\right\\rVert \\leqslant r_{0} \\leqslant -f\\left( \\frac{x}{\\alpha} \\right)+\\left\\lVert  \\frac{x}{\\alpha}+x_{0}  \\right\\rVert  \\] <p>由于\\(M\\)是子空间，可以简化为下面形式：</p> \\[ -f(x)-\\lVert x+x_{0} \\rVert \\leqslant r_{0} \\leqslant -f(x)+\\lVert x+x_{0} \\rVert ,\\forall x\\in M \\] <p>我们要求对于上面的不等式有解即要求：</p> \\[ \\sup\\limits\\left\\{ -f(x)-\\lVert x+x_{0} \\rVert :x\\in M \\right\\} \\leqslant \\inf\\left\\{ -f(y)+\\lVert y+x_{0} \\rVert  :y\\in M\\right\\}  \\] <p>因此任何满足上面不等式条件的\\(r_{0}\\)均可以，而上面的等式是显然成立的，因为：</p> \\[ \\begin{aligned} f(y)-f(x)&amp;=f(y-x)\\\\ &amp;\\leqslant \\lVert y-x \\rVert \\\\ &amp;\\leqslant\\lVert y+x_{0} \\rVert +\\lVert x+x_{0} \\rVert  \\end{aligned} \\] <p>第一个不等号是因为我们假设了\\(\\lVert f \\rVert=1\\)，第二个不等号是因为三角不等式，综上也就是说我们可以将\\(f\\)延拓到\\(M_{0}\\)上了，下面来说明可以延拓到\\(E\\)上：</p> <p><code>Step 4</code> 延拓到\\(E\\)</p> <p>具体的思路可以参考补充的张恭庆《泛函分析讲义》，下面直接给出构造：</p> \\[ \\mathscr{F}=\\left\\{ (h,H) \\right\\}  \\] <p>这个集合的\\(H\\)是\\(E\\)的子空间，\\(h\\)是定义在其上的连续线性泛函，满足相应的函数值相等和范数相等(1)，我们定义相关的序关系(显然\\(\\mathscr{F}\\)非空因为\\((f,M)\\subset \\mathscr{F}\\))：</p> \\[ (h_{1},H_{1})\\prec (h_{2},H_{2}),if\\ H_{1}\\subset H_{2},h_{2}|_{H_{1}}=h_{1} \\] <p>根据一个全序子集\\(C\\)构造，\\(K=\\bigcup\\limits_{(h,H)\\in C}H,k:K\\to \\mathbb{K}\\)，显然\\(k\\)也是连续线性泛函，那么我们可以知道\\((k,K)\\)是一个\\(C\\)在\\(\\mathscr{F}\\)的上界</p> <p>那么利用Zorn引理可以得到\\((g,G)\\)是\\(\\mathscr{F}\\)的最大元，我们只需要说明\\(G\\)是\\(E\\)即可，可以使用反证法，那么仿照<code>Step 3</code>的做法，我们可以延拓一个更大的集合\\(G_{0}\\)，那么与最大元矛盾，从而我们可以知道\\(g\\)是定义在\\(E\\)的连续线性泛函\\(f\\)的延拓，并且\\(\\lVert g \\rVert=\\lVert f \\rVert\\)</p> <p>[!cite] 张恭庆的补充 直接证明是一种比较粗暴且缺乏动机的做法，数学中常见的做法是从简单的情况出发，然后将定理条件放宽，得到更加general的形式，在此cite张恭庆老师的《泛函分析讲义》中有关线性泛函的延拓定理的部分内容供增进理解和参考</p> <p>[!info] 实Hahn-Banach定理 为了统一记号做了一些修改，\\(E\\)是实线性空间，\\(p\\)是\\(E\\)上的次线性泛函，\\(M\\)是\\(E\\)的实线性子空间，\\(f\\)是\\(M\\)的实线性泛函且\\(f\\leqslant p,\\forall x\\in M\\)，那么在\\(E\\)上一定存在一个实线性泛函\\(g\\)使得： (1)\\(g\\leqslant p,\\forall x\\in E\\) (2)\\(g(x)=f(x),\\forall x\\in M\\)</p> <p><code>Proof.</code></p> <p>\\(\\forall y\\in E\\setminus M\\)，记\\(M'=\\left\\{ x+\\alpha y,x\\in M,\\alpha\\in \\mathbb{R} \\right\\}\\)，我们的证明目标是将\\(M\\)上的函数\\(f\\)延拓到\\(E\\)上，我们知道\\(E\\)可以由若干个\\(M'\\)构成，我们可以先尝试延拓到\\(M'\\)上</p> <p>将延拓后的函数记为\\(f_{1}\\)那么有：</p> \\[ f_{1}(x+\\alpha y)=f(x)+\\alpha f_{1}(y),\\forall x\\in M,\\alpha\\in \\mathbb{R} \\] <p>根据题目要求的受到控制条件，我们有\\(f_{1}(x+\\alpha y)\\leqslant p(x+\\alpha y)\\)，可以通过上式两边同时除以\\(\\lvert \\alpha \\rvert\\)，从而推出如下结论(对\\(\\alpha\\)的正负性进行讨论)：</p> \\[ \\begin{aligned} \\frac{1}{\\lvert \\alpha \\rvert } f_{1}(x+\\alpha y)&amp;=f_{1}(x'+y)\\leqslant p(x'+y),\\forall x'\\in M\\\\ \\frac{1}{\\lvert \\alpha \\rvert } f_{1}(x+\\alpha y)&amp;=f_{1}(x'-y)\\leqslant p(x'-y),\\forall x'\\in M \\end{aligned} \\] <p>结合上述两个不等式可以推出：</p> \\[ f(x')-p(x'-y) \\leqslant f_{1}(y)\\leqslant p(x'+y)-f(x')=p(-x''+y)+f(x'') \\] <p>要想使得结论成立，必须要有：</p> \\[ \\sup\\limits_{x'\\in M}\\left\\{ f(x')-p(x'-y) \\right\\} \\leqslant \\inf\\limits_{x''\\in M}\\left\\{ f(x'')+p(-x''+y) \\right\\}  \\] <p>这实际是必然成立的，因为\\(\\forall x',x''\\in M\\)有：</p> \\[ \\begin{aligned} f(x')-f(x'')&amp;=f(x'-x'')\\\\ &amp;\\leqslant p(x'-x'')\\\\ &amp; \\leqslant p(x'-y)+p(-x''+y) \\end{aligned} \\] <p>因此这种延拓是存在的，且不唯一(如果不等式不取等号的话)，剩下的问题就是如何从\\(M'\\)过度到\\(E\\)，需要利用Zorn引理</p> <p>我们先构造一个半序集：</p> \\[ \\mathscr{F}=\\left\\{ (M_{\\Delta},f_{\\Delta})|M\\subset M_{\\Delta}\\subset E;f_{\\Delta}=f,x\\in M;f_{\\Delta}\\leqslant p,x\\in M_{\\Delta} \\right\\}  \\] <p>序关系按照一般的定义：</p> \\[ (M_{\\Delta_{1}},f_{\\Delta_{1}})\\prec (M_{\\Delta_{2}},f_{\\Delta_{2}})\\implies M_{\\Delta_{1}}\\subset M_{\\Delta_{2}},f_{\\Delta_{1}}=f_{\\Delta_{2}},x\\in M_{\\Delta_{1}} \\] <p>设\\(K\\)是\\(\\mathscr{F}\\)中的任一个全序子集，那么令\\(M_{K}=\\bigcup\\limits_{(M_{\\Delta},f_{\\Delta})\\in K}\\left\\{ M_{\\Delta} \\right\\}\\)</p> <p>所以\\(M_{K}\\)是\\(E\\)中包含\\(M\\)的子空间，且\\(f_{K}\\)唯一确定(\\(f_{K}=f_{\\Delta}\\))，\\(f_{K}\\leqslant p\\)，根据Zorn引理\\(\\mathscr{F}\\)本身存在极大元，下面只需要说明那个极大元就是\\(E\\)即可，使用反证法，如若不然，可以构造出另一个\\(\\mathscr{F}\\)中元素使得出现更大元，由此证毕</p> <p>[!NOTE] Riesz representation theorem Every bounded linear functional \\(F\\in C[a,b]^{*}\\) if given by a unique normalized function \\(f\\in BV[a,b]\\) such that</p> \\[F(x)=\\int_{a}^{b} x(t)df(t),\\forall x\\in C[a,b] \\] <p>Moreover, \\(\\lVert F \\rVert=V(f)\\)</p> <p><code>Proof.</code></p> <p>这个定理将泛函分析中的线性泛函和实分析中的有界变差函数联系起来，我个人理解这个定理的含义就是说：任何线性泛函\\(F(x)\\)都可以表示为对\\(x(t)\\)的加权积分，而\\(df(t)\\)需要使用到\\(Riemann-Stieltijes\\)积分</p>","path":["Some big thorems"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Some%20big%20thorems/#continuous-linear-functionals-of-a-tvs","level":2,"title":"Continuous linear functionals of a TVS","text":"","path":["Some big thorems"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Some%20big%20thorems/#exercise-52","level":2,"title":"Exercise 5.2","text":"<p>(1) Show that the convex hull of a balanced set is balanced. Give a counter example that the balanced hull of a convex set might not be convex.</p> <p>(2) Show that \\(0 \\in A\\) if \\(A\\) is an absorbing set or a balanced set of a vector space \\(X\\).</p> <p>(3)</p> <p>Show that every neighborhood \\(V\\) of zero in a TVS \\(X\\) is an absorbing set.</p> <p><code>Proof.</code></p> <p>先回顾定义然后再完成证明</p> <p>1. 定义回顾</p> <ul> <li>拓扑向量空间 (TVS)：在这类空间中，向量加法和标量乘法都是连续映射。特别是，标量乘法映射 \\(\\Phi: \\mathbb{K} \\times X \\to X\\) 定义为 \\((\\lambda, x) \\mapsto \\lambda x\\) 是连续的。</li> <li>吸收集 (Absorbing Set)：集合 \\(A \\subseteq X\\) 被称为吸收集，如果对于空间中的任意向量 \\(x \\in X\\)，都存在一个实数 \\(\\delta &gt; 0\\)，使得当标量 \\(\\lambda\\) 满足 \\(|\\lambda| \\le \\delta\\) 时，都有 \\(\\lambda x \\in A\\)。</li> </ul> <p>2. 详细证明</p> <p>只需要根据定义验证即可：</p> <p>首先任取\\(X\\)中的向量\\(x\\)，我们希望对于这个\\(x\\)能够找到一个常数\\(\\delta\\)使得\\(\\delta x\\)被\\(V\\)所吸收，考虑连续性，构造一个映射\\(f:\\mathbb{K}\\to X\\)，\\(f(\\lambda)=\\lambda x\\)，其中有\\(\\lambda\\in \\mathbb{K},x\\in X\\)，显然在TVS中这是一个连续函数，那么考虑\\(\\lambda=0\\)时有\\(f(0)=0\\)，根据邻域和连续函数的定义可知\\(f^{-1}(V)\\)必然是\\(0\\)的一个邻域，而关于0的任何邻域一定存在一个以0为中心的开球，因此我们可以知道存在\\(\\delta&gt;0\\)，使得\\(\\lvert \\lambda \\rvert&lt;\\delta\\)的情况下，\\(\\lambda x\\in V\\)，由此即证</p> <p>(4) Let \\(A = \\{x = (x_1, x_2) \\in \\mathbb{R}^2 : |x_1| \\le x_2^2, \\text{ or } x_1 = 0, |x_2| \\le 1\\}\\). Show that \\(A\\) is absorbing. Let \\(\\rho_A\\) be the sublinear functional of \\(\\mathbb{R}^2\\) associated with \\(A\\). Draw the sets \\(\\{x \\in \\mathbb{R}^2 : \\rho_A(x) &lt; 1\\}\\), \\(\\{x \\in \\mathbb{R}^2 : \\rho_A(x) \\le 1\\}\\) and the interior \\(\\text{int } A\\) of \\(A\\). Is \\(\\text{int } A\\) an absorbing set in \\(\\mathbb{R}^2\\)?</p> <p>(5) Let \\(A = \\{x = (x_1, x_2) \\in \\mathbb{R}^2 : \\|x\\|_2 \\le 1/2 \\text{ or } \\|x\\|_2 = 1\\}\\). Show that the gauge \\(\\rho_A\\) of the non-convex set \\(A\\) agrees with the norm \\(\\|\\cdot\\|_2\\) of \\(\\mathbb{R}^2\\).</p> <p><code>Proof.</code></p> <p>首先考虑集合 \\(A\\) 的几何形状：它是以原点为中心半径小于等于\\(\\frac{1}{2}\\)的闭球与以原点为中心半径等于\\(1\\)的单位圆周的并集</p> <p>仍然是根据定义证明，闵可夫斯基泛函（Gauge）的定义为：</p> \\[ \\rho_A(x) = \\inf \\{ \\lambda &gt; 0 : x \\in \\lambda A \\} = \\inf \\{ \\lambda &gt; 0 : \\frac{x}{\\lambda} \\in A \\} \\] <p>我们需要证明对于任意 \\(x \\in \\mathbb{R}^2\\)，有 \\(\\rho_A(x) = \\|x\\|_2\\)。</p> <p>\\(x=0\\)时显然，根据定义 \\(\\rho_A(0) = 0\\)，且范数 \\(\\|0\\|_2 = 0\\)。\\(x \\neq 0\\)，令 \\(r = \\|x\\|_2 &gt; 0\\)。我们需要考察使得 \\(\\frac{x}{\\lambda} \\in A\\) 成立的 \\(\\lambda &gt; 0\\) 的集合。</p> \\[ \\left\\| \\frac{x}{\\lambda} \\right\\|_2 \\le \\frac{1}{2} \\quad \\text{or} \\quad \\left\\| \\frac{x}{\\lambda} \\right\\|_2 = 1 \\iff \\frac{r}{\\lambda} \\le \\frac{1}{2} \\quad \\text{or} \\quad \\frac{r}{\\lambda} = 1  \\] <p>因此，使得 \\(x \\in \\lambda A\\) 成立的 \\(\\lambda\\) 的集合为：</p> \\[ S = \\{ \\lambda : \\lambda = r \\} \\cup [2r, +\\infty) $$ 显然： $$ \\inf S = \\min \\{ r, 2r \\} = r \\] <p>因为 \\(r = \\|x\\|_2\\)，所以我们得到： $$ \\rho_A(x) = |x|_2 $$</p> <p>[!cite] Ans. PROOF. For any \\(0 \\neq x_0 \\in \\mathbb{R}^2\\), we have that \\(x_0 \\in \\|x_0\\|_2 A\\), which shows that \\(\\rho_A(x_0) \\le \\|x\\|_2\\). On the other hand, if \\(\\lambda &lt; \\|x_0\\|\\), we have that \\(\\|\\lambda a\\| \\le \\lambda &lt; \\|x_0\\|\\) for each \\(a \\in A\\), which implies that \\(x_0 \\notin \\lambda A\\). Therefore, \\(\\rho_A(x_0) = \\|x_0\\|_2\\). \\(\\square\\)</p> <p>尽管集合 \\(A\\) 缺失了半径在 \\((1/2, 1)\\) 之间的部分，导致它不是凸集，但由于它包含了单位圆周（\\(\\|x\\|_2=1\\)），使得 \\(\\lambda = \\|x\\|_2\\) 始终是一个合法的缩放因子。这个因子比将向量压缩进内部小球（\\(B[0, 1/2]\\)）所需的缩放因子（\\(\\lambda \\ge 2\\|x\\|_2\\)）要小。因此，下确界由外部边界决定，正好等于欧几里得范数</p> <p>(6) Let \\(h\\) be a sublinear functional of a real vector space \\(X\\). Prove that \\(\\rho(x) = \\max \\{h(x), h(-x)\\}\\) is a seminorm of \\(X\\).</p> <p>(7) Let \\(c_{00}\\) be the vector space of scalar sequences \\((x_n)_n\\) in which at most finitely many terms \\(x_n\\)'s are nonzero. Equip \\(c_{00}\\) with the supnorm \\(\\|(x_n)_n\\|_\\infty = \\sup_n |x_n|\\). Let \\(A = \\{(x_n)_n \\in c_{00} : |x_n| &lt; 1/n \\text{ for } n = 1, 2, \\dots\\}\\). Show that \\(A\\) is an absolutely convex and absorbing set in \\(c_{00}\\), but it is not a norm neighborhood of zero.</p> <p>(8) Show that (5.7) holds for any absorbing set \\(V\\) in a TVS \\(X\\). Give examples such that both inclusions can be strict. Show that if \\(q\\) is a seminorm of \\(X\\) such that $$ {x \\in X : q(x) &lt; 1} \\subseteq V \\subseteq {x \\in X : q(x) \\le 1} $$ then \\(q = \\rho_V\\).</p> <p>(9) Prove Lemma 5.2.4.</p>","path":["Some big thorems"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Some%20big%20thorems/#seperation-theorems","level":2,"title":"Seperation Theorems","text":"","path":["Some big thorems"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Some%20big%20thorems/#uniform-boundness-principle","level":2,"title":"Uniform Boundness Principle","text":"<p>先给出一致有界定理(有时也被称作是\\(Banach-Steinhaus\\)定理)的内容：</p> <p>[!tip] Uniform Boundness Principle Let \\(E\\) be a Banach space and \\(F\\) a normed space. Let \\(\\left\\{ T_{\\lambda} \\right\\}_{\\lambda\\in\\Lambda}\\subseteq B(E,F)\\) be a family of bounded continuous linear operators. Then the following are equivalent:</p> <p>(1) \\(\\left\\{ T_{\\lambda}:\\lambda\\in\\Lambda \\right\\}\\) is uniformly bounded; (2) \\(\\left\\{ T_{\\lambda}:\\lambda\\in\\Lambda \\right\\}\\) is pointwise bounded</p> <p>In other words, if for each \\(x\\) in \\(E\\), there is an \\(M(x)&gt; 0\\) such that</p> <p>$\\(\\lVert T_{\\lambda}x \\rVert \\leqslant M(x),\\forall\\lambda\\in\\Lambda\\)$</p> <p>then there is a constant \\(0&lt;M &lt;+\\infty\\) such that </p> <p>$\\(\\lVert T_{\\lambda} \\rVert \\leqslant M,\\forall\\lambda\\in\\Lambda\\)$</p> <p>让我们听听<code>Gemini3</code>如何零基础讲解这个定理：</p> <p>这个定理叫一致有界性原理 (Uniform Boundedness Principle, UBP)，也被称为 Banach-Steinhaus 定理。它是泛函分析中“三大定理”之一（另外两个是开映射定理和Hahn-Banach定理），非常核心。</p> <p>通俗地说，这个定理告诉我们：“如果你能对每一个单独的点都保持有界，那么在某种条件下，你整体上就是有界的。”</p> <p>下面我为你拆解里面的重要名词，然后再解释定理在说什么。</p> <p>(1) Normed Space (赋范空间) \\(F\\) *   通俗理解：给向量空间装了一把“尺子”。 *   定义：在这个空间里，每一个向量 \\(x\\) 都有一个对应的非负实数，叫范数 (Norm)，记作 \\(\\|x\\|\\)。你可以把它理解为向量的“长度”。有了范数，我们就可以讨论收敛、极限和距离了。</p> <p>(2) Banach Space (巴拿赫空间) \\(E\\) *   通俗理解：一个没有“漏洞”的赋范空间。 *   定义：它首先是一个赋范空间，其次它是完备的 (Complete)。     *   什么是完备？ 意思是如果你有一个柯西序列（一串越来越靠近彼此的向量），那么它们的极限点一定还在这个空间里，不会跑出去。     *   例子：实数集 \\(\\mathbb{R}\\) 是完备的（Banach空间），但有理数集 \\(\\mathbb{Q}\\) 就不是（因为有理数序列可以收敛到 \\(\\sqrt{2}\\)，而 \\(\\sqrt{2}\\) 不在 \\(\\mathbb{Q}\\) 里）。     *   为什么重要？ 这个定理成立的关键就在于 \\(E\\) 必须是 Banach 空间。如果是普通赋范空间，定理不一定成立。</p> <p>(3) Linear Operator (线性算子) \\(T_\\lambda\\) *   通俗理解：一个保持结构的函数。 *   定义：从空间 \\(E\\) 射到空间 \\(F\\) 的映射 \\(T\\)。它满足 \\(T(x+y) = T(x)+T(y)\\) 和 \\(T(\\alpha x) = \\alpha T(x)\\)。简单说就是：输入的叠加等于输出的叠加。</p> <p>(4) Bounded Operator (有界算子) *   通俗理解：不会把输入“无限放大”的算子。 *   定义：存在一个常数 \\(C\\)，使得对于所有向量 \\(x\\)，都有 \\(\\|Tx\\| \\le C\\|x\\|\\)。 *   算子范数 \\(\\|T\\|\\)：这个 \\(C\\) 的最小值就是算子的范数 \\(\\|T\\|\\)。它代表了这个算子的“最大放大倍率”。在泛函分析中，线性算子的“连续性”和“有界性”是等价的。</p> <p>这个定理最精彩的地方在于区分并联系了两种不同的有界性：</p> <p>概念 A：逐点有界 (Pointwise Bounded) *   对应原文：Condition (2) 和 \"\\(M(x) &gt; 0\\)\" 那部分。 *   含义：固定住一个向量 \\(x\\)。     当我们用这一堆算子 \\(\\{T_\\lambda\\}\\) 去作用于同一个 \\(x\\) 时，得到的输出结果 \\(\\|T_\\lambda x\\|\\) 不会趋向于无穷大。     *   注意：对于不同的 \\(x\\)，这个界限 \\(M(x)\\) 可以不一样。比如对于 \\(x_1\\)，所有算子输出都不超过 10；对于 \\(x_2\\)，所有算子输出都不超过 10000。只要是有限的就行。</p> <p>概念 B：一致有界 (Uniformly Bounded) *   对应原文：Condition (1) 和 \"\\(M &lt; +\\infty\\)\" 那部分。 *   含义：不看具体的 \\(x\\)，只看算子本身。     这堆算子 \\(\\{T_\\lambda\\}\\) 每一个都有一个“最大放大倍率” \\(\\|T_\\lambda\\|\\)。一致有界是指，这些放大倍率有一个共同的天花板 \\(M\\)。     *   这意味着，不管你取哪个算子，它的范数都不会超过 \\(M\\)。</p> <p>一致有界性原理在说什么？</p> <p>它说：只要你的定义域 \\(E\\) 是一个 Banach 空间（这很重要，空间不能有漏洞），那么：</p> <p>如果你这帮算子，在每一个单独的向量 \\(x\\) 上产生的效果都是有限的（逐点有界），那么这帮算子整体的“放大能力”一定有一个共同的上限（一致有界）。</p> <p>为什么要专门提这个定理？</p> <p>因为从直觉上讲，(2) 推不出 (1) 似乎是很正常的。</p> <ul> <li>直觉陷阱：想象一堆算子，第 1 个把 \\(x\\) 放大 1 倍，第 2 个把 \\(x\\) 放大 2 倍……第 \\(n\\) 个把 \\(x\\) 放大 \\(n\\) 倍。对于任何固定的 \\(x\\)，这似乎都是有限数值，但算子的倍率 \\(n\\) 却趋向无穷大。</li> <li>定理的反转：UBP 告诉我们，在 Banach 空间里，上述这种“坏情况”是不可能发生的。如果每一个点 \\(x\\) 都没有被无限放大，那么算子序列的范数就不可能趋于无穷。</li> </ul>","path":["Some big thorems"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Some%20big%20thorems/#exercise-54","level":2,"title":"Exercise 5.4","text":"<p>(1) Let \\(X\\) be a Banach space, \\(Y\\) a normed space, and \\(T_n : X \\to Y\\) (\\(n \\in \\mathbb{N}\\)) a sequence of linear continuous operators. Prove that the following conditions are equivalent:</p> <p>(a) If \\(\\sum_{n=1}^\\infty x_n\\) converges in norm, then \\(T_n(x_n) \\to 0\\) in norm; (b) \\(\\sup_{n\\in\\mathbb{N}} \\|T_n\\| &lt; \\infty\\).</p> <p><code>Proof.</code></p> <p>\\((b) \\Rightarrow (a)\\)</p> <p>假设条件 (b) 成立，即存在常数 \\(M &gt; 0\\) 使得对于所有 \\(n \\in \\mathbb{N}\\)，都有 \\(\\|T_n\\| \\le M\\)。假设级数 \\(\\sum_{n=1}^\\infty x_n\\) 在 \\(X\\) 中收敛。根据级数收敛的必要条件，通项趋于零，并且由于 \\(T_n\\) 是线性的且受范数控制，我们有：</p> \\[ \\|T_n(x_n)\\| \\le \\|T_n\\| \\cdot \\|x_n\\| \\le M \\|x_n\\| \\] <p>因为当 \\(n \\to \\infty\\) 时 \\(\\|x_n\\| \\to 0\\)，所以 \\(M\\|x_n\\| \\to 0\\)。</p> <p>根据夹逼定理，\\(\\|T_n(x_n)\\| \\to 0\\)，即 \\(T_n(x_n) \\to 0\\) 在范数下成立。</p> <p>\\((a) \\Rightarrow (b)\\)</p> <p>我们将使用反证法。假设 (b) 不成立，即算子序列不是一致有界的：</p> \\[ \\sup_{n\\in\\mathbb{N}} \\|T_n\\| = \\infty \\] <p>这意味着我们可以选取一个子序列 \\(\\{T_{n_k}\\}\\)，使得 \\(\\|T_{n_k}\\|\\) 增长得足够快。具体来说，我们可以归纳地选取下标 \\(n_k\\)，使得 \\(\\|T_{n_k}\\| &gt; k^3\\)。</p> <p>对于每个 \\(k\\)，根据算子范数的定义，存在单位向量 \\(u_k \\in X\\)（即 \\(\\|u_k\\|=1\\)）使得：</p> \\[ \\|T_{n_k}(u_k)\\| \\ge \\frac{1}{2} \\|T_{n_k}\\| &gt; \\frac{k^3}{2} \\] <p>现在，我们构造一个序列 \\((x_n)\\) 如下：</p> <ul> <li>当 \\(n = n_k\\) 时，令 \\(x_{n_k} = \\frac{1}{k^2} u_k\\)；</li> <li>当 \\(n \\neq n_k\\)（即 \\(n\\) 不在子序列下标中）时，令 \\(x_n = 0\\)。</li> </ul> <p>首先检查 \\(\\sum x_n\\) 是否收敛。考察其范数和：</p> \\[ \\sum_{n=1}^\\infty \\|x_n\\| = \\sum_{k=1}^\\infty \\|x_{n_k}\\| = \\sum_{k=1}^\\infty \\left\\| \\frac{1}{k^2} u_k \\right\\| = \\sum_{k=1}^\\infty \\frac{1}{k^2} \\] <p>由于级数 \\(\\sum \\frac{1}{k^2}\\) 收敛，且 \\(X\\) 是Banach 空间，因此级数 \\(\\sum_{n=1}^\\infty x_n\\) 在 \\(X\\) 中收敛。这满足了条件(a)。</p> <p>然而，考察像序列 \\(T_n(x_n)\\) 在 \\(n=n_k\\) 时的行为：</p> \\[ \\|T_{n_k}(x_{n_k})\\| = \\left\\| T_{n_k}\\left(\\frac{1}{k^2} u_k\\right) \\right\\| = \\frac{1}{k^2} \\|T_{n_k}(u_k)\\| &gt; \\frac{1}{k^2} \\cdot \\frac{k^3}{2} = \\frac{k}{2} \\] <p>当 \\(k \\to \\infty\\) 时，\\(\\frac{k}{2} \\to \\infty\\)，因此 \\(\\|T_{n_k}(x_{n_k})\\| \\to \\infty\\)。</p> <p>这就意味着序列 \\(T_n(x_n)\\) 甚至不是有界的，更不可能收敛到 0。</p> <p>这与条件 (a) 矛盾。因此假设不成立，即证</p> <p>(2) Let \\(X\\) be a normed space, and \\((x_n)_{n\\in\\mathbb{N}} \\subseteq X\\) with the property that</p> \\[ \\sum_{n=1}^\\infty |x^*(x_n)| &lt; \\infty, \\quad \\forall x^* \\in X^*. \\] <p>Prove that</p> \\[ \\sup_{\\|x^*\\|\\le 1} \\sum_{n=1}^\\infty |x^*(x_n)| &lt; \\infty. \\] <p><code>Proof.</code></p> <p>这道题是一致有界性原理 (Uniform Boundedness Principle, Banach-Steinhaus Theorem)的一个经典应用。</p> <p>我们要证明的是对偶空间单位球上级数和的一致有界性。观察题目中给出的条件，对于任意固定的线性泛函，其作用在序列上得到的数值序列是绝对收敛的，这提示我们可以利用序列空间 \\(\\ell_1\\) 的性质来处理。</p> <p>首先定义一个从对偶空间 \\(X^*\\) 到序列空间 \\(\\ell_1\\) 的映射 \\(T\\)，将每一个泛函 \\(x^*\\) 映射为数列 \\((x^*(x_n))\\)。由题目假设可知，对于任意的 \\(x^*\\)，该数列的各项绝对值之和是有限的，因此 \\(T\\) 的像确实落在 \\(\\ell_1\\) 空间内。</p> <p>为了证明 \\(T\\) 的有界性，我们引入一列截断算子 \\(T_k\\)。对于每个正整数 \\(k\\)，定义 \\(T_k\\) 为只取前 \\(k\\) 项数值、后续项均为零的映射。由于 \\(T_k(x^*)\\) 只是有限项的线性组合，且每个 \\(x_n\\) 在赋范空间中都是固定的向量，因此每一个 \\(T_k\\) 显然都是从 \\(X^*\\) 到 \\(\\ell_1\\) 的连续线性算子。</p> <p>接下来考察这一列算子的收敛性。根据已知条件，对于任意固定的 \\(x^*\\)，级数 \\(\\sum |x^*(x_n)|\\) 是收敛的。这意味着当截断项数 \\(k\\) 趋于无穷大时，序列 \\(T_k(x^*)\\) 在 \\(\\ell_1\\) 的范数意义下收敛于 \\(T(x^*)\\)。既然序列逐点收敛，那么对于每一个 \\(x^*\\)，算子序列 \\(\\{T_k(x^*)\\}\\) 都是有界的。</p> <p>此时我们满足了应用一致有界性原理的所有条件：\\(X^*\\) 作为赋范空间的对偶空间必然是 Banach 空间，且我们有一列定义在 \\(X^*\\) 上的连续线性算子 \\(\\{T_k\\}\\) 逐点收敛。根据一致有界性原理（Banach-Steinhaus 定理），这列算子的极限算子 \\(T\\) 必然也是有界线性算子。</p> <p>最后，算子 \\(T\\) 的范数定义为单位球上像的范数的上确界，即 \\(\\sup_{\\|x^*\\| \\le 1} \\sum |x^*(x_n)|\\)。既然我们已经证明了 \\(T\\) 是有界算子，那么这个上确界必然是有限的，从而得证。</p> <p>[!cite] Ans.  令 \\(T : X^* \\to \\ell_1\\) 定义为</p> \\[ T(x^*) = (x^*(x_n))_{n\\in\\mathbb{N}}. \\] <p>假设条件保证了 \\(T(x^*) \\in \\ell_1\\)。令 \\(T_n : X^* \\to \\ell_1\\) 定义为</p> \\[ T_n(x^*) = (x^*(x_1), \\dots, x^*(x_n), 0, \\dots). \\] <p>那么对于每一个 \\(x^* \\in X^*\\)，由于级数 \\(\\sum_{n=1}^\\infty |x^*(x_n)|\\) 收敛，推得 \\(\\sum_{k=n+1}^\\infty |x^*(x_k)| \\to 0\\)，即对于每一个 \\(x^* \\in X^*\\) 都有 \\(T_n(x^*) \\to T(x^*)\\)。 \\(T_n\\) 是线性连续的（因为 \\(\\|T_n\\| \\le \\sum_{k=1}^n \\|x_k\\|\\)），且 \\(X^*\\) 是一个 Banach 空间，由一致有界性原理可知 \\(T\\) 是线性且连续的。我们有</p> \\[ \\|T\\| = \\sup_{\\|x^*\\|\\le 1} \\|T(x^*)\\|_{\\ell_1} = \\sup_{\\|x^*\\|\\le 1} \\sum_{n=1}^\\infty |x^*(x_n)| \\] <p>并且 \\(\\|T\\| &lt; \\infty\\)。 \\(\\square\\)</p> <p>(3) Let \\(1 &lt; p &lt; \\infty\\), and \\(1 &lt; q &lt; \\infty\\) be the conjugate of \\(p\\), that is, \\(\\frac{1}{p} + \\frac{1}{q} = 1\\). Let \\(X = (C[0, 1], \\|\\cdot\\|_p)\\), where $$ |f|p = (\\int_0^1 |f(x)|^p dx)^{\\frac{1}{p}}, \\quad \\forall f \\in C[0, 1]. $$ Let \\((b_n)_{n\\in\\mathbb{N}} \\subseteq [0, 1], (c_n)_{n\\in\\mathbb{N}} \\subseteq [0, 1]\\) with \\(b_n \\le c_n\\) for each \\(n \\in \\mathbb{N}\\). Let \\((a_n)_{n\\in\\mathbb{N}} \\subseteq \\mathbb{K}\\). For any \\(n \\in \\mathbb{N}\\), define \\(x_n^* : X \\to \\mathbb{K}\\) by $$ x_n^*(f) = a_n \\int f(x)dx, \\quad \\forall f \\in C[0, 1]. $$ (a) Prove that }^{c_n\\(x_n^* \\in X^*\\) for each \\(n \\in \\mathbb{N}\\). (b) Prove that the sequence \\((x_n^*)_{n\\in\\mathbb{N}} \\subseteq X^*\\) is pointwise bounded if and only if \\((a_n(c_n - b_n))_{n\\in\\mathbb{N}}\\) is bounded. (c) Prove that the sequence \\((x_n^*)_{n\\in\\mathbb{N}} \\subseteq X^*\\) is uniformly bounded if and only if \\((a_n(c_n - b_n)^{1/q})_{n\\in\\mathbb{N}}\\) is bounded. (d) Prove that we can find \\((z_n^*)_{n\\in\\mathbb{N}} \\subseteq X^*\\) pointwise bounded which is not uniformly bounded.</p>","path":["Some big thorems"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/Some%20big%20thorems/#open-mapping-theorem-and-closed-graph-theorem","level":2,"title":"Open Mapping Theorem and Closed Graph Theorem","text":"","path":["Some big thorems"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%902020-2021%E6%9C%9F%E6%9C%AB/","level":1,"title":"泛函分析2020-2021期末","text":"<p>[!question] (1) 一. （15 分） 设 \\(A_1\\) 和 \\(A_2\\) 是度量空间 \\(X\\) 中的两个集合，记 \\(d(A_1, A_2) = \\inf\\limits_{x\\in A_1, y\\in A_2} d(x, y)\\)。证明存在 \\(X\\) 中的不交开集 \\(G_1, G_2\\), 分别包含 \\(A_1, A_2\\)。</p> <p>考察度量空间中集合的分离性质。注意：对于一般的集合 \\(A_1, A_2\\)，该结论成立的前提通常是 \\(d(A_1, A_2) &gt; 0\\)。如果距离为 0，例如在 \\(\\mathbb{R}\\) 中有理数集和无理数集，则不存在这样的开集。基于题目形式，我们假设 \\(d(A_1, A_2) &gt; 0\\) 进行证明。</p> <p><code>Proof.</code></p> <p>证明思路： 利用距离函数构造开邻域。如果两个集合之间的距离 \\(r = d(A_1, A_2) &gt; 0\\)，我们可以以 \\(A_1\\) 中的点为中心，半径小于 \\(r/2\\) 的球的并集作为 \\(G_1\\)，同理构造 \\(G_2\\)。利用三角不等式证明这两个开集不相交。</p> <p>详细证明： 记 \\(r = d(A_1, A_2)\\)。根据题目结论的有效性，我们假设 \\(r &gt; 0\\)。</p> <p>定义 \\(G_1\\) 和 \\(G_2\\) 如下：</p> \\[\\begin{aligned}  G_1 &amp;= \\{z \\in X : d(z, A_1) &lt; \\frac{r}{2} \\} = \\bigcup_{x \\in A_1} U(x, \\frac{r}{2}) \\\\ G_2 &amp;= \\{z \\in X : d(z, A_2) &lt; \\frac{r}{2} \\} = \\bigcup_{y \\in A_2} U(y, \\frac{r}{2})  \\end{aligned}\\] <p>其中 \\(U(x, \\delta)\\) 表示以 \\(x\\) 为心、\\(\\delta\\) 为半径的开球。显然 \\(G_1\\) 和 \\(G_2\\) 是开集（开球的并），且 \\(A_1 \\subset G_1\\), \\(A_2 \\subset G_2\\)。下面证明 \\(G_1 \\cap G_2 = \\emptyset\\)。</p> <p>用反证法。假设存在 \\(z \\in G_1 \\cap G_2\\)。由 \\(z \\in G_1\\)，存在 \\(x \\in A_1\\) 使得 \\(d(z, x) &lt; \\frac{r}{2}\\)。由 \\(z \\in G_2\\)，存在 \\(y \\in A_2\\) 使得 \\(d(z, y) &lt; \\frac{r}{2}\\)。</p> <p>根据三角不等式： $$ d(x, y) \\le d(x, z) + d(z, y) &lt; \\frac{r}{2} + \\frac{r}{2} = r $$</p> <p>即 \\(d(x, y) &lt; d(A_1, A_2)\\)。这与下确界 \\(d(A_1, A_2) = \\inf_{a\\in A_1, b\\in A_2} d(a, b)\\) 的定义矛盾。因此假设不成立，即 \\(G_1 \\cap G_2 = \\emptyset\\)。</p> <p>[!question] (2) 二. （15 分） 设 \\(\\{x_n\\}\\) 是 Banach 空间中的数列，\\(\\forall f \\in X^\\star\\), 数列 \\(\\{f(x_n)\\}\\) 是 \\(\\mathbb{R}\\) 中的 Cauchy 列，证明 \\(\\{x_n\\}\\) 是有界数列。</p> <p>考察一致有界原理（Banach-Steinhaus 定理）及其推论。</p> <p><code>Proof.</code></p> <p>证明思路： 将 \\(x_n\\) 视为 \\(X^{\\star\\star}\\) 中的线性泛函（通过自然嵌入）。利用弱收敛（或点点有界）以及 \\(X^\\star\\) 的完备性，通过一致有界原理推导范数有界性。</p> <p>详细证明：</p> <ol> <li>点点有界性：     对于任意固定的\\(f \\in X^\\star\\)，已知数列 \\(\\{f(x_n)\\}\\) 是 \\(\\mathbb{R}\\) 中的 Cauchy 列。因为\\(\\mathbb{R}\\)是完备的，所以\\(\\{f(x_n)\\}\\)是收敛数列。收敛数列必有界，故存在常数\\(M_f &gt; 0\\)（依赖于 \\(f\\)），使得\\(\\sup_{n} |f(x_n)| \\le M_f\\)。</li> <li>应用一致有界原理：     考虑 \\(X\\) 到其二次对偶空间 \\(X^{\\star\\star}\\) 的自然嵌入映射(Canonical Embedding)\\(J: X \\to X^{\\star\\star}\\)，定义为 \\(J(x)(f) = f(x)\\)。由 Hahn-Banach 定理可知 \\(J\\) 是保范同构，即 \\(\\|J(x)\\| = \\|x\\|\\)。     令 \\(T_n = J(x_n) \\in X^{\\star\\star}\\)。此时 \\(\\{T_n\\}\\) 是 Banach 空间 \\(X^\\star\\) 上的线性泛函序列。由步骤 1 可知，对任意 \\(f \\in X^\\star\\)，序列 \\(\\{T_n(f)\\}\\) 有界（即 \\(\\{f(x_n)\\}\\) 有界）。根据一致有界原理（Banach-Steinhaus 定理），\\(\\{T_n\\}\\) 的算子范数序列是一致有界的。即存在常数 \\(M &gt; 0\\)，使得 \\(\\sup_{n} \\|T_n\\| \\le M\\)。</li> <li>结论：     由于 \\(\\|T_n\\| = \\|J(x_n)\\| = \\|x_n\\|\\)，因此 \\(\\sup_{n} \\|x_n\\| \\le M\\)。即 \\(\\{x_n\\}\\) 是有界数列。</li> </ol> <p>[!question] (3) 三. （15 分） 设 \\(f\\) 是 \\(C[0, 1]\\) 上的线性泛函, 且 \\(f(x) = \\int_0^{\\frac{1}{2}} x(t)dt - \\int_{\\frac{1}{2}}^1 x(t)dt\\)。证明 \\(f\\) 是连续的并求 \\(\\|f\\|\\)。</p> <p>考察 \\(C[0,1]\\) 上线性泛函的连续性证明及范数计算。</p> <p><code>Proof.</code></p> <p>证明思路： 通过放缩法证明有界性从而得到连续性；通过构造具体的函数序列逼近上确界来求范数。</p> <p>详细证明：</p> <ol> <li> <p>证明连续性：     对任意 \\(x \\in C[0, 1]\\)，有     $$ |f(x)| = \\left| \\int_0^{\\frac{1}{2}} x(t)dt - \\int_{\\frac{1}{2}}^1 x(t)dt \\right| \\le \\int_0^{\\frac{1}{2}} |x(t)|dt + \\int_{\\frac{1}{2}}^1 |x(t)|dt = \\int_0^1 |x(t)|dt $$     由于 \\(\\int_0^1 |x(t)|dt \\le \\max_{t\\in[0,1]} |x(t)| \\cdot (1-0) = \\|x\\|_\\infty\\)，     所以 \\(|f(x)| \\le \\|x\\|_\\infty\\)。     由此可知 \\(f\\) 是有界线性泛函，因此 \\(f\\) 是连续的，且 \\(\\|f\\| \\le 1\\)。</p> </li> <li> <p>求 \\(\\|f\\|\\)：     考虑函数 \\(y(t)\\)：     $$ y(t) = \\begin{cases} 1, &amp; t \\in [0, \\frac{1}{2}) \\ -1, &amp; t \\in (\\frac{1}{2}, 1] \\end{cases} $$     虽然 \\(y(t) \\notin C[0, 1]\\)，但我们可以构造连续函数序列逼近它。     对任意 \\(n \\ge 3\\)，构造连续函数 \\(x_n(t) \\in C[0, 1]\\) 如下：     $$ x_n(t) = \\begin{cases} 1, &amp; 0 \\le t \\le \\frac{1}{2} - \\frac{1}{n} \\ -n(t - \\frac{1}{2}), &amp; \\frac{1}{2} - \\frac{1}{n} &lt; t &lt; \\frac{1}{2} + \\frac{1}{n} \\ -1, &amp; \\frac{1}{2} + \\frac{1}{n} \\le t \\le 1 \\end{cases} $$     显然 \\(\\|x_n\\|_\\infty = 1\\)。     计算 \\(f(x_n)\\)：     $$ f(x_n) = \\int_0^{\\frac{1}{2}} x_n(t)dt - \\int_{\\frac{1}{2}}^1 x_n(t)dt $$     $$ = \\left( \\int_0^{\\frac{1}{2}-\\frac{1}{n}} 1 dt + \\int_{\\frac{1}{2}-\\frac{1}{n}}^{\\frac{1}{2}} x_n(t) dt \\right) - \\left( \\int_{\\frac{1}{2}}^{\\frac{1}{2}+\\frac{1}{n}} x_n(t) dt + \\int_{\\frac{1}{2}+\\frac{1}{n}}^1 (-1) dt \\right) $$     注意到中间两个积分区间长度为 \\(1/n\\)，被积函数绝对值不超过 1，故这两项绝对值之和小于 \\(2/n\\)。     主要部分为：     $$ (\\frac{1}{2} - \\frac{1}{n}) - (- (\\frac{1}{2} - \\frac{1}{n})) = 1 - \\frac{2}{n} $$     当 \\(n \\to \\infty\\) 时，\\(f(x_n) \\to 1\\)。     因为 \\(\\|f\\| = \\sup_{\\|x\\|\\le 1} |f(x)|\\)，且我们找到了序列使得 \\(f(x_n) \\to 1\\)，结合之前证明的 \\(\\|f\\| \\le 1\\)，     可得 \\(\\|f\\| = 1\\)。</p> </li> </ol> <p>[!question] (4) 四. （15 分） 设 \\((X, \\|\\cdot\\|)\\) 是可分赋范空间, 证明存在可数子集 \\(\\Phi \\subset X^\\star\\)，使得对于每一个 \\(x \\in X\\), 使得 \\(\\|x\\| = \\sup\\limits_{f\\in\\Phi} |f(x)|\\)。</p> <p>考察可分性与对偶空间性质的结合，利用 Hahn-Banach 定理构造赋范集。类似作业题</p> <p><code>Proof.</code></p> <p>证明思路：  利用 \\(X\\) 的可分性，在单位球面上选取一个稠密的可数子集，对该子集中的每个元素利用 Hahn-Banach 定理选取支撑泛函，这些泛函构成的集合即为所求。</p> <p>详细证明： 1.  由于 \\(X\\) 是可分的，其单位球面 \\(S_X = \\{x \\in X : \\|x\\| = 1\\}\\) 也是可分的（或者取全空间的稠密子集投影到球面上）。设 \\(\\{x_n\\}_{n=1}^\\infty\\) 是 \\(S_X\\) 中的可数稠密子集。</p> <ol> <li> <p>根据 Hahn-Banach 定理的一个推论，对于每一个 \\(x_n\\)，存在 \\(f_n \\in X^\\star\\) 满足：     $$ |f_n| = 1 \\quad \\text{且} \\quad f_n(x_n) = |x_n| = 1 $$     令 \\(\\Phi = \\{f_n\\}_{n=1}^\\infty\\)。显然 \\(\\Phi\\) 是 \\(X^\\star\\) 的可数子集。</p> </li> <li> <p>下面证明对于任意 \\(x \\in X\\)，有 \\(\\|x\\| = \\sup_{f \\in \\Phi} |f(x)|\\)。</p> <ul> <li>不等号 \\(\\ge\\)：由于对于任意 \\(f \\in \\Phi\\), \\(\\|f\\|=1\\)，所以 \\(|f(x)| \\le \\|f\\|\\|x\\| = \\|x\\|\\)。因此 \\(\\sup_{f \\in \\Phi} |f(x)| \\le \\|x\\|\\)。</li> <li>不等号 \\(\\le\\)：     若 \\(x = 0\\)，显然成立。     若 \\(x \\neq 0\\)，令 \\(u = \\frac{x}{\\|x\\|} \\in S_X\\)。     对于任意 \\(\\epsilon &gt; 0\\)，由于 \\(\\{x_n\\}\\) 在 \\(S_X\\) 中稠密，存在 \\(x_k\\) 使得 \\(\\|u - x_k\\| &lt; \\epsilon\\)。     考察对应于 \\(x_k\\) 的泛函 \\(f_k \\in \\Phi\\)：     $$ f_k(u) = f_k(x_k) + f_k(u - x_k) = 1 + f_k(u - x_k) $$     $$ |f_k(u)| \\ge 1 - |f_k(u - x_k)| \\ge 1 - |f_k| |u - x_k| &gt; 1 - \\epsilon $$     所以 \\(\\sup_{f \\in \\Phi} |f(u)| \\ge 1\\)。     代回 \\(x = \\|x\\|u\\)，有：     $$ \\sup_{f \\in \\Phi} |f(x)| = |x| \\sup_{f \\in \\Phi} |f(u)| \\ge |x| (1 - \\epsilon) $$     由于 \\(\\epsilon\\) 的任意性，得 \\(\\sup_{f \\in \\Phi} |f(x)| \\ge \\|x\\|\\)。</li> </ul> <p>综上所述，\\(\\|x\\| = \\sup_{f \\in \\Phi} |f(x)|\\)。</p> </li> </ol> <p>[!question] (5) 五. （15 分） 设 \\(S\\) 是 \\(l^2 \\to l^2\\) 上的线性算子，且满足 $$ Sx(k) = x(k+2) \\quad k = 1, 2, \\cdots \\quad {x(k)} \\in l^2. $$ 试求 \\(\\lim\\limits_{n\\to\\infty} \\|S^n\\|\\)。</p> <p>考察算子范数的计算，特别是移位算子的性质。</p> <p><code>Proof.</code></p> <p>实际上就是利用算子范数的等价定义，由于\\(\\lVert S^{n} \\rVert^{2}=\\sup\\limits_{\\lVert x \\rVert_{l^{2}}=1}\\lVert S^{n}x \\rVert^{2}_{l^{2}}\\)</p> <p>那么有下面的等式成立</p> \\[ \\begin{aligned} \\lVert S ^{n}\\rVert^{2}&amp;=\\sup\\limits_{\\lVert x \\rVert _{l^{2}}=1}\\sum\\limits_{k=1}^{\\infty} \\lVert x_{2n+k} \\rVert ^{2}\\\\ &amp;\\leqslant \\sup\\limits_{\\lVert x \\rVert _{l^{2}}=1}\\sum\\limits_{k=1}^{\\infty} \\lVert x_{k} \\rVert ^{2}=1 \\end{aligned} \\] <p>并且有取\\(x=(0,\\dots,0,1,0,\\dots)\\)时，得到\\(\\sum\\limits_{k=1}^{\\infty}\\lVert x_{2n+k} \\rVert^{2}=1\\)，所以范数为1</p> <p>[!question] (6) 六. （15 分） 设 \\(f\\) 是 Banach 空间 \\(X\\) 到 \\(\\mathbb{R}\\) 上的线性泛函， \\(f\\) 不是常数函数，试证 \\(f\\) 是开映射。(PS: 我确信没有有界这个条件(PS(我): 你要是有界那不是直接满射然后开映射直接秒掉了吗，你是人类吗))</p> <p>考察开映射的定义。对于线性泛函，只要非零（即满射到域），它总是开映射，无论是否连续。</p> <p><code>Proof.</code></p> <p>证明思路： 开映射的定义是将开集映为开集。由于目标空间是 \\(\\mathbb{R}\\)（一维），非零线性泛函的值域是整个 \\(\\mathbb{R}\\)。我们直接根据定义验证即可。</p> <ol> <li>目标：     我们要证明对于 \\(X\\) 中的任意开集 \\(U\\)，它的像 \\(f(U)\\) 是 \\(\\mathbb{R}\\) 中的开集。</li> <li>取点与找球：     任取 \\(y_0 \\in f(U)\\)。这意味着存在一个原像 \\(x_0 \\in U\\) 使得 \\(f(x_0) = y_0\\)。因为 \\(U\\) 是开集，所以 \\(x_0\\) 包含在一个小球里：\\(B(x_0, r) \\subset U\\)。</li> <li>引入方向向量（关键一步）：     因为 \\(f\\) 不是常数函数（即 \\(f \\neq 0\\)），所以肯定存在某个向量 \\(z \\in X\\)，使得 \\(f(z) \\neq 0\\)。我们不妨缩放一下 \\(z\\)，让它的长度很小，小到 \\(\\|z\\| &lt; r\\)。</li> <li>构造线段：     考虑一条穿过 \\(x_0\\) 的线段：\\(L = \\{ x_0 + t z : t \\in (-1, 1) \\}\\)。     因为 \\(\\|z\\| &lt; r\\)，当 \\(t\\) 在 \\((-1, 1)\\) 之间变动时，这点 \\(x_0 + tz\\) 肯定没跑出球 \\(B(x_0, r)\\) 的范围，也就肯定在 \\(U\\) 里面。</li> <li>看像的形状：     把这条线段映射过去：     $$ f(x_0 + tz) = f(x_0) + t \\cdot f(z) = y_0 + t \\cdot C $$     其中 \\(C = f(z)\\) 是一个非零常数。当 \\(t\\) 从 \\(-1\\) 扫到 \\(1\\) 时，这一项 \\(t \\cdot C\\) 就覆盖了一个以 \\(0\\) 为中心的开区间 \\((-|C|, |C|)\\)。所以，像 \\(f(L)\\) 就覆盖了以 \\(y_0\\) 为中心的开区间 \\((y_0 - |C|, y_0 + |C|)\\)。</li> <li>结论：     因为线性泛函的像集要么是0要么是全集，所以\\(f(U)=\\mathbb{R}\\)，肯定包含这个开区间。所以 \\(y_0\\) 是内点，\\(f(U)\\) 是开集。</li> </ol> <p>[!question] (7) 七. （10 分） 设 \\(H\\) 是 Hilbert 空间，\\(H_0\\) 是 \\(H\\) 的闭子空间，设 \\(x_0 \\in H\\), 证明： $$ \\inf_{x\\in H_0} |x - x_0| = \\max_{y\\in H_0^\\perp, |y|=1} |(x_0, y)|. $$</p> <p>考察 Hilbert 空间中的最佳逼近与正交补的对偶关系。只需要使用正交分解定理即可得到，不会做的直接拉出去毙了</p> <p><code>Proof.</code></p> <p>证明思路： 利用正交分解定理，将 \\(x_0\\) 分解为 \\(H_0\\) 和 \\(H_0^\\perp\\) 上的分量，分别计算等式两边的值。</p> <p>详细证明：</p> <ol> <li> <p>左边（最佳逼近）：     由 Hilbert 空间的正交投影定理，对于 \\(x_0 \\in H\\) 和闭子空间 \\(H_0\\)，存在唯一的分解：</p> \\[ x_0 = u + v, \\quad u \\in H_0, \\, v \\in H_0^\\perp \\] <p>此时，\\(u = P_{H_0}x_0\\) 是 \\(x_0\\) 在 \\(H_0\\) 上的正交投影。\\(x_0\\) 到 \\(H_0\\) 的距离为： $$ \\inf_{x \\in H_0} |x - x_0| = |x_0 - u| = |v| $$</p> </li> <li> <p>右边（对偶公式）：     考察 \\(\\sup_{y \\in H_0^\\perp, \\|y\\|=1} |(x_0, y)|\\)。对于任意 \\(y \\in H_0^\\perp\\) 且 \\(\\|y\\|=1\\)：</p> \\[ (x_0, y) = (u + v, y) = (u, y) + (v, y) \\] <p>因为 \\(u \\in H_0, y \\in H_0^\\perp\\)，所以 \\((u, y) = 0\\)。故 \\(|(x_0, y)| = |(v, y)|\\)。由 Cauchy-Schwarz 不等式：</p> \\[ |(v, y)| \\le \\|v\\| \\|y\\| = \\|v\\| \\] <p>这意味着右边的最大值不超过 \\(\\|v\\|\\)。</p> <p>我们需要证明最大值可以取到 \\(\\|v\\|\\)。</p> <ul> <li>若 \\(v = 0\\)，则等式两边均为 0，成立。</li> <li>若 \\(v \\neq 0\\)，取 \\(y^* = \\frac{v}{\\|v\\|}\\)。     显然 \\(y^* \\in H_0^\\perp\\)（因为 \\(v \\in H_0^\\perp\\) 且 \\(H_0^\\perp\\) 是线性子空间），且 \\(\\|y^*\\| = 1\\)。     代入计算：     $$ |(x_0, y^*)| = |(v, \\frac{v}{|v|})| = \\frac{(v, v)}{|v|} = \\frac{|v|^2}{|v|} = |v| $$ 因此，最大值确实存在且等于 \\(\\|v\\|\\)。</li> </ul> </li> <li> <p>结论：     $$ \\inf_{x\\in H_0} |x - x_0| = |v| = \\max_{y\\in H_0^\\perp, |y|=1} |(x_0, y)| $$</p> </li> </ol>","path":["泛函分析2020-2021期末"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%902021-2022%E6%9C%9F%E6%9C%AB/","level":1,"title":"泛函分析2021-2022期末","text":"<p>[!question] (1) 设 \\(A_1, A_2\\) 是赋范空间 \\(X\\) 中的子集. 如果 \\(A_1\\) 是紧集, \\(A_2\\) 是闭集且 \\(A_1 \\cap A_2 = \\emptyset\\). 证明: 存在 \\(r &gt; 0\\), 使得</p> \\[ (A_1 + U(0, r)) \\cap A_2 = \\emptyset, \\] <p>其中 \\(U(0, r) = \\{x \\in X : \\|x\\| &lt; r\\}\\).</p> <p>考察点集拓扑的基本性质，利用紧集与闭集的分离性。</p> <p><code>Proof.</code></p> <p>证明思路： 我们需要证明 \\(A_1\\) 有一个“加宽”的邻域与 \\(A_2\\) 不相交。本质上这等价于证明 \\(A_1\\) 与 \\(A_2\\) 之间的距离严格大于 0。由于 \\(A_2\\) 是闭集，点到集合的距离连续；再利用 \\(A_1\\) 的紧性取最小值即可。</p> <p>详细证明：</p> <p>首先，定义点 \\(x\\) 到集合 \\(A_2\\) 的距离函数 \\(f(x) = \\inf_{y \\in A_2} \\|x - y\\|\\)。众所周知，距离函数在赋范空间上是连续的。由于 \\(A_2\\) 是闭集且与 \\(A_1\\) 不相交，对于任意 \\(a \\in A_1\\)，都有 \\(f(a) &gt; 0\\)。因为 \\(A_1\\) 是紧集，连续函数 \\(f(x)\\) 在紧集上必能取到最小值，记为 \\(m = \\min_{a \\in A_1} f(a)\\)。由于 \\(f\\) 处处为正，故最小值 \\(m &gt; 0\\)。</p> <p>令 \\(r = \\frac{m}{2}\\)。我们要证 \\((A_1 + U(0, r)) \\cap A_2 = \\emptyset\\)。</p> <p>假设结论不成立，即存在点 \\(z\\) 既属于 \\(A_2\\)，又属于 \\(A_1\\) 的 \\(r\\)-邻域。这意味着存在 \\(a \\in A_1\\)，使得 \\(\\|z - a\\| &lt; r\\)。根据距离定义，这推导出 \\(d(a, A_2) \\le \\|z - a\\| &lt; \\frac{m}{2}\\)，这与最小值 \\(m\\) 的定义矛盾。因此假设不成立，结论得证。</p> <p>[!question] (2) 当 \\(1 &lt; r &lt; s &lt; \\infty\\) 时, 有 \\(L^s[a, b] \\subset L^r[a, b]\\).</p> <p>有限测度空间上 \\(L^p\\) 空间的包含关系，Holder不等式的直接应用。送分的。</p> <p><code>Proof.</code></p> <p>证明思路： 利用\\(H \\ddot{o} lder\\)不等式。由于积分区间 \\([a, b]\\) 是有限的，高阶可积函数必然低阶可积。</p> <p>详细证明：</p> <p>我们的目标是 \\(f \\in L^s[a, b]\\)，即 \\(\\int_a^b |f(x)|^s dx &lt; \\infty\\)。能够推出 \\(f \\in L^r[a, b]\\)，即 \\(\\int_a^b |f(x)|^r dx &lt; \\infty\\)。</p> <p>考察积分 \\(\\int_a^b |f(x)|^r \\cdot 1 \\, dx\\)。</p> <p>应用\\(H \\ddot{o} lder\\)不等式，取指数 \\(p = \\frac{s}{r}\\) 和 \\(q = \\frac{s}{s-r}\\)。注意到 \\(s &gt; r\\)，故 \\(p &gt; 1\\)，且 \\(\\frac{1}{p} + \\frac{1}{q} = \\frac{r}{s} + \\frac{s-r}{s} = 1\\)。</p> \\[ \\int_a^b |f(x)|^r \\cdot 1 \\, dx \\le \\left( \\int_a^b (|f(x)|^r)^p dx \\right)^{\\frac{1}{p}} \\left( \\int_a^b 1^q dx \\right)^{\\frac{1}{q}} \\] \\[ = \\left( \\int_a^b |f(x)|^s dx \\right)^{\\frac{r}{s}} (b - a)^{\\frac{s-r}{s}} \\] <p>因为\\(f \\in L^s[a, b]\\)，上述第一项有限；因为区间有限，\\((b-a)\\)有限。故\\(\\int_a^b |f(x)|^r dx &lt; \\infty\\)，即\\(f \\in L^r[a, b]\\)。</p> <p>[!question] (3) 设 \\(A\\) 是赋范空间 \\(X\\) 的子集. 证明: \\(A\\) 在 \\(X\\) 中是有界集当且仅当对任意的 \\(x^* \\in X^*\\), 集合 \\(x^*(A) \\equiv \\{x^*(z) : z \\in A\\}\\) 是有界集.</p> <p>主要是利用自然嵌入的一个方法然后结合经典的一致有界原理，还结合了对偶空间一定是Banach空间的性质</p> <p><code>Proof.</code></p> <p>证明思路： “必要性”利用算子范数定义直接推导；“充分性”将 \\(A\\) 视为 \\(X^{**}\\) 中的泛函族，利用 \\(X^*\\) 的完备性及一致有界原理证明。</p> <p>详细证明：</p> <p>\\((\\Rightarrow)\\) 必要性：</p> <p>若 \\(A\\) 是有界集，则存在 \\(M &gt; 0\\) 使得 \\(\\forall z \\in A, \\|z\\| \\le M\\)。对于任意固定的 \\(x^* \\in X^*\\)，有</p> \\[ |x^*(z)| \\le \\|x^*\\| \\|z\\| \\le \\|x^*\\| M \\] <p>这表明数集 \\(x^*(A)\\) 有界（界为 \\(M\\|x^*\\|\\)）。</p> <p>\\((\\Leftarrow)\\) 充分性：</p> <p>考虑 \\(X\\) 到其双对偶空间 \\(X^{**}\\) 的典范嵌入映射 \\(J: X \\to X^{**}\\)，定义为 \\(J(z)(x^*) = x^*(z)\\)。由 Hahn-Banach 定理推论知 \\(J\\) 是等距嵌入，即 \\(\\|J(z)\\| = \\|z\\|\\)。将 \\(A\\) 中的元素 \\(z\\) 视为 \\(X^*\\) 上的线性泛函 \\(J(z)\\)。</p> <p>已知条件为：对任意 \\(x^* \\in X^*\\)，集合 \\(\\{x^*(z) : z \\in A\\}\\) 有界。这等价于说，对于族 \\(\\mathcal{F} = \\{J(z) : z \\in A\\} \\subset X^{**}\\) 中的每一个泛函 \\(f\\)，在任意点 \\(x^*\\) 处的取值是有界的（点点有界）。</p> <p>由于 \\(X^*\\) 是 Banach 空间（对偶空间总是完备的），根据一致有界原理（Uniform Boundedness Principle），这一族线性泛函在范数上是一致有界的。即存在常数 \\(C &gt; 0\\)，使得：</p> \\[ \\sup_{z \\in A} \\|J(z)\\| \\le C \\] <p>又因为 \\(\\|J(z)\\| = \\|z\\|\\)，所以</p> \\[ \\sup_{z \\in A} \\|z\\| \\le C \\] <p>即 \\(A\\) 在 \\(X\\) 中是有界集。</p> <p>[!question] (4) 设 \\(\\|\\cdot\\|\\) 是 \\(C[0, 1]\\) 中的完备范数使得: 当 \\(\\lim\\limits_{n\\to\\infty} \\|x_n - x_0\\| = 0\\) 时, 对任意的 \\(t \\in [0, 1]\\), 都有 \\(\\lim\\limits_{n\\to\\infty} x_n(t) = x_0(t)\\). 证明: \\(\\|\\cdot\\|\\) 等价于上确界范数 \\(\\|\\cdot\\|_\\infty\\), 也即是: 存在常数 \\(C_1, C_2 &gt; 0\\) 使得</p> \\[ C_1\\|x\\|_\\infty \\le \\|x\\| \\le C_2\\|x\\|_\\infty, \\quad \\forall x \\in C[0, 1]. \\] <p>闭图像定理或逆算子定理的应用。题目条件实质给出了收敛性的强弱关系。</p> <p><code>Proof.</code></p> <p>证明思路： 利用闭图像定理证明单位算子是连续的。由于两个范数下的空间都是 Banach 空间，且其一连续，由逆算子定理可得范数等价。</p> <p>详细证明：</p> <p>记 \\(X = C[0, 1]\\)。考虑恒等算子 \\(T: (X, \\|\\cdot\\|) \\to (X, \\|\\cdot\\|_\\infty)\\)，定义为 \\(Tx = x\\)。我们试图要验证这是一个闭算子，也就是\\(Tx=y\\)</p> <p>第一步：证明 \\(T\\) 有界（闭图像定理）</p> <p>设 \\(\\{x_n\\} \\subset X\\) 满足 \\(\\|x_n\\| \\to 0\\) 且 \\(\\|Tx_n - y\\|_\\infty \\to 0\\)。由题目条件，\\(\\|x_n\\| \\to 0\\) 蕴含 \\(\\forall t, x_n(t) \\to 0\\)。由无穷范数定义，\\(\\|x_n - y\\|_\\infty \\to 0\\) 蕴含一致收敛，故 \\(\\forall t, x_n(t) \\to y(t)\\)。由极限唯一性得 \\(y = 0\\)。故 \\(T\\) 是闭算子。因定义域与值域均为 Banach 空间，由闭图像定理知 \\(T\\) 有界，即存在常数 \\(C_1 &gt; 0\\) 使得：</p> \\[ \\|x\\|_\\infty \\le C_1 \\|x\\|. \\] <p>第二步：证明 \\(T^{-1}\\) 有界（逆算子定理）</p> <p>\\(T\\) 是 Banach 空间之间的一一对应且有界的线性算子。根据逆算子定理，其逆算子 \\(T^{-1}\\) 也是有界的，即存在常数 \\(C_2 &gt; 0\\) 使得：</p> \\[ \\|x\\| \\le C_2 \\|x\\|_\\infty. \\] <p>综上，两个范数等价。</p> <p>[!question] (5) 设 \\((X, \\|\\cdot\\|)\\) 是赋范空间, 对任意的 \\(x, y \\in X\\), 令 $$ \\rho(x, y) = \\begin{cases} 0 &amp; \\text{如果 } x = y, \\ |x - y| + 1 &amp; \\text{如果 } x \\neq y. \\end{cases} $$ 证明: \\(\\rho\\) 是 \\(X\\) 上的一个距离, 但不能由范数诱导.</p> <p>构造的一个离散型度量，显然不满足范数的齐次性。也是送的。</p> <p><code>Proof.</code></p> <p>证明思路： 验证距离的三条公理（非负性、对称性、三角不等式）；通过反证法，利用范数的绝对齐次性证明其不能由范数诱导。</p> <p>详细证明：</p> <ol> <li>证明 \\(\\rho\\) 是距离：</li> <li>非负性与正定性：显然 \\(\\rho(x, y) \\ge 0\\)，且 \\(\\rho(x, y) = 0 \\iff x = y\\)</li> <li>对称性：\\(\\rho(x, y) = \\|x - y\\| + 1\\)（若 \\(x \\neq y\\)），因 \\(\\|x - y\\| = \\|y - x\\|\\)，故 \\(\\rho(x, y) = \\rho(y, x)\\)</li> <li> <p>三角不等式：需证 \\(\\rho(x, z) \\le \\rho(x, y) + \\rho(y, z)\\)。显然的，利用\\(1&lt;2\\)和原本的三角不等式即可</p> </li> <li> <p>证明不能由范数诱导：    由范数诱导的距离 \\(d(x, y) = \\|x - y\\|'\\) 必须满足平移不变性和绝对齐次性，特别是：</p> </li> </ol> <p>$$ d(\\alpha x, \\alpha y) = |\\alpha x - \\alpha y|' = |\\alpha| |x - y|' = |\\alpha| d(x, y) $$</p> <p>取 \\(\\alpha = 2\\)，\\(x \\neq y\\)。按照 \\(\\rho\\) 的定义计算：左边 \\(= \\rho(2x, 2y) = \\|2x - 2y\\| + 1 = 2\\|x - y\\| + 1\\)。右边 \\(= 2 \\rho(x, y) = 2(\\|x - y\\| + 1) = 2\\|x - y\\| + 2\\)。显然 \\(2\\|x - y\\| + 1 \\neq 2\\|x - y\\| + 2\\)。故 \\(\\rho\\) 不满足齐次性，不能由范数诱导。</p> <p>[!question] (6) 设 \\(X\\) 是赋范空间, \\(X_0\\) 是 \\(X\\) 的稠密子空间. 证明: 对于每一个 \\(x \\in X\\), 存在元列 \\(\\{x_n\\}_{n=1}^\\infty \\subset X_0\\) 使得 $$ x = \\sum_{n=1}^\\infty x_n \\quad \\text{且} \\quad \\sum_{n=1}^\\infty |x_n| &lt; \\infty. $$</p> <p>利用稠密性逐步逼近构造级数。基本上也是送的，按照定义写。</p> <p><code>Proof.</code></p> <p>证明思路： 利用 \\(X_0\\) 的稠密性，我们可以找到一个序列快速收敛到 \\(x\\)，然后通过差分构造级数项 \\(x_n\\)，使得其范数和收敛。</p> <p>详细证明：</p> <p>1. 构造逼近序列</p> <p>设 \\(y_0 = 0\\)。利用 \\(X_0\\) 在 \\(X\\) 中的稠密性，对于任意 \\(k \\ge 1\\)，选取 \\(y_k \\in X_0\\) 使得</p> \\[ \\|x - y_k\\| &lt; \\frac{1}{2^k}. \\] <p>定义序列 \\(x_n = y_n - y_{n-1}\\) (\\(n \\ge 1\\))。显然 \\(\\{x_n\\} \\subset X_0\\)。</p> <p>2. 验证级数性质</p> <p>首先，该级数的部分和序列即为 \\(\\{y_k\\}\\)，故级数收敛于 \\(x\\)：</p> \\[ \\sum_{n=1}^\\infty x_n = \\lim_{k \\to \\infty} \\sum_{n=1}^k (y_n - y_{n-1}) = \\lim_{k \\to \\infty} (y_k - y_0) = x. \\] <p>其次，利用三角不等式考察级数的绝对收敛性：</p> \\[ \\begin{aligned} \\sum_{n=1}^\\infty \\|x_n\\| &amp;= \\|x_1\\| + \\sum_{n=2}^\\infty \\|y_n - y_{n-1}\\| \\\\ &amp;= \\|y_1 - y_0\\| + \\sum_{n=2}^\\infty \\|(y_n - x) + (x - y_{n-1})\\| \\\\ &amp;\\le \\underbrace{(\\|y_1 - x\\| + \\|x\\|)}_{\\text{由于 } y_0=0} + \\sum_{n=2}^\\infty (\\underbrace{\\|y_n - x\\|}_{&lt; 2^{-n}} + \\underbrace{\\|x - y_{n-1}\\|}_{&lt; 2^{-(n-1)}}) \\\\ &amp;&lt; \\left(\\frac{1}{2} + \\|x\\|\\right) + \\sum_{n=2}^\\infty \\frac{3}{2^n} &lt; \\infty. \\end{aligned} \\] <p>[!question] (7) 设 \\(Y\\) 是可分 Banach 空间 \\(X\\) 的闭子空间. 已知商空间 \\(X/Y \\equiv \\{x + Y : x \\in X\\}\\) 在商范数</p> \\[ \\|x + Y\\| = \\inf\\{\\|x + y\\| : y \\in Y\\} \\] <p>下仍然是 Banach 空间; 相应的商映射 \\(\\pi : X \\to X/Y\\) 定义为 \\(\\pi(x) = x + Y, \\forall x \\in X\\). 证明: \\(X/Y\\) 也是可分的.</p> <p>可分空间的连续像也是可分的。送分的。</p> <p><code>Proof.</code></p> <p>证明思路： 利用可分性的定义（存在可数稠密子集）。\\(X\\) 有可数稠密子集，通过连续满射 \\(\\pi\\) 映射过去，该集合的像在 \\(X/Y\\) 中也是稠密的。</p> <p>详细证明：</p> <p>因为 \\(X\\) 是可分的，所以存在一个可数稠密子集 \\(D = \\{d_n\\}_{n=1}^\\infty \\subset X\\)。考虑 \\(D\\) 在商映射下的像 \\(D' = \\{\\pi(d_n)\\}_{n=1}^\\infty \\subset X/Y\\)。显然 \\(D'\\) 是可数的。</p> <p>下面证明 \\(D'\\) 在 \\(X/Y\\) 中稠密。需要利用的一点是：\\(\\lVert \\pi(x) \\rVert\\leqslant \\lVert x \\rVert\\)，可以根据定义得到。</p> <p>任取 \\(X/Y\\) 中的一个元素 \\(\\hat{y}\\) 以及任意误差 \\(\\epsilon &gt; 0\\)。由于 \\(\\pi\\) 是满射，必存在原像 \\(y \\in X\\) 使得 \\(\\pi(y) = \\hat{y}\\)。利用 \\(X\\) 中 \\(\\{x_n\\}\\) 的稠密性，存在某个 \\(x_k\\)，使得 \\(\\|y - x_k\\| &lt; \\epsilon\\)。根据商范数的性质（投影后的长度 \\(\\le\\) 原来的长度），我们有：</p> \\[ \\|\\hat{y} - \\pi(x_k)\\|_{X/Y} = \\|\\pi(y) - \\pi(x_k)\\|_{X/Y} = \\|\\pi(y - x_k)\\|_{X/Y} \\le \\|y - x_k\\|_X &lt; \\epsilon \\] <p>因此稠密性得证，所以 \\(X/Y\\) 是可分的。</p>","path":["泛函分析2021-2022期末"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%902023-2024%E6%9C%9F%E6%9C%AB/","level":1,"title":"泛函分析2023-2024期末","text":"<p>注：非常容易，脑子没有病的话都能全部写出来</p> <p>[!question] (1) 证明: \\(c_{00}\\) 在 \\(l^\\infty\\) 中不是稠密的.</p> <p>讲义里的例子，非常显然的问题</p> <p><code>Proof.</code></p> <p>证明思路：</p> <p>要证明一个子空间在全空间中不是稠密的，等价于在全空间中找到一个元素，使得该子空间中没有任何元素能够无限接近它。换句话说，我们要找到一个 \\(y \\in l^\\infty\\)，使得 \\(y\\) 到 \\(c_{00}\\) 中任意元素 \\(x\\) 的距离都有一个无法消除的下界（例如大于等于 \\(1\\)）</p> <p>首先给出相关的定义：</p> <p>\\(l^\\infty\\) 是由所有有界数列 \\(x=\\{x_n\\}_{n=1}^\\infty\\) 构成的空间，其范数定义为：</p> \\[ \\|x\\|_\\infty = \\sup_{n\\in\\mathbb{N}} |x_n| \\] <p>\\(c_{00}\\) 是由所有具有有限支集的数列构成的子空间。即对于任意 \\(x \\in c_{00}\\)，存在一个正整数 \\(N\\)（依赖于 \\(x\\)），使得当 \\(n &gt; N\\) 时：</p>","path":["泛函分析2023-2024期末"],"tags":[]},{"location":"Analysis/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%902023-2024%E6%9C%9F%E6%9C%AB/#x_n-0","level":2,"title":"$$ x_n = 0 $$","text":"<p>下面正式进行论证：</p> <p>我们选取 \\(l^\\infty\\) 中的一个常数数列 \\(y = (1, 1, 1, \\dots)\\)。显然对于所有的 \\(n\\)，都有 \\(|y_n| = 1\\)，因此 \\(y\\) 是有界的，属于 \\(l^\\infty\\)。</p> <p>现在任取 \\(c_{00}\\) 中的一个元素 \\(x=\\{x_n\\}\\)。根据 \\(c_{00}\\) 的定义，必存在一个下标 \\(N\\)，使得对于所有 \\(n &gt; N\\) 的项，都有 \\(x_n = 0\\)。</p> <p>接下来考察 \\(y\\) 与 \\(x\\) 之间的距离 \\(\\|y - x\\|_\\infty\\)。根据范数的定义，这是两数列对应项之差绝对值的上确界：</p> \\[ \\|y - x\\|_\\infty = \\sup_{n\\in\\mathbb{N}} |y_n - x_n| \\] <p>注意到在 \\(n &gt; N\\) 的部分，由于 \\(y_n = 1\\) 且 \\(x_n = 0\\)，我们有：</p> \\[ |y_n - x_n| = |1 - 0| = 1 \\] <p>既然对于所有 \\(n &gt; N\\) 的项该差值都等于 \\(1\\)，那么整体的上确界必然满足：</p> \\[ \\|y - x\\|_\\infty \\ge 1 \\] <p>上述结论对任意的 \\(x \\in c_{00}\\) 都成立。这意味着无法在 \\(c_{00}\\) 中找到一个序列收敛于 \\(y\\)（因为距离始终至少为 1）。因此，\\(c_{00}\\) 在 \\(l^\\infty\\) 中不是稠密的。</p> <p>[!question] (2) 设 \\(c=\\{c_n\\}_{n\\in\\mathbb{N}} \\in l^\\infty\\). 对 \\(\\forall x=\\{x_n\\}_{n\\in\\mathbb{N}} \\in l^2\\), 定义线性算子 \\(T_c(x)=(c_n x_n)_{n\\in\\mathbb{N}}\\). 证明 \\(T_c\\) 连续.</p> <p>算子理论有那么多的东西最后考了连续等价有界吗，有趣</p> <p><code>Proof.</code></p> <p>证明思路： 证明线性算子连续等价于证明其有界。我们需要利用 \\(c\\) 的有界性，寻找常数 \\(M\\) 使得 \\(\\|T_c x\\|_2 \\le M \\|x\\|_2\\)。</p> <p>首先回顾范数定义，\\(l^2\\) 空间元素 \\(x\\) 的范数为 \\(\\|x\\|_2 = (\\sum |x_n|^2)^{1/2}\\)，\\(l^\\infty\\) 元素 \\(c\\) 的范数为 \\(\\|c\\|_\\infty = \\sup |c_n|\\)。考察 \\(T_c x\\) 的范数平方，即 \\(\\sum_{n=1}^\\infty |c_n x_n|^2\\)。由于 \\(c \\in l^\\infty\\)，对于任意 \\(n\\) 都有 \\(|c_n| \\le \\|c\\|_\\infty\\)。</p> <p>将此不等式代入求和式中，我们有 \\(\\sum_{n=1}^\\infty |c_n|^2 |x_n|^2 \\le \\|c\\|_\\infty^2 \\sum_{n=1}^\\infty |x_n|^2\\)。即 \\(\\|T_c x\\|_2^2 \\le \\|c\\|_\\infty^2 \\|x\\|_2^2\\)。两边开方可得 \\(\\|T_c x\\|_2 \\le \\|c\\|_\\infty \\|x\\|_2\\)。这表明 \\(T_c\\) 是有界算子，且算子范数不超过 \\(\\|c\\|_\\infty\\)，故 \\(T_c\\) 连续。</p> <p>[!question] (3) 条件同上一题. 求 \\(T_c\\) 的共轭算子.</p> <p><code>Proof.</code></p> <p>证明思路： 在希尔伯特空间中，算子 \\(T_c\\) 的共轭算子 \\(T_c^*\\) 需满足 \\(\\langle T_c x, y \\rangle = \\langle x, T_c^* y \\rangle\\)。我们将通过展开内积公式来确定 \\(T_c^* y\\) 的具体形式。</p> <p>对于 \\(l^2\\) 空间，内积定义为 \\(\\langle x, y \\rangle = \\sum_{n=1}^\\infty x_n \\overline{y_n}\\)。计算 \\(\\langle T_c x, y \\rangle\\)，代入 \\(T_c\\) 的定义得 \\(\\sum_{n=1}^\\infty (c_n x_n) \\overline{y_n}\\)。利用复数乘法的结合律，将其变形为 \\(x\\) 与某向量的内积形式，即 \\(\\sum_{n=1}^\\infty x_n (c_n \\overline{y_n}) = \\sum_{n=1}^\\infty x_n \\overline{(\\overline{c_n} y_n)}\\)。</p> <p>观察上式最后一步，这正是向量 \\(x\\) 与向量 \\(\\{\\overline{c_n} y_n\\}\\) 的内积。由共轭算子的唯一性可知，\\(T_c^* y = \\{\\overline{c_n} y_n\\}_{n\\in\\mathbb{N}}\\)。换言之，\\(T_c\\) 的共轭算子 \\(T_c^*\\) 也是一个乘法算子，其对应的乘法序列是原序列 \\(c\\) 的复共轭 \\(\\bar{c}\\)。</p> <p>[!question] (4) 在 \\(L^2[-1,1]\\) 中对 \\(\\{1, x, x^2\\}\\) 应用 Gram-Schmidt 正交化求一标准正交系.</p> <p>考察你使用Schmidt正交化方法求标准正交基的技能，大概是高代考试吧</p> <p><code>Proof.</code></p> <p>纯AI写的，我都懒得改了</p> <p>证明思路： Gram-Schmidt 过程包含正交化（减去在前面基向量上的投影）和单位化（除以模长）。我们将依次处理 \\(1, x, x^2\\)。</p> <p>首先处理 \\(v_1=1\\)。计算其模长平方 \\(\\int_{-1}^1 1^2 dt = 2\\)，故归一化后的第一个基向量为 \\(e_1 = \\frac{1}{\\sqrt{2}}\\)。</p> <p>接着处理 \\(v_2=x\\)。由于区间 \\([-1,1]\\) 对称，\\(x\\) 为奇函数，\\(1\\) 为偶函数，二者内积 \\(\\int_{-1}^1 x \\cdot 1 dt = 0\\)，说明 \\(x\\) 已与 \\(e_1\\) 正交。直接计算其模长平方 \\(\\int_{-1}^1 x^2 dt = \\frac{2}{3}\\)，归一化得到第二个基向量 \\(e_2 = \\frac{x}{\\sqrt{2/3}} = \\sqrt{\\frac{3}{2}} x\\)。</p> <p>最后处理 \\(v_3=x^2\\)。需减去它在 \\(e_1\\) 和 \\(e_2\\) 上的投影。计算内积：\\(\\langle x^2, e_1 \\rangle = \\int_{-1}^1 \\frac{x^2}{\\sqrt{2}} dt = \\frac{\\sqrt{2}}{3}\\)，而 \\(\\langle x^2, e_2 \\rangle = \\int_{-1}^1 x^2 \\cdot \\sqrt{\\frac{3}{2}}x dt = 0\\)（奇函数积分）。于是正交化后的向量 \\(u_3 = x^2 - \\frac{\\sqrt{2}}{3} e_1 = x^2 - \\frac{1}{3}\\)。计算 \\(u_3\\) 的模长平方 \\(\\int_{-1}^1 (x^2-\\frac{1}{3})^2 dt = \\frac{8}{45}\\)。归一化得到 \\(e_3 = \\frac{x^2-1/3}{\\sqrt{8/45}} = \\sqrt{\\frac{5}{8}}(3x^2-1)\\)。</p> <p>最终标准正交系为 \\(\\{ \\frac{1}{\\sqrt{2}}, \\sqrt{\\frac{3}{2}}x, \\sqrt{\\frac{5}{8}}(3x^2-1) \\}\\)。</p> <p>[!question] (5) 定义线性算子 \\(\\varphi: C[0,1] \\to \\mathbb{R}\\) 为 \\(\\varphi(f)=\\int_0^1 f(t) dt\\). 证明: \\(\\|\\varphi\\|=1\\).</p> <p>很经典的例子</p> <p><code>Proof.</code></p> <p>[!NOTE] 补充知识 先给出算子范数的定义：</p> <p>设 \\(X\\) 和 \\(Y\\) 是赋范线性空间（Normed Linear Spaces），\\(T: X \\to Y\\) 是一个线性算子。\\(T\\) 的算子范数 \\(\\|T\\|\\) 定义为：</p> \\[ \\|T\\| = \\sup_{\\substack{x \\in X \\\\ x \\neq 0}} \\frac{\\|Tx\\|_Y}{\\|x\\|_X} \\] <p>证明思路： 证明算子范数等于 1 通常分两步：先证明 \\(\\|\\varphi\\| \\le 1\\)（上界），再找具体元素证明 \\(\\|\\varphi\\| \\ge 1\\)（下界）。</p> <p>首先证明 \\(\\|\\varphi\\| \\le 1\\)。对于任意 \\(f \\in C[0,1]\\)，考察 \\(|\\varphi(f)| = |\\int_0^1 f(t) dt|\\)。将绝对值放进积分号内并利用范数放缩，得 \\(|\\varphi(f)| \\le \\int_0^1 |f(t)| dt \\le \\int_0^1 \\|f\\|_\\infty dt = \\|f\\|_\\infty\\)。由算子范数定义可知 \\(\\|\\varphi\\| \\le 1\\)。</p> <p>其次证明 \\(\\|\\varphi\\| \\ge 1\\)。取特例 \\(f_0(t) = 1\\)，显然 \\(\\|f_0\\|_\\infty = 1\\)。代入算子计算得 \\(\\varphi(f_0) = \\int_0^1 1 dt = 1\\)。此时 \\(|\\varphi(f_0)| = \\|f_0\\|_\\infty\\)，这说明算子范数至少能取到 1。结合上界得证 \\(\\|\\varphi\\|=1\\)。</p> <p>[!question] (6) 对于 Banach 空间 \\(E\\) 及赋范空间 \\(F\\), 设 \\(T_n \\in B(E,F)\\) 满足对 \\(\\forall x \\in E\\), \\(\\{T_n x\\}_{n\\in\\mathbb{N}}\\) 在 \\(F\\) 中收敛. 定义 \\(Tx = \\lim\\limits_{n\\to\\infty} T_n x\\), 证明: \\(T \\in B(E,F)\\).</p> <p>根据定义验证，给出算子的线性性和有界性即可</p> <p><code>Proof.</code></p> <p>证明思路： 要证 \\(T \\in B(E,F)\\)，需验证 \\(T\\) 的线性性与有界性。线性性由极限的线性性质保证，有界性则需借助 Banach 空间的一致有界原理。</p> <p>首先验证线性。对于任意 \\(x, y \\in E\\) 及标量 \\(\\alpha, \\beta\\)，由于每个 \\(T_n\\) 均为线性算子，且极限运算保持线性关系，故 \\(T(\\alpha x + \\beta y) = \\lim (\\alpha T_n x + \\beta T_n y) = \\alpha Tx + \\beta Ty\\)，即 \\(T\\) 是线性的。</p> <p>其次验证有界性。已知对于任意 \\(x\\)，序列 \\(\\{T_n x\\}\\) 收敛，故其有界。因为 \\(E\\) 是 Banach 空间，根据一致有界原理（共鸣定理），点点有界的线性算子列必然一致有界，即存在常数 \\(M\\) 使得 \\(\\sup_n \\|T_n\\| \\le M\\)。于是对于任意 \\(x\\)，\\(\\|T_n x\\| \\le M \\|x\\|\\)。令 \\(n \\to \\infty\\)，由范数的连续性得 \\(\\|Tx\\| \\le M \\|x\\|\\)。这表明 \\(T\\) 是有界的，证毕。</p> <p>[!question] (7) 证明: 赋范空间的开子空间必是其自身.</p> <p>赋范空间中凡是内部有一个开球的子空间，一定是自身，依然习题</p> <p><code>Proof.</code></p> <p>证明思路： 本题利用线性空间的缩放性质。若子空间包含原点的一个邻域，通过线性运算可以将该邻域扩张至覆盖整个空间。</p> <p>设 \\(Y\\) 是赋范空间 \\(X\\) 的一个子空间，且 \\(Y\\) 是开集。由于 \\(Y\\) 是子空间，必含零向量 \\(0\\)。又因 \\(Y\\) 为开集，故存在 \\(r&gt;0\\)，使得以 \\(0\\) 为心的开球 \\(B(0,r)\\) 完全包含于 \\(Y\\) 中。</p> <p>任取空间 \\(X\\) 中的非零元素 \\(x\\)。我们可以通过缩放将其“拉”入上述开球中(利用的是空间的数乘性质)。令向量 \\(z = \\frac{r}{2\\|x\\|} x\\)，计算其范数可知 \\(\\|z\\| = r/2 &lt; r\\)，故 \\(z \\in B(0,r) \\subset Y\\)。由于 \\(Y\\) 是线性空间，对数乘封闭，而 \\(x\\) 是 \\(z\\) 的标量倍数（\\(x = \\frac{2\\|x\\|}{r} z\\)），因此 \\(x\\) 也必须属于 \\(Y\\)。这意味着 \\(X \\subseteq Y\\)，结合 \\(Y \\subseteq X\\)，即得 \\(Y=X\\)。</p>","path":["泛函分析2023-2024期末"],"tags":[]},{"location":"Analysis/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","level":1,"title":"引言","text":"<p>注意</p> <p>以下内容均由Deepseek生成doge</p>","path":["引言"],"tags":["评价"]},{"location":"Analysis/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#_2","level":2,"title":"数学之径的永恒驿站","text":"<p>——经典本科数学书籍读书笔记典藏馆·引言</p> <p>数学是人类理性构建的巴别塔，其砖石是公理与定义，黏合剂是逻辑与想象。从柯朗笔下《微积分与数学分析引论》的严谨长阶，到菲赫金哥尔茨《微积分学教程》中青铜刻度般的精密推演；从Rudin《数学分析原理》冷冽如冰的证明之美，到Hoffman与Kunze《线性代数》公理森林间优雅的抽象图腾——这些经典著作的页边空白处，永远留存着求知者与伟大思想对话的痕迹。</p> <p>这里建立的读书笔记典藏库，不是简单的摘抄陈列馆，而是数学思维生长的培养皿。每篇笔记都是对Euclid《几何原本》千年命题的现代重诠，是对Riemann曲面拓扑的个性化注解，是穿越Rota《有限算子微积分》迷雾时的思维航标。我们相信：对同一命题的二十种证明视角，比标准答案更能诠释数学的本质；在概率论习题边栏记录的困惑与顿悟，往往比教科书定理更能照亮后来者的道路。</p> <p>在此存放的笔记将形成动态的知识拓扑结构：大一新生对《代数学基础》的疑问可能被研二学生的伽罗瓦理论笔记解答；物理系学生读《实变函数论》时绘制的测度论思维导图，或许会成为计算机专业同侪理解机器学习理论的密钥。这些带着墨迹温度的手写批注、电子笔记中的\\(\\LaTeX\\)公式、甚至是草稿纸上的灵感速写，共同编织着数学认知网络的非交换图景。</p> <p>欢迎每位跋涉在数学之径的旅人在此寄存思考的星火。让我们以笔记为媒介，在Cauchy序列的收敛处相遇，在Fourier变换的频域中共鸣，让个体的数学体验通过共享与对话，升华为属于整个求知共同体的思维交响乐。正如G.H.Hardy在《一个数学家的辩白》中所言：\"数学家的印记，首要不是证明的结果，而是思考的轨迹。\"这，正是本典藏库存在的终极意义。</p>","path":["引言"],"tags":["评价"]},{"location":"Analysis/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#_3","level":2,"title":"一些可能有帮助的网络资源","text":"<ul> <li>Durrett</li> </ul>","path":["引言"],"tags":["评价"]},{"location":"Analysis/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Principles%20of%20Mathematical%20Analysis(Rudin)/The%20Real%20and%20Complex%20Number%20Systems/","level":1,"title":"Introduction","text":"<p>A satisfied discussion of the main concepts of analysis must be based on an accurately defined number concept.                                                                                                                 ——WalterRudin</p> <p>We first assume familiarity with the rational numbers(the numbers of the form \\(\\frac{m}{n}\\),where m and n are integers and \\(n\\neq 0\\))</p> <p>The rational number system is inadequate for many purposes,both as a field and an ordered set.(These terms will be defined in Secs.1.6 and 1.12)</p> <p>Motivation Instance:there is no rational \\(p\\) such that \\(p^{2} =2\\).</p> <p>We can use a sequence that is made of infinite decimal expansions to approximate the irrational numbers \"actually \\(\\sqrt{ 2 }\\)\"</p> \\[ 1,1.4,1.41,1.414,1.4142,\\dots \\] <p>it \"tends to \\(\\sqrt{ 2 }\\)\" if we know the irrational number.</p> <p>But without the definition of irrational number, we can't answer the question : What is it that this sequence \"tends to\"?</p> <p>Statement: There is no rational \\(p\\) satisfied the equation \\(p^{2}=2\\)</p> <p><code>Proof</code> If there were such a \\(p\\),we could write \\(p= \\frac{m}{n}\\) where m and n are integers that are not both even.If not, we eliminate the 2. We can get \\(m^{2}=2n^{2}\\),this shows that \\(m^{2}\\) is even and \\(m^{2}\\) is divisble by 4 (m is divisble by 2).Such that n is also divisble by 2(n is even).Hence the equation is impossible for rational \\(p\\).</p> <p>Now we can use this instance to make two subsets of \\(\\mathbb{Q+}\\) denote it example 1.1 Let A be the set of all positive rational \\(p\\) such that \\(p^{2}&lt;2\\),let B be the set of all positive rational \\(p\\) such that \\(p^{2}&gt;2\\) .We shall show that A contains no largest number and B contains no smallest.</p> <p>More explicity,for every \\(p\\) in A we can find a rational \\(q\\) in A such that \\(p&lt;q\\) (B is the same)</p> <p>A structure quite elegant:</p> \\[ \\begin{align} q=p- \\frac{p^{2}-2}{p+2}= \\frac{2p+2}{p+2} \\\\ q^{2}-2= \\frac{2(p^{2}-2)}{(p+2)^{2}} \\end{align} \\] <p>If \\(p\\) is in A then \\(p^{2}-2&lt;0\\) ,shows that \\(q&gt;p\\),and shows that \\(q^{2}&lt;2\\).</p> <p>Thinking: How to construct this \\(q\\) looks difficult?</p> <p>Answer: We can use \\(\\sqrt{ 2 }\\) (or any other symbol) to approximate the number \\(q\\). To make an appropriate approximation, we should clearify our goal first(what conditions the number q should satisfy)</p> <ol> <li>it must bigger than p(only think about the situation \\(p^{2}&lt;2\\)).</li> <li>\\(q^{2}&lt;2\\),too.</li> </ol> \\[ \\begin{align} q &amp; &lt;p+\\sqrt{ 2 }-p=\\sqrt{ 2 } \\\\ q &amp; &lt;p+ \\frac{2-p^{2}}{\\sqrt{ 2 }+p} \\end{align} \\] <p>that's a draft and the other situation is the same. \\(q&gt;p-(p-\\sqrt{ 2 })=p+ \\frac{2-p^{2}}{\\sqrt{ 2 }+p}\\) ,you will find the numerator be control by (2-\\(p^{2}\\)) ,and we actually can use any number bigger than \\(\\sqrt{ 2 }\\) to displace the 2 in the Rudin's book.</p> <p>Remark: The rational number system has certain gaps,if \\(r&lt;s\\) then \\(r&lt; \\frac{r+s}{2}&lt;s\\),the real number system fills these gaps.</p> <p>In order to elucidate its structure, as well as that of the complex numbers,we start with a discussion of the general concepts of ordered set and field</p> <p>Some definition of the ordered set and field: \\(\\not\\in \\emptyset \\subset \\supset\\)</p> <p>Definition Throughout Chap.1,the set of all rational numbers will be denoted by \\(\\mathbb{Q}\\)</p>","path":["Introduction"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Principles%20of%20Mathematical%20Analysis(Rudin)/The%20Real%20and%20Complex%20Number%20Systems/#ordered-sets","level":1,"title":"Ordered sets","text":"<p>Definition Let \\(S\\) be a set.An order on \\(S\\) is a relation,denoted by &lt;,with the following two properties: (1) If \\(x\\in S\\) and \\(y \\in S\\) then only one of the statements is true.</p> \\[ x&lt;y,x=y,y&lt;x \\] <p>(2) If \\(x,y,z\\in S\\) , if \\(x&lt;y\\) and \\(y&lt;z\\) ,then \\(x&lt;z\\). \"\\(x&lt;y\\)\" may be read as \"x is less than y\" or \"x is smaller than y\" or \"x precedes y\". Or we can use y&gt;x replace the \"x&lt;y\".The notation \\(x\\le y\\) indicates that \"x&lt;y\" or \"x=y\"</p> <p>Definition An ordered set is a set \\(S\\) in which an order is defined.</p> <p>Assume \\(S\\) is an ordered set and \\(E \\subset S\\).(Used in following definitions)</p> <p>Definition If there exists a \\(\\beta \\in S\\) such that \\(x\\le \\beta\\) for every \\(x\\in E\\),we say that \\(\\mathbb{E}\\) is bounded above,and call \\(\\beta\\) an upper bound of \\(E\\) Lower bounds are defined in the same way.</p> <p>Definition \\(\\alpha\\) is called the least upper bound(or the supremum) of \\(E\\) if exists the \\(\\alpha\\) with the following properties (there is at most one such \\(\\alpha\\), we can get it from (2)) (1) \\(\\alpha\\) is an upper bound of \\(E\\) (2) If \\(\\gamma &lt;\\alpha\\) then \\(\\gamma\\) is not an upper bound of \\(E\\) and we write \\(\\alpha=sup\\ E\\) Like it,we can define the greatest lower bound,or infimum.We write (in convenient we use a letter different from the \\(\\alpha\\)) \\(\\beta=inf\\ E\\)</p> <p>Examples (a) The set A is bounded above and has no least upper bound in \\(\\mathbb{Q}\\) Back to the example 1.1 and consider A and B as subsets of the ordered set \\(\\mathbb{Q}\\),we may get (a) in the following three conclusions.</p> <p>(b) If \\(\\alpha=sup\\ E\\) exists,then \\(\\alpha\\) may or may not be a member of \\(E\\).  For instance,let \\(E_{1}\\) be the set of all \\(r\\in \\mathbb{Q}\\) with \\(r&lt;0\\) .Let \\(E_{2}\\) be the set of all \\(r\\in \\mathbb{Q}\\) with \\(r\\le 0\\).Then \\(sup\\ E_{1}=sup \\ E_{2}=0\\) and \\(0\\not\\in E_{1},0\\in E_{2}\\).</p> <p>(c) \\(E\\) is an ordered set,\\(sup\\ E\\) and \\(inf\\ E\\) have one in \\(E\\) Let \\(E\\) be a consist of all numbers \\(\\frac{1}{n}\\) ,where \\(n=1,2,\\dots\\) ,Then \\(sup\\ E=1\\) ,which is in \\(E\\) ,but on the other hand \\(inf\\ E=0\\) ,which is not in \\(E\\).</p> <p>Definition An ordered set \\(S\\) is said to have the least-upper-bound property if the following is true If \\(E \\subset S\\),\\(E\\) is not empty,and E is bounded above,then \\(sup\\ E\\) exists in \\(S\\). The example in (a) shows that \\(\\mathbb{Q}\\) does not have the least-upper-bound property.</p> <p>The close relation between greatest lower bounds and least upper bounds: every ordered set with the least-upper-bound property also has the greatest-lower-bound property. We can summary it as a theorem.(We should discuss the set with least-upper-bound property)</p> <p>Theorem Suppose \\(S\\) is an ordered set with the least-upper-bound property,\\(B\\subset S\\),B is not empty,and B is bounded below.Let L be the set of all lower bounds of B.Then \\(\\alpha=sup\\ L\\) exists in \\(S\\) ,and \\(\\alpha=inf\\ B\\).In particular,\\(inf\\ B\\) exists in \\(S\\).</p> <p><code>Proof</code></p> <p>Step 1: Since B is bounded below, L is not empty.  Since L consits of exactly all of the y which satisfy the inequality \\(y\\le x\\) for every \\(x\\in B\\) ,then every \\(x\\in B\\) is an upper bound of L.(B is not empty) Thus L is bounded above.Our hypothsis about \\(S\\) implies therefore that L has supremum in \\(S\\) ; call it \\(\\alpha\\). Step 2: Due to the definition of supremum,think about two situations(left and right):     if \\(\\gamma&lt;\\alpha\\) then \\(\\gamma\\) is not an upper bound of L,hence \\(\\gamma \\not\\in B\\)(every elements of B is an upper bound of L). It shows that \\(\\alpha\\le x\\) for every \\(x\\in B\\) .(Because every \\(x\\in B\\) should greater or equal to the \\(\\alpha\\) so we can get the \\(\\alpha\\) is the lower bound of B)Thus \\(\\alpha\\in L\\).     if \\(\\alpha&lt;\\beta\\) then \\(\\beta \\not\\in L\\) ,since \\(\\alpha\\) is an upper bound of L. In my words, they mean the number is bigger than \\(\\alpha\\) is not belong to L then is not the lower bound of B.  From these we can get the conclusion that \\(\\alpha=inf\\ B\\) (In definition) </p> <p>Some words:I think I should not write the definitions in my note or write very simplely, they waste the time!  Another some words: the author skip one or two logical explaination sentence in one conclusion.</p>","path":["Introduction"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Principles%20of%20Mathematical%20Analysis(Rudin)/The%20Real%20and%20Complex%20Number%20Systems/#fields","level":1,"title":"Fields","text":"<p>Q&amp;A Q: Straightly, the first question, what is a field ? A: a set F with two operations, \"addition and multiplication\" , precisely is satisfy the following \"field axioms\" (A), (M) and (D) explained below. (A) and (M) both have 5 subaxioms 1. 封闭性 2. 交换律 3. 结合律 4. 幺元律 5. 逆元存在 (D) 乘法分配律</p> <p>Use the filed axioms to prove some familiar properties of \\(\\mathbb{Q}\\) , such that we won't prove them again for real number and complex number.</p> <p>Give one example for each axioms.(Others can found in the book)</p>","path":["Introduction"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Principles%20of%20Mathematical%20Analysis(Rudin)/The%20Real%20and%20Complex%20Number%20Systems/#the-real-field","level":1,"title":"The Real Field","text":"<p>Remark: This chapter's notes is too long and like copy the rudin's book. I will change the way in next chapters (but on the other word,is it a proof for the book is good?)</p>","path":["Introduction"],"tags":["Mathematical Analysis"]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/","level":1,"title":"随机过程","text":"<p>[!tldr] 课程简介 所属大学：南开大学 主讲教师：赵尉辰(Weichen Zhao) 先修要求：数学分析+高等代数+初等概率论+(实变函数/测度论、泛函分析) 课程难度：⭐⭐⭐ 预计学时：50h 给分情况： 考试难度： 修读时间：Spring 25(旁听)/Spring 26</p> <ul> <li>随机过程导论/应用随机过程</li> <li>参考书目<ul> <li>Sheldon M. Ross, Stochastic Processes. 2nd Edition</li> <li>Sheldon M. Ross 著，龚光鲁 译，随机过程(第2版)</li> <li>James R. Norris, Markov chains.</li> <li>陆大䋮 张颢，随机过程及其应用(第2版)</li> </ul> </li> <li>主要内容<ul> <li>概率论基础</li> <li>Poisson过程</li> <li>Markov链</li> <li>连续时间Markov链 (排队论)</li> <li>Markov过程* (状态连续)</li> <li>随机过程在数据科学中的应用 (MCMC算法, 模拟退火, Markov决策过程*)</li> </ul> </li> <li>后续课程：随机分析</li> </ul>","path":["随机过程"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/#lecture-1-introduction-preliminaries","level":2,"title":"Lecture 1 - Introduction &amp; Preliminaries","text":"","path":["随机过程"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/#lecture-2-poisson-processes","level":2,"title":"Lecture 2 - Poisson Processes","text":"","path":["随机过程"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/#lecture-3-extensions-of-poisson-process","level":2,"title":"Lecture 3 - Extensions of Poisson Process","text":"","path":["随机过程"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/#lecture-4-discrete-time-markov-chains","level":2,"title":"Lecture 4 - Discrete-time Markov Chains","text":"","path":["随机过程"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/#lecture-5-classification-of-states","level":2,"title":"Lecture 5 - Classification of States","text":"","path":["随机过程"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/#lecture-6-limit-behaviour-ergodic-theory","level":2,"title":"Lecture 6 - Limit Behaviour &amp; Ergodic Theory","text":"","path":["随机过程"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%201%20-%20Introduction%20&%20Preliminaries/","level":1,"title":"Lecture 1 - Introduction &amp; Preliminaries","text":"<p>[!tldr] Overview 1. 课程概括 2. 概率空间 3. 随机变量 4. 数学期望 5. 一些概率工具：矩母函数、概率不等式、jixiandingli 6. 随机过程</p>","path":["Lecture 1 - Introduction &amp; Preliminaries"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%202%20-%20Poisson%20Processes/","level":1,"title":"Lecture 2 - Poisson Processes","text":"<p>[!tldr] Syllabus + Poisson 过程 + 到达间隔 + 到达时间</p>","path":["Lecture 2 - Poisson Processes"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%202%20-%20Poisson%20Processes/#poisson","level":2,"title":"Poisson过程的定义","text":"<p>Poisson过程刻画了人们“等待”和“计数”等行为中所蕴含随机性。Poisson 过程是最基本也是最重要的一类连续时间参数随机过程。它是最典型的 Markov过程，Levy过程；而且还是一个半鞅。</p>","path":["Lecture 2 - Poisson Processes"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%202%20-%20Poisson%20Processes/#_1","level":3,"title":"基本概念","text":"<p>[!NOTE] Definition 2.1 (计数过程, Counting processes) 如果随机过程\\(\\left\\{ N(t),t \\geqslant 0 \\right\\}\\)表示时间段内发生的事件总数，则称随机过程\\(N(t)\\)为计数过程(Counting processes)</p> <p>It should qualified:</p> <ul> <li>\\(N(t)\\geqslant 0\\)</li> <li>\\(N(t)\\)是整数</li> <li>单调性</li> </ul> <p>为了更好的研究计数过程可以增加一些自定义的约束条件：独立增量与平稳增量</p> <p>[!NOTE] Definition 2.2 (独立增量过程， independent increments) 对于连续时间的随机过程，简单来说就是任意设置间隔点，其中发生的事件数相互独立，这就称为独立增量过程</p> <p>如果对于\\(X(t+s)-X(t)\\)，有任意的\\(t\\)分布相同，则称为平稳增量过程(stationary increments)</p> <p>接下来利用上面的概念给出最基本的一类随机过程-Poisson过程的刻画</p>","path":["Lecture 2 - Poisson Processes"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%202%20-%20Poisson%20Processes/#poisson_1","level":3,"title":"Poisson过程","text":"<p>[!NOTE] Definition 2.3 (Poisson过程, 1) 若计数过程\\(\\left\\{ N(t),t \\geqslant 0 \\right\\}\\)满足 + N(0)=0 + 具有独立增量 + 长度为\\(t\\)的任意区间内的事件数服从均值\\(\\lambda t\\)的Poisson分布，即\\(\\forall s,t \\geqslant 0,P(N(t+s)-N(s)=n)=e^{-\\lambda t} \\frac{\\left( \\lambda t \\right)^{n}}{n!},n=0,1\\dots\\)</p> <p>称为具有速率\\(\\lambda\\)的Poisson过程.</p> <p>然而条件(3)在实际中是很难验证的，所以我们有必要给出一个等价定义</p> <p>Remark: 需要掌握其中的差别和互推的方式</p>","path":["Lecture 2 - Poisson Processes"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%202%20-%20Poisson%20Processes/#_2","level":2,"title":"到达间隔与等待时间的分布","text":"","path":["Lecture 2 - Poisson Processes"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%202%20-%20Poisson%20Processes/#_3","level":2,"title":"到达时间的条件分布","text":"","path":["Lecture 2 - Poisson Processes"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%202%20-%20Poisson%20Processes/#mg1","level":2,"title":"M/G/1的忙期","text":"","path":["Lecture 2 - Poisson Processes"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%203%20-%20Extensions%20of%20Poisson%20Process/","level":1,"title":"Lecture 3 - Extensions of Poisson Process","text":"<p>[!tldr] Syllabus + 非时齐Poisson过程 + 复合Poisson过程 + 条件Poisson过程</p>","path":["Lecture 3 - Extensions of Poisson Process"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%203%20-%20Extensions%20of%20Poisson%20Process/#poisson","level":2,"title":"非时齐 Poisson 过程","text":"<p>本小节放松平稳增量这一条件，也就是说过程的速率会依赖于时间，下面给出非时齐 Poisson 过程的定义</p> <p>[!NOTE] Defnition 3.1 (非时齐 Poisson 过程)  若计数过程\\(\\{N(t),t\\geq0\\}\\)满足：</p> <p>(1) \\(N( 0) = 0;\\) (2)具有独立增量； (3) \\(P\\{ N( t+ h) - N( t) = 1\\} = \\lambda ( t) h+ o( h)\\), \\(\\lambda ( t) , t\\geq 0\\)为连续函数 (4) \\(P\\{ N( t+ h) - N( t) \\geq 2\\} = o( h)\\)</p> <p>则称为具有强度函数\\(\\lambda(t)\\)的非时齐(Nonhomogeneous)Poisson过程 。 </p> <p>与标准Poisson 过程一样，我们接下来考察\\(N(t)\\)的分布。</p> <p>[!NOTE] Proposition 3.2  设\\(\\{N(t),t\\geq0\\}\\)为一个非时齐Poisson过程，记</p> \\[m(t)=\\int_0^t\\lambda(s)ds\\] <p>在区间\\([t+s]\\)中的事件数\\(N(t+s)-N(t)\\)服从均值为\\(m(t+s)-m(t)=\\int_t^{t+s}\\lambda(y)dy\\)的Poisson分布，即</p> \\[P(N(t+s)-N(s)=n)=\\exp\\{-[m(t+s)-m(s)]\\}\\frac{[m(t+s)-m(s)]^n}{n!}.\\] <p><code>Proof.</code></p> <p>与定理2.5的证明想法类似。对给定的\\(t\\),定义：</p> \\[P_n(s)\\triangleq P\\{N(t+s)-N(t)=n\\}\\] <p>则有</p> \\[ \\begin{aligned} P_{0}(s+h)=P\\{N(t+s+h)-N(t)=0\\}&amp;=P\\left\\{(t,t+s)中有0个事件(t+s,t+s+h)中有0个事件\\right\\} \\\\ &amp;=P\\left\\{(t,t+s)中有0个事件\\right\\}P\\left\\{(t+s,t+s+h)中有0个事件\\right\\}\\\\ &amp;=P_0(s)[1-\\lambda(t+s)h+o(h)], \\end{aligned} \\] <p>因此</p> \\[\\frac{P_0(s+h)-P_0(s)}h=-\\lambda(t+s)P_0(s)+\\frac{o(h)}h.\\] <p>令\\(h\\to0\\),得到微分方程</p> \\[P_0'(s)=-\\lambda(t+s)P_0(s)\\]","path":["Lecture 3 - Extensions of Poisson Process"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%204%20-%20Discrete-time%20Markov%20Chains/","level":1,"title":"Lecture 4 - Discrete-time Markov Chains","text":"<p>[!tldr] Syllabus + Markou链 + Chapman-Kolmogorou方程 + 不变分布</p> <p>[!tip] HW2 Sheldon Ross 2.5 2.8 2.17 2.20 2.29 2.36</p>","path":["Lecture 4 - Discrete-time Markov Chains"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%204%20-%20Discrete-time%20Markov%20Chains/#markov","level":2,"title":"离散时间Markov链","text":"<p>[!NOTE] Defnition4.1 (离散时间Markov链) 设\\(E\\) 是一个可数集合，不妨为\\(\\mathbb{N}^{+}=\\{1,2,\\ldots\\}\\) 。称状态空间为\\(E\\) 的离散时间随机过程\\(\\{ X_{n}\\), \\(n= 0, 1, 2, \\ldots \\}\\) 为一个(离散时间)Markou链，如果对于任意\\(n\\geq0\\) ，任意状态\\(i_0,i_1,\\ldots,i_{n-1},i,j\\in E\\) ，有Markou性(4.1)：</p> \\[ \\begin{aligned} &amp;P\\{X_{n+1}=j|X_n=i,X_{n-1}=i_{n-1},\\dots,X_1=i_1,X_0=i_0\\}\\\\ =&amp;P\\{X_{n+1}=j|X_n=i\\} \\end{aligned} \\] <p>成立。 </p> <p>称\\(P(n,i;n+1,j)\\) 为时刻\\(n\\)处于状态\\(i\\),时刻\\(n+1\\)转移到状态的转移函数。若它与\\(n\\) 无关，则记为\\(P_{ij}\\) ，此时称\\(\\{X_n\\}\\) 为一个时齐Markou链，矩阵\\(P=(P_{ij})_{i,j\\in E}\\) 称为一步转移矩阵。我们之后都考虑时齐Markou链。</p> <p>注1.Markov性(4.1)等价于(4.2)</p> \\[\\begin{aligned} &amp;P\\{X_{n+1}=j,X_{n-1}=i_{n-1},\\dots,X_{0}=i_{0}|X_{n}=i\\}\\\\ =&amp;P\\{X_{n+1}=j|X_n=i\\}\\cdot P\\{X_{n-1}=i_{n-1},\\dots,X_0=i_0|X_n=i\\} \\end{aligned}\\] <p>即验证：</p> \\[P(C\\mid BA)=P(C\\mid B)\\Leftrightarrow P(CA\\mid B)=P(C\\mid B)P(A\\mid B)\\] <p>其中A表示“过去”，B表示“现在”， \\(C\\) 表示“未来”，用条件概率的初等定义即可验证。</p> <p>(4.2)说明Markov性等价于在已知“现在”的条件下，“过去”和“未来”是独立的。</p> <p>注2.Markov性(4.1)还等价于(4.3)</p> \\[P(X_0=i_0,X_1=i_1,\\cdots,X_n=i_n)=P(X_0=i_0)\\prod_{k=1}^nP(k-1,i_{k-1};k,i_k).\\] <p>(4.3)有的地方称为链式法则(chainrule)。可以看出，Markov链的有限维联合分布由初始分布和转移函数决定，在时齐情形，</p> \\[P(X_0=i_0,X_1=i_1,\\cdots,X_n=i_n)=P(X_0=i_0)\\prod_{k=1}^nP_{i_{k-1}i_k}.\\] <p>注3.若矩阵\\(P=(P_{ij})_{i,j\\in E}\\) 满足：</p> \\[P_{ij}\\geq0,\\quad i,j\\in E\\] \\[\\displaystyle\\sum_{j\\in E}P_{ij}=1,\\quad\\forall i\\in E\\] <p>则称\\(P\\) 为\\(E\\) 上的转移矩阵（transitionmatrix)/随机矩阵(stochasticmatrix，注意和randon matrix的区分).称\\(P_{ij}\\) 为从状态到的转移概率。</p>","path":["Lecture 4 - Discrete-time Markov Chains"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%204%20-%20Discrete-time%20Markov%20Chains/#_1","level":2,"title":"例子","text":"<p>[!example] Example4.2 (一维简单随机游走) 考虑一个在Z上运动的粒子，它每一次等可能地向左或向右移动一步，即</p> \\[P_{i,i+1}=P_{i,i-1}=\\frac{1}{2},\\quad\\forall i\\in\\mathbb{Z}.\\] <p>粒子在Z上的位置为一个随机过程，称为一维简单随机游走。</p> <p>我们也可以用独立地抛一枚公平的硬币的随机试验来刻画这个模型：每次抛到正面则让粒子往右走(位置加1)，抛到反面则让粒子往左走(位置减1)。</p> <p>我们还可以用随机变量序列来进行刻画，假设\\(\\xi_{1},\\xi_{2},\\ldots\\) .独立同分布于</p> \\[P(\\xi_1=1)=P(\\xi_1=-1)=\\frac{1}{2}.\\] <p>假设\\(S_{0}\\) 为取整数值的随机变量，且它独立于\\(\\xi_{1},\\xi_{2},\\ldots\\) ，令</p> \\[S_n:=S_0+\\xi_1+\\cdots+\\xi_n=S_{n-1}+\\xi_n.\\] <p>那么\\(S_{n}\\) 为从\\(S_{0}\\) 出发的一维简单随机游走。</p> <p>\\(\\xi_{n}\\) 可以服从更一般的分布，此时， \\(S_n\\) 称为一般随机游走。</p> <p>[!EXAMPLE] Example4.3 (Ehrenfest模型) 在统计热力学的研究中，一个经典的模型是Ehrenfest模型，用来模拟气体分子在两个容器中的扩散过程。考虑甲乙两个容器，其中总共的气体分子为\\(N\\) 。假设单位时间内，有且只有一个分子在甲乙两个容器之间扩散，扩散的分子是随机选取的。</p> <p>记n时间后甲容器内的气体分子数为\\(X_{n}\\) ，则\\(X_{n}\\)是一个状态空间为\\(E=\\{0,1,\\ldots,N\\}\\) 的离散时间Markou链，转移概率为</p> \\[P\\left(X_{n+1}=j|X_n=i\\right)=\\left\\{\\begin{array}{cc}1-\\frac{i}{N},&amp;j=i+1\\\\\\frac{i}{N},&amp;j=i-1\\\\0,&amp;|j-i|\\ne1\\end{array}\\right.\\] <p>直观上，如果一开始甲容器里没有气体分子，经过自由扩散，两个容器中的气体分子数量应该会趋于一致。这本质上是热力学第二定律描述的熵增现象，说明在封闭系统中，微观随机行为会导致宏观熵的增加。</p> <p>[!EXAMPLE] Example4.4 (图上的随机游走) 设\\(\\mathcal{G}=(\\mathcal{V},\\mathcal{E})\\) 为一个图，对于节点\\(,j\\in\\mathcal{V}\\) ，如果\\((i,j)\\in\\) \\(\\varepsilon\\) ，则称节点i， \\(j\\) 相邻，记为\\(i\\sim j\\)</p> <p>考虑一个位置位于图上节点的粒子，它每次随机地移动到相邻节点上。记\\(X_{n}\\) 为它在时刻\\(n\\) 所处的位置，则\\(\\{X_n\\}\\) 是一个状态空间为V的离散时间Markov链，转移概率为</p> \\[P_{ij}=\\begin{cases}\\frac{1}{\\deg(i)}&amp;\\text{if}j\\sim i,\\\\[2ex]0&amp;otherwise.\\end{cases}\\] <p>其中\\(\\deg(i)\\) 为节点i的度（degree)，表示节点i相邻的节点的数目。</p>","path":["Lecture 4 - Discrete-time Markov Chains"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%204%20-%20Discrete-time%20Markov%20Chains/#chapman-kolmogorov","level":2,"title":"Chapman-Kolmogorov方程","text":"<p>记时齐Markov链的n步转移概率为</p> \\[P_{ij}^{(n)}=P\\{X_{n+m}=j|X_{m}=i\\},\\quad n\\ge0,\\quad i,j\\ge0.\\] <p>[!NOTE] Proposition 4.5 (Chapman-Kolmogorov方程 CK-Equation) 对任意\\(i,j\\in E,m,n\\geqslant0\\)</p> \\[P_{ij}^{(n+m)}=\\sum_{k\\in E}P_{ik}^{(n)}P_{kj}^{(m)}\\] <p>注：实际是一个例子，由于重要性记为Prop.</p> <p><code>Proof.</code></p> \\[\\begin{aligned} P_{ij}^{(n+m)}&amp; =P\\{X_{n+m}=j|X_{0}=i\\}  \\\\ &amp;=\\sum_{k\\in E}P\\{X_{n+m}=j,X_{n}=k|X_{0}=i\\} \\\\ &amp;=\\sum_{k\\in E}P\\{X_{n+m}=j|X_{n}=k,X_{0}=i\\}P\\{X_{n}=k|X_{0}=i\\} \\\\ &amp;\\overset{Markov}{=}\\sum_{k\\in E}P_{kj}^{(m)}P_{ik}^{(n)}. \\end{aligned}\\] <p>记\\(P^{(n)}\\) 为n步转移矩阵，则由Chapman-Kolmogorov方程</p> \\[P^{(n+m)}=P^{(n)}\\cdot P^{(m)},\\] <p>其中\\(\\cdot\\)为矩阵乘法，那么</p> \\[P^{(n)}=P\\cdot P^{(n-1)}=P\\cdot P\\cdot P^{(n-2)}=\\cdots=P^{n}.\\] <p>[!example] Example4.6 (两状态的Markov链 \\(I\\))</p> <p>设离散时间Markov 链的样本空间只有两个状态。一步转移概率矩阵为</p> \\[P=\\left(\\begin{array}{cc}1-\\alpha&amp;\\alpha\\\\\\beta&amp;1-\\beta\\end{array}\\right)\\] <p>其中\\(\\alpha,\\beta\\in(0,1)\\) 。</p> <p>我们想要计算它的n步转移矩阵，由Chapman-Kolmogorou方程，只需要计算\\(P^{n}\\) 。做特征值分解,\\(P\\)的两个特征值为</p> \\[\\lambda_0=1,\\quad\\lambda_1=1-\\alpha-\\beta \\] <p>可得</p> \\[P=\\frac{1}{\\alpha+\\beta}\\left(\\begin{array}{cc}1&amp;\\alpha\\\\1&amp;-\\beta\\end{array}\\right)\\begin{pmatrix}1&amp;0\\\\0&amp;1-\\alpha-\\beta\\end{pmatrix}\\begin{pmatrix}\\beta&amp;\\alpha\\\\1&amp;-1\\end{pmatrix}\\] <p>那么</p> \\[\\begin{gathered} P^{n} =\\frac{1}{\\alpha+\\beta}\\left(\\begin{array}{cc}{1}&amp;{\\alpha}\\\\{1}&amp;{-\\beta}\\end{array}\\right)\\left(\\begin{array}{cc}{1}&amp;{0}\\\\{0}&amp;{(1-\\alpha-\\beta)^{n}}\\end{array}\\right)\\left(\\begin{array}{cc}{\\beta}&amp;{\\alpha}\\\\{1}&amp;{-1}\\end{array}\\right) \\\\ =\\frac{1}{\\alpha+\\beta}\\left(\\begin{array}{cc}\\beta&amp;\\alpha\\\\\\beta&amp;\\alpha\\end{array}\\right)+\\frac{(1-\\alpha-\\beta)^{n}}{\\alpha+\\beta}\\left(\\begin{array}{cc}\\alpha&amp;-\\alpha\\\\-\\beta&amp;\\beta\\end{array}\\right)  \\end{gathered}\\] <p>注意到，随着\\(n\\to\\infty\\), \\(n\\) 步转移概率存在极限</p> \\[\\lim\\limits_{n\\to\\infty}P_{00}^{(n)}=\\lim\\limits_{n\\to\\infty}P_{10}^{(n)}=\\frac{\\beta}{\\alpha+\\beta}\\] \\[\\lim\\limits_{n\\to\\infty}P_{11}^{(n)}=\\lim\\limits_{n\\to\\infty}P_{01}^{(n)}=\\frac{\\alpha}{\\alpha+\\beta}\\] <p>这是我们之后要学习的遍历性。</p> <p>[!question] 思考 如果\\(|1-\\alpha-\\beta|=1\\) ，即\\(\\alpha=\\beta=1\\) 时会发生什么？ </p>","path":["Lecture 4 - Discrete-time Markov Chains"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%204%20-%20Discrete-time%20Markov%20Chains/#_2","level":2,"title":"不变分布","text":"<p>之前我们关心Markov链的转移概率,但\\(X_{n}\\) 作为一个随机变量,我们也关心它分布的变化,设\\(\\{X_n\\}\\) 是一个转移矩阵为\\(P\\)的Markov链,初始分布为\\(X_{0}\\sim\\mu\\) ，则\\(X_{1}\\) 的分布列为</p> \\[\\begin{aligned} P(X_{1}=j) &amp;=\\sum_{k\\in E}P(X_{0}=k)P(X_{1}=j|X_{0}=k) \\\\ &amp;=\\sum_{k\\in E}\\mu_{k}P_{kj},\\quad j\\in E  \\end{aligned}\\] <p>把分布\\(\\mu\\) 视为状态空间\\(E\\)上的行向量，那么\\(X_{1}\\) 的分布\\(\\mu_{1}\\)为\\(\\mu P\\),自然地,\\(X_n\\) 的分布为\\(\\mu P^{(n)}=\\) \\(\\mu P^{n}\\)</p> <p>[!NOTE] Definition4.7 (不变测度) 设\\(\\pi=\\{\\pi_{i},i\\in E\\}\\) 为\\(E\\) 上的测度，若π满足不变方程</p> \\[\\pi_j=\\sum_{k\\in E}\\pi_kP_{kj},\\quad\\forall j\\in E\\] <p>则称\\(\\pi\\)为\\(P\\)的不变测度(inwariant measure)。进一步，若\\(\\sum\\limits _{i\\in E}\\pi _{i}=1\\)，则称\\(\\pi\\)为不变分布。也称\\(\\pi\\)为以\\(P\\)为转移矩阵的Markov链的不变测度。</p> <p>这也可以理解为是收敛性的一种体现</p> <p>注1．显然\\(\\pi_{i}=0,\\forall i\\in E\\)是一个平凡的不变测度。若π是非平凡的，且\\(\\sum\\limits_{i\\in E}\\pi_{i}&lt;\\infty\\) 的不变测度，那么我们总可以将其归一化得到不变分布.</p> \\[\\frac{\\pi_i}{\\sum\\limits_{k\\in E}\\pi_k},\\quad i\\in E\\] <p>注2.设\\(\\pi\\)为不变分布，如果\\(X_0\\sim\\pi\\),那么(4.4)</p> \\[(X_0,X_1,\\cdots,X_n)\\overset{d}{=}(X_m,X_{m+1},\\cdots,X_{m+n})\\:,\\quad\\forall n,m\\geqslant1.\\] <p>满足(4.4)的随机过程称为平稳过程(Stationary Process)，即任何时刻\\(m\\)作为起点，相同时间间隔\\(n\\)随机过程的有限维分布都是相同的。因此不变分布π也被称为平稳分布(Stationary Distribution).</p> <p>注意与平稳增量过程做对比(Stationary Crements)</p> <p>注3．若E是有限的，把π视为行向量，不变分布π就是矩阵P的特征值为1的左特征向量，于是我们可以通过解线性方程组</p> \\[\\pi=\\pi P\\] <p>来求不变分布。</p> <p>注4．一般而言，Markov链可以没有不变分布，例如一维简单随机游动（思考一下)；也可以有多个不变分布，例如以单位矩阵为转移矩阵的Markov链，或者一个非平凡的例子：转移矩阵为</p> \\[P=\\begin{pmatrix}0&amp;1&amp;0&amp;0\\\\[1ex]1&amp;0&amp;0&amp;0\\\\[1ex]0&amp;0&amp;0&amp;1\\\\[1ex]0&amp;0&amp;1&amp;0\\end{pmatrix}\\] <p>的Markov链，它的不变分布为</p> \\[\\begin{pmatrix}\\frac{\\alpha}{2},\\frac{\\alpha}{2},\\frac{\\beta}{2},\\frac{\\beta}{2}\\end{pmatrix},\\quad\\alpha,\\beta\\geqslant0,\\alpha+\\beta=1\\] <p>有无穷多个。</p> <p>Markov链研究中的一个基本问题是确定所有的不变分布。</p> <p>有下列几个自然的问题： 1.不变分布在什么条件下存在？ 2.假设不变分布存在，那么它在什么条件下是唯一的？在什么条件下\\(\\mu\\mathbf{P}^{n}\\) 收敛到不变分布？ 3.如果\\(\\mu\\mathbf{P}^{n}\\) 收敛到不变分布，那么收敛速度有多快(Design of algorithm)？</p> <p>我们在后面的学习中会回答这些问题。</p> <p>[!Example] Example4.8(两状态的Markov链 \\(II\\)) 考虑状态空间为\\(\\{0,1\\}\\) ，转移矩阵为</p> \\[P=\\left(\\begin{array}{cc}1-\\alpha&amp;\\alpha\\\\\\beta&amp;1-\\beta\\end{array}\\right)\\] <p>的Markov链，它的不变分布\\(\\pi\\) 满足：</p> \\[\\begin{array}{c}\\pi_0(1-\\alpha)+\\pi_1\\beta=\\pi_0\\\\  \\pi_0\\alpha+\\pi_1(1-\\beta)=\\pi_1\\end{array}\\] <p>结合\\(\\pi_{0}+\\pi_{1}=1\\) ，可以解得</p> \\[\\pi_0=\\frac{\\beta}{\\alpha+\\beta},\\pi_1=\\frac{\\alpha}{\\alpha+\\beta}.\\] <p>[!QUESTION] 思考</p> \\[\\lim\\limits_{n\\to\\infty}P^{(n)}=\\frac{1}{\\alpha+\\beta}\\left(\\begin{array}{cc}\\beta&amp;\\alpha\\\\\\beta&amp;\\alpha\\end{array}\\right)=\\left(\\begin{array}{c}\\pi\\\\\\pi\\end{array}\\right).\\] <p>回顾转移概率的极限和不变分布之间有什么关系呢？</p> <p>Recall: 与前文的两状态Markov链\\(I\\)中的不变分布的极限值相等，我们不免思考其中是否存在什么联系？</p>","path":["Lecture 4 - Discrete-time Markov Chains"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%205%20-%20Classification%20of%20States/","level":1,"title":"Lecture 5 - Classification of States","text":"<p>[!tldr] Syllabus + 可约性 + 周期性 + 常返性</p>","path":["Lecture 5 - Classification of States"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%205%20-%20Classification%20of%20States/#_1","level":2,"title":"可约性与周期性","text":"<p>[!NOTE] Definition 5.1(可达)  设\\(i,j\\in E\\)是Markov链中的两个状态，如果\\(\\exists n\\geqslant 0\\)使得从\\(i\\)出发经过\\(n\\)步转移可以到达\\(j\\)(\\(P_{ij}&gt;0\\))，则称状态\\(i\\)可达(accessible)\\(j\\)，记作\\(i\\to j\\)，如果\\(i\\)不可达\\(j\\)，即\\(\\forall n&gt;0,P_{ij}^{n}=0\\),记作\\(i\\not\\to j\\)</p> <p>注：可达具有传递性，设\\(i,j,k\\in E，n,m \\geqslant 0\\)，使得\\(P_{ij}^{(n)}&gt;0,P_{jk}^{(m)}&gt;0\\)，则</p> \\[ P_{ik}^{(n+m)}=\\sum\\limits_{j\\in E}P_{ij}^{(n)}P_{jk}^{(m)}\\geqslant P_{ij}^{(n)}P_{jk}^{(m)}&gt;0 \\] <p>即若\\(i\\to j,j\\to k\\)，那么\\(i\\to k\\)</p> <p>[!NOTE] Definition 5.2(互通) 设\\(i,j\\in E\\)是Markov链中两个状态，如果\\(\\exists n,m \\geqslant 0\\)使得</p> \\[P_{ij}^{(n)}&gt;0,P_{ji}^{m}&gt;0\\] <p>就称\\(i\\)和\\(j\\)互通(communicate),记作\\(i \\leftrightarrow j\\)</p> <p>[!NOTE] 命题 5.3 互通是状态空间\\(E\\)上的一个等价关系，即 + 自反性 + 对称性 + 传递性(Proved by CK-Equation)</p> <p>因此所有互通的状态构成等价类，称这样的等价类为互通类(Communication Class)</p> <p>[!NOTE] Definition 5.4(不可约性 irreducible) 一个Markov链称为不可约的(irreducible)，如果它的互通类只有一个，即所有状态都是互通的</p> <p>注1. 矩阵的不可约性</p> <p>设\\(A\\in \\mathbb{R}^{n\\times n}\\)为一个\\(n\\)阶方阵，称\\(A\\)可约(reducible),如果存在置换矩阵\\(B\\),使得</p> \\[ B^{T}AB=\\begin{vmatrix} C &amp; D \\\\ O &amp; E \\end{vmatrix} \\] <p>称这个矩阵是可约的，否则称\\(A\\)不可约</p> <p>[!NOTE] 推论 一个Markov链不可约\\(\\iff\\)它的转移矩阵不可约</p> <p>[!NOTE] Definition 5.5(周期性) 状态\\(i\\in E\\)的周期(period)定义为</p> \\[ d_{i} \\overset{\\Delta}{=} gcd\\left\\{  {n,P_{ii}^{(n)}&gt;0}\\right\\}\\] <p>若\\(d_{i}=1\\)，则称状态\\(i\\)是非周期的</p> <p>[!NOTE] 命题 5.6 若\\(i \\leftrightarrow j\\)，则\\(d_{i}=d_{j}\\)</p> <p><code>Proof.</code></p> <p>由于\\(i \\leftrightarrow j\\)，故\\(\\exists n,m \\geqslant 0\\),使得\\(P_{ij}^{(n)}&gt;0,P_{ij}^{(m)}&gt;0\\)</p> <p>又\\(d_{j}\\)为状态\\(j\\)的周期，所以\\(\\exists k\\)，\\(P_{jj}^{(kd_{j})}&gt;0,P_{jj}^{((k+1)d_{j})}&gt;0\\)</p> <p>那么</p> \\[\\begin{aligned} P_{ii}^{(m+kd_{j}+n)}&amp;\\geqslant P_{ij}^{(m)}P_{jj}^{(kd_{j})}P_{ji}^{(n)}&gt;0\\\\ P_{ii}^{(m+(k+1)d_{j}+n)}&amp;\\geqslant P_{ij}^{(m)}P_{jj}^{((k+1)d_{j})}P_{ji}^{(n)}&gt;0 \\end{aligned}\\] <p>即\\(d_{i} \\mid(m+kd_{j}+n),d_{i}\\mid(m+(k+1)d_{j}+n)\\)</p> <p>故\\(d_{i}\\mid d_{j}\\)，同理可证\\(d_{j}\\mid d_{i}\\),故\\(d_{i}=d_{j}\\)</p> <p>利用周期性，可以利用互通性对状态进行进一步分类，下面不妨先考虑只有一个互通类的Markov链也就是不可约的Markov链</p> <p>由不可约性，由命题5.6，每个状态周期相同，不妨记为\\(d\\)，给定某个状态之后\\(i_{0}\\)，我们定义下面集合</p> \\[ \\begin{aligned} C_{0}&amp;\\overset{\\Delta}{=}\\left\\{ j\\in E,P_{ij}^{(n)}&gt;0,n\\equiv 0 (mod\\ d) \\right\\} \\\\ C_{1}&amp;\\overset{\\Delta}{=}\\left\\{ j\\in E,P_{ij}^{(n)}&gt;0,n\\equiv 1 (mod\\ d) \\right\\} \\\\ \\dots&amp;\\\\ C_{d-1}&amp;\\overset{\\Delta}{=}\\left\\{ j\\in E,P_{ij}^{(n)}&gt;0,n\\equiv d-1 (mod\\ d) \\right\\}  \\end{aligned} \\] <p>根据模的余数分类构成了一个最小剩余</p> <p>那么状态集合\\(E=C_{0}\\bigcup C_{1}\\bigcup\\dots \\bigcup C_{d-1}\\)</p> <p>[!NOTE] 命题 5.7 若状态\\(i\\in C_{p}\\)，且\\(P_{ij}&gt;0\\)，那么\\(j\\in C_{p+1}\\)</p> <p><code>Proof.</code></p> <p>由于\\(i\\in C_{p}\\),则存在\\(a=kd+p\\)，其中\\(k\\in N\\)使得\\(P_{i_{0}i}^{(a)}&gt;0\\)</p> <p>对\\(a+1=kd+p+1\\)</p> \\[ P_{i_{0}i}^{(n+1)}\\geqslant P_{i_{0}i}^{(a)}P_{ij}&gt;0 \\] <p>即\\(j\\in C_{p+1}\\)</p> <p>注：当\\(0\\leqslant k \\leqslant d-1\\)时，从\\(C_{k}\\)中的状态转移到\\(C_{k+1}\\)，然后从\\(C_{d-1}\\)回到\\(C_{0}\\)，即经过适当的行列置换，它的转移矩阵可以表示为：</p> \\[ P=\\begin{pmatrix} 0 &amp; A_{0,1} &amp; \\dots &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; A_{1,2} &amp; \\dots &amp; 0 \\\\ \\dots \\\\ A_{d-1,0} &amp; \\dots &amp; \\dots &amp; \\dots &amp; 0 \\end{pmatrix} \\] <p>[!question] 思考 一步转移矩阵如上，那么n步转移矩阵(\\(P^{2},P^{3},\\dots\\))？</p>","path":["Lecture 5 - Classification of States"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%205%20-%20Classification%20of%20States/#_2","level":2,"title":"常返性","text":"<p>George Polyo</p> <p>[!NOTE] Definition 5.8(首达时) 设\\(\\left\\{ X_{n} \\right\\}\\)为一个状态空间为\\(E\\)的Markov链，从\\(n=0\\)出发首次达到状态\\(j\\)的时刻，我们记为</p> <p>$$\\tau_{j}\\overset{\\Delta}{=}\\inf \\left{ n \\geqslant 1: X_{n}=j \\right} $$ 若\\(\\left\\{ n \\geqslant 1,X_{n}=j \\right\\}=\\emptyset\\),则\\(\\tau_{j}\\overset{\\Delta}{=}\\infty\\)</p> <p>[!NOTE] Definition 5.9(首达概率) 设\\(\\left\\{ X_{n} \\right\\}\\)为一个状态空间为\\(E\\)的Markov链，则经过\\(n\\)步从状态\\(i\\)到\\(j\\)的首达概率为</p> \\[\\begin{aligned} f_{ij}^{(n)}&amp;\\overset{\\Delta}{=}P\\left( \\tau_{j}=n\\mid X_{0}=i \\right) \\\\ &amp;=P\\left(  X_{n}=j,X_{n-1}\\neq j \\dots ,X_{1}\\neq j \\mid X_{0}=i\\right)  \\end{aligned}\\] <p>注：定义事件\\(A_{n}\\overset{\\Delta}{=}\\left\\{ X_{n}=j,X_{n-1}\\neq j \\dots ,X_{1}\\neq j \\mid X_{0}=i \\right\\}\\)</p> <p>则\\(\\left\\{ A_{n} \\right\\}\\)互不相容的，即\\(A_{n}\\bigcap A_{m}=\\emptyset,\\forall n,m\\),那么从状态\\(i\\)出发迟早到达\\(j\\)的概率为</p> \\[\\begin{aligned} f_{ij}^{(n)}&amp;\\overset{\\Delta}{=}P\\left( \\tau_{j}&lt; \\infty\\mid X_{0}=i \\right)\\\\ &amp;=P\\left( \\bigcup\\limits_{k=1}^{\\infty}A_{k}\\mid X_{0}=i \\right)\\\\ &amp;=\\sum\\limits_{n=1}^{\\infty} f_{ij}^{(n)}\\leqslant 1 \\end{aligned}\\] <p>[!NOTE] Definition 5.10(常返性) 如果\\(f_{ii}=\\sum\\limits_{n=1}^{\\infty}f_{ii}^{(n)}=1\\)，则称状态\\(i\\)是常返的(Recurrent)，否则称\\(i\\)为暂留的(Transient)，或者非常返的(Nonrecurrent)).</p> <p>虽然我们通过\\(f_{ij}\\) 来定义常返性，但\\(f_{ij}^{(n)}\\) 的计算并不容易，所以我们想要通过n步转移概率\\(P_{ij}^{(n)}\\) 来计算，通过\\(P_{ij}^{(n)}\\) 来获得状态是否是常返的判据，这即是下面的定理：</p> <p>[!important] Theorem 5.11 状态\\(i\\)是常返态的充分必要条件是</p> \\[\\begin{aligned}\\sum_{n=0}^{\\infty}P_{ii}^{(n)}=\\infty\\end{aligned}\\] <p><code>Proof.</code></p> <p>注意到事件</p> \\[A_n\\triangleq\\{X_n=j,X_{n-1}\\neq j,\\cdots,X_1\\neq j|X_0=i\\}\\] <p>互不相容，考虑基于此对样本轨道进行分解</p> \\[\\begin{aligned} P_{ij}^{(n)}&amp;=P(X_{n}=j|X_{0}=i) \\\\ &amp;=\\sum_{k=1}^nP(X_n=j,X_k=j,X_{k-1}\\neq j,\\cdots,X_1\\neq j|X_0=i) \\\\ &amp;=\\sum_{k=1}^{n}P(X_{n}=j|X_{k}=j,X_{k-1}\\neq j,\\cdots,x_{1}\\neq j,X_0=i)P(X_{k}=j,X_{k-1}\\neq j,\\cdots|X_0=i)  \\\\ &amp;\\overset{Markov}{=}\\sum_{k=1}^{n}P(X_{n}=j|X_{k}=j)P(X_{k}=j,X_{k-1}\\neq j,\\cdots,X_{1}\\neq j|X_{0}=i) \\\\ &amp;=\\sum_{k=1}^{n}f_{ij}^{(k)}P_{jj}^{(n-k)} \\end{aligned}\\] <p>于是根据形式可以考虑卷积\\(\\to\\)母函数方法(记号：\\(\\delta_{ij}=1(i=j)\\)，否则为0)</p> \\[\\begin{aligned} \\sum_{n=0}^{\\infty}P_{ij}^{(n)}z^{n}&amp; =\\delta_{ij}+\\sum_{n=1}^{\\infty}P_{ij}^{(n)}z^{n}  \\\\ &amp;=\\delta_{ij}+\\sum_{n=1}^{\\infty}\\sum_{k=1}^{n}f_{ij}^{(k)}P_{jj}^{(n-k)}z^{n} \\\\ &amp;=\\delta_{ij}+\\sum_{n=1}^{\\infty}\\sum_{k=1}^{n}(f_{ij}^{(k)}z^{k})(P_{jj}^{(n-k)}z^{n-k}) \\\\ &amp;\\overset{Abel}{=}\\delta_{ij}+\\sum_{k=1}^{\\infty}(f_{ij}^{(k)}z^{k})\\sum_{n=k}^{\\infty}(P_{jj}^{(n-k)}z^{n-k}) \\\\ &amp;=\\delta_{ij}+\\sum_{k=1}^\\infty(f_{ij}^{(k)}z^k)\\sum_{m=0}^\\infty(P_{jj}^{(m)}z^m) \\end{aligned}\\] <p>那么令\\(j=i\\)</p> \\[\\begin{aligned}\\sum_{n=0}^\\infty P_{ii}^{(n)}z^n=1+\\sum_{k=1}^\\infty(f_{ii}^{(k)}z^k)\\sum_{n=0}^\\infty(P_{ii}^{(n)}z^n)\\end{aligned}\\] <p>即</p> \\[\\begin{aligned}\\sum_{n=0}^{\\infty}P_{ii}^{(n)}z^n=\\frac{1}{1-\\sum_{k=1}^{\\infty}f_{ii}^{(k)}z^k}\\end{aligned}\\] <p>令\\(z\\to1^{-}\\) ，由Abel定理可得</p> \\[\\begin{aligned}\\sum_{n=1}^{\\infty}P_{ii}^{(n)}&amp;=\\frac{1}{1-f_{ii}}\\end{aligned}\\] <p>那么\\(f_{ii}=1\\)即等价于\\(\\sum\\limits_{n=0}^{\\infty}P_{ii}^{(n)}=\\infty\\)</p> <p>注1．另一种概率方法的证明：</p> <p>由\\(f_{ii}\\)的定义，Markov链\\(\\{X_n\\}\\)从状态出发，最终能回到的概率为\\(f_{ii}\\)，那么一直回不到的概率为\\(1-f_{ii}\\)</p> <p>由于Markov性，所以在回到\\(i\\)之后，过程在概率意义下又重新开始，那么\\(X_{0}=i\\) 开始，Markov链\\(\\{X_n\\}\\) 恰有\\(n\\) 次处于状态\\(i\\)服从几何分布，\\(P\\{X_n\\)处于状态i的次数\\(=n\\mid X_{0}=i\\}=f_{ii}^{n-1}(1-f_{ii})\\)</p> <p>所以，从\\(i\\)出发以后，处于\\(i\\)状态的期望为</p> \\[\\begin{aligned}\\sum_{n=1}^{\\infty}nf_{ii}^{n-1}(1-f_{ii})=\\frac{1}{1-f_{ii}}\\end{aligned}\\] <p>那么\\(i\\)是常返态，当且仅当\\(E[X_{n}\\)处于状态i的次数\\(\\left|\\begin{array}{c}X_{0}=i\\end{array}\\right]=\\infty\\)，下面证明期望与所求概率和相等：</p> <p>记随机序列\\(I_{n}\\)为：当\\(X_{n}=i\\)时\\(I_{n}=1\\)，否则为0，那么\\(\\sum_{n=0}^{\\infty}I_{n}\\)表示\\(I_{n}\\)处于状态\\(i\\)的次数，则有</p> \\[\\mathbb{E}\\left[\\sum_{n=1}^\\infty I_n|X_0=i\\right]=\\sum_{n=1}^\\infty\\mathbb{E}[I_n|X_0=i]=\\sum_{n=1}^\\infty P(X_n=i|X_0=i)=\\sum_{n=1}^\\infty P_{ii}^{(n)}\\] <p>故状态是常返态的充分必要条件是\\(\\sum_{n=0}^{\\infty}P_{ii}^{(n)}=\\infty\\)(\\(n=0\\)时概率有界量不影响证明-无穷大)</p> <p>注2．从注1的证明过程中，我们可以看出若状态\\(i\\)是暂留的，则Markov链只会有限次处于状态\\(i\\) ，可以具体表述为下面推论。</p> <p>[!NOTE] Corollary 5.12 如果状态\\(j\\)是暂留的，那么对任意状态\\(i\\)</p> \\[P_{ij}^{(n)}\\to0,\\quad n\\to\\infty \\] <p><code>Proof</code></p> <p>若\\(j=i\\) 是暂留的，我们已经证明：</p> \\[\\begin{aligned}\\sum_{n=1}^{\\infty}P_{ii}^{(n)}=\\frac{1}{1-f_{ii}}&lt;\\infty\\end{aligned}\\] <p>所以级数的通项\\(\\lim\\limits_{ n \\to \\infty }P_{ij}^{(n)}=0\\)(收敛的必要条件)</p> <p>另一方面，若\\(j\\neq i\\) 是暂留的，我们已经证明：</p> \\[\\begin{aligned}\\sum_{n=0}^\\infty P_{ij}^{(n)}=\\delta_{ij}+\\sum_{k=1}^\\infty f_{ij}^{(k)}\\sum_{n=0}^\\infty P_{jj}^{(n)}=\\sum_{n=1}^\\infty f_{ij}^{(n)}\\sum_{n=0}^\\infty P_{jj}^{(n)}&lt;\\infty\\end{aligned}\\] <p>所以级数的通项\\(\\lim\\limits_{ n \\to \\infty }P_{ij}^{(n)}=0\\)</p> <p>注3．常返与非常返具有类的性质</p> <p>[!NOTE] Corollary 5.13 若状态\\(i\\)是常返的，且\\(i\\leftrightarrow j\\) ，则\\(j\\) 是常返的</p> <p><code>Proof</code></p> <p>由于\\(i\\leftrightarrow j\\) ，则存在\\(m\\) 和\\(n\\) 使得</p> \\[P_{ij}^{(n)}&gt;0,\\quad P_{ji}^{(m)}&gt;0\\] <p>对任意\\(s&gt;0\\) ，由CK方程有</p> \\[P_{jj}^{(m+n+s)}\\geq P_{ji}^{(m)}P_{ii}^{(s)}P_{ij}^{(n)}\\] <p>由于状态是常返的，即\\(\\sum_{s=0}^{\\infty}P_{ii}^{(s)}=\\infty\\) ，所以</p> \\[\\displaystyle\\sum_{s=0}^{\\infty}P_{jj}^{(m+n+s)}\\geq P_{ji}^{(m)}P_{ij}^{(n)}\\sum_{s=0}^{\\infty}P_{ii}^{(s)}=\\infty \\] <p>由定理5.11， \\(j\\) 是常返的。</p> <p>上面的推论表明常返性与非常返是互通类的性质，因此我们可以说一个状态的集合为一个常返类或非常返类。如果Markov链不可约，则所有状态或者都常返，或者都非常返。此时，我们也可说Markov链是常返的或非常返的。</p> <p>注4.有的文献也称\\(\\sum\\limits_{n=0}^{\\infty}P_{ij}^{(n)}\\)为格林函数，记为\\(G_{ij}\\)</p> <p>如果Markov链的状态是有限的，常返性的判定会更加简化，有下面结论：</p> <p>[!NOTE] Proposition 5.14 有限状态Markov链必然存在常返态</p> <p><code>Proof</code></p> <p>反证法，若命题不成立。设状态空间\\(E=\\{1,2,\\ldots,N\\}\\)，则所有状态都是暂留的。固定状态\\(i\\)，对任意\\(j\\)，由推论5.12</p> \\[P_{ij}^{(k)}\\to0,\\quad k\\to\\infty \\] <p>所以</p> \\[\\sum_{j=1}^NP_{ij}^{(k)}\\to0,\\quad k\\to\\infty \\] <p>但是由转移概率的性质，对任意k有</p> \\[\\sum_{j=1}^NP_{ij}^{(k)}=1\\] <p>矛盾！故命题成立。</p> <p>注.结合推论5.13，我们知道：对于状态有限不可约Markov链，所有状态都是常返态。</p> <p>[!example] Example 5.15 ( \\(d\\) 维简单随机游走的常返性） 设\\(\\xi_{1},\\xi_{2},\\ldots\\) .是取值于\\(E=\\mathbb{Z}^{d}\\)独立同分布随机向量，满足</p> \\[P(\\xi_1=e_i)=P(\\xi_1=-e_i)=\\frac{1}{2d},\\quad i=1,\\dots,d\\] <p>其中\\(e_i\\) 是第\\(i\\)个坐标为1，其余为0的方向向量。</p> <p>设\\(S_{0}\\)独立于\\(\\xi_{1},\\xi_{2},\\ldots\\xi _n\\)，令</p> \\[S_n:=S_0+\\xi_1+\\cdots+\\xi_n=S_{n-1}+\\xi_n.\\] <p>则\\(S_{n}\\) 为从\\(S_{0}\\) 出发的d维简单随机游走。</p> <p>当\\(d=1,2\\) 时，\\(S_{n}\\)是常返的，当\\(d\\geq3\\) 时，\\(S_{n}\\)是非常返的。</p> <p><code>Proof</code></p> <p>不妨假设\\(S_0=0\\)，由\\(\\xi_{i}\\)的定义，所有状态都是互通的，即\\(S_{n}\\)不可约，所以所有状态的常返性一致，因此我们只考虑0状态的常返性。</p> <p>容易注意到经过奇数步不可能回到状态0，若经过\\(2n\\)步回到0，那么对任意方向\\(i\\in\\{1,\\ldots,d\\}\\)必须在该方向前进和后退相同的步数，记为\\(n_{i}\\)，于是</p> \\[P_{00}^{(2n)}=\\sum_{n_1+\\cdots+n_d=n}\\frac{(2n)!}{(n_1!\\:)^2\\cdots(n_d!\\:)^2}\\frac{1}{(2d)^{2n}}.\\] <p>\\(d=1\\) 时</p> \\[\\begin{aligned}\\sum_{n=0}^{\\infty}P_{00}^{(2n)}=\\sum_{n=0}^{\\infty}\\frac{(2n)!}{(n!)^2}\\frac{1}{2^{2n}}.\\end{aligned}\\] <p>由Stirling公式\\(\\lim\\limits_{ n \\to \\infty }n! = \\sqrt{ 2\\pi n } \\left( \\frac{n}{e} \\right)^{n}\\)，对任意的\\(\\varepsilon&gt;0\\) ，存在\\(n_0\\) ，当\\(n&gt;n_0\\) 时</p> \\[\\left(1-\\varepsilon\\right)\\frac{1}{\\sqrt{\\pi n}}\\leqslant\\frac{\\left(2n\\right)!}{\\left(n!\\right)^2}\\frac{1}{2^{2n}}\\leqslant\\left(1+\\varepsilon\\right)\\frac{1}{\\sqrt{\\pi n}}.\\] <p>所以\\(\\sum\\limits_{n=0}^{\\infty}P_{00}^{(2n)}=\\infty\\)，即\\(S_{n}\\)常返。</p> <p>\\(d=2\\) 时，</p> \\[\\begin{aligned} P_{00}^{(2n)}&amp; =\\sum_{n_{1}+n_{2}=n}\\frac{\\left(2n\\right)!}{\\left(n_{1}!\\right)^{2}\\left(n_{2}!\\right)^{2}}\\cdot\\frac{1}{4^{2n}} \\\\ &amp;=\\frac{\\left(2n\\right)!}{n!\\:n!}\\cdot\\frac{1}{4^{2n}}\\sum_{n_{1}+n_{2}=n}\\frac{n!}{n_{1}!\\:n_{2}!}\\cdot\\frac{n!}{n_{2}!\\:n_{1}!} \\\\ &amp;=C_{2n}^{n}\\cdot\\frac{1}{4^{2n}}\\sum_{n_{1}=0}^{n}C_{n}^{n_{1}}C_{n}^{n-n_{1}} \\\\ &amp;=C_{2n}^{n}\\cdot\\frac{1}{4^{2n}}\\cdot C_{2n}^{n}=\\left(C_{2n}^{n}\\frac{1}{2^{2n}}\\right)^{2} \\\\ &amp;\\approx\\frac{1}{\\pi n} \\end{aligned}\\] <p>所以\\(\\sum\\limits_{n=0}^{\\infty}P_{00}^{(2n)}=\\infty\\)，即\\(S_{n}\\)常返</p> <p>当\\(d\\geq3\\) 时，可以证明，当\\(n\\) 充分大时，有</p> \\[P_{00}^{(2n)}\\leqslant C_{d}\\cdot n^{-d/2},\\] <p>其中\\(C_d\\) 是依赖于d的常数。</p> <p>(参考《应用随机过程》，陈大岳、章复熹，北京大学出版社 2023 P95-P99)</p> <p>所以\\(\\sum\\limits_{n=0}^{\\infty}P_{00}^{(2n)}&lt;\\infty\\) ，即\\(S_{n}\\)非常返。</p> <p>这表明一维或二维的简单随机游动一定能回到起点，但三维以上的简单随机游动却不一定。</p> <p>日本学者角谷静夫Kakutani在加利福尼亚大学洛杉矶分校（UCLA）演讲时对此给出了一个有趣的注解：“A drunk man willfindhis wayhome,but a drunkbird may getlost forever.\"</p>","path":["Lecture 5 - Classification of States"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%206%20-%20Limit%20Behaviour%20&%20Ergodic%20Theory/","level":1,"title":"Lecture 6 - Limit Behaviour &amp; Ergodic Theory","text":"<p>[!tldr] Syllabus + 正常返 + 遍历定理 + 不变分布的存在性与唯一性</p> <p>本节课接着常返性的内容，考虑\\(n\\to\\infty\\) 的情形，继续研究随时间推移,Markov链转移的规律。由上一节课中Corollary 5.12，若状态\\(j\\) 是暂留的，那么对任意状态</p> \\[P_{ij}^{(n)}\\to0,\\quad n\\to\\infty \\] <p>所以本节课我们只考虑常返状态。</p>","path":["Lecture 6 - Limit Behaviour &amp; Ergodic Theory"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%206%20-%20Limit%20Behaviour%20&%20Ergodic%20Theory/#_1","level":2,"title":"弱遍历定理","text":"","path":["Lecture 6 - Limit Behaviour &amp; Ergodic Theory"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%206%20-%20Limit%20Behaviour%20&%20Ergodic%20Theory/#_2","level":3,"title":"平均返回时间和正常返","text":"<p>假设状态\\(i\\)是常返的，那么\\(f_{ii}=\\sum\\limits_{n=1}^{\\infty}f_{ii}^{(n)}=1\\)，把\\(\\left\\{ f_{ii}^{(n)} \\right\\}\\)看成\\(\\mathbb{N}^{+}\\)上的一个分布，我们可以定义返回状态\\(i\\)的平均转移次数</p> <p>[!NOTE] Definition 6.1(平均返回时间) 对于常返状态\\(i\\)的平均返回时间定义为</p> \\[\\mu_{ii}\\overset{\\Delta}{=}\\sum\\limits_{n=1}^{\\infty} nf_{ii}^{(n)}\\] <p>利用平均返回时间可以进一步对常返状态分类</p> <p>[!NOTE] Definition 6.2(正常返) 假设状态\\(i\\)常返，如果它的平均返回时间是有限的，也就是\\(\\mu_{ii}&lt;\\infty\\)，就称状态\\(i\\)是正常返的(Positive recurrent)，否则，\\(M_{ii}=\\infty\\)，我们则称\\(i\\)为零常返(Null recurrent)</p>","path":["Lecture 6 - Limit Behaviour &amp; Ergodic Theory"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%206%20-%20Limit%20Behaviour%20&%20Ergodic%20Theory/#_3","level":3,"title":"弱遍历定理","text":"<p>[!tip] Theorem 6.3(弱遍历定理) 设\\(\\left\\{ X_{n} \\right\\}\\)是不可约常返Markov链，那么对\\(\\forall i,j\\)状态</p> \\[\\lim\\limits_{ n \\to \\infty } \\frac{1}{n}\\sum\\limits_{k=0}^{n-1} P_{ij}^{(k)}= \\frac{1}{\\mu_{jj}}\\] <p><code>Proof.</code></p> <p>先给出一个引理(不加证明)</p> <p>[!NOTE] Lemma 6.4(Hardy&amp;Littlewood) 设\\(\\forall n ,a_{n}\\geqslant 0\\)，记幂级数\\(A(z)\\)为\\(\\sum\\limits_{n=0}^{\\infty}a_{n}z^{n},0\\leqslant z&lt;1\\) 则有</p> \\[\\lim\\limits_{ n \\to \\infty } \\frac{1}{n}\\sum\\limits_{k=0}^{n-1} a_{k}=\\lim\\limits_{ z \\to 1^{-} }(1-z)A(z)\\] <p>设\\(P_{ij}(z)\\overset{\\Delta}{=}\\sum\\limits_{n=0}^{\\infty}P_{ij}^{(n)}z^{n}\\)，由引理得</p> \\[ \\lim\\limits_{ n \\to \\infty } \\frac{1}{n}\\sum\\limits_{k=0}^{n-1}P_{ij}^{(k)}=\\lim\\limits_{ z \\to 1^{-} }(1-z)\\sum\\limits_{n=0}^{\\infty} P_{ij}^{(k)}z^{n} \\] <p>回顾Theorem 5.11的证明中</p> \\[ \\sum\\limits_{n=0}^{\\infty} P_{ij}^{(n)}z^{n}=\\delta_{ij}+\\sum\\limits_{k=1}^{\\infty} \\left( f_{ij}^{(k)}z^{k} \\right) \\sum\\limits_{k=0}^{\\infty} \\left( P_{ij}^{(k)}z^{k} \\right)  \\] <p>设\\(F_{ij}(z)\\overset{\\Delta}{=}\\sum\\limits_{n=1}^{\\infty}f_{ij}^{(n)}z^{n}\\)，当\\(i\\neq j\\)时，由Abel定理可得</p> \\[ F_{ij}(1^{-})=\\lim\\limits_{ z \\to 1^{-} } \\sum\\limits_{n=1}^{\\infty} f_{ij}^{(n)}z^{n}=\\sum\\limits_{n=1}^{\\infty} f_{ij}^{(n)}=1 \\] <p>所以</p> \\[ \\begin{aligned} \\lim\\limits_{ z \\to 1^{-} } (1-z)F_{ij}(z)P_{jj}(z)&amp;=\\lim\\limits_{ z \\to 1^{-} } P_{jj}(z)\\\\ &amp;=\\lim\\limits_{ z \\to 1^{-} }  \\frac{1-z}{1-F_{jj}(z)} \\end{aligned} \\] <p>当\\(i=j\\)时，直接有</p> \\[ \\lim\\limits_{ z \\to 1^{-} } (1-z)P_{jj}(z)=\\lim\\limits_{ z \\to 1^{-} } \\frac{1-z}{1-F_{jj}(z)} \\] <p>无论是否有\\(i=j\\)，即\\(\\forall i\\)都有</p> \\[ \\begin{aligned} \\lim\\limits_{ z \\to 1^{-} } (1-z)P_{ij}(z)=\\lim\\limits_{ z \\to 1^{-} } \\frac{1-z}{1-F_{jj}(z)}\\\\ \\overset{L'Hospital}{=}\\lim\\limits_{ z \\to 1^{-} } \\frac{1}{F_{jj}'(z)} \\end{aligned} \\] <p>由Abel定理(结合上面的所有等式可得)</p> \\[ \\lim\\limits_{ n \\to \\infty } \\frac{1}{n}\\sum\\limits_{k=0}^{n-1} P_{ij}^{(k)}=\\lim\\limits_{ z \\to 1^{-} } \\frac{1}{\\sum\\limits_{n=1}^{\\infty} nf_{jj}^{(n)}z^{n-1}}=\\frac{1}{\\mu_{jj}} \\] <p>注. \\(\\dfrac{1}{n}\\sum\\limits_{k=0}^{n-1}P_{ij}^{(k)}\\) 具有明确的概率含义(概率转化为示性函数的期望)，</p> \\[\\begin{aligned} \\frac{1}{n}\\sum_{k=0}^{n-1}P_{ij}^{(k)}&amp; =\\frac{1}{n}\\sum_{k=0}^{n-1}\\mathbb{E}(\\mathbf{I}_{[X_{k}=j|X_{0}=i]}) \\\\ &amp;=\\frac1n\\mathbb{E}(\\#\\{n&gt;k\\geqslant0:X_{k}=j|X_{0}=i\\}) \\end{aligned}\\] <p>其中#A表示集合A中元素的个数。所以\\(\\dfrac{1}{n}\\sum\\limits_{k=0}^{n-1}P_{ij}^{(k)}\\)表示在\\(n-1\\)步转移中，处于状态\\(j\\)的次数与记录状态总数\\(n\\) 的比值。</p>","path":["Lecture 6 - Limit Behaviour &amp; Ergodic Theory"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%206%20-%20Limit%20Behaviour%20&%20Ergodic%20Theory/#_4","level":3,"title":"正常返的简单性质","text":"<p>和常返性一样，正常返也具有类的性质，即下面命题：</p> <p>[!NOTE] Proposition 6.5 若\\(i\\)正常返,\\(i\\to j\\),那么\\(j\\) 也正常返。</p> <p><code>Proof</code></p> <p>由于\\(i\\to j\\)，那么存在\\(m\\)，使得\\(P_{ij}^{(m)}&gt;0\\) ，由CK方程，</p> \\[P_{kj}^{(l+m)}=\\sum_{s\\in E}P_{ks}^{(l)}P_{sj}^{(m)}\\geqslant P_{ki}^{(l)}P_{ij}^{(m)}\\] <p>不等式两端对\\(l\\)求和平均，</p> \\[\\frac{1}{n}\\sum\\limits_{l=0}^{n-1}P_{kj}^{(l+m)}\\geqslant\\frac{1}{n}\\sum\\limits_{l=0}^{n-1}P_{ki}^{(l)}P_{ij}^{(m)}\\] <p>两端同时令\\(n\\to\\infty\\)取极限，利用弱遍历定理：</p> \\[\\frac{1}{\\mu_{jj}}\\geqslant\\frac{P_{ij}^{(m)}}{\\mu_{ii}}&gt;0\\] <p>故\\(\\mu_{jj}&lt;\\infty\\)，所以\\(j\\)正常返。</p> <p>进一步，如果Markov链的状态是有限的，和常返性一样，有下面结论：</p> <p>[!NOTE] Proposition 6.6 有限状态Markov链必然存在正常返态</p> <p><code>Proof</code></p> <p>反证法，若命题不成立。设状态空间\\(E=\\{1,2,\\ldots,N\\}\\)，则所有状态都是暂留的或者零常返的。固定状态\\(i\\)，对任意\\(j\\)，由弱遍历定理，</p> \\[\\frac{1}{n}\\sum\\limits_{k=0}^{n-1}P_{ij}^{(k)}\\to0,\\quad n\\to\\infty \\] <p>那么对有限的N，</p> \\[\\begin{aligned}\\sum_{j=1}^N\\frac{1}{n}\\sum_{k=0}^{n-1}P_{ij}^{(k)}\\to0,\\quad n\\to\\infty\\end{aligned}\\] <p>然而，由概率转移矩阵的性质：对任意\\(k\\)，\\(\\sum\\limits_{j=1}^{N}P_{ij}^{(k)}=1\\)</p> \\[\\begin{aligned}\\frac{1}{n}\\sum_{j=1}^{N}\\sum_{k=0}^{n-1}P_{ij}^{(k)}=1\\end{aligned}\\] <p>矛盾(按假设应当趋于0)！故命题成立。</p> <p>注.结合推论6.5可知，状态有限的不可约Markov链，所有状态都是正常返态。</p>","path":["Lecture 6 - Limit Behaviour &amp; Ergodic Theory"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%206%20-%20Limit%20Behaviour%20&%20Ergodic%20Theory/#_5","level":2,"title":"不变分布的存在唯一性","text":"","path":["Lecture 6 - Limit Behaviour &amp; Ergodic Theory"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%206%20-%20Limit%20Behaviour%20&%20Ergodic%20Theory/#_6","level":3,"title":"基本问题","text":"<p>本节我们利用弱遍历定理回答关于不变分布的问题：</p> <p>1.如果不变分布存在，什么条件下具有唯一性？</p> <p>便于研究随机动力系统</p> <p>2.不变分布在什么条件下存在？</p> <p>3.如果存在且唯一那么那个Markov链的收敛速度有多快？如何刻画这个速度？(Next Lecture)</p>","path":["Lecture 6 - Limit Behaviour &amp; Ergodic Theory"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%206%20-%20Limit%20Behaviour%20&%20Ergodic%20Theory/#_7","level":3,"title":"不变分布的唯一性","text":"<p>首先回答第一个问题，即下面定理(仍然研究不可约常返的Markov链)</p> <p>[!NOTE] Theorem 6.7 设\\(\\{X_n\\}\\) 是不可约常返的Markov链， \\(\\pi\\)是\\(P\\)的一个不变分布，即满足不变方程\\(\\pi=\\pi P\\)，则对任意状态\\(j\\)，都有\\(\\pi_j&gt;0\\)，且</p> \\[\\pi_j=\\frac{1}{\\mu_{jj}}\\] <p><code>Proof.</code></p> <p>先给出一个引理-有界收敛定理(实际是控制收敛定理的一个特例，M也就是控制函数，控制收敛定理可以在实变函数中得到证明，但有界收敛定理只需要初等概率论的知识)</p> <p>[!NOTE] Lemma 6.8(有界收敛定理) 设\\(X_{1},X_{2},\\ldots\\).为随机变量序列，依概率收敛于\\(X\\)。若存在\\(M&gt;\\) 0，使得对任意\\(n\\geq1\\)，\\(P(|X_n|\\leq M)=1\\)，那么</p> \\[\\lim\\limits_{n\\to\\infty}\\mathbb{E}[X_n]=\\mathbb{E}[\\lim\\limits_{n\\to\\infty}X_n]=\\mathbb{E}[X]\\] <p>依概率收敛，记为\\(X_n\\stackrel{\\mathrm{P}}{\\longrightarrow}X\\)，如果对于\\(\\varepsilon&gt;0\\)</p> \\[\\mathrm{P}(\\omega:|X_n(\\omega)-X(\\omega)|&gt;\\varepsilon)\\to0,n\\to\\infty.\\] <p><code>Proof</code></p> <p>首先，由于\\(X_{n}\\) 依概率收敛于\\(X\\) ，且\\(P(|X_{n}|\\leq M)=1\\) ，所以对任意\\(\\epsilon&gt;0\\)</p> \\[P(|X|&gt;M+\\epsilon)\\leq P(|X_n-X|&gt;\\epsilon)\\to0\\] <p>即\\(P(|X|\\leq M)=1\\) ．其次，对任意\\(\\varepsilon&gt;0\\)</p> \\[\\begin{aligned} \\mathbb{E}[|X_{n}-X|]&amp; =\\mathbb{E}[\\left|X_{n}-X\\right|\\mathbf{I}_{\\left|X_{n}-X\\right|&gt;\\varepsilon}]+\\mathbb{E}[\\left|X_{n}-X\\right|\\mathbf{I}_{\\left|X_{n}-X\\right|\\leqslant\\varepsilon}] \\\\ &amp;\\leq\\mathbb{E}[(|X_{n}|+|X|)\\mathbf{I}_{|X_{n}-X|&gt;\\varepsilon}]+\\varepsilon \\\\ &amp;\\leqslant2MP\\left(|X_{n}-X|&gt;\\varepsilon\\right)+\\varepsilon. \\end{aligned}\\] <p>最后，令\\(n\\to\\infty\\) 可得，</p> \\[\\lim\\sup\\limits_{n\\to\\infty}\\mathbb{E}|X_n-X|\\leqslant\\varepsilon \\] <p>再令\\(\\varepsilon\\rightarrow0\\) 即证。</p> <p>回到原命题，对任意状态\\(i\\)，由于\\(\\sum\\limits_{s\\in E}\\pi_{s}=1\\)，所以存在\\(j\\in S\\)，使得\\(\\pi_j&gt;0\\)。对于任意状态\\(i\\)，由于\\(\\{X_n\\}\\) 不可约，所以\\(j\\to i\\)，故存在\\(n\\) ，使得\\(P_{ji}^{(n)}&gt;0\\)，那么根据不变方程：</p> \\[\\pi_i=\\sum_{k\\in E}\\pi_kP_{ki}^{(n)}\\ge\\pi_jP_{ji}^{(n)}&gt;0\\] <p>命题第一部分得证(\\(\\forall i,\\pi_{i}&gt;0\\))。</p> <p>不妨考虑\\(\\{X_{n}\\}\\)初始分布为\\(\\pi\\)，由于\\(\\pi\\)是不变分布，所以对任意\\(k\\)， \\(P(X_{k}=j)=\\pi_{j}\\) ，那么</p> \\[\\begin{aligned} \\mathbb{E}_{X_{0}\\sim\\pi}\\left[{\\frac{1}{n}}\\sum_{k=0}^{n-1}P_{ij}^{(k)}\\right]&amp; =\\mathbb{E}_{X_{0}\\sim\\pi}\\left[\\frac{1}{n}\\sum_{k=0}^{n-1}\\mathbb{E}[\\mathbf{I}_{X_{k}=j|X_{0}=i}]\\right] \\\\ &amp;=\\frac{1}{n}\\sum_{k=0}^{n-1}P(X_{k}=j)=\\pi_{j} \\end{aligned}\\] <p>由于\\(0\\leqslant\\dfrac{1}{n}\\sum\\limits_{k=0}^{n-1}P_{ij}^{(k)}\\leqslant 1\\)，所以由有界收敛定理+弱遍历定理</p> \\[\\begin{aligned} \\pi_{j}&amp; =\\lim_{n\\to\\infty}\\mathbb{E}_{X_{0}\\sim\\pi}\\left[\\frac{1}{n}\\sum_{k=0}^{n-1}P_{ij}^{(k)}\\right] \\\\ &amp;=\\mathbb{E}_{X_{0}\\sim\\pi}\\left[\\operatorname*{lim}_{n\\to\\infty}\\frac{1}{n}\\sum_{k=0}^{n-1}P_{ij}^{(k)}\\right]=\\mathbb{E}_{X_{0}\\sim\\pi}\\left[\\frac{1}{\\mu_{jj}}\\right]=\\frac{1}{\\mu_{jj}} \\end{aligned}\\] <p>注．上面的命题表明，对于不可约常返Markov链，不变分布如果存在，则是唯一的，并\\(\\exists\\pi_{j}=\\frac{1}{\\mu_{jj}}&gt;0\\) ，那么对任意状态\\(j\\)</p> \\[\\mu_{jj}=\\frac{1}{\\pi_{j}}&lt;\\infty \\] <p>这说明：如果不变分布存在，就有所有状态都是正常返的。</p> <p>下面我们证明其逆命题，也就是若\\(\\mu_{jj}&lt;\\infty\\) ，令\\(\\pi_{i}=\\frac{1}{\\mu_{jj}}\\) ，则\\(\\pi\\) 就是不变分布，这回答了：不变分布在什么条件下存在？</p>","path":["Lecture 6 - Limit Behaviour &amp; Ergodic Theory"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%206%20-%20Limit%20Behaviour%20&%20Ergodic%20Theory/#_8","level":3,"title":"不变分布的存在性","text":"<p>[!NOTE] Theorem 6.9 不可约正常返的Markov链存在平稳分布。</p> <p><code>Proof</code></p> <p>由弱遍历定理，对不可约正常返Markov链中的任意状态\\(i,j\\)</p> \\[\\begin{aligned}\\lim_{n\\to\\infty}\\frac{1}{n}\\sum_{k=0}^{n-1}P_{ij}^{(k)}=\\frac{1}{\\mu_{jj}}\\triangleq p_j&gt;0\\end{aligned}\\] <p>我们下面证明\\(p=(p_{0},p_{1},\\ldots)\\) 为一个不变分布，即满足不变方程\\(p=pP\\) ，且是一个概率分布。</p> <p>先证不变方程\\(p=pP\\) 成立。由C-K方程</p> \\[\\begin{aligned}\\frac{1}{n}\\sum_{k=0}^{n-1}P_{ij}^{(k+1)}=\\sum_{l\\in E}\\left(\\frac{1}{n}\\sum_{k=0}^{n-1}P_{il}^{(k)}\\right)P_{lj}\\end{aligned}\\] <p>由于\\(\\frac{1}{n}(P_{ij}^{(n)}-P_{ij}^{(0)})\\to0\\) \\(n\\to\\infty\\)</p> \\[\\begin{aligned}p_j=\\lim_{n\\to\\infty}\\frac{1}{n}\\sum_{k=0}^{n-1}P_{ij}^{(k)}=\\lim_{n\\to\\infty}\\frac{1}{n}\\sum_{k=0}^{n-1}P_{ij}^{(k+1)}\\end{aligned}\\] <p>由于\\(0\\leqslant\\frac{1}{n}\\sum\\limits_{k=0}^{n-1}P_{ij}^{(k)}\\leqslant1\\) ，所以由有界收敛定理</p> \\[\\lim\\limits_{n\\to\\infty}\\frac{1}{n}\\sum\\limits_{k=0}^{n-1}P_{ij}^{(k+1)}=\\sum\\limits_{l\\in E}\\left(\\lim\\limits_{n\\to\\infty}\\frac{1}{n}\\sum\\limits_{k=0}^{n-1}P_{il}^{(k)}\\right)P_{lj}\\] <p>即得不变方程</p> \\[\\begin{aligned}p_j=\\sum_{l\\in E}p_lP_{lj}\\end{aligned}\\] <p>再证\\(p\\)是一个概率分布，即\\(\\sum_{l\\in E}p_{l}=1\\) ．由于对任意\\(k\\)</p> \\[p=pP\\Longrightarrow p=pP^k\\] <p>所以</p> \\[p_j=\\sum_{l\\in E}p_l\\left(\\frac{1}{n}\\sum_{k=0}^{n-1}P_{lj}^{(k)}\\right)\\] <p>由于\\(0\\leq\\frac{1}{n}\\sum_{k=0}^{n-1}P_{ij}^{(k)}\\leq1\\) ，所以由有界收敛定理</p> \\[\\begin{aligned} \\text{p} &amp;=\\lim_{n\\to\\infty}p_{j}=\\lim_{n\\to\\infty}\\sum_{l\\in E}p_{l}\\left(\\frac{1}{n}\\sum_{k=0}^{n-1}P_{lj}^{(k)}\\right) \\\\ &amp;=\\sum_{l\\in E}p_{l}\\left(\\operatorname*{lim}_{n\\to\\infty}\\frac{1}{n}\\sum_{k=0}^{n-1}P_{lj}^{(k)}\\right)=p_{j}\\sum_{l\\in E}p_{l}  \\end{aligned}\\] <p>所以\\(\\sum\\limits_{l\\in E}p_{l}=1\\)</p>","path":["Lecture 6 - Limit Behaviour &amp; Ergodic Theory"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%206%20-%20Limit%20Behaviour%20&%20Ergodic%20Theory/#_9","level":3,"title":"弱遍历定理的另一形式","text":"<p>我们已经知道了弱遍历极限和不变分布的关系，可以得到弱遍历定理的另一个形式</p> <p>[!NOTE] Theorem 6.10(弱遍历定理) 设\\(\\{X_{n}\\}\\) 是不可约正常返的Markov链，\\(\\pi\\) 是不变分布，那么对任意状态\\(i,j\\)，</p> \\[\\lim\\limits_{n\\to\\infty}\\frac{1}{n}\\sum\\limits_{k=0}^{n-1}P_{ij}^{(k)}=\\pi_j\\]","path":["Lecture 6 - Limit Behaviour &amp; Ergodic Theory"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%206%20-%20Limit%20Behaviour%20&%20Ergodic%20Theory/#_10","level":3,"title":"平均遍历定理","text":"<p>更一般地，可以得到下面的(平均)遍历定理(证明比较复杂课上略过)</p> <p>[!NOTE] Theorem 6.11(遍历定理） 设\\(\\{X_n\\}\\) 是不可约常返的Markov链， \\(\\pi\\)是不变分布， \\(f\\)是\\(E\\)上的函数，满足\\(\\sum\\limits_{i\\in E}\\pi_{i}|f(i)|&lt;\\infty\\)，则</p> \\[\\lim\\limits_{n\\to\\infty}\\frac{1}{n}\\sum\\limits_{k=0}^{n-1}f(X_k)=\\sum\\limits_{i\\in E}\\pi_if(i)\\] <p><code>Proof</code></p> <p>参考《应用随机过程》，陈大岳、章复熹，北京大学出版社，2023，P118，P124-P128.</p> <p>注1.遍历定理说明了长时间尺度下，函数\\(f\\)的时间平均，等于在空间上平均。这意味着系统的长期统计行为可以由其稳态分布完全描述。此外，在计算数学中，经常会处理高维空间上积分计算的问题，即\\(E\\)是高维空间，那么由遍历定理，即可通过构造随机动力系统(遍历的Markov过程)，通过计算时间上的一维积分，取极限得到高维积分的结果。</p> <p>Addition：刘军 -《科学计算中的蒙特卡洛策略》- 科学出版社</p> <p>注2.遍历定理可以视为大数定律在Markov依赖结构下的推广。大数定律适用于独立同分布的随机变量，表明样本均值收敛到期望：而遍历定理适用于具有Markov性的序列，表明时间平均收敛到平稳分布下的期望。两者都揭示了“平均行为的稳定性”，但遍历定理处理的是更一般的Markov依赖的情况。</p> <p>回顾大数定律：</p> \\[ \\begin{aligned} \\frac{1}{n}\\sum\\limits_{i=1}^{n} X_{i}\\overset{p}{\\to}E\\left[ X_{i} \\right]\\\\ \\frac{1}{n}\\sum\\limits_{i=1}^{n} X_{i}\\overset{a.s.}{\\to}E\\left[ X_{i} \\right] \\end{aligned} \\]","path":["Lecture 6 - Limit Behaviour &amp; Ergodic Theory"],"tags":[]},{"location":"Analysis/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/Assets/Lecture%206%20-%20Limit%20Behaviour%20&%20Ergodic%20Theory/#_11","level":2,"title":"强遍历定理","text":"<p>常返性和弱遍历定理虽然给出了随Markov链转移状态的渐近规律，但是当\\(n\\rightarrow\\infty\\)时，转移概率\\(P_{ij}^{(n)}\\)的极限情况我们仍然不清楚。先看一个例子。</p> <p>[!example] Example 6.12(两状态的Markov链III) 考虑Markov链，状态空间为\\(\\{0,1\\}\\) ，转移矩阵为</p> \\[P=\\left(\\begin{array}{cc}1-\\alpha&amp;\\alpha\\\\\\beta&amp;1-\\beta\\end{array}\\right)\\] <p>其中\\(\\alpha,\\beta\\in(0,1)\\)</p> \\[P^n=\\frac{1}{\\alpha+\\beta}\\left(\\begin{array}{cc}\\beta&amp;\\alpha\\\\\\beta&amp;\\alpha\\end{array}\\right)+\\frac{(1-\\alpha-\\beta)^n}{\\alpha+\\beta}\\left(\\begin{matrix}\\alpha&amp;-\\alpha\\\\-\\beta&amp;\\beta\\end{matrix}\\right)\\] <p>转移概率的极限：</p> \\[\\lim\\limits_{n\\to\\infty}P^{(n)}=\\frac{1}{\\alpha+\\beta}\\left(\\begin{array}{cc}\\beta&amp;\\alpha\\\\\\beta&amp;\\alpha\\end{array}\\right)=\\left(\\begin{array}{c}\\pi\\\\\\pi\\end{array}\\right),\\] <p>即\\(\\lim\\limits_{ n \\to \\infty }P_{ij}^{(n)}=\\pi_{j}\\).但是，如果\\(\\alpha=\\beta=1\\)，即</p> \\[P=\\left(\\begin{array}{cc}0&amp;1\\\\1&amp;0\\end{array}\\right)\\] <p>计算容易发现规律</p> \\[P_{00}^{(n)}=P_{11}^{(n)}=\\left\\{\\begin{array}{ll}1,&amp;n=2k\\\\[6pt]0,&amp;n=2k-1\\end{array}\\right.\\] <p>有</p> \\[\\lim\\limits_{n\\to\\infty}\\frac{1}{n}\\sum\\limits_{k=0}^{n-1}P_{00}^{(n)}=\\lim\\limits_{n\\to\\infty}\\frac{1}{n}\\sum\\limits_{k=0}^{n-1}P_{11}^{(n)}=\\frac{1}{2}\\] <p>该Markov链正常返，平均返回时间为2。然而，\\(\\lim\\limits_{ n \\to \\infty }P_{00}^{(n)}\\) 和\\(\\lim\\limits_{ n \\to \\infty }P_{11}^{(n)}\\)都不存在</p> <p>这个例子说明了弱遍历性无法得到\\(P_{ij}^{(n)}\\) 的极限性质，即</p> \\[\\lim\\limits_{n\\to\\infty}\\frac{1}{n}\\sum\\limits_{k=0}^{n-1}P_{ij}^{(n)}=\\pi_j\\nRightarrow\\lim\\limits_{n\\to\\infty}P_{ij}^{(n)}=\\pi_j\\] <p>也就是说，对于正常返的Markov链，\\(P_{ij}^{(n)}\\) 的极限也可能不存在。事实上，状态的周期性对于转移概率的极限是否存在起着关键作用。</p> <p>这个定理的证明将使用到概率论中的耦合方法(Very Important)</p> <p>[!NOTE] Theorem 6.13(强遍历定理) 设\\(\\{X_{n}\\}\\) 是不可约非周期的Markov链，若\\(\\pi\\)是\\(P\\)的不变分布， 那么</p> \\[\\lim\\limits_{n\\to\\infty}\\sum\\limits_{j\\in E}\\lvert P_{ij}^{(n)}-\\pi_{j}\\lvert=0,\\quad\\forall i\\in E.\\] <p>那么自然有</p> \\[\\lim\\limits_{n\\to\\infty}P_{ij}^{(n)}=\\pi_j\\] <p><code>Proof</code></p> <p>设\\(\\{X_{n}:n\\geqslant0\\}\\)和\\(\\{Y_{n}:n\\geqslant0\\}\\)是\\(E\\) 上以\\(P\\) 为转移矩阵的相互独立的Markov链，初分布分别为\\(\\mu\\)和\\(\\nu\\)令</p> <p>Remark：\\(Y_{n}\\)的存在性需要保证，但是存在性证明比较复杂所以跳过</p> <p>下面这个构造方法叫做耦合方法(概率论研究的常用方法)：</p> \\[\\{Z_n=(X_n,Y_n):n\\geqslant0\\}\\] <p>则它为\\(E\\times E\\) 上以\\(\\mu\\times\\nu\\)为初分布的马氏链，转移矩阵记为</p> <p>Remark：\\(\\mu \\times \\nu\\)是乘积测度(Measure Theory)</p> \\[\\overline{P}\\triangleq P\\otimes P,\\] \\[A\\otimes B=\\begin{bmatrix}a_{11}B&amp;\\cdots&amp;a_{1n}B\\\\\\vdots&amp;\\ddots&amp;\\vdots\\\\a_{m1}B&amp;\\cdots&amp;a_{mn}B\\end{bmatrix}.\\] <p>其中\\(\\otimes\\)表示Kronecker积，即</p> \\[\\overline{P}_{(i,j)(k,l)}=P_{ik}P_{jl}\\quad\\forall(i,j)(k,l)\\in E\\times E\\] <p>自行验证\\(\\overline{P}_{(i,j)(k,l)}^{(n)}=P_{ik}^{(n)}P_{jl}^{(n)}\\)</p> <p>Step1. 证明\\(Z_{n}\\)不可约非周期</p> <p>由于\\(P\\)不可约，所以存在\\(N_{1},N_{2}\\),使得\\(\\forall(i,j)(k,l)\\in E\\times E\\)</p> \\[P_{ik}^{(n_1)}&gt;0,\\:P_{jl}^{(n_2)}&gt;0,\\quad\\forall n_1&gt;N_1,\\:n_2&gt;N_2\\] <p>当\\(n&gt;\\max\\{N_{1},N_{2}\\}\\)时，</p> \\[\\overline{P}_{(i,j)(k,l)}^{(n)}=P_{ik}^{(n)}P_{jl}^{(n)}&gt;0\\] <p>即\\(\\overline{P}\\)不可约。</p> <p>由于\\(P\\) 非周期，所以对任意\\(i,j\\in E\\)</p> \\[\\gcd\\{n:P_{ii}^{(n)}&gt;0\\}=1,\\quad\\gcd\\{n:P_{jj}^{(n)}&gt;0\\}=1\\] <p>那么</p> \\[\\gcd\\{n:\\overline{P}_{(i,j)(i,j)}^{(n)}=P_{ii}^{(n)}P_{jj}^{(n)}&gt;0\\}=1\\] <p>即\\(\\bar{P}\\) 非周期。</p> <p>Step2. \\(\\overline{P}\\)的不变分布为</p> \\[\\overline{\\pi}_{(i,j)}=\\pi_i\\pi_j\\] <p>不难自行验证。</p> <p>Step3. 证明\\(\\{X_{n}:n\\geqslant0\\}\\)与\\(\\{Y_{n}:n\\geqslant0\\}\\)迟早相遇。</p> <p>因为\\(P\\)不可约且存在不变分布，那么\\(Z_{n}\\) 是常返的。令</p> \\[\\tau=\\inf\\{n\\geqslant0:X_n=Y_n\\}.\\] <p>它是\\(\\{X_{n}:n\\geqslant0\\) 与\\(\\{Y_{n}:n\\geqslant0\\}\\) 的相遇时刻，即\\(\\{Z_{n}:n\\geqslant0\\}\\)首达对角线</p> \\[\\overline D\\triangleq\\{(i,i):i\\in E\\}\\] <p>的时间，他不会超过\\(Z_{n}\\)首达某个具体状态\\((i,i)\\) 的时间，即</p> \\[\\tau\\leqslant\\tau_{(i,i)}\\triangleq\\inf\\{n\\geq0:Z_n=(i,i)\\}\\] <p>由于\\(Z_n\\)常返，所以</p> \\[P(\\tau_{(i,i)}&lt;\\infty)=1.\\] <p>那么\\(P(\\tau&lt;\\infty)=1\\)</p> <p>Step4. 证明在\\(\\{X_{n}:n\\geqslant0\\}\\)与\\(\\{Y_{n}:n\\geqslant0\\}\\)相遇之后，它们有同样的分布(unbelievable)，即</p> \\[P(X_n=j,\\tau\\leqslant n)=P(Y_n=j,\\tau\\leqslant n)\\] <p>假设\\(\\{X_{n}:n\\geqslant0\\}\\) 与\\(\\{Y_{n}:n\\geqslant0\\}\\) 在时刻\\(m\\) 相遇于状态\\(i\\)。</p> <p>直观上，那么从时刻\\(m\\)开始重新计时的话，它们都是从\\(i\\)出发以\\(P\\) 为转移矩阵的马氏链，从而它们在任何时刻有相同的分布。严格的证明如下：</p> \\[\\begin{aligned} P(X_{n}=j,\\tau\\leqslant n)&amp; =\\sum_{m=0}^{n}\\sum_{i\\in E}P(X_{n}=j,\\tau=m,Z_{m}=(i,i))  \\\\ &amp;=\\sum_{m=0}^n\\sum_{i\\in E}P(\\tau=m,Z_m=(i,i))P(X_n=j|\\tau=m,Z_m=(i,i)). \\end{aligned}\\] <p>注意到</p> \\[\\{\\tau=m,Z_m=(i,i)\\}=\\{Z_0,\\cdots,Z_{m-1}\\notin\\overline D,Z_m=(i,i)\\}.\\] <p>把\\(m\\)视为现在的时间，由\\(Z_{n}\\)的Markov性</p> \\[\\begin{aligned} P(X_{n}=j|\\tau=m,Z_{m}=(i,i))&amp; =P(X_{n}=j|Z_{m}=(i,i))  \\\\ &amp;=P(X_{n}=j|X_{m}=i,Y_{m}=i) \\\\ &amp;=P(X_{n}=j|X_{m}=i)=P_{ij}^{(n-m)}.\\quad(X_{n},Y_{n}\\text{独立}) \\end{aligned}\\] <p>所以</p> \\[P(X_n=j,\\tau\\leqslant n)=\\sum_{m=0}^n\\sum_{i\\in E}P(\\tau=m,Z_m=(i,i))P_{ij}^{(n-m)}.\\] <p>同理，</p> \\[\\begin{aligned} P(Y_{n}=j,\\tau\\leqslant n)&amp;=\\sum_{m=0}^{n}\\sum_{i\\in E}P(\\tau=m,Z_{m}=(i,i))P(Y_{n}=j|Z_{m}=(i,i))\\\\ &amp;=\\sum_{m=0}^{n}\\sum_{i\\in E}P(\\tau=m,Z_{m}=(i,i))P_{ij}^{(n-m)}.\\end{aligned}\\] <p>因此\\(P(X_{n}=j,\\tau\\leqslant n)=P(Y_{n}=j,\\tau\\leqslant n).\\)</p> <p>Step5. 注意到</p> \\[\\begin{aligned} P(X_n=j)&amp;=P(X_n=j,\\tau\\leq n)+P(X_n=j,\\tau&gt;n)\\\\ P(Y_n=j)&amp;=P(Y_n=j,\\tau\\leq n)+P(Y_n=j,\\tau&gt;n) \\end{aligned}\\] <p>于是</p> \\[\\begin{aligned} \\sum_{j\\in E}\\lvert P(X_{n}=j)-P(Y_{n}=j)\\rvert &amp; =\\sum_{j\\in E}\\lvert P(X_{n}=j,\\tau&gt;n)-P(Y_{n}=j,\\tau&gt;n)\\rvert   \\\\ &amp;\\leqslant\\sum_{j\\in E}(P(X_{n}=j,\\tau&gt;n)+P(Y_{n}=j,\\tau&gt;n)) \\\\ &amp;=2P(\\tau&gt;n)\\overset{n\\to\\infty}{\\longrightarrow}0.\\quad(\\text{由于}P(\\tau&lt;\\infty)=1) \\end{aligned}\\] <p>特别地，取\\(X_{n}\\)和\\(Y_{n}\\)的初分布分别为\\(\\mu=\\delta_{i}(Dirac\\ mass)\\)和\\(\\nu=\\pi\\)，那么</p> \\[P(X_n=j)=P_{ij}^{(n)},\\quad P(Y_n=j)=\\pi_j.\\] <p>定理即证。</p> <p>注1.不可约Markov链中，非周期正常返的状态称为遍历态(Ergodic state)</p> <p>注2.这里构造\\(Z_{n}\\) 的方法称为耦合方法(Coupling Method)，是概率论中非常重要的证明方法，由于\\(X_{n}\\) 和\\(Y_n\\) 是独立的，这种特殊的耦合称为独立耦合。一般地，两个概率分布\\(\\mu\\) 和\\(\\nu\\)的耦合(Coupling)定义为同一个概率空间上的一对随机变量\\((X,Y)\\) ，满足</p> \\[P\\{X=x\\}=\\mu(x),\\quad P\\{Y=y\\}=\\nu(y).\\] <p>注3.还可以通过更新定理证明，参考《随机过程及其应用》，陆大䋮，张颢，清华大学出版社 定理7.3。</p> <p>定理6.13讨论了正常返、非周期情形\\(P_{ij}^{(n)}\\)的极限，对于其他情况可以总结为下面定理。</p> <p>[!NOTE] Theorem 6.14 \\(\\{X_{n}\\}\\) 是不可约常返的Markou链，那么</p> <p>(1)若j是零常返状态，则</p> \\[\\lim_{n\\to\\infty}P_{ij}^{(n)}=0;\\] <p>(2)若\\(j\\) 是正常返周期状态，周期为\\(d_{j}\\) ，则</p> \\[\\begin{aligned}\\lim_{n\\to\\infty}P_{ij}^{(nd_j)}=\\frac{d_j}{\\mu_{jj}}\\end{aligned}\\] <p>其中\\(\\mu_{jj}\\triangleq\\sum\\limits_{n=1}^{\\infty}nf_{ij}^{(n)}\\) 为平均返回时间。</p> <p>书上的例子留作阅读学习作业。</p> <p>不可约Markov链的分类总结如下：</p> <ul> <li>不可约<ul> <li>常返<ul> <li>正常返\\(\\iff\\)有不变分布<ul> <li>\\(P_{ij}^{(n)}\\to \\pi_{j}\\)(非周期)</li> <li>\\(\\frac{1}{n}\\sum\\limits_{k=0}^{n}P_{ij}^{(k)}\\to \\pi_{j}\\)(周期)</li> </ul> </li> <li>零常返：\\(P_{ij}^{(n)}\\to 0\\)</li> </ul> </li> <li>非常返：\\(P_{ij}^{(n)}\\to 0\\)</li> </ul> </li> </ul>","path":["Lecture 6 - Limit Behaviour &amp; Ergodic Theory"],"tags":[]},{"location":"CS50x/","level":1,"title":"CS50x","text":"","path":["CS50x"],"tags":["CS","CS50x","国外公开课"]},{"location":"CS50x/#welcome","level":2,"title":"Welcome","text":"<p>This is CS50, Harvard University’s introduction to the intellectual enterprises of computer science and the art of programming, for concentrators and non-concentrators alike, with or without prior programming experience. (Two thirds of CS50 students have never taken CS before.) This course teaches you how to solve problems, both with and without code, with an emphasis on correctness, design, and style. Topics include computational thinking, abstraction, algorithms, data structures, and computer science more generally. Problem sets inspired by the arts, humanities, social sciences, and sciences. More than teach you how to program in one language, this course teaches you how to program fundamentally and how to teach yourself new languages ultimately. The course starts with a traditional but omnipresent language called C that underlies today’s newer languages, via which you’ll learn not only about functions, variables, conditionals, loops, and more, but also about how computers themselves work underneath the hood, memory and all. The course then transitions to Python, a higher-level language that you’ll understand all the more because of C. Toward term’s end, the course introduces SQL, via which you can store data in databases, along with HTML, CSS, and JavaScript, via which you can create web and mobile apps alike. Course culminates in a final project.</p>","path":["CS50x"],"tags":["CS","CS50x","国外公开课"]},{"location":"CS50x/#workflow","level":2,"title":"Workflow","text":"<p>采用如下工作流：</p> <ol> <li>课程提供了相当丰富的Notes几乎可以自学(bushi)</li> <li>完全可以不做笔记认真听，因为确实难度不太大</li> <li>语言debuff在经过长时间听力后可以有好转</li> </ol>","path":["CS50x"],"tags":["CS","CS50x","国外公开课"]},{"location":"CS50x/#my-timeline-and-some-learning-tips","level":2,"title":"My Timeline and some learning tips","text":"","path":["CS50x"],"tags":["CS","CS50x","国外公开课"]},{"location":"CS50x/#before-learning","level":3,"title":"Before learning","text":"<ol> <li>You can search the csdiy.wiki to get first rough information.</li> <li>Reading the syllabus in the CS50x and get a concept of the workflow.</li> </ol> <p>[!todo] Week 0 Scratch  - [x] Finish Time: 2024.12.06   - [x] Video(2h)  - [x] Problem Set 0   Have a try in problem set (not make a project but know basic operations) - [x] Scratch website</p> <p>[!todo] Week 1 C - [x] Finish Time: 2025.1.10   - [x] Video(2h)  - [x] Problem Set 1   - [x]  Hello   - [x]  mario-more   - [x]  cash   - [x]  credit</p> <p>[!todo] Week 2 Arrays - [x] Finished Time: 2025.7.4   - [x] Video(2h)   - [x] Section(1h)   - [x] Shorts  - [x] Problem Set 2   - [x] Scrabble    - [x] Readability   - [x] Caesar    - [x] Substitution</p> <p>[!todo] Week 3  Algorithms - [x] Finished Time: 2025.7.4   - [x] Video(2h)   - [x] Section   - [x] Shorts  - [x] Problem Set 3</p> <p>[!todo] Week 4 Memory - [x] Finished Time: 2025.7.4   - [x] Video(2h)   - [x] Section   - [x] Shorts  - [x] Problem Set 4</p> <p>[!todo] Week 5 Data Structures - [x] Finished Time: 2025.7.4   - [x] Video(2h)   - [x] Section   - [x] Shorts  - [x] Problem Set 5</p>","path":["CS50x"],"tags":["CS","CS50x","国外公开课"]},{"location":"CS50x/Week%200%20Scratch/","level":1,"title":"Week 0 Scratch","text":"","path":["Week 0 Scratch"],"tags":[]},{"location":"CS50x/Week%200%20Scratch/#syllabus","level":2,"title":"Syllabus","text":"<p>Computer Science. Computational Thinking. Problem Solving: Inputs, Outputs. Representation: Unary, Binary, Decimal, ASCII, Unicode, RGB. Abstraction. Algorithms. Running Times. Pseudocode. Scratch: Functions, Arguments, Return Values; Variables; Boolean Expressions, Conditionals; Loops; Events; Threads.</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"CS50x/Week%200%20Scratch/#notes","level":2,"title":"Notes","text":"","path":["Week 0 Scratch"],"tags":[]},{"location":"CS50x/Week%200%20Scratch/#binary","level":3,"title":"Binary","text":"<p>Computer is a base-2 system we can use 0 and 1 to represent all of it.</p> <p>Case: use the hand to count the number by control the finger up and down, how many can you count?</p> <p>The answer is 31 if you start with the 0(we have \\(2^{5}\\) outcomes)</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"CS50x/Week%200%20Scratch/#bit","level":4,"title":"bit","text":"<p>For the computer, it is useful and simple because it imply the on and off.</p> <p>binary digit-BIT!</p> <p>we can make the 1 value means on and 0 means off. and use light bulb to represent the fingers' up and down.</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"CS50x/Week%200%20Scratch/#decimal","level":4,"title":"decimal","text":"<p>\\(123=100*1+10*2+1*3\\)</p> <p>And we can use this method to understand the bulbs' light and more far from it is the binary. WE can use the 0 and 1 represent the information in computer.</p> <p>More often used than bit is byte, what is byte? A byte is 8 bit(or 8 bulbs) it can represent the 255.</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"CS50x/Week%200%20Scratch/#ascii","level":3,"title":"ASCII","text":"<p>So how can we use them denote the number A? Assign every letter a number -for some reasons the A strats with 65(64+1).</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"CS50x/Week%200%20Scratch/#unicode","level":3,"title":"Unicode","text":"<p>Unicode code point U+1F602 </p> <p>Remark: The U+ is a conventional mark for unicode in computer science. </p>","path":["Week 0 Scratch"],"tags":[]},{"location":"CS50x/Week%200%20Scratch/#color","level":3,"title":"Color","text":"<p>Zeros and ones can be used to represent color.</p> <p>Red, green, and blue (called <code>RGB</code>) is a combination of three numbers.</p> <p>One  pixel dot will ocuppy 3 bits of colors.</p> <p>We will think more things can be represent by 0's and 1's so between the input and output is what?</p> <p>It's algorithms!</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"CS50x/Week%200%20Scratch/#algorithms","level":3,"title":"Algorithms","text":"<p>Case: Find John Harvard in the book and take three algorithms.</p> <ol> <li>one step each </li> <li>two steps each</li> <li>half of the remainings </li> </ol> <p>We can solve the problem correctly and more efficiently as well.</p> <p>One graph can draw the efficientcy.</p> <pre><code>Pick up phone book\nOpen to middle of phone book\nlook at page \nIf person is on page\n    call him\nElse if person is ealier in book\n    Open to middle of left half of book\n    Go back to line 3\nElse if person is later in book\n    Open to middle of right half of book\n    Go back to line 3\nElse\n    Quit \n</code></pre> <p>They called functions and use conditions.</p> <p>Boolean expression can give two types answers (0 and 1 or something else)</p> <p>And above it's a loop can go and go.</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"CS50x/Week%200%20Scratch/#artificial-intelligence","level":3,"title":"Artificial Intelligence","text":"<p>If use simple input the binary question each an answer, it will be difficult.</p> <p>Large language models(LLMs)</p> <pre><code>#include&lt;stdio.h&gt;\n\nint main(void)\n{\n    printf(\"hello world\\n\")\n}\n</code></pre>","path":["Week 0 Scratch"],"tags":[]},{"location":"CS50x/Week%200%20Scratch/#scratch","level":3,"title":"Scratch","text":"<p>Through dragging and dropping some puzzles to make a program.</p> <p>Very interesting parts.</p> <p>Ivy's Hardest Game --So difficult!(Can it passed?)</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"CS50x/Week%200%20Scratch/#summing-up","level":2,"title":"Summing up","text":"<p>In this lesson, you learned how this course sits in the wide world of computer science and programming. You learned…</p> <ul> <li>Few students come to this class with prior programming experience!</li> <li>You are not alone! You are part of a community.</li> <li>Problem-solving is the essence of the work of computer scientists.</li> <li>This course is not simply about programming – this course will introduce you to a new way of learning that you can apply to almost every area of life.</li> <li>How numbers, text, images, music, and video are understood and represented by computers.</li> <li>The fundamental programming skill of pseudocoding.</li> <li>Reasonable and unreasonable ways to utilize AI in this course.</li> <li>How abstraction will play a role in your future work in this course.</li> <li>The basic building blocks of programming including functions, conditionals, loops, and variables.</li> <li>How to build a project in Scratch.</li> </ul> <p>This was CS50! Welcome aboard! See you next time!</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"CS50x/Week%200%20Scratch/#problem-set-0","level":2,"title":"Problem Set 0","text":"<p>It’s time to choose your own adventure! Your assignment, quite simply, is to implement in Scratch, at scratch.mit.edu, any project of your choice, be it an interactive story, game, animation, or anything else, subject only to the following requirements:</p> <ul> <li>Your project must use at least two sprites, at least one of which must not be a cat.</li> <li>Your project must have at least three scripts total (i.e., not necessarily three per sprite).</li> <li>Your project must use at least one conditional, at least one loop, and at least one variable.</li> <li>Your project must use at least one custom block that you have made yourself (via Make a Block), which must take at least one input.</li> <li>Your project should be more complex than most of those demonstrated in lecture (many of which, though instructive, were quite short) but it can be less complex than Oscartime and Ivy’s Hardest Game.</li> </ul> <p>Due the Scratch's high freedom property I pass the problem set(Or make an easy one?). </p>","path":["Week 0 Scratch"],"tags":[]},{"location":"CS50x/Week%201%20C/","level":1,"title":"Week 1 C","text":"","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#syllabus","level":2,"title":"Syllabus","text":"<p>C. Source Code. Machine Code. Compiler. Correctness, Design, Style. Visual Studio Code. Syntax Highlighting. Escape Sequences. Header Files. Libraries. Manual Pages. Types. Conditionals. Variables. Loops. Linux. Graphical User Interface (GUI). Command-Line Interface (CLI). Constants. Comments. Pseudocode. Operators. Integer Overflow. Floating-Point Imprecision.</p>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#notes","level":2,"title":"Notes","text":"","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#machine-code","level":3,"title":"Machine Code","text":"<pre><code>#include&lt;stdio.h&gt; //standard io.h\n\nint main(void) //void -no input\n{\n    printf(\"hello world\\n\")\n}\n</code></pre> <p>The computer can onlrecy ognize the binary numbers so we need a compiler(编译器) to make the higher level language to a lower level language.</p> <p>![[compiler.svg]]</p> <p>use a cloud(best) URL or you can use VS code in your computer</p> <p>Some words you should know: GUI CLI</p>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#hello-world","level":3,"title":"Hello world","text":"<pre><code>#include&lt;stdio.h&gt;\n//pronounced \"include standard io.h\"\n\nint main(void)\n{\n    printf(\"hello world\\n\")\n}\n</code></pre> <p>Some little concepts:</p> <p><code>#include stdio.h</code> - include standard io.h <code>curly braces</code> - 大括号{} <code>printf</code> - F means formatted <code>semicolon</code> - 分号; <code>syntax</code> - 句法</p> <p>In the terminal</p> <pre><code>$ code hello.c\n$ make hello\n// not need to input hello.c make can look the folder\n// make to compile the file from source code to machine code\n$ ./hello\n\nand get the \nhello world$(\\n)\n</code></pre>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#libraryheader-files","level":3,"title":"Library(Header Files)","text":"<p>We can use the code others write before via library and for example we can find the stdio.h  Manual Pages </p> <pre><code>printf(\"hello, %s\\n\", answer)\n// %s means a place holder\n</code></pre> <p>Case 1</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    string answer = get_string(\"What's your name?\");\n    printf(\"hello, &amp;s\\n\", answer);\n}\n</code></pre> <p>Error: get_string is not claimed.</p> <p>Case 2</p> <pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    string answer = get_string(\"What's your name?\");\n    printf(\"hello, &amp;s\\n\", answer);\n}\n</code></pre> <p>Here gets so many cases and we can design the programs so that it can be more efficient.</p>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#terminal-commands","level":3,"title":"Terminal Commands","text":"<p>We can know more about them by Google.</p> <p>In the terminal window, some common command-line arguments we may use include:</p> <ul> <li><code>cd</code>, for changing our current directory (folder)</li> <li><code>cp</code>, for copying files and directories</li> <li><code>ls</code>, for listing files in a directory</li> <li><code>mkdir</code>, for making a directory</li> <li><code>mv</code>, for moving (renaming) files and directories</li> <li><code>rm</code>, for removing (deleting) files</li> <li><code>rmdir</code>, for removing (deleting) directories</li> </ul>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#types-of-the-variablews","level":3,"title":"Types of the variablews","text":"<p>Types with which you might interact during this course include:</p> <ul> <li><code>bool</code>, a Boolean expression of either true or false</li> <li><code>char</code>, a single character like a or 2</li> <li><code>double</code>, a floating-point value with more digits than a float</li> <li><code>float</code>, a floating-point value, or a real number with a decimal value</li> <li><code>int</code>, integers up to a certain size, or number of bits</li> <li><code>long</code>, integers with more bits, so they can count higher than an int</li> <li><code>string</code>, a string of characters</li> </ul> <p>Followings are make the Scratch codes to C. </p>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#conditionals","level":3,"title":"Conditionals","text":"<p>Some tips:     Don't make some unnecessary operations.     Focus on how to design the better structure of codes.</p> <pre><code>if (x &lt; y)\n{\n    printf(\"x is less than y\\n\");\n}\nelse if (x &gt; y)\n{\n    printf(\"x is greater than y\\n\");\n}\nelse\n{\n    printf(\"x is equal to y\\n\");\n}\n</code></pre> <p>But not make the three ifs because it will waste the time.</p>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#loop","level":3,"title":"Loop","text":"<p>Motivation: We want to let the vsc meows like the Scratch and how should we do? Answer: We can make a loop to decrease our codes.</p> <pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nvoid meow(int n);\n\nint main(void)\n{\n    int n;\n    do\n    {\n        n = get_int(\"Number: \");\n    }\n    while (n &lt; 1);\n    meow(n);\n}\n\n// Meow some number of times\nvoid meow(int n)\n{\n    for (int i = 0; i &lt; n; i++)\n    {\n        printf(\"meow\\n\");\n    }\n}\n</code></pre> <p>Comments Typically, each comment is a few words or more, providing the reader an opportunity to understand what is happening in a specific block of code. Further, such comments serve as a reminder for you later when you need to revise your code.</p>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#functions","level":3,"title":"Functions","text":"<p>An inspiring idea is to make the repeating parts a new role that we can use them by include or write the function's name.</p> <p>Here's a example from Mario(循环嵌套). Notice how printing a row is accomplished through a new function.</p> <pre><code>// Helper function\n\n#include &lt;stdio.h&gt;\n\nvoid print_row(int width);\n\n//void means no output , int width means we have one input\n\nint main(void)\n{\n    const int n = 3;\n    for (int i = 0; i &lt; n; i++)\n    {\n        print_row(n);\n    }\n}\n\n//Row function\nvoid print_row(int width)\n{\n    for (int i = 0; i &lt; width; i++)\n    {\n        printf(\"#\");\n    }\n    printf(\"\\n\");\n}\n</code></pre>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#calculator","level":3,"title":"Calculator","text":"<pre><code>// int\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int dollars = 1;\n    while (true)\n    {\n        char c = get_char(\"Here's $%i. Double it and give to next person? \", dollars);\n        if (c == 'y')\n        {\n            dollars *= 2;\n        }\n        else\n        {\n            break;\n        }\n    }\n    printf(\"Here's $%i.\\n\", dollars);\n}\n</code></pre> <ul> <li>Types are very important because each type has specific limits. For example, because of the limits in memory, the highest value of an <code>int</code> can be <code>4294967295</code>. If you attempt to count an <code>int</code> higher, an integer overflow will result where an incorrect value will be stored in this variable.</li> <li>The number of bits limits how high and low we can count.</li> <li>This can have catastrophic, real-world impacts.</li> <li>We can correct this by using a data type called <code>long</code>.</li> </ul> <pre><code>// long\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    long dollars = 1;\n    while (true)\n    {\n        char c = get_char(\"Here's $%li. Double it and give to next person? \", dollars);\n        if (c == 'y')\n        {\n            dollars *= 2;\n        }\n        else\n        {\n            break;\n        }\n    }\n    printf(\"Here's $%li.\\n\", dollars);\n}\n</code></pre>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#truncation","level":3,"title":"Truncation","text":"<pre><code>// Division with ints, demonstrating truncation\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    // Prompt user for x\n    int x = get_int(\"x: \");\n\n    // Prompt user for y\n    int y = get_int(\"y: \");\n\n    // Divide x by y\n    printf(\"%i\\n\", x / y);\n}\n</code></pre> <p>An integer divided by an integer will always result in an integer in C. Accordingly, the above code will often result in any digits after the decimal being thrown away.</p> <pre><code>// Floats\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    // Prompt user for x\n    float x = get_float(\"x: \");\n\n    // Prompt user for y\n    float y = get_float(\"y: \");\n\n    // Divide x by y\n    printf(\"%.50f\\n\", x / y);\n}\n</code></pre> <ul> <li>Floating point imprecision illustrates that there are limits to how precise computers can calculate numbers.</li> <li>As you are coding, pay special attention to the types of variables you are using to avoid problems within your code.</li> <li>We examined some examples of disasters that can occur through type-related errors.</li> </ul>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#summing-up","level":2,"title":"Summing up","text":"<ul> <li>How to create your first program in C.</li> <li>How to use the command line.</li> <li>About predefined functions that come natively with C.</li> <li>How to use variables, conditionals, and loops.</li> <li>How to create your own functions to simplify and improve your code.</li> <li>How to er codevaluate you on three axes: correctness, design, and style.</li> <li>How to integrate comments into your code.</li> <li>How to utilize types and operators and the implications of your choices.</li> </ul>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#problem-set-1","level":2,"title":"Problem Set 1","text":"","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#hello-its-me","level":3,"title":"Hello, It’s Me","text":"<pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    string name = get_string(\"What's your name?\");\n    printf(\"hello, %s\\n\",name);\n}\n</code></pre>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#mario-more","level":3,"title":"Mario-more,","text":"<pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int height;\n    do\n    {\n        height = get_int(\"Height= \");\n    }\n    while (height &lt; 1 || height &gt; 8);\n    int row = 0;\n    while (row &lt; height)\n    {\n        for (int i = 0; i &lt; height - row - 1; i++)\n        {\n            printf(\" \");\n        }\n        for (int j = 0; j &lt; row + 1; j++)\n        {\n            printf(\"#\");\n        }\n        printf(\"  \");\n        for (int j = 0; j &lt; row + 1; j++)\n        {\n            printf(\"#\");\n        }\n        row++;\n        printf(\"\\n\");\n    }\n}\n</code></pre>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#cash","level":3,"title":"Cash,","text":"<pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int changeOwed;\n    do\n    {\n        changeOwed = get_int(\"Change owed: \");\n    }\n    while (changeOwed &lt; 0);\n\n    int quarters;\n    int dimes;\n    int nickels;\n    int pennies;\n\n    quarters = changeOwed / 25;\n    changeOwed = changeOwed - quarters * 25;\n    dimes = changeOwed / 10;\n    changeOwed = changeOwed - dimes * 10;\n    nickels = changeOwed / 5;\n    changeOwed = changeOwed - nickels * 5;\n    pennies = changeOwed;\n\n    int k = quarters + dimes + nickels + pennies;\n    printf(\"%i\\n\", k);\n\n}\n</code></pre>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%201%20C/#credit","level":3,"title":"Credit,","text":"<pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    long checknum;\n    // get a number\n    checknum = get_long(\"Number: \");\n    // 最终求和变量\n    int checksum = 0;\n    // 指示变量\n    int digit = 1;\n    \n    // checksum part\n    int reminder;\n    int save1 = 0;\n    int save2 = 0;\n    while (checknum &gt; 0)\n    {\n        save2 = save1;\n        save1 = 0;\n        reminder = 0;\n        if (digit % 2 == 0)\n        {\n            save1 = checknum % 10;\n            reminder = checknum % 10 * 2;\n            checknum /= 10;\n            if (reminder &gt;= 10)\n            {\n                reminder = reminder % 10 + 1;\n                checksum += reminder;\n            }\n            else\n            {\n                checksum += reminder;\n            }\n        }\n        else\n        {\n            save1 = checknum % 10;\n            checksum += checknum % 10;\n            checknum /= 10;\n        }\n        digit += 1;\n    }\n    digit -= 1;\n    \n    // claim\n    if (checksum % 10 == 0)\n    {\n        if (save1 == 3 &amp;&amp; digit == 15)\n        {\n            if (save2 ==4 || save2 == 7)\n            {\n                 printf(\"AMEX\\n\");\n            }\n            else\n            {\n                printf(\"INVALID\\n\");\n            }\n        }\n        else if (save1 == 5 &amp;&amp; digit == 16)\n        {\n            if (save2 &gt;=1 &amp;&amp; save2 &lt;= 5)\n            {\n                 printf(\"MASTERCARD\\n\");\n            }\n            else\n            {\n                printf(\"INVALID\\n\");\n            }\n        }\n        else if (save1 == 4 &amp;&amp; (digit ==13 || digit == 16))\n        {\n            printf(\"VISA\\n\");\n        }\n        else\n        {\n            printf(\"INVALID\\n\");\n        }\n    }\n    else\n    {\n        printf(\"INVALID\\n\");\n    }\n}\n</code></pre>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"CS50x/Week%202%20Arrays/","level":1,"title":"Week 2 Arrays","text":"","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#syllabus","level":2,"title":"Syllabus","text":"<p>Preprocessing. Compiling. Assembling. Linking. Debugging. Arrays. Strings. Command-Line Arguments. Cryptography.</p>","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#notes","level":2,"title":"Notes","text":"","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#preprocessing","level":3,"title":"Preprocessing","text":"<p>Motivation: reading levels</p> <p>Recall a graph:</p> <p>Source Code -&gt; Compiler -&gt; Machine Code</p>","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#compiling","level":4,"title":"Compiling","text":"<p>What's actually happend in the process of translating?(Compiling)</p> <pre><code>clang hello.c\n./a.out\n</code></pre> <pre><code>clang -o hello hello.c -lcs50\n//If you want to use the cs50 library\n</code></pre> <p>preprocessor preprocessing step</p> <p>If you want to code C or other languages, the CPU will process the code from C into a low levlel language called assembly code.</p> <p>And focus on compiling</p> <pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    printf(\" \");\n}\n</code></pre> <p>What's the definition of linking neatly? A: the process of combining multiple object files (pieces of compiled code) generated by a compiler into a single executable program.</p> <p>Four steps of compiling: + preprocessing + compile to assembly code + assembly code translates to machine code + linking: combining multiple object files (pieces of compiled code)</p>","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#debugging","level":3,"title":"Debugging","text":"<ul> <li>Everyone will make mistakes while coding.</li> <li>Debugging is the process of locating and removing bugs from your code.</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    for (int i = 0; i &lt;  3; i++)\n    {\n        printf(\"i is %i\\n\", i);\n        printf(\"#\\n\");\n    }\n}\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#arrays","level":3,"title":"Arrays","text":"<p>Motivation: We don't want so many variables for a same type(or same purpose)</p> <pre><code>int scores[3];\nscores[0] = 72;\nscores[1] = 73;\nscores[2] = 33;\n</code></pre> <p>So this tech has an advantage that we can change it easily and sustained.</p> <pre><code>// Averages three numbers using an array, a constant, and a helper function\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\n// Constant\nconst int N = 3;\n\n// Prototype\nfloat average(int length, int array[]);\n\nint main(void)\n{\n    // Get scores\n    int scores[N];\n    for (int i = 0; i &lt; N; i++)\n    {\n        scores[i] = get_int(\"Score: \");\n    }\n\n    // Print average\n    printf(\"Average: %f\\n\", average(N, scores));\n}\n\nfloat average(int length, int array[])\n{\n    // Calculate average\n    int sum = 0;\n    for (int i = 0; i &lt; length; i++)\n    {\n        sum += array[i];\n    }\n    return sum / (float) length;\n}\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#strings","level":3,"title":"Strings","text":"<ul> <li>A <code>string</code> is simply an array of variables of type <code>char</code>: an array of characters.</li> <li>To explore <code>char</code> and <code>string</code>, type <code>code hi.c</code> in the terminal window and write code as follows:</li> </ul> <pre><code>    // Prints chars\n\n    #include &lt;stdio.h&gt;\n\n    int main(void)\n    {\n        char c1 = 'H';\n        char c2 = 'I';\n        char c3 = '!';\n\n        printf(\"%c%c%c\\n\", c1, c2, c3);\n    }\n</code></pre> <p>Notice that this will output a string of characters.</p> <p>A string is a sequence of characters like a array of the type of characters. </p> <p>NUL says string end here.</p> <pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    string words[2];\n\n    words[0] = \"HI!\";\n    words[1] = \"BYE!\";\n\n    printf(\"%c%c%c\\n\", words[0][0], words[0][1], words[0][2]);\n    printf(\"%c%c%c%c\\n\", words[1][0], words[1][1], words[1][2], words[1][3]);\n\n// arrays of arrays so strings are actually arrays\n}\n</code></pre> <p>strlen function include  <p>Since this is such a common problem within programming, other programmers have created code in the <code>string.h</code> library to find the length of a string. You can find the length of a string by modifying your code as follows:</p> <pre><code>// Determines the length of a string using a function\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void)\n{\n    // Prompt for user's name\n    string name = get_string(\"Name: \");\n    int length = strlen(name);\n    printf(\"%i\\n\", length);\n}\n</code></pre> <p>Notice that this code uses the <code>string.h</code> library, declared at the top of the file. Further, it uses a function from that library called <code>strlen</code>, which calculates the length of the string passed to it.</p> <p>ctype.h</p> <p>While the program does what we want, there is an easier way using the <code>ctype.h</code> library. Modify your program as follows:</p> <pre><code>// Uppercases string using ctype library (and an unnecessary condition)\n\n#include &lt;cs50.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void)\n{\n    string s = get_string(\"Before: \");\n    printf(\"After:  \");\n    for (int i = 0, n = strlen(s); i &lt; n; i++)\n    {\n        if (islower(s[i]))\n        {\n            printf(\"%c\", toupper(s[i]));\n        }\n        else\n        {\n            printf(\"%c\", s[i]);\n        }\n    }\n    printf(\"\\n\");\n}\n</code></pre> <p>Notice that the program iterates through each character of the string. The <code>toupper</code> function is passed <code>s[i]</code>. Each character (if lowercase) is converted to uppercase.</p>","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#command-line-arguments","level":3,"title":"Command-Line Arguments","text":"<ul> <li><code>Command-line arguments</code> are those arguments that are passed to your program at the command line. For example, all those statements you typed after <code>clang</code> are considered command line arguments. You can use these arguments in your own programs!</li> <li> <p>In your terminal window, type <code>code greet.c</code> and write code as follows:</p> <pre><code>// Uses get_string\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    string answer = get_string(\"What's your name? \");\n    printf(\"hello, %s\\n\", answer);\n}\n</code></pre> </li> </ul> <p>Notice that this says <code>hello</code> to the user.</p> <ul> <li> <p>Still, would it not be nice to be able to take arguments before the program even runs? Modify your code as follows:</p> <pre><code>// Prints a command-line argument\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(int argc, string argv[])\n{\n    if (argc == 2)\n    {\n        printf(\"hello, %s\\n\", argv[1]);\n    }\n    else\n    {\n        printf(\"hello, world\\n\");\n    }\n}\n</code></pre> </li> </ul> <p>Notice that this program knows both <code>argc</code>, the number of command line arguments, and <code>argv</code>, which is an array of the characters passed as arguments at the command line.</p> <p>Remark that one of CLAs is the name of the program!</p> <ul> <li>Therefore, using the syntax of this program, executing <code>./greet David</code> would result in the program saying <code>hello, David</code>.</li> <li>You can print each of the command-line arguments with the following:</li> </ul> <pre><code>    // Prints command-line arguments\n\n    #include &lt;cs50.h&gt;\n    #include &lt;stdio.h&gt;\n\n    int main(int argc, string argv[])\n    {\n        for (int i = 0; i &lt; argc; i++)\n        {\n            printf(\"%s\\n\", argv[i]);\n        }\n    }\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#exit-status","level":3,"title":"Exit Status","text":"<ul> <li>When a program ends, a special exit code is provided to the computer.</li> <li>When a program exits without error, a status code of <code>0</code> is provided to the computer. Often, when an error occurs that results in the program ending, a status of <code>1</code> is provided by the computer.</li> <li> <p>You could write a program as follows that illustrates this by typing <code>code status.c</code> and writing code as follows:</p> <pre><code>// Returns explicit value from main\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(int argc, string argv[])\n{\n    if (argc != 2)\n    {\n        printf(\"Missing command-line argument\\n\");\n        return 1;\n    }\n    printf(\"hello, %s\\n\", argv[1]);\n    return 0;\n}\n</code></pre> </li> </ul> <p>Notice that if you fail to provide <code>./status David</code>, you will get an exit status of <code>1</code>. However, if you do provide <code>./status David</code>, you will get an exit status of <code>0</code>.</p> <ul> <li>You can type <code>echo $?</code> in the terminal to see the exit status of the last run command.</li> <li>You can imagine how you might use portions of the above program to check if a user provided the correct number of command-line arguments.</li> </ul>","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#cryptography","level":3,"title":"Cryptography","text":"<ul> <li>Cryptography is the art of ciphering and deciphering a message.</li> <li>Now, with the building block of arrays, chars, and strings, you can cipher and decipher a message.</li> <li><code>plaintext</code> and a <code>key</code> are provided to a <code>cipher</code>, resulting in ciphered text.</li> </ul> <p>Key and Plaintext -&gt; Cipher -&gt; Ciphertext</p>","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#summing-up","level":2,"title":"Summing Up","text":"<p>In this lesson, you learned more details about compiling and how data is stored within a computer. Specifically, you learned…</p> <ul> <li>Generally, how a compiler works.</li> <li>How to debug your code using four methods.</li> <li>How to utilize arrays within your code.</li> <li>How arrays store data in back to back portions of memory.</li> <li>How strings are simply arrays of characters.</li> <li>How to interact with arrays in your code.</li> <li>How command-line arguments can be passed to your programs.</li> <li>The basic building-blocks of cryptography.</li> </ul>","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#sections","level":2,"title":"Sections","text":"<ul> <li>Arrays<ul> <li>Initialize</li> <li>assignment</li> <li>change</li> </ul> </li> <li>Strings<ul> <li>get_string</li> <li>Connection with arrays</li> <li>ASCII code(Alphabetical Exercise)</li> </ul> </li> <li>Command Line Arguments aka. CLA</li> </ul> <p>A program about CLAs:</p> <pre><code>#include &lt;cs50.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, string argv[])\n{\n    // Get user's input\n    if (argc != 2)\n    {\n        printf(\"Please provide a word.\\n\");\n        return 1;\n    }\n\n    string text = argv[1];\n    int len = strlen(text);\n\n    for (int i = 0; i &lt; len; i++)\n    {\n        if (!isalpha(text[i]))\n        {\n            printf(\"This is not a letter.\\n\");\n            return 2;\n        }\n    }\n\n    // Iterate through each element in the string\n    for (int i = 1; i &lt; len; i++)\n    {\n        if (text[i] &lt; text[i - 1])\n        {\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n    // Print out yes\n    printf(\"Yes\\n\");\n}\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#problem-set-2","level":2,"title":"Problem Set 2","text":"","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#scrabble","level":3,"title":"Scrabble","text":"<pre><code>#include &lt;cs50.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n// Points assigned to each letter of the alphabet\nint POINTS[] = {1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10};\n\nint compute_score(string word);\n\nint main(void)\n{\n    // Prompt the user for two words\n    string word1 = get_string(\"Player 1: \");\n    string word2 = get_string(\"Player 2: \");\n\n    // Compute the score of each word\n    int score1 = compute_score(word1);\n    int score2 = compute_score(word2);\n\n    // Print the winner\n    if (score1 &gt; score2)\n    {\n        printf(\"Player 1 wins!\\n\");\n    }\n    else if (score1 &lt; score2)\n    {\n        printf(\"Player 2 wins!\\n\");\n    }\n    else\n    {\n        printf(\"Tie!\\n\");\n    }\n}\n\nint compute_score(string word)\n{\n    // Keep track of score\n    int score = 0;\n\n    // Compute score for each character\n    for (int i = 0, len = strlen(word); i &lt; len; i++)\n    {\n        if (isupper(word[i]))\n        {\n            score += POINTS[word[i] - 'A'];\n        }\n        else if (islower(word[i]))\n        {\n            score += POINTS[word[i] - 'a'];\n        }\n    }\n\n    return score;\n}\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#readability","level":3,"title":"Readability","text":"<pre><code>#include &lt;ctype.h&gt;\n#include &lt;cs50.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint count_letters(string text);\nint count_words(string text);\nint count_sentences(string text);\n\nint main(void)\n{\n    // Prompt the user for some text\n    string text = get_string(\"Text: \");\n\n    // Count the number of letters, words, and sentences in the text\n    int letters = count_letters(text);\n    int words = count_words(text);\n    int sentences = count_sentences(text);\n\n    // Compute the Coleman-Liau index\n    float L = (float)letters / words * 100; // Average letters per 100 words\n    float S = (float)sentences / words * 100; // Average sentences per 100 words\n    float index_original = 0.0588 * L - 0.296 * S - 15.8; // Coleman-Liau index formula\n    // Print the grade level\n    int index = round(index_original);\n    if (index &lt; 1)\n    {\n        printf(\"Before Grade 1\\n\");\n    }\n    else if (index &gt;= 16)\n    {\n        printf(\"Grade 16+\\n\");\n    }\n    else\n    {\n        printf(\"Grade %d\\n\", index);\n    }\n}\n\nint count_letters(string text)\n{\n    // Return the number of letters in text\n    int letter_count = 0;\n    for (int i = 0, n = strlen(text); i &lt; n; i++)\n    {\n        if (isalpha(text[i]))\n        {\n            letter_count++;\n        }\n    }\n    return letter_count; // Return the count of letters\n}\n\nint count_words(string text)\n{\n    // Return the number of words in text\n    int word_count = 0;\n    for (int i = 0, n = strlen(text); i &lt; n; i++)\n    {\n        if (isspace(text[i]) || i == n - 1) // Count words by spaces or end of text\n        {\n            word_count++;\n        }\n    }\n    return word_count; // Return the count of words\n}\n\nint count_sentences(string text)\n{\n    // Return the number of sentences in text\n    int sentence_count = 0;\n    for (int i = 0, n = strlen(text); i &lt; n; i++)\n    {\n        if (text[i] == '.' || text[i] == '!' || text[i] == '?')\n        {\n            sentence_count++;\n        }\n    }\n    return sentence_count; // Return the count of sentences\n}\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#caesar","level":3,"title":"Caesar","text":"<pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, string argv[])\n{\n    // Make sure program was run with just one command-line argument\n    if (argc != 2)\n    {\n        printf(\"Usage: ./caesar key\\n\");\n        return 1;\n    }\n    // Make sure every character in argv[1] is a digit\n    for (int i = 0, n = strlen(argv[1]); i &lt; n; i++)\n    {\n        if (argv[1][i] &lt; '0' || argv[1][i] &gt; '9')\n        {\n            printf(\"Usage: ./caesar key\\n\");\n            return 1;\n        }\n    }\n    // Convert argv[1] from a `string` to an `int`\n    int key = atoi(argv[1]) % 26; // Ensure key is within 0-25\n    // Prompt user for plaintext\n    string plaintext = get_string(\"plaintext: \");\n    // For each character in the plaintext:\n    printf(\"ciphertext: \");\n    for (int i = 0, n = strlen(plaintext); i &lt; n; i++)\n    {\n        // Check if the character is an uppercase letter\n        if (plaintext[i] &gt;= 'A' &amp;&amp; plaintext[i] &lt;= 'Z')\n        {\n            // Rotate the character\n            printf(\"%c\", ((plaintext[i] - 'A' + key) % 26) + 'A');\n        }\n        // Check if the character is a lowercase letter\n        else if (plaintext[i] &gt;= 'a' &amp;&amp; plaintext[i] &lt;= 'z')\n        {\n            // Rotate the character\n            printf(\"%c\", ((plaintext[i] - 'a' + key) % 26) + 'a');\n        }\n        else\n        {\n            // If it's not a letter, just print it as is\n            printf(\"%c\", plaintext[i]);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"CS50x/Week%202%20Arrays/#substitution","level":3,"title":"Substitution","text":"<pre><code>#include &lt;cs50.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;ctype.h&gt;\n\nint main(int argc, string argv[])\n{\n    // Make sure program was run with just one command-line argument\n    if (argc != 2)\n    {\n        printf(\"Usage: ./substitution key\\n\");\n        return 1;\n    }\n\n    // Optimize: Calculate key length once\n    int key_len = strlen(argv[1]);\n    for (int i = 0; i &lt; key_len; i++)\n    {\n        // Check if the key contains only alphabetic characters\n        if (!isalpha(argv[1][i]))\n        {\n            printf(\"Key must contain 26 characters.\\n\");\n            return 1;\n        }\n    }\n\n    // Make sure argv[1] has 26 characters (Logic preserved as per original code)\n    for (int i = 0; i &lt; key_len; i++) // Use pre-calculated key_len\n    {\n        if ((argv[1][i] &lt;= 'z' &amp;&amp; argv[1][i] &gt;= 'a') || (argv[1][i] &lt;= 'Z' &amp;&amp; argv[1][i] &gt;= 'A'))\n        {\n            // Use pre-calculated key_len here as well\n            if (key_len != 26) // Use pre-calculated key_len\n            {\n                printf(\"Key must contain 26 characters.\\n\");\n                return 1;\n            }\n            else\n            {   // Check for duplicate characters in the key\n                for (int j = 0; j &lt; key_len; j++) // Use pre-calculated key_len\n                {\n                    for (int k = j + 1; k &lt; key_len; k++) // Use pre-calculated key_len\n                    {\n                        if (argv[1][j] == argv[1][k] || argv[1][j] + 32 == argv[1][k] || argv[1][j] - 32 == argv[1][k])\n                        {\n                            printf(\"Key must not contain repeated characters.\\n\");\n                            return 1;\n                        }\n                    }\n                }\n                // Prompt user for plaintext\n                string plaintext = get_string(\"plaintext: \");\n\n                // Optimize: Calculate plaintext length once\n                int plaintext_len = strlen(plaintext);\n\n                // For each character in the plaintext:\n                for (int j = 0; j &lt; plaintext_len; j++) // Use pre-calculated plaintext_len\n                {\n                    if ((plaintext[j] - 'a') &gt;= 0 &amp;&amp; (plaintext[j] - 'a') &lt;= 26) // Original condition preserved\n                    {\n                        // Convert lowercase letters\n                        plaintext[j] = argv[1][plaintext[j] - 'a'];\n                        if (plaintext[j] &gt;= 'A' &amp;&amp; plaintext[j] &lt;= 'Z')\n                        {\n                            // Convert to lowercase if necessary\n                            plaintext[j] += 32; // ASCII value adjustment\n                        }\n                    }\n                    else if ((plaintext[j] - 'A') &gt;= 0 &amp;&amp; (plaintext[j] - 'A') &lt;= 26) // Original condition preserved\n                    {\n                        // Convert uppercase letters\n                        plaintext[j] = argv[1][plaintext[j] - 'A'];\n                        if (plaintext[j] &gt;= 'a' &amp;&amp; plaintext[j] &lt;= 'z')\n                        {\n                            // Convert to uppercase if necessary\n                            plaintext[j] -= 32; // ASCII value adjustment\n                        }\n                    }\n                }\n                printf(\"ciphertext: %s\\n\", plaintext);\n                return 0;\n            }\n        }\n        else\n        {\n            printf(\"Usage: ./substitution key\\n\");\n            return 1;\n        }\n    }\n    // Note: The original code's control flow causes it to exit the main function within the first iteration\n    // of the key validation loop (if conditions are met).\n    // This final 'return 0' would only be reached if the key_len was 0 or the loop somehow finished without returning.\n    return 0;\n}\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"CS61A/","level":1,"title":"CS61A","text":"Progress Bar Example","path":["CS61A"],"tags":["国外公开课","CS"]},{"location":"CS61A/#_1","level":2,"title":"前言","text":"<p>存放@Eurekaimer在完成CS61A过程中的HWs/Labs/Projects的实现和一些新手可能犯的错误(因为我在学习过程中应该会都踩一遍)，相关实现请参考Github的CS61A仓库</p> <p>完成的时间轴：TBA(To be anounced)(2025.04.05-)</p> <ul> <li> 版本选用：2024spring</li> </ul> <p>由于一些版权上的问题UCB似乎向非UCB的学习者封闭了Archive的通道，所以这里建议选用国内的备份站点和B站的视频</p> <ul> <li> <p> 时间安排：预计200h</p> </li> <li> <p> 语言：Python</p> </li> <li> <p> 前置：无</p> </li> <li> <p> 参考学习顺序：videos-reading-q&amp;a-(lab/disc/hw)-project</p> </li> </ul> <p>完成的时间轴：TBA(2025.04.05-)</p> <p>以下是所有内容的完成情况(按照顺序排列):</p> <ul> <li> 61A-Week-1 2025.4.5<ul> <li> Disc 00</li> <li> Reading</li> <li> Videos(Functions)</li> <li> Lab 00</li> <li> HW 01</li> </ul> </li> <li> 61A-Week-2 2025.4.25<ul> <li> Videos(Control,Higher-Order Functions,Environments)</li> <li> Reading</li> <li> Lab 01</li> <li> Disc 01</li> <li> HW 02: Higher-Order Functions</li> <li> Hog</li> </ul> </li> <li> 61A-Week-3 2025.4.27<ul> <li> Videos(Functional Abstraction,Function Examples)</li> <li> Lab 02</li> <li> Disc 02</li> </ul> </li> <li> 61A-Week-4 2025.4.30<ul> <li> Videos(Recursion,Tree Recursion)</li> <li> HW 03</li> <li> Disc 03</li> </ul> </li> <li> 61A-Week-5 2025.5.12<ul> <li> Videos(Sequences,Containers,Data Abstraction)</li> <li> Lab 03</li> <li> Disc 04</li> <li> Cats</li> </ul> </li> <li> 61A-Week-6 2025.5.13<ul> <li> Videos</li> <li> Lab 04</li> <li> Disc 05</li> <li> HW 04</li> </ul> </li> <li> 61A-Week-7 2025.9.2<ul> <li> Videos(Iterators, Generators, Objects)</li> <li> Lab 05</li> <li> Disc 06</li> <li> HW 05</li> </ul> </li> </ul>","path":["CS61A"],"tags":["国外公开课","CS"]},{"location":"CS61A/#_2","level":2,"title":"资源汇总","text":"<p>CS61a的资源参考(24spring)如下： 1. ZJU课程评价平台 2. CSDIY 3. Videos/Recordings 4. 参考实现 5. Learn-CS：主要使用这个备份站点的资源(无法使用Recording) 6. 一个学习总结</p> <p>文章参考：</p> <ol> <li>CS61a学习总结</li> <li>CS61A 学习经验&amp;感想</li> </ol> <p>也可以使用24fall备份(可fork完成作业)</p>","path":["CS61A"],"tags":["国外公开课","CS"]},{"location":"CS61A/#question-and-feedback","level":2,"title":"Question and Feedback","text":"<p>实际上，这门课的视频几乎可以说是完全包含于textbook中了，我认为如果有一定基础完全可以不看视频直接看书本然后完成lab和hw即可</p>","path":["CS61A"],"tags":["国外公开课","CS"]},{"location":"CS61A/#lab-00","level":3,"title":"Lab 00","text":"<ul> <li>在线评测如何local使用OK(不通过UCBedu邮箱)的问题: 在正确的目录中(ls contains ok) type <code>python ok --local</code> in terminal</li> </ul>","path":["CS61A"],"tags":["国外公开课","CS"]},{"location":"CS61A/#hw-03","level":3,"title":"HW 03","text":"<ul> <li>关于匿名实现递归的信仰之跃</li> </ul>","path":["CS61A"],"tags":["国外公开课","CS"]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/","level":1,"title":"Project 1-The Game of Hog","text":"<p>When students in the past have tried to implement the functions without thoroughly reading the problem description, they’ve often run into issues. 😱 Read each description thoroughly before starting to code.</p> <p>这主要是一个二人的零和博弈游戏，深究应该会涉及到博弈论相关的知识</p> <p>大约需要4h</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#rule","level":2,"title":"Rule","text":"<p>主要规则如下：</p> <ul> <li>Sow Sad. If any of the dice outcomes is a 1, the current player's score for the turn is <code>1</code>.</li> </ul> <p>In a normal game of Hog, Sow Sad is all the rules. To spice up the game, we'll include some special rules:</p> <ul> <li>Boar Brawl. A player who rolls zero dice scores three times the absolute difference between the tens digit of the opponent’s score and the ones digit of the current player’s score, or 1, whichever is higher. The ones digit refers to the rightmost digit and the tens digit refers to the second-rightmost digit. If a player's score is a single digit (less than 10), the tens digit of that player's score is 0.</li> </ul> <p>可以选择不掷色子获得自身个位数与对方十位数差的绝对值的三倍的分数(最小为1)</p> <ul> <li>Sus Fuss. We call a number sus if it has exactly 3 or 4 factors, including 1 and the number itself. If, after rolling, the current player's score is a sus number, they gain enough points such that their score instantly increases to the next prime number.</li> </ul> <p>掷色子后的分数如果恰好有三个或四个因数(包括1和本身)，那么自动将分数提高到下一个质数</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#begin","level":2,"title":"Begin","text":"<p>For the project, you'll only be making changes to <code>hog.py</code>.</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#phase-1-rules-of-the-game","level":2,"title":"Phase 1: Rules of the Game","text":"<p>In the first phase, you will develop a simulator for the game of Hog.</p> <p>值得注意的是每个Problem在正式进行代码书写前，都有一个增进理解的What printed？的项目，主要是有一个对问题的划分意识</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#problem-0-0-pt","level":3,"title":"Problem 0 (0 pt)","text":"<p>增进理解</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#problem-1-2-pt","level":3,"title":"Problem 1 (2 pt)","text":"<p>完成对于sow_sad的判断，单个回合掷色子得到的分数计算</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#problem-2-2-pt","level":3,"title":"Problem 2 (2 pt)","text":"<p>完成Boar-Brawl的实现，计算不抛掷色子情况下的得分判断</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#problem-3-2-pt","level":3,"title":"Problem 3 (2 pt)","text":"<p>题面可能说的不太清楚，输入的是三个参数，综合前两个函数即可</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#problem-4-2-pt","level":3,"title":"Problem 4 (2 pt)","text":"<p>这是为了sus规则的函数，到这里实现了所有的规则</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#problem-5-4-pt","level":3,"title":"Problem 5 (4 pt)","text":"<p>实现最核心的play函数</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#interlude-user-interfaces","level":2,"title":"Interlude: User Interfaces","text":"<p>There are no required problems in this section of the project, just some examples for you to read and understand. See Phase 2 for the remaining project problems.</p> <p>感觉是给出了项目重构的一些思路和方法，如何在原有简单代码的基础上比较好的扩展和方便改进</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#phase-2-strategies","level":2,"title":"Phase 2: Strategies","text":"<p>In this phase, you will experiment with ways to improve upon the basic strategy of always rolling five dice. A strategy is a function that takes two arguments: the current player's score and their opponent's score. It returns the number of dice the player will roll, which can be from 0 to 10 (inclusive).</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#problem-6-2-pt","level":3,"title":"Problem 6 (2 pt)","text":"<p>直接lambda实现就好了</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#problem-7-2-pt","level":3,"title":"Problem 7 (2 pt)","text":"<p>写个循环嵌套暴力遍历得了</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#problem-8-2-pt","level":3,"title":"Problem 8 (2 pt)","text":"<p>Important: To implement this function, you will need to use a new piece of Python syntax. We would like to write a function that accepts an arbitrary number of arguments, and then calls another function using exactly those arguments. Here's how it works.</p> <p>只需要使用例子中的<code>*args</code>即可</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#problem-9-2-pt","level":3,"title":"Problem 9 (2 pt)","text":"<p>下面是一个有问题的代码，笔者想了很久，发现在比较时会调用roll_dice函数，而判断后赋值调用第二次，这就会导致结果受到影响</p> <pre><code>num = 1  \nroll_num = 1  \nmake_averaged_func = make_averaged(roll_dice, samples_count)  \nmax_average = 0  \nwhile num &lt;= 10:  \n    if make_averaged_func(num, dice) &gt; max_average:  \n        max_average = make_averaged_func(num, dice)  \n        roll_num = num  \n    num += 1  \nreturn roll_num\n</code></pre> <p>可以增加一个临时的局部变量进行控制，下面是正确的代码：</p> <pre><code>num = 1  \nroll_num = 1  \nmake_averaged_func = make_averaged(roll_dice, samples_count)  \nmax_average = 0  \nwhile num &lt;= 10:  \n    average_container = make_averaged_func(num, dice)  \n    if average_container &gt; max_average:  \n        max_average = average_container  \n        roll_num = num  \n    num += 1  \nreturn roll_num\n</code></pre>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#running-experiments","level":3,"title":"Running Experiments","text":"<p>还有一个模拟胜率的模块，真是相当完善的评测机制</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#problem-10-2-pt","level":3,"title":"Problem 10 (2 pt)","text":"<p>简单的选择结构</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#problem-11-2-pt","level":3,"title":"Problem 11 (2 pt)","text":"<p>同理可得</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%201-The%20Game%20of%20Hog/#optional-problem-12-0-pt","level":3,"title":"Optional: Problem 12 (0 pt)","text":"<p>因为没有给出色子的参数，所以如果要测试会比较麻烦，干脆给出一个比较简单的策略</p> <pre><code>return 0 if sus_update(0, score, opponent_score) &gt;= GOAL else 6\n</code></pre> <p>在绝对的运气面前策略似乎不太有效呢(欧皇发言doge)</p> <p></p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/","level":1,"title":"Project 2-CS 61A Autocorrected Typing Software","text":"<p>Programmers dream of Abstraction, recursion, and Typing really fast.</p> <p>In this project, you will write a program that measures typing speed. Additionally, you will implement typing autocorrect, which is a feature that attempts to correct the spelling of a word after a user types it. This project is inspired by typeracer.</p> <p>大约需要4h</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#phase-1-typing","level":2,"title":"Phase 1: Typing","text":"","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-1-1-pt","level":3,"title":"Problem 1 (1 pt)","text":"<p>Implement <code>pick</code>. This function selects which paragraph the user will type.</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-2-1-pt","level":3,"title":"Problem 2 (1 pt)","text":"<p>Implement <code>about</code>, which takes a list of <code>subject</code> words. It returns a function which takes a paragraph and returns a boolean indicating whether that paragraph contains any of the words in <code>subject</code>.</p> <p>简单的字符串匹配问题</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-3-2-pts","level":3,"title":"Problem 3 (2 pts)","text":"<p>Implement <code>accuracy</code>, which takes a <code>typed</code> paragraph and a <code>source</code> paragraph. It returns the percentage of words in <code>typed</code> that exactly match the corresponding words in <code>source</code>. Case and punctuation must match as well. \"Corresponding\" here means that two words must occur at the same indices in <code>typed</code> and <code>source</code>; the first words of both must match, the second words of both must match, and so on.</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-4-1-pt","level":3,"title":"Problem 4 (1 pt)","text":"<p>Implement <code>wpm</code>, which computes the words per minute, a measure of typing speed, given a string <code>typed</code> and the amount of <code>elapsed</code> time in seconds. Despite its name, words per minute is not based on the number of words typed, but instead the number of groups of 5 characters, so that a typing test is not biased by the length of words. The formula for words per minute is the ratio of the number of characters (including spaces) typed divided by 5 (a typical word length) to the elapsed time in minutes.</p> <p>实际上就是一个简单的算式</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#phase-2-autocorrect","level":2,"title":"Phase 2: Autocorrect","text":"","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-5-2-pts","level":3,"title":"Problem 5 (2 pts)","text":"<p>Implement <code>autocorrect</code>, which takes a <code>typed_word</code>, a <code>word_list</code>, a <code>diff_function</code>, and a <code>limit</code>. The goal of <code>autocorrect</code> is to return the word in <code>word_list</code> that is closest to the provided <code>typed_word</code>.</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-6-3-pts","level":3,"title":"Problem 6 (3 pts)","text":"<p>Implement <code>feline_fixes</code>, which is a diff function that takes two strings. It returns the minimum number of characters that must be changed in the <code>typed</code> word in order to transform it into the <code>source</code> word. If the strings are not of equal length, the difference in lengths is added to the total.</p> <p>可能需要额外注意判断字符串为空的情况避免调用报错</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-7-3-pts","level":3,"title":"Problem 7 (3 pts)","text":"<p>Implement <code>minimum_mewtations</code>, which is a diff function that returns the minimum number of edit operations needed to transform the <code>typed</code> word into the <code>source</code> word.</p> <p>实现编辑距离（Edit Distance）算法，也称为莱文斯坦距离（Levenshtein Distance）</p> <p>以 <code>typed = \"cats\"</code>，<code>source = \"scat\"</code> 为例：</p> <p>边界条件判断：</p> <pre><code>   ∅  s  c  a  t\n∅  0  1  2  3  4\nc  1  0  0  0  0\na  2  0  0  0  0\nt  3  0  0  0  0\ns  4  0  0  0  0\n</code></pre> <p>填充后得到</p> <pre><code>   ∅  s  c  a  t\n ∅ 0  1  2  3  4\n c 1  1  1  2  3\n a 2  2  2  1  2\n t 3  3  3  2  1\n s 4  3  4  3  2\n</code></pre> <p>实际上就是利用二维数组的思路，然后结合递推公式填充矩阵即可，动态规划类型.</p> <p>关于这个算法的正确性证明我翻了很多中文平台都没有看到写的比较像人的，如果理解不了为什么这样做就是最小的还是看一下这篇paper，这里也贴一个本人的理解，首先我们需要对三种操作都进行分析，三种操作分别是替换，插入，删除权重相同，并且三种操作可选取的位置都是任意的，那么就会出现一个问题，采用逆向思维，再进行最后一步操作的时候恰好两个字符串对齐，那么String1和String2的大半部分一定已经相同了(一定存在一个特别大程度相似的公共字符串)</p> <p>下面开始分类讨论：</p> <ul> <li>替换：只需要一步替换就可以完成的话，两个字符串的长度一定已经相同并且替换位点的后续已经对齐，前面也是对齐的，那么不妨假设前面有\\(i\\)个，那么问题就是前面\\(i\\)个对齐的最小次数+1</li> <li>插入、删除：长度相差1，同样对位点考虑即可，后续问题即变为一个小矩阵，以那个位点为新的顶点进行递归</li> </ul> <p>可以参考Leetcode 72虽然我觉得题解写的也不清楚</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#optional-extension-final-diff-0-pts","level":3,"title":"(Optional) Extension: Final Diff (0 pts)","text":"","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#phase-3-multiplayer","level":2,"title":"Phase 3: Multiplayer","text":"","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-8-2-pts","level":3,"title":"Problem 8 (2 pts)","text":"<p>Implement <code>report_progress</code>, which is called every time the user finishes typing a word. It takes a list of the words <code>typed</code>, a list of the words in the <code>source</code>, the user's <code>user_id</code>, and a <code>upload</code> function that is used to upload a progress report to the multiplayer server. There will never be more words in <code>typed</code> than in <code>source</code>.</p> <p>按照数据抽象使用即可</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-9-2-pts","level":3,"title":"Problem 9 (2 pts)","text":"<p>写之前看一眼</p> <pre><code>def match(words, times):\n    \"\"\"A data abstraction containing all words typed and their times.\n\n    Arguments:\n        words: A list of strings, each string representing a word typed.\n        times: A list of lists for how long it took for each player to type\n            each word.\n            times[i][j] = time it took for player i to type words[j].\n\n    Example input:\n        words: ['Hello', 'world']\n        times: [[5, 1], [4, 2]]\n    \"\"\"\n    assert all([type(w) == str for w in words]), 'words should be a list of strings'\n    assert all([type(t) == list for t in times]), 'times should be a list of lists'\n    assert all([isinstance(i, (int, float)) for t in times for i in t]), 'times lists should contain numbers'\n    assert all([len(t) == len(words) for t in times]), 'There should be one word per time.'\n    return {\"words\": words, \"times\": times}\n\ndef get_word(match, word_index):\n    \"\"\"A utility function that gets the word with index word_index\"\"\"\n    assert 0 &lt;= word_index &lt; len(get_all_words(match)), \"word_index out of range of words\"\n    return get_all_words(match)[word_index]\n\ndef time(match, player_num, word_index):\n    \"\"\"A utility function for the time it took player_num to type the word at word_index\"\"\"\n    assert word_index &lt; len(get_all_words(match)), \"word_index out of range of words\"\n    assert player_num &lt; len(get_all_times(match)), \"player_num out of range of players\"\n    return get_all_times(match)[player_num][word_index]\n\ndef get_all_words(match):\n    \"\"\"A selector function for all the words in the match\"\"\"\n    return match[\"words\"]\n\ndef get_all_times(match):\n    \"\"\"A selector function for all typing times for all players\"\"\"\n    return match[\"times\"]\n\ndef match_string(match):\n    \"\"\"A helper function that takes in a match data abstraction and returns a string representation of it\"\"\"\n    return f\"match({get_all_words(match)}, {get_all_times(match)})\"\n</code></pre>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-10-2-pts","level":3,"title":"Problem 10 (2 pts)","text":"<p>Implement <code>fastest_words</code>, which returns which words each player typed fastest. This function is called once all players have finished typing. It takes in a <code>match</code>.</p> <p>很简单的比大小选择</p> <p></p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"CS61A/Week%201/","level":1,"title":"Week 1","text":"","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%201/#summary","level":2,"title":"Summary","text":"<p>大致需要3.5h完成</p> <ol> <li>建议先看Videos再看Reading，这样对Reading的内容有一个粗略的把握看书会更快</li> <li>一定要写Lab和HW</li> <li>可以先写Lab 00再写HW01</li> </ol>","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%201/#disc-005min","level":2,"title":"Disc 00(5min)","text":"<ul> <li> Part 0 没有Group pass</li> <li> Part 1 没有Discord账号 pass</li> <li> Part 2 破冰小游戏 pass</li> <li> Part 3 唯一的问题(30 min)</li> </ul> <p>Imagine you can call only the following three functions: - f(x): Subtracts one from an integer x - g(x): Doubles an integer x - h(x, y): Concatenates the digits of two different positive integers x and y. For example, h(789, 12) evaluates to 78912 and h(12, 789) evaluates to 12789.</p> <p>Definition: A small expression is a call expression that contains only f, g, h, the number 5, and parentheses. All of these can be repeated. For example, h(g(5), f(f(5))) is a small expression that evaluates to 103.</p> <p>Q:What’s the shortest small expression you can find that evaluates to 2024? A:h(g(g(5)),g(g(g(f(f(5))))))?</p> <ul> <li> Part 4 拍合照/考勤/讨论Part 3的计算机实现</li> </ul>","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%201/#reading2h","level":2,"title":"Reading(2h)","text":"<p>Chapter 1: Building Abstractions with Functions</p> <ul> <li>1.1   Getting Started</li> <li>1.2   Elements of Programming</li> <li>1.3   Defining New Functions</li> </ul>","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%201/#ch-11","level":3,"title":"Ch. 1.1","text":"<p>Computers are very powerful, looking at volumes of data very quickly. Computers can perform billions of operations per second, where each operation is pretty simple. Computers are also shockingly stupid and fragile. The operations that they can do are extremely rigid, simple, and mechanical. The computer lacks anything like real insight ... it's nothing like the HAL 9000 from the movies. If nothing else, you should not be intimidated by the computer as if it's some sort of brain. It's very mechanical underneath it all. Programming is about a person using their real insight to build something useful, constructed out of these teeny, simple little operations that the computer can do.</p>","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%201/#ch-12","level":3,"title":"Ch. 1.2","text":"<p>As videos and some addition</p> <p>The possibility of binding names to values and later retrieving those values by name means that the interpreter must maintain some sort of memory that keeps track of the names, values, and bindings. This memory is called an environment.</p> <p>pure function:</p> <p>Pure functions have the property that applying them has no effects beyond returning a value. Moreover, a pure function must always return the same value when called twice with the same arguments.</p> <p>Non-pure function:</p> <p>In addition to returning a value, applying a non-pure function can generate side effects, which make some change to the state of the interpreter or computer. A common side effect is to generate additional output beyond the return value, using the print function.</p> <p>Remark: The value that print returns is always None, a special Python value that represents nothing. The interactive Python interpreter does not automatically print the value None. In the case of print, the function itself is printing output as a side effect of being called.</p>","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%201/#ch-13","level":3,"title":"Ch. 1.3","text":"<p>Defining New Functions</p> <p>Function Signatures. Functions differ in the number of arguments that they are allowed to take. A description of the formal parameters of a function is called the function's signature.</p>","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%201/#videos1h","level":2,"title":"Videos(1h)","text":"","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%201/#functions","level":3,"title":"Functions","text":"","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%201/#call-expression","level":4,"title":"Call expression","text":"<ul> <li>expresstion tree</li> <li>recursion</li> </ul>","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%201/#names-assignment-and-user-defined-functions","level":4,"title":"Names, Assignment, and User-Defined Functions","text":"<p>Discussion Qustion 1</p> <pre><code>f = min\nf = max\ng, h = min, max\nmax = g\nmax(f(2, g(h(1, 5), 3)), 4)\n</code></pre> <p>Answer: 3</p> <p></p>","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%201/#environment-diagrams","level":4,"title":"Environment Diagrams","text":"<p>给出了Environment Diagrams的概念，目前粗略感觉就是一个简单的可视化过程(类似单纯形表的东西)</p>","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%201/#defining-functions","level":4,"title":"Defining Functions","text":"<p>assignment is binding name to values and function can be more powerful to bind names to expressions.</p> <p>Execution procedure for def statements:</p> <ul> <li>create a function with signature</li> <li>set the body</li> <li>bind name to that function in the current frame</li> </ul>","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%201/#print-and-none","level":4,"title":"Print and None","text":"<p>Interesting case <pre><code># input\nprint(print(2), print(3))\n# output\n2\n3 \nNone  None\n</code></pre></p> <ul> <li>Pure function</li> <li>Non-pure function</li> </ul> <p></p>","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%201/#lab-0010min","level":2,"title":"Lab 00(10min)","text":"<p>UNIX tutorial</p> <p>纪念一下第一次使用ok的Lab</p> <p></p>","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%201/#hw0115min","level":2,"title":"HW01(15min)","text":"<p>还是比较简单的，比较有趣的是Q4是冰雹猜想，不过确实也是很多OJ上的老题了</p> <p>Remark: + Q1注意返回的是<code>f(a,b)</code>，所以你需要输入的是函数 + Q4冰雹猜想需要注意初始的数和迭代后的1也都需要print + 61A的AIdebug真的好玩，玩过头了</p>","path":["CS61A","Week 1"],"tags":[]},{"location":"CS61A/Week%202/","level":1,"title":"Week 2","text":"","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#summary","level":2,"title":"Summary","text":"<p>先看Videos再看Reading，需要注意的是Ch 1.6内容很多，每天的Videos只是讲解了其中的一部分内容并且有时不按顺序，可以先全部看完Videos再看Reading</p> <p>大致需要6h完成(不包括project)</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#videos2h","level":2,"title":"Videos(2h)","text":"","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#control","level":3,"title":"Control","text":"","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#multiple-environments","level":4,"title":"Multiple Environments","text":"<p>Life cycle of a User-Defined Function:</p> <ul> <li>Def statement</li> <li>Call expression</li> <li>Calling/Applying</li> </ul> <p>Names have no meaning without environments</p> <p>Names have different meanings in different environments</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#miscellaneous-python-features","level":4,"title":"Miscellaneous Python Features","text":"<ul> <li>truediv and floordiv</li> <li>mod operator</li> </ul> <p>Vim?!</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#doc-test","level":4,"title":"doc test","text":"<pre><code>from operator import floordiv, mod\n\ndef divide_exact(n,d):\n    \"\"\"Return the quotient and remainder of diving N by D.\n\n    &gt;&gt;&gt; q, r = divide_exact(2013, 10)\n    &gt;&gt;&gt; q\n    201\n    &gt;&gt;&gt; r\n    2\n    \"\"\"\n    return floordiv(n, d), mod(n, d)\n\n# We can type python3 -m doctest -v filename.py to get results \n</code></pre> <p>default value (not assignment)： 只是作为一个占位符，在没有赋值的情况下使用，并不是赋值操作</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#conditional-statements","level":4,"title":"Conditional statements","text":"<pre><code>def absolute_value(x):\n    \"\"\"Return the absolute value of x\"\"\"\n    if x &lt; 0:\n        return -x\n    elif x == 0:\n        return 0\n    else:\n        return x\n</code></pre> <p>George Boole: boolean contexts</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#iteration","level":4,"title":"Iteration","text":"<p>Iteration means repeating things</p> <pre><code>i, total = 0, 0\nwhile i &lt; 3:\n    i = i + 1\n    total = total + i\n</code></pre> <p>这个部分就是讲解简单的循环逻辑，感觉可以不用看.</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#higher-order-functions","level":3,"title":"Higher-Order Functions","text":"","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#iteration-example","level":4,"title":"Iteration Example","text":"<p>talk about Fibonacci sequence and quite trivial</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#control_1","level":4,"title":"Control","text":"<p>用一个函数来表达判断的结构</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#control-expressions","level":4,"title":"Control Expressions","text":"<p>Some expressions can be passed in Python like (left and right &amp;&amp; or) </p> <pre><code>def has_big_sqrt(x)\n    return x &gt; 0 and sqrt(x) &gt; 10\n\n# 聪明的设计，这时输入-1000 程序并不会崩溃，说明右侧程序不执行\n</code></pre> <p>精度丢失问题：</p> <pre><code>def reasionable(n):\n    return n == 0 or 1 / n != 0\n\n&gt;&gt;&gt;reasionable(10 ** 10000)\nFalse\n</code></pre>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#higher-order-functions_1","level":4,"title":"Higher-Order Functions","text":"<p>1.Generalizing Patterns with Arguments</p> <ul> <li>Find common shape</li> <li>share solving method</li> </ul> <p>assert statement:</p> <p>like <code>assert r &gt; 0, 'A length must be positive'</code></p> <p>2.Generalizing Over Computational Processes</p> \\[ \\sum\\limits_{k=1}^{5} k,\\sum\\limits_{k=1}^{5} k^{3},\\sum\\limits_{k=1}^{5}  \\frac{8}{(4k-3)(4k-1)} \\] <p>将模式抽象出来进行归纳式的解决以函数为参量，是一种很自然的想法</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#functions-as-return-values","level":4,"title":"Functions as Return Values","text":"<pre><code>def make_adder(n):\n    def adder(k):\n        return k + n # 取决于make_adder的输入\n    return adder \n\n&gt;&gt;&gt; add_three = make_adder(3)\n&gt;&gt;&gt; add_three(4)\n7\n</code></pre> <p>The purpose of Higher-Order Functions</p> <ul> <li>Express general methods of computation</li> <li>Remove repetition from programs</li> <li>Separate concerns among functions</li> </ul>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#environments","level":3,"title":"Environments","text":"","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#environments-for-higher-order-functions","level":4,"title":"Environments for Higher-Order Functions","text":"<pre><code>def apply_twice(f, x):\n    return f(f(x))\n\ndef square(x)\n    return x * x\n\nresult = apply_twice(square, 2)\n</code></pre>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#environments-for-nested-definitions","level":4,"title":"Environments for Nested Definitions","text":"<p>Mainly about how to draw environment diagram and decide the parent frame of any function. </p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#local-names","level":4,"title":"Local names","text":"<p>Formal parameters of functions have a local scope means that if we call a function but the parameter of it doesn't be defined in local frame, it will cause an error.</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#function-composition","level":4,"title":"Function Composition","text":"<p>Use some simple functions to compose a big function.</p> <pre><code>def compose1(f, g):\n    def h(x):\n        return f(g(x))\n    return h\n</code></pre>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#lambda-expressions","level":4,"title":"Lambda Expressions","text":"<p>由于它没有return部分，使用lambda只能创建简单的函数，在Python中也不经常用，但是对于其他语言常用(我学Python和R的，我可以不看吗？)</p> <p></p> <p>Only the def statement gives the function an intrinsic name. </p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#function-currying","level":4,"title":"Function Currying","text":"<pre><code>def curry2(f):\n    def g(x):\n        def h(y):\n            return f(x, y) # 调用输入的参数\n        return h # 第二步开始调用\n    return g # 第一步开始调用\n\ncurry2 = lambda f : lambda x : lambda y : f(x, y)\n</code></pre> <p>Here should be an environment diagram but none.</p> <p>more clear case: </p> <pre><code>def curried_pow(x):\n    def h(y):\n        return pow(x, y)\n    return h\n\n&gt;&gt;&gt; curried_pow(2)(3)\n8\n</code></pre>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#reading2h","level":2,"title":"Reading(2h)","text":"<p>Chapter 1: Building Abstractions with Functions</p> <ul> <li>1.4  Designing Functions</li> <li>1.5  Control </li> <li>1.6  Higher-Order Functions</li> </ul>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#ch-14","level":3,"title":"Ch. 1.4","text":"<p>Functions are an essential ingredient of all programs, large and small, and serve as our primary medium to express computational processes in a programming language.</p> <p>Good functions should obey following guidelines:</p> <ul> <li>only excute one job</li> <li>Don't repeat yourself(DRY)</li> <li>define generally</li> </ul> <p>A function definition will often include documentation describing the function, called a docstring, which must be indented along with the function body. Docstrings are conventionally triple quoted. The first line describes the job of the function in one line. The following lines can describe arguments and clarify the behavior of the function:</p> <p>When you call help with the name of a function as an argument, you see its docstring (type q to quit Python help).</p> <p>例如：<code>help(function name)</code> 就会给出文档说明</p> <p>Comment will be passed by complier but can be read by person.</p> <p><code># comments</code></p> <p>As a guideline, most data values used in a function's body should be expressed as default values to named arguments, so that they are easy to inspect and can be changed by the function caller. Some values that never change, such as the fundamental constant k, can be bound in the function body or in the global frame.</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#ch-15","level":3,"title":"Ch. 1.5","text":"<p>Instead of computing something, executing a control statement determines what the interpreter should do next.</p> <p>Compound statements: 1. header  2. suite 3. clause</p> <p>Practical Guidance. When indenting a suite, all lines must be indented the same amount and in the same way (use spaces, not tabs). Any variation in indentation will cause an error.</p> <p>Some defines: 1. Local assignment 2. Conditional statements 3. Boolean contexts 4. Boolean values 5. Boolean operators</p> <p>About boolean operators:</p> <p>These procedures exploit the fact that the truth value of a logical expression can sometimes be determined without evaluating all of its subexpressions, a feature called short-circuiting.</p> <p>Remark: not calculate all subexpressions</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#test","level":4,"title":"test","text":"<p><code>python3 -m doctest &lt;python_source_file&gt;</code></p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#ch-16","level":3,"title":"Ch. 1.6","text":"<p>To express certain general patterns as named concepts, we will need to construct functions that can accept other functions as arguments or return functions as values. Functions that manipulate functions are called higher-order functions. This section shows how higher-order functions can serve as powerful abstraction mechanisms, vastly increasing the expressive power of our language.</p> <p></p> <p>注：就好像泛函一样，只是这里叫高阶函数</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#golden-ratio-case","level":4,"title":"Golden-ratio case","text":"<pre><code># 主要以两个函数为参数\ndef improve(update, close, guess = 1):\n    while not close(guess): # 停机准则函数\n        guess = update(guess)\n    return guess\n\n# 更新guess的函数\ndef golden_update(guess):\n    return 1 / guess + 1\n\n# 以guess作为输入给出判断(实际上可以合并)\ndef square_close_to_successor(guess):\n    return approx_eq(guess * guess, guess + 1)\n\n# 停机准则函数\ndef approx_eq(x, y, tolerance=1e-3):\n    return abs(x - y) &lt; tolerance\n\nphi = improve(golden_update, square_close_to_successor)\n</code></pre>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#defining-functions-iii-nested-definitions","level":4,"title":"Defining Functions III: Nested Definitions","text":"<p>相当重要的一个东西，做一个函数嵌套</p> <p>Lexical scope. Locally defined functions also have access to the name bindings in the scope in which they are defined.</p> <p>two key advantages of lexical scoping in Python</p> <ul> <li>The names of a local function do not interfere with names external to the function in which it is defined, because the local function name will be bound in the current local environment in which it was defined, rather than the global environment.</li> <li>A local function can access the environment of the enclosing function, because the body of the local function is evaluated in an environment that extends the evaluation environment in which it was defined.</li> </ul> <p>还需要注意环境和函数的关系</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#newtons-method","level":4,"title":"Newton's Method","text":"<p>已经学了不知道多少遍了</p> <p>既然讲了Newton-Raphson Algorithm也应该讲一下Fisher-scoring Algorithm吧(From Mathematical Statistic)</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#currying","level":4,"title":"Currying(柯里化)","text":"<p>\"Currying\" 在英语中，尤其是在编程和数学领域，指的是“柯里化”。柯里化是一种将使用多个参数的函数转换为一系列使用单一参数的函数的技术。</p> <p>Currying allows us to do so without writing a specific function for each number whose powers we wish to compute.</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#lambda-function","level":4,"title":"Lambda function","text":"<p>是一种简洁的函数表示方法但是由于理解的不容易不怎么使用，在Python中更倾向于使用def而不是lambda函数(为了方便别人也为了方便自己，知道这个用法应当足够，自己的程序最好还是不要用了)</p> <p>Standard formal:</p> <p>lambda x : f(g(x)) means \"A function that  takes x  and returns  f(g(x))\"</p> <p>Case: </p> <p><code>compose1 = lambda f, g : lambda x: f(g(x))</code></p> <p>The significance of higher-order functions is that they enable us to represent these abstractions explicitly as elements in our programming language, so that they can be handled just like other computational elements.</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#function-decorators","level":4,"title":"Function Decorators","text":"<p>相当于在原本函数的基础上增加一些新的小功能并且不更改函数名和原本调用</p> <p>Question: 为什么不直接重构呢？</p> <p>以下是一些可能的原因(瞎琢磨)：</p> <ul> <li>代码复用(用一个片段一直修饰不同的函数)</li> <li>保证原本函数的简洁</li> <li>所谓的\"开闭原则\"</li> <li>方便维护和扩展(装饰器的部分应该不是函数核心的功能，如果不用或是修改的话可以直接重构多个函数)</li> </ul>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#lab-011h","level":2,"title":"Lab 01(1h)","text":"<p>[!tip] 写完一定要对答案!</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#what-would-python-display-wwpd","level":3,"title":"What Would Python Display? (WWPD)","text":"","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#q1-wwpd-control","level":4,"title":"Q1: WWPD: Control","text":"<p>注意：Python的函数在没有显式使用return的情况下默认返回None，print后就会得到None</p> <p>例子</p> <pre><code>def how_big(x):\n    if x &gt; 10: \n        print('huge') \n    elif x &gt; 5: \n        return 'big' \n    if x &gt; 0: \n        print('positive') \n    else: \n        print(0)\n\n&gt;&gt;&gt; print(how_big(12))\nline1 huge\nline2 positive\nline3 None\n</code></pre>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#q2-debugging-quiz","level":4,"title":"Q2: Debugging Quiz","text":"<p>有点搞，不知道为什么交互式做选择题比单纯做题有乐子，做题家基因觉醒了.</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#write-code","level":3,"title":"Write Code","text":"","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#q3-falling-factorial","level":4,"title":"Q3: Falling Factorial","text":"<p>唯一的问题是要把所有的doctest和题目看完，不要直接写</p> <p>答案没有专门对0判断而是用了更聪明的做法(移项可知\\(k&gt;0\\))</p> <pre><code>total, stop = 1, n-k  \nwhile n &gt; stop:  \n    total, n = total*n, n-1  \nreturn total\n</code></pre>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#q4-divisible-by-k","level":4,"title":"Q4: Divisible By k","text":"<p>相当于实现一个更完整的range函数</p> <p>感觉写的不是特别好</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#q5-sum-digits","level":4,"title":"Q5: Sum Digits","text":"<p>经典的OJ题，做法太多了</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#syllabus-quiz","level":3,"title":"Syllabus Quiz","text":"","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#q6-syllabus-quiz","level":4,"title":"Q6: Syllabus Quiz","text":"<p>做不了</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#optional-questions","level":3,"title":"Optional Questions","text":"","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#q7-wwpd-what-if","level":4,"title":"Q7: WWPD: What If?","text":"<p>非常容易不知道和前面比难在哪</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#q8-double-eights","level":4,"title":"Q8: Double Eights","text":"<p>同样非常容易，OJ老题</p> <p>这个参考答案节约了一些空间</p> <pre><code>def double_eights_alt(n):  \n    while n:  \n        if n % 10 == 8 and n // 10 % 10 == 8:  \n            return True  \n        n //= 10  \n    return False\n</code></pre>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#disc-0130min","level":2,"title":"Disc 01(30min)","text":"","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#while-and-if","level":3,"title":"While and If","text":"","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#q1-race","level":4,"title":"Q1: Race","text":"<pre><code>def race(x, y):\n    \"\"\"The tortoise always walks x feet per minute, while the hare repeatedly\n    runs y feet per minute for 5 minutes, then rests for 5 minutes. Return how\n    many minutes pass until the tortoise first catches up to the hare.\n\n    &gt;&gt;&gt; race(5, 7)  # After 7 minutes, both have gone 35 steps\n    7\n    &gt;&gt;&gt; race(2, 4) # After 10 minutes, both have gone 20 steps\n    10\n    \"\"\"\n    assert y &gt; x and y &lt;= 2 * x, 'the hare must be fast but not too fast'\n    tortoise, hare, minutes = 0, 0, 0\n    while minutes == 0 or tortoise - hare:\n        tortoise += x\n        if minutes % 10 &lt; 5:\n            hare += y\n        minutes += 1\n    return minutes\n</code></pre> <p>错误应该为乌龟超越兔子但二者行走距离不同，第二次追及</p> <p>Wrong value：(2，3),(6, 11)</p> <p>注1：直接考虑构建一个二元方程组，考虑特殊情况下运动相同距离就应该是在兔子运动时相遇，\\((10+t)x=(5+t)y\\)，此时只需要取整数解即可\\((1\\leqslant t \\leqslant 5)\\)，随便取一个好算的分数通分即可(注意不要循环起来也不要是整数比，两倍肯定相同，小技巧是选取互素的整数对(x, y)且gcd(x,5)=1，注意这样在第一轮就始终无法走相同距离)</p> <p>注2：好像应该用试的但是没忍住分析了一下</p> <p>无限运行应该是乌龟超过兔子后兔子追不上</p> <p>Runs forever：(4, 5)</p> <p>注3：延续上面的思路即可\\((10k+t)x=(5k+t)y\\)，考虑互素的情形，并且不为两倍关系直接令\\(y=5\\)，令\\(t=5\\)排除\\(x=3\\implies x=4\\)</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#q2-fizzbuzz","level":4,"title":"Q2: Fizzbuzz","text":"<p>非常简单的判断，代码参考repo</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#q3-is-prime","level":4,"title":"Q3: Is Prime?","text":"<p>经典素数筛，理论上有许多筛法，这里偷懒直接选用了一个最基本的数论结果</p> <pre><code>if n == 1:  \n    return False  \nk = 2  \nwhile k &lt; (n / 2):  \n    # save time  \n    if n % k == 0:  \n        return False  \n    k += 1  \nreturn True\n</code></pre>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#q4-unique-digits","level":4,"title":"Q4: Unique Digits","text":"<p>完成两个函数即可，第一个只需要在第二个函数基础上写while循环</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#q5-bottles","level":4,"title":"Q5: Bottles","text":"<p>pass</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#q6-double-trouble","level":4,"title":"Q6: Double Trouble","text":"","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%202/#hw0230min","level":2,"title":"HW02(30min)","text":"<p>大都比较简单，不再赘述，代码可参考仓库</p>","path":["CS61A","Week 2"],"tags":[]},{"location":"CS61A/Week%203/","level":1,"title":"Week 3","text":"","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#summary","level":2,"title":"Summary","text":"<p>大概需要2.5小时，Lab质量相当高，可以很好的弥补理解上的一些问题</p>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#videos1h","level":2,"title":"Videos(1h)","text":"","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#functional-abstraction","level":3,"title":"Functional Abstraction","text":"","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#lambda-function-environments","level":4,"title":"Lambda Function Environments","text":"<p>This is main case:</p> <pre><code>a = 1\ndef f(g):\n    a = 2\n    return lambda y: a * g(y)\nf(lambda y: a + y)(a)\n\n# we can get 4(2 * (1 + 1))\n</code></pre>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#return","level":4,"title":"Return","text":"<pre><code>def search(f):\n    \"\"\"找出能够返回Ture的最小非负整数\"\"\"\n    x = 0\n    while True:\n        if f(x):\n            return x\n        x += 1\n    # 下面是一个改进版本\n    while not f(x):\n        x += 1\n    return x\n\ndef inverse(f):\n    \"\"\"Return g(y) such that g(f(x)) -&gt; x.\"\"\"\n    # 找出使f(x)=y成立的最小x\n    return lambda y: search(lambda x: f(x) == y)\n\n# 找反函数\nsqrt = inverse(square) \n</code></pre>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#abstraction","level":4,"title":"Abstraction","text":"<p>Choose a name for valued function or parameters.</p> <p>Some name guideline. </p>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#errors-tracebacks","level":4,"title":"Errors &amp; Tracebacks","text":"<p>Teach you check some errors and read tracebacks</p>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#function-examples","level":3,"title":"Function Examples","text":"","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#midterm-1-review","level":4,"title":"Midterm 1 Review","text":"<ul> <li>WWPP</li> </ul> <pre><code>def delay(arg):\n    print('delayed')\n    def g():\n        return arg\n    return g\n\ndelay(delay)()(6)()\n\n# 分析\n# delay(delay) -&gt; 返回g 传入参数为delay函数 print也被调用\n# delay(delay)() -&gt; 调用g 返回delay\n# delay(delay)()(6) -&gt; 调用delay 传入参数为6 相当于delay(6)=g print也被调用\n# delay(delay)()(6)() -&gt; 调用g() 上一步知道传入参数为6 返回6\n\nprint(delay(print)()(4))\n\n# 同理分析即可\n</code></pre> <p>Last example but a litttle difficult</p> <pre><code>def horse(mask):\n    horse = mask\n    def mask(horse):\n        return horse\n    return horse(mask)\n\nmask = lambda horse: horse(2)\n\nhorse(mask)\n</code></pre> <p>有一种当年玩指针的美感(只要正确的指向就可以明白，这里的环境图确实是加进理解的一种手段)</p> <p></p>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#implementing-functions","level":4,"title":"Implementing Functions","text":"<p>Strategy:</p> <ul> <li>Read the description</li> <li>Verify the example &amp; pick a simple one</li> <li>If the template is helpful, use it</li> <li>Write cide to compute the result</li> </ul> <p>A case</p> <pre><code>def remove(n, digit):\n    kept, digits = 0, 0\n    while n &gt; 0:\n        n, last = n // 10, n % 10\n        if last != digit:\n            kept = kept + last * 10 ** digits\n            digits += 1\n    return kept\n</code></pre>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#decoraters","level":4,"title":"Decoraters","text":"<pre><code>def trace1(fn):\n\"\"\"Return a version of fn\"\"\"\n    def traced(x):\n        print('Calling', fn, 'on argument', x)\n        return fn(x)\n    return traced\n\n@trace1 # square = trace1(square)\ndef square(x):\n    return x * x\n\n@trace1\ndef sum_squares_ up_to(n):\n    k = 1\n    total = 0\n    while k &lt;= n:\n        total, k = total + square(k), k + 1\n    return total\n</code></pre>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#lab-021h","level":2,"title":"Lab 02(1h)","text":"<p>前面是一些基础的Review部分，算是强行带你复习吗?感觉还是不错的，给出了Short-circuiting这个概念详细的解释</p> <p>这里需要注意lambda表达式和def表达式的一些细微区别</p> <pre><code># A lambda expression by itself does not alter\n# the environment\nlambda x: x * x\n# We can assign lambda functions to a name\n# with an assignment statement\nsquare = lambda x: x * x\nsquare(3)\n\n# Lambda expressions can be used as an operator\n# or operand\nnegate = lambda f, x: -f(x)\nnegate(lambda x: x * x, 3)\n</code></pre> <p>Note: As we saw in the <code>lambda</code> expression section above, <code>lambda</code> functions have no intrinsic name. When drawing <code>lambda</code> functions in environment diagrams, they are labeled with the name <code>lambda</code> or with the lowercase Greek letter λ. This can get confusing when there are multiple lambda functions in an environment diagram, so you can distinguish them by numbering them or by writing the line number on which they were defined.</p>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#wwpd","level":3,"title":"WWPD","text":"","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#q1-wwpd-the-truth-will-prevail","level":4,"title":"Q1: WWPD: The Truth Will Prevail","text":"<p>If <code>and</code> and <code>or</code> do not short-circuit, they just return the last value; another way to remember this is that <code>and</code> and <code>or</code> always return the last thing they evaluate, whether they short circuit or not. Keep in mind that <code>and</code> and <code>or</code> don't always return booleans when using values other than <code>True</code> and <code>False</code>.</p> <p>Used above info.</p> <pre><code># 有点阴的例子\nprint(3) or ''\n# print会执行但是返回的None是假值，而空字符串也是假值，于是最终返回最后计算的空字符串\n# 3\n# ''\n</code></pre> <p>只要做完就会对短路求值这件事彻底理解</p>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#q2-wwpd-higher-order-functions","level":4,"title":"Q2: WWPD: Higher-Order Functions","text":"<p>这个也有点搞，需要稍微仔细一点去想返回的是函数还是调用函数</p>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#q3-wwpd-lambda","level":4,"title":"Q3: WWPD: Lambda","text":"<pre><code># case 无参数 还真没想过\n(lambda: 3)()\n</code></pre> <p>注：这个lab真是大开眼界了</p>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#coding-practice","level":3,"title":"Coding Practice","text":"","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#q4-composite-identity-function","level":4,"title":"Q4: Composite Identity Function","text":"","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#q5-count-cond","level":4,"title":"Q5: Count Cond","text":"<p>这些代码并不难，答案也没有什么很优雅的做法</p>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#environment-diagram-practice","level":3,"title":"Environment Diagram Practice","text":"","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#q6-hof-diagram-practice","level":4,"title":"Q6: HOF Diagram Practice","text":"","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#optional-questions","level":3,"title":"Optional Questions","text":"","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#q7-multiple","level":4,"title":"Q7: Multiple","text":"<p>实际上应该是找最小公倍数的问题，有很多优化算法，偷懒打个简单的</p> <pre><code>i = 1  \nwhile True:  \n    if (max(a, b) * i) % min(a, b) == 0:  \n        return max(a, b) * i  \n    else:  \n        i += 1\n</code></pre> <p>可能答案想打个遍历吧，但是显然这样复杂度对于大数来说不划算</p>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#q8-i-heard-you-liked-functions","level":4,"title":"Q8: I Heard You Liked Functions...","text":"<p>这个题目也是够套娃的...但是也还好逻辑比较简单</p> <p>Define a function <code>cycle</code> that takes in three functions <code>f1</code>, <code>f2</code>, and <code>f3</code>, as arguments. <code>cycle</code> will return another function <code>g</code> that should take in an integer argument <code>n</code> and return another function <code>h</code>. That final function <code>h</code> should take in an argument <code>x</code> and cycle through applying <code>f1</code>, <code>f2</code>, and <code>f3</code> to <code>x</code>, depending on what <code>n</code> was. Here's what the final function <code>h</code> should do to <code>x</code> for a few values of <code>n</code>:</p> <ul> <li><code>n = 0</code>, return <code>x</code></li> <li><code>n = 1</code>, apply <code>f1</code> to <code>x</code>, or return <code>f1(x)</code></li> <li><code>n = 2</code>, apply <code>f1</code> to <code>x</code> and then <code>f2</code> to the result of that, or return <code>f2(f1(x))</code></li> <li><code>n = 3</code>, apply <code>f1</code> to <code>x</code>, <code>f2</code> to the result of applying <code>f1</code>, and then <code>f3</code> to the result of applying <code>f2</code>, or <code>f3(f2(f1(x)))</code></li> <li><code>n = 4</code>, start the cycle again applying <code>f1</code>, then <code>f2</code>, then <code>f3</code>, then <code>f1</code> again, or <code>f1(f3(f2(f1(x))))</code></li> <li>And so forth.</li> </ul> <p>Hint: most of the work goes inside the most nested function.</p> <p>保险起见写了一个特别简单的版本，可以参考答案的做法</p> <pre><code>def classifier(n):  \n    def inner_loop(x):  \n        i = 1  \n        while i &lt;= n:  \n            if (i % 3) == 1:  \n                x = f1(x)  \n            elif (i % 3) == 2:  \n                x = f2(x)  \n            elif (i % 3) == 0:  \n                x = f3(x)  \n            i += 1  \n        return x  \n    return inner_loop  \nreturn classifier\n</code></pre> <p>优雅的递归解法</p> <pre><code>def g(n):  \n    def h(x):  \n        if n == 0:  \n            return x  \n        return cycle(f2, f3, f1)(n - 1)(f1(x))  \n    return h  \nreturn g\n</code></pre>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#disc-0230min","level":2,"title":"Disc 02(30min)","text":"<p>相应的测试代码在CS61A的仓库内</p>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#q1-warm-up","level":3,"title":"Q1: Warm Up","text":"<p>trivial</p>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#q2make-keeper","level":3,"title":"Q2：Make Keeper","text":"<p>也是很简单的</p> <pre><code>def cond(f):  \n    i = 1  \n    while i &lt;= n:  \n        if f(i):  \n            print(i)  \n        i += 1  \nreturn cond\n</code></pre>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#q3-digit-finder","level":3,"title":"Q3: Digit Finder","text":"<pre><code>def give_digit(x):  \n    return (x // (pow(10, k-1))) % 10  \nreturn give_digit\n</code></pre> <p>答案使用的是lambda匿名封装(效果可能差不多但是有点帅，想学)</p> <pre><code>return lambda x: (x // pow(10, k-1)) % 10\n</code></pre>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%203/#q4-match-maker","level":3,"title":"Q4: Match Maker","text":"<p>也比较简单，因为已给出了一个框架</p> <pre><code>def check(x):  \n    while x // (10 ** k) &gt; 0:  \n        if (x % 10) != (x // (10 ** k)) % 10:  \n            return False  \n        x //= 10  \n    return True  \nreturn check\n</code></pre> <p>总的来说Disc还是比较简单的</p>","path":["CS61A","Week 3"],"tags":[]},{"location":"CS61A/Week%204/","level":1,"title":"Week 4","text":"","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#summary","level":2,"title":"Summary","text":"<p>大概需要5小时，本次的HW很有价值</p> <p>一些小建议：</p> <ul> <li>不一定需要做笔记，理解&gt;记录(优先于)，可以先观看完后根据印象重写代码或是写一下随想</li> <li>最好定期复习，这时笔记发挥作用</li> <li>可以尝试修改一些课程的代码(实践促进理解)</li> </ul>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#videos1h","level":2,"title":"Videos(1h)","text":"","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#recursion","level":3,"title":"Recursion","text":"","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#self-reference","level":4,"title":"Self-Reference","text":"<pre><code>def print_all(x):\n    print(x)\n    return print_all\n\nprint_all(1)(2)(3)\n</code></pre> <p>sum case:</p> <pre><code>def print_sums(x):\n    print(x)\n    def next_sum(y)\n        return print_sums(x+y)\n    return next_sum\n\nprint_sums(1)(3)(5)\n</code></pre>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#recursive-functions","level":4,"title":"Recursive Functions","text":"<p>Digit Sums</p> <pre><code>def split(n):\n    return n // 10, n % 10\n\ndef sum_digits(n):\n    if n &lt; 10；\n        return n\n    else:\n        all_but_last, last = split(n)\n        return sum_digits(all_but_last) + last\n</code></pre>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#recursion-in-environment-diagrams","level":4,"title":"Recursion in Environment Diagrams","text":"<pre><code>def fact(n):\n    if n == 0:\n        return 1\n    else:\n        return n * fact(n-1)\n\nfact(3)\n</code></pre> <p>Iteration is a special case of recursion.</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#verifying-recursive-functions","level":4,"title":"Verifying Recursive Functions","text":"","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#mutual-recursion","level":4,"title":"Mutual Recursion","text":"<p>The Luhn Algorithm</p> <p>Actually, I have seen this algorithm in CS50x before and it was the optional case in problem set.</p> <p>Very Interesting!</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#recursion-and-iteration","level":4,"title":"Recursion and Iteration","text":"<p>some examples and we can change any iteration case to recursion type.</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#tree-recursion","level":3,"title":"Tree Recursion","text":"","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#order-of-recursive-calls","level":4,"title":"Order of Recursive Calls","text":"<p>cascade case:</p> <pre><code>def cascade(n):\n    print(n)\n    if n &gt;= 10:\n        cascade(n // 10)\n        print(n)\n\ndef cascade(n):\n    if n &lt; 10:\n        print(n)\n    else:\n        print(n)\n        cascade(n // 10)\n        print(n)\n</code></pre> <p>write code for people!</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#example-inverse-cascade","level":4,"title":"Example: Inverse Cascade","text":"<pre><code>def inverse_cascade(n):\n    grow(n)\n    print(n)\n    shrink(n)\n\ndef f_then_g(f, g, n):\n    if n:\n        f(n)\n        g(n)\n\ngrow = lambda n: f_then_g(grow, print, n // 10)\nshrink = lambda n: f_then_g(print, shrink, n // 10)\n</code></pre>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#tree-recursion_1","level":4,"title":"Tree Recursion","text":"<pre><code>def Fib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n         return Fib(n-1) + Fib(n-2)\n</code></pre>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#reading1h","level":2,"title":"Reading(1h)","text":"<p>Chapter 1: Building Abstractions with Functions + 1.7 Recursive Functions</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#ch-17","level":3,"title":"Ch. 1.7","text":"<p>A function is called recursive if the body of the function calls the function itself, either directly or indirectly.</p> <p>An example use recursion function to calculate sum of digits</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#the-anatomy-of-recursive-functions","level":4,"title":"The Anatomy of Recursive Functions","text":"<p>Treating a recursive call as a functional abstraction has been called a recursive leap of faith.</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#mutual-recursion_1","level":4,"title":"Mutual Recursion","text":"<p>When a recursive procedure is divided among two functions that call each other, the functions are said to be mutually recursive.</p> <pre><code>def is_even(n):\n    if n== 0:\n        return True\n    else:\n        return is_odd(n-1)\n\ndef is_odd(n):\n    if n == 0:\n        return False\n    else:\n        return is_even(n-1)\n\nresult = is_even(4)\n</code></pre> <p>No matter even or odd, the function will return iff n equals to 0.</p> <p>As such, mutual recursion is no more mysterious or powerful than simple recursion, and it provides a mechanism for maintaining abstraction within a complicated recursive program.</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#printing-in-recursive-functions","level":4,"title":"Printing in Recursive Functions","text":"<p>talk about the cascade function in videos, here is passed.</p> <p>One another case:</p> <p>As another example of mutual recursion, consider a two-player game in which there are n initial pebbles on a table. The players take turns, removing either one or two pebbles from the table, and the player who removes the final pebble wins. Suppose that Alice and Bob play this game, each using a simple strategy:</p> <ol> <li>Alice always removes a single pebble</li> <li>Bob removes two pebbles if an even number of pebbles is on the table, and one otherwise</li> </ol> <p>Use mutual recursion</p> <pre><code>def play_alice(n):\n    if n == 0:\n        print(\"Bob wins!\")\n    else:\n        play_bob(n-1)\n\ndef play_bob(n):\n    if n == 0:\n        print(\"Alice wins!\")\n    elif is_even(n):\n        play_alice(n-2)\n    else:\n        play_alice(n-1)\n</code></pre> <p>Remark: This code pattern can be used in any two-players game, and help dinner major in Math(Stat\\OR...) save a lot of time.</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#tree-recursion_2","level":4,"title":"Tree Recursion","text":"<p>Classical Fibonacci computation and use recursion algorithm.</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#example-partitions","level":4,"title":"Example: Partitions","text":"<p>The number of partitions of a positive integer n, using parts up to size m, is the number of ways in which n can be expressed as the sum of positive integer parts up to m in increasing order. For example, the number of partitions of 6 using parts up to 4 is 9.</p> <p>Obviously, we can use recursion to solve the problem and code below.</p> <p>The most important is get the recursion process, and the (n, m) can be devided two parts:</p> <ol> <li>(n, m-1) no doubt one case</li> <li>we use the m so remain n-m to devide: (n-m, m)</li> </ol> <pre><code># The number of ways to partition n using integers up to m equals\ndef partitions(n, m):\n    \"\"\"Count the ways to partition n using parts up to m\"\"\"\n    # 1. There is one way to partition 0: include no parts.\n    if n == 0:\n        return 1\n    #  There are 0 ways to partition a negative n.\n    elif n &lt; 0:\n        return 0\n    # There are 0 ways to partition any n greater than 0 using parts of size 0 or less.\n    elif m &lt;= 0: # the book use m == 0, but I think this is better.\n        return 0\n    # main recursion algorithm\n    else:\n        return partitions(n-m, m) + partitions(n, m-1)\n</code></pre>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#disc-031h30min","level":2,"title":"Disc 03(1h30min)","text":"","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#recursion_1","level":3,"title":"Recursion","text":"<p>实现均可以参考仓库</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#q1-swipe","level":4,"title":"Q1: Swipe","text":"<p>不太难</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#q2-skip-factorial","level":4,"title":"Q2: Skip Factorial","text":"<p>不太难</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#q3-is-prime","level":4,"title":"Q3: Is Prime","text":"<p>不太难</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#q4-recursive-hailstone","level":4,"title":"Q4: Recursive Hailstone","text":"<p>不太难</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#some-interesting-questions","level":3,"title":"Some interesting questions","text":"","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#q5-sevens","level":4,"title":"Q5: Sevens","text":"<p>还是比较容易的，可能判断起来有点麻烦</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#q6-karel-the-robot","level":4,"title":"Q6: Karel the Robot","text":"<p>卡在这里比较长时间，网上的答案大多也是错的</p> <pre><code>from karel.stanfordkarel import *\n\n\ndef main():\n    if front_is_clear():\n        move()\n        if front_is_clear():\n            move()\n            if front_is_clear():\n                main()\n    if front_is_blocked(): \n       turn_left()\n       turn_left()\n    move()\n</code></pre>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#hw031h30min","level":2,"title":"HW03(1h30min)","text":"","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#q1-num-eights","level":3,"title":"Q1: Num Eights","text":"<p>不难</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#q2-digit-distance","level":3,"title":"Q2: Digit Distance","text":"<p>不难，答案写的略微复杂</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#q3-interleaved-sum","level":3,"title":"Q3: Interleaved Sum","text":"<p>编写过程中会很自然意识到需要倒序递归，其实编写一个反序的就可以，有点类似第二数学归纳法的感觉</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#q4-count-coins","level":3,"title":"Q4: Count Coins","text":"<p>此事在CS50x中亦有记载</p> <p>类似之前例子中的Partitions吧(或者Catlant数?)，经典OJ题了</p> <p>不知道为什么官方写辅助函数不多写一个判断返回0，自己编写完成后查看报错发现返回了错误类型(增加判断None)，如果发现和测试对不上可以自己找案例测试一下(比如total为0应该返回1)</p> <p>编写时可以思考各个判断之间的依赖关系(可能有冗余判断)，笔者选择对特殊情况添加判断以在大数部分节约机时(但其实没有这个判断也可以跑通)</p> <p>注：本次HW的选做题比较难也比较有意思，尤其是最后一道题确实有一定难度</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#q5-towers-of-hanoi","level":3,"title":"Q5: Towers of Hanoi","text":"<p>坏孩子原本想直接使用递推式(\\(a_{n}=2a_{n-1}+1\\))，后发现还需要打印步骤，那么只好老老实实写递归</p> <p>这里有一个小技巧，如何判断除了start和end外剩余的柱子，只需要利用label做减法(6 - start - end)自然可以得到.</p> <p>主要思想是逆向思维：将下层视为没有(因为是最大的所以一定是做底的)，只需要考虑将剩余部分挪到辅助柱上，然后将最大的一层挪到3，此时剩余所有的柱子一定在2上，剩下就是将原本的1作为辅助柱，循环下去.</p> <p>编写出的代码也基本符合这一思想</p> <pre><code>if n == 1:  \n    print_move(start, end)  \nelse:  \n    other = 6 - start - end  \n    move_stack(n-1, start, other)  \n    print_move(start, end)  \n    move_stack(n-1, other, end)\n</code></pre> <p>这个时候就体现了书中“信仰之跃”的重要性，不要管怎么实现的，假设已经实现了，然后只要把简单的case定好，能够覆盖所有的收敛情况即可.</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%204/#q6-anonymous-factorial","level":3,"title":"Q6: Anonymous Factorial","text":"<p>This question demonstrates that it's possible to write recursive functions without assigning them a name in the global frame.</p> <p>实际编写：</p> <p>Step 1: 确认输入输出，输入一个数记为k，返回一个高阶函数F'以函数F为参数</p> <p>T(F): lambda F: lambda k: F(F, k)</p> <p>Step 2: 思考输入的F的构造，应当接受两个参量，k为1返回1，否则就进行一个类似递归的计算</p> <p>F = lambda f, k: 1 if k == 1 else k * f(f, k - 1) </p> <p>此处不妨假设f(f, k - 1)就是所需要的递归函数</p> <p>实际最终函数是：</p> <p>lambda k: (lambda f, k: 1 if k == 1 else k * f(f, k - 1))((lambda f, k: 1 if k == 1 else k * f(f, k - 1)), k)</p> <p>下面是可能有用的推演过程</p> <p>尝试：输入一个f直接代表递归函数，并且f只接受一个k</p> <p>lambda f: (lambda k: f(k))--(lambda k: 1 if k == 0 else k * f(k - 1)?)</p> <p>发现无法调用f,判断必须要求两个输入f, k以调用希望的f(k - 1)，那么进行修改，仍然认为f(k)是我们需要的递归函数，但是需要两个输入，增加假定f(f, k)也是我们需要的阶乘函数</p> <p>(lambda f: (lambda k: f(f, k)))--(lambda f, k: 1 if k == 0 else k * f(f, k - 1))</p> <p>仍然是信仰之跃！</p>","path":["Week 4"],"tags":[]},{"location":"CS61A/Week%205/","level":1,"title":"Week 5","text":"","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#summary","level":2,"title":"Summary","text":"<p>大概需要5h，不包括完成Project的时间，终于进入了Python比较核心的部分，有了Lists, Slicing, Container等概念，发现软件老师使用的例子与61A的例子一模一样.</p> <p>总的来说，抽象化的教学还是有益的，虽然前期进展的很慢，但是培养了比较良好的习惯，比如Absraction Barriers方便后续维护的这种意识.</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#videos2h","level":2,"title":"Videos(2h)","text":"","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#sequences","level":3,"title":"Sequences","text":"","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#lists","level":4,"title":"Lists","text":"<p>Note that the begining index is 0 not 1, and elements of lists can be various </p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#containers","level":4,"title":"Containers","text":"","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#for-statements","level":4,"title":"For Statements","text":"<pre><code>&gt;&gt;&gt; range(-2, 2)\n-2 -1 0 1 \n&gt;&gt;&gt; range(4)\n&gt;&gt;&gt; 0 1 2 3\n</code></pre>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#list-comprehensions","level":4,"title":"List Comprehensions","text":"<pre><code>&gt;&gt;&gt; odds = [1, 3, 5, 7, 9]\n&gt;&gt;&gt; [x + 1 for x in odds]\n[2, 4, 6, 8, 10]\n&gt;&gt;&gt; [x for x in odds if 25 % x == 0]\n[1, 5]\n</code></pre> <pre><code>def divisions(n):\n    return [1] + [x for x in range(2, n) if n % x == 0]\n</code></pre>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#lists-slices-recursion","level":4,"title":"Lists, Slices, &amp;Recursion","text":"<pre><code># Recursion examples: sum\ndef sum_list(s):\n    if len(s) == 0:\n        return 0\n    else:\n        return s[0] + sum_list(s[1:])\n</code></pre> <p>A case more complex but can be done.</p> <pre><code>def large(s, n):\n    \"\"\"return the sublist of positive numbers s with the \n    largest sum that is less than or equal to n\"\"\"\n    if s == []:\n        return []\n    elif s[0] &gt; n:\n        return large(s[1:], n)\n    else:\n        first = s[0]\n        with_s0 = [first] + large(s[1:], n - first)\n        without_s0 = large(s[1:], n)\n        if sum_list(with_s0) &gt; sum_list(without_s0):\n            return with_s0\n        else:\n            return without_s0\n</code></pre> <p>Remark: Like conditional probability trick used in probability theory, we get complex situation easier by make proper condition or division events.</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#containers_1","level":3,"title":"Containers","text":"","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#box-and-pointer-notation","level":4,"title":"Box-and-Pointer Notation","text":"<p>Just a way like environmental diagram to explain the list operations.</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#slicing","level":4,"title":"Slicing","text":"<p>Very important skill used in python and we can see some cases:</p> <pre><code>&gt;&gt;&gt; odds = [3, 5, 7, 9, 11]\n&gt;&gt;&gt; odds[1:3]\n[5, 7]\n</code></pre>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#processing-container-values","level":4,"title":"Processing Container Values","text":"<p>sum, max and all function, and these functions can be found in R also.</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#strings","level":4,"title":"Strings","text":"<p>The native data type for text in Python is called a string, and corresponds to the constructor str.</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#dictionaries","level":4,"title":"Dictionaries","text":"<p>mentioned unhashable(leave for 61b)</p> <pre><code>{&lt;key exp&gt;: &lt;value exp&gt; for &lt;name&gt; in &lt;iter exp&gt; if &lt;filter exp&gt;}\n{x * x: x for x in [1, 2, 3, 4, 5] if x &gt; 2} evaluates to {9: 3, 16: 4, 25: 5}\n</code></pre>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#data-abstraction","level":3,"title":"Data Abstraction","text":"","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#data-abstraction_1","level":4,"title":"Data Abstraction","text":"<p>Isolate two parts of data</p> <ul> <li>How data are represented</li> <li>How data are manipulated</li> </ul>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#representing-rational-numbers","level":4,"title":"Representing Rational Numbers","text":"<pre><code> pair = [1, 2]\n x, y = pair\n &gt;&gt;&gt;x\n 1\n &gt;&gt;&gt;y\n 2\n&gt;&gt; &gt;get item(pair, 0)\n1\n</code></pre> <p>We have two ways to access the elements of list.</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#abstraction-barriers","level":4,"title":"Abstraction Barriers","text":"","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#data-representations","level":4,"title":"Data Representations","text":"<p>You can read Ch. 2.2 for more info about abstraction barriers.</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#reading2h","level":2,"title":"Reading(2h)","text":"<p>Chapter 2: Building Abstractions with Data + 2.1   Introduction + 2.2   Data Abstraction + 2.3   Sequences</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#ch-21","level":3,"title":"Ch. 2.1","text":"<p>This chapter focuses on data. The techniques we investigate here will allow us to represent and manipulate information about many different domains. Due to the explosive growth of the Internet, a vast amount of structured information is freely available to all of us online, and computation can be applied to a vast range of different problems. Effective use of built-in and user-defined data types are fundamental to data processing applications.</p> <p>Native data types have the following properties:</p> <ol> <li>There are expressions that evaluate to values of native types, called literals.</li> <li>There are built-in functions and operators to manipulate values of native types.</li> </ol> <p>Python includes three native numeric types: integers (int), real numbers (float), and complex numbers (complex).</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#ch-22","level":3,"title":"Ch. 2.2","text":"<p>We are using here a powerful strategy for designing programs: wishful thinking. We haven't yet said how a rational number is represented, or how the functions numer, denom, and rational should be implemented. Even so, if we did define these three functions, we could then add, multiply, print, and test equality of rational numbers:</p> <p>These functions are called by a higher level and implemented using a lower level of abstraction.</p> <p>The fewer functions that depend on a particular representation, the fewer changes are required when one wants to change that representation.</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#ch-23","level":3,"title":"Ch. 2.3","text":"<p>Python includes several native data types that are sequences, the most important of which is the list.</p> <p>For sequences, addition and multiplication do not add or multiply elements, but instead combine and replicate the sequences themselves.</p> <p>This pattern of binding multiple names to multiple values in a fixed-length sequence is called sequence unpacking; it is the same pattern that we see in assignment statements that bind multiple names to multiple values.</p> <pre><code>for x, y in pairs:\n    if x == y:\n        same_count = same_count + 1\n</code></pre>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#lab-0330min","level":2,"title":"Lab 03(30min)","text":"<p>Very Trivial</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#lists_1","level":3,"title":"Lists","text":"","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#q1-wwpd-lists-ranges","level":4,"title":"Q1: WWPD: Lists &amp; Ranges","text":"","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#q2-print-if","level":4,"title":"Q2: Print If","text":"","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#q3-close","level":4,"title":"Q3: Close","text":"","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#list-comprehensions_1","level":3,"title":"List Comprehensions","text":"","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#q4-wwpd-list-comprehensions","level":4,"title":"Q4: WWPD: List Comprehensions","text":"","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#q5-close-list","level":4,"title":"Q5: Close List","text":"","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#q6-squares-only","level":4,"title":"Q6: Squares Only","text":"<p>注意取整的问题</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#recursion","level":3,"title":"Recursion","text":"","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#q7-double-eights","level":4,"title":"Q7: Double Eights","text":"<p>那个答案写的怪怪的，感觉还没我写的好</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#q8-making-onions","level":4,"title":"Q8: Making Onions","text":"<p>也很简单，真的很像概率论的构造技巧</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#disc-0430min","level":2,"title":"Disc 04(30min)","text":"<p>Recursion takes practice. Please don't get discouraged if you're struggling to write recursive functions. Instead, every time you do solve one (even with help or in a group), make note of what you had to realize to make progress. Students improve through practice and reflection.</p> <p>Tree Recursion</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#q1-insect-combinatorics","level":3,"title":"Q1: Insect Combinatorics","text":"<pre><code>def paths(m, n):  \n    \"\"\"Return the number of paths from one corner of an  \n    M by N grid to the opposite corner.  \n    &gt;&gt;&gt; paths(2, 2)  \n    2    &gt;&gt;&gt; paths(5, 7)  \n    210    &gt;&gt;&gt; paths(117, 1)  \n    1    &gt;&gt;&gt; paths(1, 157)  \n    1    \"\"\"    if m == 1 or n == 1:  \n        return 1  \n    else:  \n        return paths(m-1, n) + paths(m, n-1)\n</code></pre> <p>Tree Recursion with Lists</p> <p>The most important thing to remember about lists is that a non-empty list <code>s</code> can be split into its first element <code>s[0]</code> and the rest of the list <code>s[1:]</code>.</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#q2-max-product","level":3,"title":"Q2: Max Product","text":"<pre><code>def max_product(s):  \n    \"\"\"Return the maximum product of non-consecutive elements of s.  \n\n    &gt;&gt;&gt; max_product([10, 3, 1, 9, 2])   # 10 * 9  \n    90    &gt;&gt;&gt; max_product([5, 10, 5, 10, 5])  # 5 * 5 * 5  \n    125    &gt;&gt;&gt; max_product([])                 # The product of no numbers is 1  \n    1    # 下面是自己写的测试  \n    &gt;&gt;&gt; max_product([2])  \n    2    \"\"\"    if len(s) == 0:  \n        return 1  \n    else:  \n        return max(s[0] * max_product(s[2:]), max_product(s[1:]))\n</code></pre>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%205/#q3-sum-fun","level":3,"title":"Q3: Sum Fun","text":"<pre><code>def sums(n, m):  \n    \"\"\"Return lists that sum to n containing positive numbers up to m that  \n    have no adjacent repeats.  \n    &gt;&gt;&gt; sums(5, 1)  \n    []    &gt;&gt;&gt; sums(5, 2)  \n    [[2, 1, 2]]    &gt;&gt;&gt; sums(5, 3)  \n    [[1, 3, 1], [2, 1, 2], [2, 3], [3, 2]]    &gt;&gt;&gt; sums(5, 5)  \n    [[1, 3, 1], [1, 4], [2, 1, 2], [2, 3], [3, 2], [4, 1], [5]]    &gt;&gt;&gt; sums(6, 3)  \n    [[1, 2, 1, 2], [1, 2, 3], [1, 3, 2], [2, 1, 2, 1], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]    \"\"\"    if n &lt; 0:  \n        return []  \n    if n == 0:  \n        sums_to_zero = []     # The only way to sum to zero using positives  \n        return [sums_to_zero] # Return a list of all the ways to sum to zero  \n    result = []  \n    for k in range(1, m + 1):  \n        result = result + [[k] + rest for rest in sums(n-k, m) if rest == [] or rest[0] != k ]  \n    return result\n</code></pre> <p>Remark: Slicing操作简直是为Recursion准备的，非常好用!</p>","path":["Week 5"],"tags":[]},{"location":"CS61A/Week%206/","level":1,"title":"Week 6","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#summary","level":2,"title":"Summary","text":"<p>大概需要六小时</p> <p>本节总的来说出现了两个基本且重要的数据结构就是链表和树，从递归算法上说是自然的，还有Mutable Data这一在Python中非常重要的事情的讲述，很感动的是老师通过讲述A History Stroy去说明了这件事情，感觉正常学习过Python的人都会对这个部分有很深的共鸣，因为期末考老是喜欢考啊(doge)。</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#lab-0430min","level":2,"title":"Lab 04(30min)","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#dictionaries","level":3,"title":"Dictionaries","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#q1-dictionaries","level":4,"title":"Q1: Dictionaries","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#q2-divide","level":4,"title":"Q2: Divide","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#q3-buying-fruit","level":4,"title":"Q3: Buying Fruit","text":"<p>经典买菜题</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#data-abstraction","level":3,"title":"Data Abstraction","text":"<p>A data abstraction is a set of functions that compose and decompose compound values. One function called the constructor puts together two or more parts into a whole (such as a rational number; also known as a fraction), and other functions called selectors return parts of that whole (such as the numerator or denominator).</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#q4-distance","level":4,"title":"Q4: Distance","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#q5-closer-city","level":4,"title":"Q5: Closer City","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#q6-dont-violate-the-abstraction-barrier","level":4,"title":"Q6: Don't violate the abstraction barrier!","text":"<p>所谓数据抽象，抽象屏障(Abstraction Barrier)就好像递归中的信仰之跃，我们初始时不关心函数的实现细节只是使用构造的函数进行操作，只要写的代码有合适的屏障，只需要更改上游部分下游自然会发生变化.实际上就是通过函数来承载抽象的功能，所操作和修改的对象也只是函数而不是具体的values.</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#reading2h30min","level":2,"title":"Reading(2h30min)","text":"<p>Chapter 2: Building Abstractions with Data + 2.3   Sequences + 2.4   Mutable Data</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#ch-23","level":3,"title":"Ch. 2.3","text":"<p>A tree has a root label and a sequence of branches. Each branch of a tree is a tree. A tree with no branches is called a leaf. Any tree contained within a tree is called a sub-tree of that tree (such as a branch of a branch). The root of each sub-tree of a tree is called a node in that tree.</p> <p>树是一种非常基本的数据结构，这里只是做了简单的阐述，如果想要深入的了解树、二叉树、甚至线段树、红黑树最好还是学一下数据结构然后去手搓一些算法题.树本身就蕴含着recursion的思想，包括遍历的思想，学会用树应当是递归能力的一个提高节点.</p> <p>树这种东西在图论里面经常用，所以如果有OI训练的话确实有利于组合题能力提高...</p> <p>为了方便起见，再这里将所有的数据抽象列出</p> <pre><code># 基本的树抽象，要求root的值和分支也是树\ndef tree(root_label, branches=[]):\n        for branch in branches:\n            assert is_tree(branch), 'branches must be trees'\n        return [root_label] + list(branches)\n\n# 返回根节点的值\n def label(tree):\n    return tree[0]\n# 返回分支树\ndef branches(tree):\n        return tree[1:]\n\ndef is_tree(tree):\n        if type(tree) != list or len(tree) &lt; 1:\n            return False\n        for branch in branches(tree):\n            if not is_tree(branch):\n                return False\n        return True\ndef is_leaf(tree):\n        return not branches(tree)\n</code></pre> <p>然后开始了基本的链表，又是一个基本的数据结构</p> <p>However, we can also develop sequence representations that are not built into Python. A common representation of a sequence constructed from nested pairs is called a linked list.</p> <p></p> <p>Linked lists have recursive structure: the rest of a linked list is a linked list or 'empty'. We can define an abstract data representation to validate, construct, and select the components of linked lists.</p> <p>链表的第二位存储下一个链表的位置，显然也是一种递归的结构</p> <p>Recursive Construction. Linked lists are particularly useful when constructing sequences incrementally, a situation that arises often in recursive computations.</p> <p>Reference:</p> <p>洛谷-B3631单向链表</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#ch-24","level":3,"title":"Ch. 2.4","text":"<p>One powerful technique for creating modular programs is to incorporate data that may change state over time. In this way, a single data object can represent something that evolves independently of the rest of the program. The behavior of a changing object may be influenced by its history, just like an entity in the world. Adding state to data is a central ingredient of a paradigm called object-oriented programming.</p> <p>主要讲述了Python中Non local的一些问题，关于值的绑定(Non-Local Assignment)等等，尤其是Non local函数的好处进行了一些讲解</p> <p>也讲解了一些基本的编程范式，可能需要对后面的OOP进行深入学习之后会有更深的理解.</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#videos1h30min","level":2,"title":"Videos(1h30min)","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#trees","level":3,"title":"Trees","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#trees_1","level":4,"title":"Trees","text":"<p>terminologies:</p> <ul> <li>root label</li> <li>branch(each branch is a tree)</li> </ul> <p>tree is a abstraction not a representation</p> <pre><code>def tree(label, branches= []):\n    for branch in branches:\n        assert is_tree(branch)\n    return [label] + list(branches)\ndef label(tree):\n    return tree[0]\ndef branches(tree):\n    return tree[1]\n</code></pre>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#tree-processing","level":4,"title":"Tree Processing","text":"<p>sum function doesn't remove any structures.</p> <pre><code>def leaves(tree):\nif is_leaf(tree):\n    return [label(tree)]\nelse:\n    return sum([leaves(b) for b in branches(tree)], [])\n</code></pre>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#example-printing-trees","level":4,"title":"Example: Printing Trees","text":"<pre><code>def print_tree(t, indent = 0):\n    print(' ' * indent + str(label(t)))\n    for b in branches(t):\n        print_tree(b, indent+1)\n</code></pre>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#example-summing-paths","level":4,"title":"Example: Summing Paths","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#example-counting-paths","level":4,"title":"Example Counting Paths","text":"<pre><code>def count_paths(t, total):\n    if label(t) == total:\n        found = 1\n    else:\n        found = 0\n    return found + sum([count_paths(b, total - label(t)) for b in branches(t)])\n</code></pre>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#mutability","level":3,"title":"Mutability","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#objects","level":4,"title":"Objects","text":"<p>Talked about basic concepts and OOP in Python.</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#example-strings","level":4,"title":"Example: Strings","text":"<p>Show what is the Mutable Data and its usage.</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#mutation-operations","level":4,"title":"Mutation Operations","text":"<p>some examples and questions.</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#tuples","level":4,"title":"Tuples","text":"<p>Give a tuple type to show the not mutable data in python.</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#mutation","level":4,"title":"Mutation","text":"<p>Core concepts.</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#mutable-functions","level":4,"title":"Mutable Functions","text":"<p>A good application in functions used mutation.</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#disc-0530min","level":2,"title":"Disc 05(30min)","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#q1-warm-up","level":3,"title":"Q1: Warm Up","text":"<p>简单的练习</p> <p>Answer = 6</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#q2-has-path","level":3,"title":"Q2: Has Path","text":"<pre><code>def has_path(t, p):\n    \"\"\"Return whether tree t has a path from the root with labels p.\n\n    &gt;&gt;&gt; t2 = tree(5, [tree(6), tree(7)])\n    &gt;&gt;&gt; t1 = tree(3, [tree(4), t2])\n    &gt;&gt;&gt; has_path(t1, [5, 6])        # This path is not from the root of t1\n    False\n    &gt;&gt;&gt; has_path(t2, [5, 6])        # This path is from the root of t2\n    True\n    &gt;&gt;&gt; has_path(t1, [3, 5])        # This path does not go to a leaf, but that's ok\n    True\n    &gt;&gt;&gt; has_path(t1, [3, 5, 6])     # This path goes to a leaf\n    True\n    &gt;&gt;&gt; has_path(t1, [3, 4, 5, 6])  # There is no path with these labels\n    False\n    \"\"\"\n    if p == [label(t)]:  # when len(p) is 1\n        return True\n    elif label(t) != p[0]:\n        return False\n    else:\n        for b in branches(t): \n            if has_path(b, p[1:]):\n                 return True \n        return False\n</code></pre>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#q3-find-path","level":3,"title":"Q3: Find Path","text":"<pre><code>def find_path(t, x):\n    \"\"\"\n    &gt;&gt;&gt; t2 = tree(5, [tree(6), tree(7)])\n    &gt;&gt;&gt; t1 = tree(3, [tree(4), t2])\n    &gt;&gt;&gt; find_path(t1, 5)\n    [3, 5]\n    &gt;&gt;&gt; find_path(t1, 4)\n    [3, 4]\n    &gt;&gt;&gt; find_path(t1, 6)\n    [3, 5, 6]\n    &gt;&gt;&gt; find_path(t2, 6)\n    [5, 6]\n    &gt;&gt;&gt; print(find_path(t1, 2))\n    None\n    \"\"\"\n    if label(t) == x:\n        return [label(t)]\n    for b in branches(t):\n        path = find_path(b, x)\n        if path:\n            return [label(t)] + path\n    return None\n</code></pre>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#hw041h","level":2,"title":"HW04(1h)","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#sequences","level":3,"title":"Sequences","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#q1-deep-map","level":4,"title":"Q1: Deep Map","text":"<p>原地修改(in-place modification)，不需要返回值return value</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#data-abstraction_1","level":3,"title":"Data Abstraction","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#q2-mass","level":4,"title":"Q2: Mass","text":"<p>不知道有什么作用，感觉只是为了确认你的理解，但是又感觉有点多余了，不如让实现total_mass function</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#q3-balanced","level":4,"title":"Q3: Balanced","text":"<p>由定义可知：</p> <ul> <li>左右臂力矩相等</li> <li>左右臂子系统Balanced -&gt; Recursion</li> </ul> <p>利用Data Abstraction即可，然后需要注意判断尾端planet情况(函数调用要求对象为mobile所以planet会报错)</p>","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#trees_2","level":3,"title":"Trees","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%206/#q4-maximum-path-sum","level":4,"title":"Q4: Maximum Path Sum","text":"","path":["Week 6"],"tags":[]},{"location":"CS61A/Week%207/","level":1,"title":"Week 7","text":"","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#summary","level":2,"title":"Summary","text":"<p>大致需要4h的时间完成，该Week任务量不大，题目也比较简单，主要是刚入门OOP，掌握OOP的设计思想和理念即可</p> <p>OOP的设计理念核心是==通过将现实世界的实体抽象为具有数据（属性）和操作（方法）的对象来构建软件系统，并利用类、封装、继承、多态等概念来模拟现实世界的逻辑，从而达到代码的模块化、可重用性、灵活性和可维护性==。它强调将数据和行为绑定在一起，并允许对象通过消息传递来相互通信，以构建复杂且易于扩展的系统。</p> <p>OOP主要有以下核心理念与概念：</p> <ul> <li>Object</li> <li>Class</li> <li>Encapsulation</li> <li>Inheritance</li> <li>Polymorphism</li> <li>Message Passing</li> </ul> <p>值得一提的是末尾附带了往年期末考试的相关试题，明显可以看出知识共享的普及(难度倒是不高)，对比神秘打印店和祖传资料高级了不少</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#reading2h","level":2,"title":"Reading(2h)","text":"<p>Chapter 4: Data Processing + 4.2 Implicit Sequences</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#ch42","level":3,"title":"Ch.4.2","text":"<p>A sequence can be represented without each element being stored explicitly in the memory of the computer. That is, we can construct an object that provides access to all of the elements of some sequential dataset without computing the value of each element in advance. Instead, we compute elements on demand.</p> <p>We want to achive the lazy computation in cs.</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#iterators","level":4,"title":"Iterators","text":"<p>Python and many other programming languages provide a unified way to process elements of a container value sequentially, called an iterator. An iterator is an object that provides sequential access to values, one by one.</p> <p>for example</p> <pre><code>r = range(3,13)\ns = iter(r)\nnext(s)\nt = iter(r) # not the same as s\nu = t\n# u and t have the same iterator\n</code></pre> <p>The usefulness of iterators is derived from the fact that the underlying series of data for an iterator may not be represented explicitly in memory. An iterator provides a mechanism for considering each of a series of values in turn, but all of those elements do not need to be stored simultaneously. Instead, when the next element is requested from an iterator, that element may be computed on demand instead of being retrieved from an existing memory source.</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#iterables","level":4,"title":"Iterables","text":"<p>Any value that can produce iterators is called an iterable value.</p> <p>Even unordered collections such as dictionaries must define an ordering over their contents when they produce iterators. Dictionaries and sets are unordered because the programmer has no control over the order of iteration, but Python does guarantee certain properties about their order in its specification.</p> <p>If a dictionary changes in structure because a key is added or removed, then all iterators become invalid.</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#built-in-iterators","level":4,"title":"Built-in Iterators","text":"<p>Just know about map function and filter, zip, reversed</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#for-statements","level":4,"title":"For Statements","text":"<pre><code>for &lt;name&gt; in &lt;expression&gt;:\n    &lt;suite&gt;\n</code></pre> <pre><code>counts = [1, 2, 3]\nitems = counts.__iter__()\ntry:\n    while True:\n        item = items.__next__()\n        print(item)\n    except StopIteration:\n        pass\n</code></pre> <p>Python 文档中的迭代器类型章节建议迭代器应具有一个返回迭代器本身的<code>__iter__</code>方法，因此所有迭代器都是可迭代的</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#generators-and-yield-statements","level":4,"title":"Generators and Yield Statements","text":"<p>A generator is an iterator returned by a special class of function called a generator function.</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#iterable-interface","level":4,"title":"Iterable Interface","text":"","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#creating-iterables-with-yield","level":4,"title":"Creating Iterables with Yield","text":"<p>for example</p> <pre><code>def all_pairs(s):\n    for item1 in s:\n        for item2 in s:\n            yield(item1, item2)\n\nlist(all_pairs([1, 2, 3]))\n&gt;&gt;&gt; [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]\n</code></pre>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#iterator-interface","level":4,"title":"Iterator Interface","text":"","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#streams","level":4,"title":"Streams","text":"<p>To Do(至25Fall该处仍然为空)</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#python-streams","level":4,"title":"Python Streams","text":"<p>SICP中叙述的有点抽象，我建议阅读官方的文档</p> <p>Chapter 2: Building Abstractions with Data + Ch.2.5 Object-Oriented Programming</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#ch25","level":3,"title":"Ch.2.5","text":"","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#objects-and-classes","level":4,"title":"Objects and Classes","text":"<p>A class serves as a template for all objects whose type is that class. Every object is an instance of some particular class.</p> <p>The attributes specific to a particular object, as opposed to all objects of a class, are called instance attributes</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#defining-classes","level":4,"title":"Defining Classes","text":"<p>You should know the example about bank and how to define your own classes in different situations.</p> <p>The function value that is created by a def statement within a class statement is bound to the declared name, but bound locally within the class as an attribute. That value is invoked as a method using dot notation from an instance of the class.</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#message-passing-and-dot-expressions","level":4,"title":"Message Passing and Dot Expressions","text":"<p>The built-in function getattr also returns an attribute for an object by name. It is the function equivalent of dot notation. Using getattr, we can look up an attribute using a string, just as we did with a dispatch dictionary.</p> <pre><code>getattr(spock_account, 'balanced')\n</code></pre> <p>We can also test whether an object has a named attribute with hasattr.</p> <pre><code>hasattr(spock_account, 'deposit')\n</code></pre> <p>Naming Conventions. Class names are conventionally written using the CapWords convention (also called CamelCase because the capital letters in the middle of a name look like humps). Method names follow the standard convention of naming functions using lowercased words separated by underscores.</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#class-attributes","level":4,"title":"Class Attributes","text":"<p>Some attribute values are shared across all objects of a given class. Such attributes are associated with the class itself, rather than any individual instance of the class.</p> <pre><code>class Account:\n    interest = 0.02 # A class attribute\n    def __init__(self, account_holder):\n        self.balance = 0\n        self.holder = account_holder\n    # Additional methods would be defined here\n</code></pre> <p>To evaluate a dot expression:</p> <ol> <li>Evaluate the <code>&lt;expression&gt;</code> to the left of the dot, which yields the object of the dot expression.</li> <li><code>&lt;name&gt;</code> is matched against the instance attributes of that object; if an attribute with that name exists, its value is returned.</li> <li>If <code>&lt;name&gt;</code> does not appear among instance attributes, then <code>&lt;name&gt;</code> is looked up in the class, which yields a class attribute value.</li> <li>That value is returned unless it is a function, in which case a bound method is returned instead.</li> </ol> <p>Changes to the class attribute interest will affect spock_account, but the instance attribute for kirk_account will be unaffected.</p> <p>In this evaluation procedure, instance attributes are found before class attributes, just as local names have priority over global in an environment.</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#inheritance","level":4,"title":"Inheritance","text":"<p>A subclass inherits the attributes of its base class, but may override certain attributes, including certain methods. With inheritance, we only specify what is different between the subclass and the base class. Anything that we leave unspecified in the subclass is automatically assumed to behave just as it would for the base class.</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#using-inheritance","level":4,"title":"Using Inheritance","text":"<p>We can define this procedure recursively. To look up a name in a class.</p> <ol> <li>If it names an attribute in the class, return the attribute value.</li> <li>Otherwise, look up the name in the base class, if there is one.</li> </ol> <p>Interfaces. It is extremely common in object-oriented programs that different types of objects will share the same attribute names. An object interface is a collection of attributes and conditions on those attributes. For example, all accounts must have deposit and withdraw methods that take numerical arguments, as well as a balance attribute. The classes Account and CheckingAccount both implement this interface. Inheritance specifically promotes name sharing in this way. In some programming languages such as Java, interface implementations must be explicitly declared. In others such as Python, Ruby, and Go, any object with the appropriate names implements an interface.</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#multiple-inheritance","level":4,"title":"Multiple Inheritance","text":"<p>Python supports the concept of a subclass inheriting attributes from multiple base classes, a language feature called multiple inheritance.</p> <p>Further reading. Python resolves this name using a recursive algorithm called the C3 Method Resolution Ordering. The method resolution order of any class can be queried using the mro method on all classes.</p> <pre><code>[c.__name__ for c in AsSeenOnTVAccount.mro()]\n</code></pre>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#the-role-of-objects","level":4,"title":"The Role of Objects","text":"<p>Abstraction barriers enforce the boundaries between different aspects of a large program.</p> <p>Object-oriented programming is particularly well-suited to programs that model systems that have separate but interacting parts.</p> <p>Learning to identify when to introduce a new class, as opposed to a new function, in order to simplify or modularize a program, is an important design skill in software engineering that deserves careful attention.</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#videos30min","level":2,"title":"Videos(30min)","text":"","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#iterators_1","level":3,"title":"Iterators","text":"<p>复述课本</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#generators","level":3,"title":"Generators","text":"<p>复述课本</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#objects","level":3,"title":"Objects","text":"<p>简单介绍了OOP编程的基本概念和结构，建议去看textbook写的比较详细</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#lab-0530min","level":2,"title":"Lab 05(30min)","text":"","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#mutability","level":3,"title":"Mutability","text":"","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#q1-wwpd-list-mutation","level":4,"title":"Q1: WWPD: List-Mutation","text":"<pre><code># 一个有趣的问题\n# 已知s = [3, 4, 5]\n&gt;&gt;&gt; s.extend([s.append(9), s.append(10)])  \n&gt;&gt;&gt; s  \n[3, 4, 5, 9, 10, None, None]\n</code></pre>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#q2-insert-items","level":4,"title":"Q2: Insert Items","text":"<p>很容易，只需要记得如果满足条件使指针向前挪动，否则<code>before == after</code>时会发生死循环</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#q3-group-by","level":4,"title":"Q3: Group By","text":"<p>如果对于SQL熟悉的话，这就相当于复现聚集函数了</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#iterators_2","level":3,"title":"Iterators","text":"","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#q4-wwpd-iterators","level":4,"title":"Q4: WWPD: Iterators","text":"","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#q5-count-occurrences","level":4,"title":"Q5: Count Occurrences","text":"","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#q6-repeated","level":4,"title":"Q6: Repeated","text":"<p>都比较容易</p> <p>Q7: Sprout Leaves</p> <p>利用树的数据抽象即可</p> <p>Q8: Partial Reverse</p> <p>比较容易</p>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#disc-0630min","level":2,"title":"Disc 06(30min)","text":"","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#generators_1","level":3,"title":"Generators","text":"<p>A generator is an iterator that is returned by calling a generator function, which is a function that contains yield statements instead of return statements</p> <p>Q1: Big Fib</p> <p>主要是要对几个内置函数有认识(相关的代码在Week 7文件夹中)</p> <p>such as map, filter, list, any, all, etc.</p> <pre><code>def gen_fib2():  \n    n, add = 0, 1  \n    while True:  \n        yield n  \n        n, add = n + add, n  \n\nnext(filter(lambda n : n &gt; 2024, gen_fib2()))\n</code></pre> <p>Q2: Something Different</p> <p>Q3： Partitions</p> <p>使用迭代器优化树结构的一个例子</p> <pre><code>def partition_gen(n, m):  \n    \"\"\"Yield the partitions of n using parts up to size m.  \n    &gt;&gt;&gt; for partition in sorted(partition_gen(6, 4)):    ...   print(partition)  \n    1 + 1 + 1 + 1 + 1 + 1    1 + 1 + 1 + 1 + 2    1 + 1 + 1 + 3    1 + 1 + 2 + 2    1 + 1 + 4    1 + 2 + 3    2 + 2 + 2    2 + 4    3 + 3    \"\"\"    assert n &gt; 0 and m &gt; 0  \n    if n == m:  \n        yield str(n)  \n    if n - m &gt; 0:  \n        for p in partition_gen(n - m, m):  \n            yield p + ' + ' + str(m)  \n    if m &gt; 1:  \n       yield from partition_gen(n, m - 1)\n</code></pre>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#hw0530min","level":2,"title":"HW05(30min)","text":"","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#q1-infinite-hailstone","level":3,"title":"Q1: Infinite Hailstone","text":"<p>练习yield from</p> <pre><code>def hailstone(n):  \n    \"\"\"Q1: Yields the elements of the hailstone sequence starting at n.  \n       At the end of the sequence, yield 1 infinitely.  \n    &gt;&gt;&gt; hail_gen = hailstone(10)    &gt;&gt;&gt; [next(hail_gen) for _ in range(10)]  \n    [10, 5, 16, 8, 4, 2, 1, 1, 1, 1]    &gt;&gt;&gt; next(hail_gen)  \n    1    \"\"\"    yield n  \n    if n == 1:  \n        yield from hailstone(n)  \n    if n % 2 == 1:  \n        yield from hailstone(n * 3 + 1)  \n    if n % 2 == 0:  \n        yield from hailstone(n // 2)\n</code></pre>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#q2-merge","level":3,"title":"Q2: Merge","text":"<pre><code>def merge(a, b):  \n    \"\"\"Q2:  \n    &gt;&gt;&gt; def sequence(start, step):    ...     while True:    ...         yield start    ...         start += step    &gt;&gt;&gt; a = sequence(2, 3) # 2, 5, 8, 11, 14, ...    &gt;&gt;&gt; b = sequence(3, 2) # 3, 5, 7, 9, 11, 13, 15, ...    &gt;&gt;&gt; result = merge(a, b) # 2, 3, 5, 7, 8, 9, 11, 13, 14, 15    &gt;&gt;&gt; [next(result) for _ in range(10)]  \n    [2, 3, 5, 7, 8, 9, 11, 13, 14, 15]    \"\"\"    next_a, next_b = next(a), next(b)  \n    while True:  \n        if next_a == next_b:  \n            yield next_a  \n            next_a, next_b = next(a), next(b)  \n        elif next_a &lt; next_b:  \n            yield next_a  \n            next_a = next(a)  \n        else:  \n            yield next_b  \n            next_b = next(b)\n</code></pre>","path":["Week 7"],"tags":[]},{"location":"CS61A/Week%207/#q3-yield-paths","level":3,"title":"Q3: Yield Paths","text":"<p>不知道为什么代码注释写的是Q4，合理怀疑之前还有一道题删除之后没有更改下一道题的注释</p> <pre><code>def yield_paths(t, value):  \n    \"\"\"Q4: Yields all possible paths from the root of t to a node with the label  \n    value as a list.  \n    &gt;&gt;&gt; t1 = tree(1, [tree(2, [tree(3), tree(4, [tree(6)]), tree(5)]), tree(5)])    &gt;&gt;&gt; print_tree(t1)  \n    1      2        3        4          6        5      5    &gt;&gt;&gt; next(yield_paths(t1, 6))  \n    [1, 2, 4, 6]    &gt;&gt;&gt; path_to_5 = yield_paths(t1, 5)    &gt;&gt;&gt; sorted(list(path_to_5))  \n    [[1, 2, 5], [1, 5]]  \n    &gt;&gt;&gt; t2 = tree(0, [tree(2, [t1])])    &gt;&gt;&gt; print_tree(t2)  \n    0      2        1          2            3            4              6            5          5    &gt;&gt;&gt; path_to_2 = yield_paths(t2, 2)    &gt;&gt;&gt; sorted(list(path_to_2))  \n    [[0, 2], [0, 2, 1, 2]]    \"\"\"    if label(t) == value:  \n        yield [label(t)]  \n    for b in branches(t):  \n        for subpath in yield_paths(b, value):  \n            yield [label(t)] + subpath\n</code></pre>","path":["Week 7"],"tags":[]},{"location":"STAT260/","level":1,"title":"STAT260 2021","text":"<p>Website</p>","path":["STAT260","STAT260 2021"],"tags":[]},{"location":"WebSource/","level":1,"title":"TBA","text":"","path":["Web Source","TBA"],"tags":[]},{"location":"WebSource/%E5%85%8B%E6%9E%97%E7%B4%A2%E5%B0%94%E7%9A%84%E6%9C%80%E5%90%8E%E5%A4%8F%E5%A4%A9/","level":1,"title":"克林索尔的夏天","text":"","path":["Web Source","克林索尔的夏天"],"tags":["资源"]},{"location":"WebSource/%E5%85%8B%E6%9E%97%E7%B4%A2%E5%B0%94%E7%9A%84%E6%9C%80%E5%90%8E%E5%A4%8F%E5%A4%A9/#_2","level":2,"title":"趣闻","text":"<ul> <li>一个有意思的回答：被长得丑的女生喜欢<ul> <li>文笔极其细腻，过程也很有校园特色，真的很勇敢</li> </ul> </li> <li>大学牲看刚刚好</li> <li>中文系的青春小故事？</li> <li>大学要做的50件事清单</li> </ul>","path":["Web Source","克林索尔的夏天"],"tags":["资源"]},{"location":"WebSource/%E5%85%8B%E6%9E%97%E7%B4%A2%E5%B0%94%E7%9A%84%E6%9C%80%E5%90%8E%E5%A4%8F%E5%A4%A9/#_3","level":2,"title":"古灵精怪","text":"<ul> <li>地狱通信</li> <li>Zlibrary：很好用的电子书网站可以疯狂下PDF</li> <li>MCM/ICM：美赛官网</li> <li>樱花动漫：盗版的动漫网站，尽可能保证链接畅通</li> <li>fotor：免费在线图片尺寸修改</li> <li>EMOJI网站：官方的EMOJI网站</li> <li>ACG盒子：内含多个二次元相关的网站，是一个中转站</li> <li>教员的话</li> </ul>","path":["Web Source","克林索尔的夏天"],"tags":["资源"]},{"location":"WebSource/%E5%85%8B%E6%9E%97%E7%B4%A2%E5%B0%94%E7%9A%84%E6%9C%80%E5%90%8E%E5%A4%8F%E5%A4%A9/#50","level":2,"title":"我的大学50件事清单","text":"<ul> <li> 在图书馆学到闭馆  \\(\\color{blue}{不知道多少次了}\\)</li> <li> 结识学长/学姐或学弟/学妹，听取他们的意见，或者给予他们建议  \\(\\color{blue}{都有}\\)</li> <li> 加入一个社团  \\(\\color{blue}{自然博物社和组织部}\\)</li> <li> 学一个技能  \\(\\color{blue}{不止一个(\\LaTeX,markdown,Python,剪辑)}\\)</li> <li> 去别的专业蹭一次课  \\(\\color{blue}{转专业}\\)</li> <li> 转到数统专业 \\(\\color{blue}{已完成}\\)</li> <li> 主动表白一次 \\(\\color{blue}{不结婚}\\)</li> <li> 第一个到达早八的教室 \\(\\color{blue}{已完成}\\)</li> <li> 拿一次年级第一或奖学金 \\(\\color{blue}{一期年级第一 ,一次国家奖学金}\\)</li> <li> 出去打一次工，体验赚钱的不易 \\(\\color{blue}{已完成}\\)</li> <li> 每个学期至少看一本课外书 \\(\\color{blue}{已完成}\\)</li> <li> 走上讲台进行一次认真准备的pre \\(\\color{blue}{已完成}\\)</li> <li> 报名参加一次竞赛</li> <li> 给毕业后的自己写一封信</li> <li> 深度逛一次校园，用相机记录下校园的美景</li> <li> 尝试掌握一门计算机语言 \\(\\color{blue}{不止一门}\\)</li> <li> 参加一次社会实践/实习</li> <li> 六级达到550+</li> <li> 写一次日记，记录当天的趣事 \\(\\color{blue}{已完成}\\)</li> <li> 保持一周（月）不点外卖</li> <li> 尝试一个你喜欢的发型/发色</li> <li> 整蛊一次舍友 \\(\\color{blue}{已完成}\\)</li> <li> 收到or送出礼物 \\(\\color{blue}{已完成}\\)</li> <li> 动手做一个详细的旅游攻略</li> <li> 在图书馆借100本书</li> <li> 挑战一学期上课不迟到 \\(\\color{blue}{已完成}\\)</li> <li> 挑战一星期上课不碰手机</li> </ul>","path":["Web Source","克林索尔的夏天"],"tags":["资源"]},{"location":"WebSource/%E6%95%B0%E5%AD%A6%E4%B8%8E%E7%BB%9F%E8%AE%A1%E8%B5%84%E6%96%99%E7%AB%99/","level":1,"title":"数学(统计学)讲义收集","text":"","path":["Web Source","Notes Source","数学(统计学)讲义收集"],"tags":["资源"]},{"location":"WebSource/%E6%95%B0%E5%AD%A6%E4%B8%8E%E7%BB%9F%E8%AE%A1%E8%B5%84%E6%96%99%E7%AB%99/#_2","level":2,"title":"国内讲义","text":"<ul> <li>清华于品数学分析讲义</li> <li>USTC王作勤拓扑学讲义</li> <li>ZWP学长：NKU数院学长的个人网页，存放有很多专业课试卷，截至2025仍在更新</li> <li>谢启鸿老师(torsor)的个人博客：有很多高质量的复旦大学高等代数的资料(尤其是高等代数每周一题)</li> </ul>","path":["Web Source","Notes Source","数学(统计学)讲义收集"],"tags":["资源"]},{"location":"WebSource/%E6%95%B0%E5%AD%A6%E4%B8%8E%E7%BB%9F%E8%AE%A1%E8%B5%84%E6%96%99%E7%AB%99/#_3","level":2,"title":"国外讲义","text":"<ul> <li>Terence Tao：大名鼎鼎的特仑苏·陶的个人网页，纯英文，内涵很丰富</li> </ul>","path":["Web Source","Notes Source","数学(统计学)讲义收集"],"tags":["资源"]},{"location":"WebSource/%E6%95%B0%E5%AD%A6%E4%B8%8E%E7%BB%9F%E8%AE%A1%E8%B5%84%E6%96%99%E7%AB%99/#_4","level":2,"title":"杂文和资源站","text":"<ul> <li>名词党想要速通纯数学？| 资源整合篇<ul> <li>学习英语的重要性 提到了一本书The Little Book of Math into English(Springer)</li> <li>路线规划 目标是在 2~3 年内全面了解某个纯数学领域的基础，达到准研究生的水平<ul> <li>共通线: 数学分析 高等代数</li> <li>速通主线 大致有分析与方程、代数与数论、几何与拓扑(可以参考北美phd的qualify考试大纲)</li> <li>借鉴Oxford的数学系官网 </li> </ul> </li> <li>资源站<ul> <li>知乎 中文</li> <li>MSE/MO</li> <li>香蕉百科</li> <li>arXiv</li> <li>Vim+\\(\\LaTeX\\) 一篇blog</li> </ul> </li> </ul> </li> <li>ustcmathplan<ul> <li>由中科大的学长编写的资源整理文档，可以下载来看看：链接</li> </ul> </li> <li>雪王对自学数学一篇回答<ul> <li>文章主要对数学本科课程做了一个概括，也包含了作者本人的学习路径(偏代数)，内蕴了一些数学想法和看法，也有一些方法论</li> <li>主要是参考一个学习思路，但是没有办法做到如此大广度学习放弃深度</li> </ul> </li> <li>梁老师的一篇自述<ul> <li>是那种中年一代数学人有的坚守和执着，很受感动和鼓舞</li> </ul> </li> <li>Folland的一部分答案<ul> <li>已经下载了，可以作为一个资料贴</li> </ul> </li> <li>概率论中几种收敛的关系<ul> <li>写的比较好，可以参考答主的其他几个概率论笔记</li> </ul> </li> <li>计算数学的基础学习路线(NJU)<ul> <li>比较简陋的一个框架，但是亮点在于给出了数学与其他领域的交叉思路</li> </ul> </li> <li>清华一位学长的建议贴<ul> <li>这个也是代数和几何类的</li> </ul> </li> <li>Lecture_Notes'Set<ul> <li>MSE上的一个问题，涵盖了很多讲义，似乎几何类偏多(从知乎链接得到的)</li> </ul> </li> <li>关于数学的经验贴--异顺子 <ul> <li>答主的Gitee</li> <li>另一篇子文章：如何完整推导证明</li> </ul> </li> <li>随机分析路线<ul> <li>本人很感兴趣的一个方向，希望深入了解后学习</li> <li>另一个引导贴，比较深入,给出了进阶课程的参考书</li> </ul> </li> <li>Laplace方法-渐进分析<ul> <li>数学分析内容的一个很好应用，在很多竞赛题中有所体现</li> </ul> </li> <li>实分析的笔记(Royden)--inversioner</li> <li>Rudin的一篇生平文<ul> <li>没有什么作用，但是可以了解一些在分析学教材中屡屡出现的名字的故事</li> </ul> </li> <li>一个小书单,品味还可以,主要有概率论</li> <li>小平邦彦的一篇文章<ul> <li>文章主要观点是数学是一门依赖技术的学科，所以积累很重要(有时大于天赋)</li> </ul> </li> <li>关于给22级数学系新生的一点建议 UCAS</li> <li>PKUSMS-北大数学自学手册</li> <li>Math Stackexchange(MSE)：几乎是世界上最大的数学讨论平台(不考虑MO的情况下)，优点是跨度大</li> <li>Math Overflow(MO)：最权威的数学讨论平台，只接受发布研究生以上的问题讨论，否则会被警告</li> <li>丘赛官网：Yau的手笔，里面的参考资料值得一看，也有一些国外大学的网站链接</li> <li>MIT：内嵌许多优质课程的Lecure Notes和Problem Sets</li> <li>齐震宇：搬运的Youtube上的分析一，难度比较高，老师是湾湾的(Yau的学生)</li> <li>AMM：美国数学月刊，适合和谢惠民一起使用</li> </ul> <p>第一篇文章中有一段话我很欣赏</p> <p>无论是数学专业还是数学爱好者，在面对庞大的现代数学大厦面前难免踌躇。现代数学到底学些什么？在投入人生中最宝贵的几年时间之前，这就是第一个需要解答的问题。但这个问题没有标准答案，而是取决于更基本的问题——我为什么喜欢数学？我喜欢数学的什么？对数学的需求和动机将会决定你的学习内容。</p>","path":["Web Source","Notes Source","数学(统计学)讲义收集"],"tags":["资源"]},{"location":"WebSource/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%B5%84%E6%96%99%E7%AB%99/","level":1,"title":"计算机科学资料站","text":"","path":["Web Source","Notes Source","计算机科学资料站"],"tags":["资源"]},{"location":"WebSource/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%B5%84%E6%96%99%E7%AB%99/#_2","level":2,"title":"博客技术","text":"<ul> <li>Mkdocs部署的yml说明</li> <li>Hugo框架的搭建</li> <li>MKDOCS官方：本站采用的静态框架来源于这里</li> </ul>","path":["Web Source","Notes Source","计算机科学资料站"],"tags":["资源"]},{"location":"WebSource/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%B5%84%E6%96%99%E7%AB%99/#_3","level":2,"title":"数据科学","text":"<ul> <li>ML and DL这类统计学类数据科学甚至转cs的方法</li> <li>Kaggle入门</li> </ul>","path":["Web Source","Notes Source","计算机科学资料站"],"tags":["资源"]},{"location":"WebSource/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%B5%84%E6%96%99%E7%AB%99/#cs","level":2,"title":"CS资源站","text":"<ul> <li>CSDIY：一位北大学长写的CS(Computer Science)自学指南，主要是国外的公开课资源</li> <li>CS自学社区：一位前辈在CSDIY的基础上衍生出的帮助刷课的网站</li> <li>CS50x：Harvard的一门计算机导论公开课，课程质量很高，老师口音也很正常</li> <li>博客园：有上古的好帖子，普遍文章质量较C*S*D*N高许多</li> </ul>","path":["Web Source","Notes Source","计算机科学资料站"],"tags":["资源"]},{"location":"WebSource/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%B5%84%E6%96%99%E7%AB%99/#latex","level":2,"title":"LaTeX使用","text":"<ul> <li>LaTeX的Snippets设置</li> <li>LaTeX的一个简单模板(彩色底框填充)</li> <li>Tikz的使用<ul> <li>其实最好自己学习一下如何书写</li> </ul> </li> <li>SimpleTex-OCR<ul> <li>如果你实在懒得打可以使用这个OCR工具，网页端支持的扫描数量更大但是都会出现遇到高峰期需要排队的问题，因此如果有需要最好平常就在一些少人的时间将需要的资料识别好，笔者曾经多次在随机过程课上现场OCR老师的Notes有点手忙脚乱了.</li> </ul> </li> <li>国外小哥的Vim+LaTeX</li> <li>LaTeX在线编辑器：一个简单好用且免费的在线LaTeX编辑网站</li> <li>Texlive Tshinghua University：清华的镜像站，可以用来下载Texlive(如果网络不佳)</li> <li>tikzcd-editor：可以帮助绘制tikz</li> <li>Overleaf：一个多人协作的LaTeX在线编译网站，好处是免去了本地配环境，坏处是编译速度和内存受限</li> </ul>","path":["Web Source","Notes Source","计算机科学资料站"],"tags":["资源"]},{"location":"WebSource/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%B5%84%E6%96%99%E7%AB%99/#obsidian","level":2,"title":"Obsidian使用","text":"<ul> <li>Obsidian的使用--一位研究生</li> <li>一位学长使用Obsidian的心得</li> </ul>","path":["Web Source","Notes Source","计算机科学资料站"],"tags":["资源"]},{"location":"%E4%BB%A3%E6%95%B0%E5%AD%A6/","level":1,"title":"代数学总站","text":"","path":["代数学总站"],"tags":["Algebra"]},{"location":"%E4%BB%A3%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/","level":1,"title":"高等代数","text":"<p>一切内容均遵循均遵循 CC BY-SA 4.0 license.</p>","path":["高等代数"],"tags":["Algebra"]},{"location":"%E4%BB%A3%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%9E%8B/","level":1,"title":"二次型","text":"","path":["二次型"],"tags":[]},{"location":"%E4%BB%A3%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%9E%8B/#_2","level":2,"title":"预备知识","text":"<ul> <li> 配方法</li> <li> 对称阵的定义</li> <li> 矩阵的初等变换</li> </ul>","path":["二次型"],"tags":[]},{"location":"%E4%BB%A3%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%9E%8B/#_3","level":2,"title":"二次型的定义及其矩阵表示","text":"<p>[!NOTE] 二次型的定义 设\\(P\\)为一个数域，关于\\(x_{1},x_{2},\\dots,x_{n}\\)的二次齐次多项式 \\(f(x_{1},x_{2},\\dots,x_{n})=a_{11}x_{1}^{2}+2a_{12}x_{1}x_{2}+\\dots+a_{nn}x_{n}^{2}\\)，其中\\(a_{ij}\\in P\\)，那么多项式称为\\(P\\)上的一个\\(n\\)元二次型</p> <p>很自然的会有想对称书写的想法使结果更加的美观</p> \\[ X= \\begin{pmatrix} x_{1} \\\\ x_{2} \\\\ \\vdots \\\\ x_{n} \\end{pmatrix}, A= \\begin{pmatrix} a_{11} &amp; a_{12} &amp;\\dots &amp; a_{1n} \\\\ a_{21} &amp; a_{22} &amp;\\dots &amp; a_{2n} \\\\ \\vdots \\\\ a_{n1} &amp; a_{n2} &amp;\\dots &amp; a_{nn} \\end{pmatrix} \\] <p>一个二次型与它的矩阵相互唯一确定</p>","path":["二次型"],"tags":[]},{"location":"%E4%BB%A3%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%9E%8B/#_4","level":2,"title":"二次型的非退化线性变换与对称矩阵的合同变换","text":"<p>[!NOTE] 线性变换的定义</p> \\[ \\left\\{\\begin{matrix} x_{1}=c_{11}y_{1}  +c_{12}y_{2}+\\dots c_{1n}y_{n}, \\\\ x_{2}=c_{21}y_{1}  +c_{22}y_{2}+\\dots c_{2n}y_{n}, \\\\ \\vdots \\\\ x_{n}=c_{n1}y_{1}  +c_{n2}y_{2}+\\dots c_{nn}y_{n}, \\end{matrix}\\right.\\] <p>这称为\\(x_{1},x_{2},\\dots,x_{n}\\)到\\(y_{1},y_{2},\\dots,y_{n}\\)的一个线性变换，这记为\\(X=CY\\)</p> <p>所谓非退化就是变换的矩阵\\(C\\)是可逆的</p> <p>[!NOTE] 合同的定义 如果\\(A,B\\)是两个\\(n\\)阶方阵，存在\\(C\\)是\\(n\\)阶可逆矩阵，使得 $$ B=C'AC$$ 那么称\\(A,B\\)合同</p> <p>也就是说经过非退化的线性变换后，新二次型的矩阵和原本的矩阵是合同的</p> <p>那么我们的目标也明确了，我们将用非退化的线性变换把二次型简化，同时用合同变换把对称矩阵化为简单的矩阵</p>","path":["二次型"],"tags":[]},{"location":"%E4%BB%A3%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%9E%8B/#_5","level":2,"title":"二次型的标准形","text":"<p>[!Theorem] 定理4.1 任意二次型一定可以经过适当的非退化线性变换化为标准形(也就是新变量平方和的形式的二次型) $$ d_{1}y_{1}^{2}+d_{2}y_{2}^{2}+\\dots+d_{r}y_{r}^{2},r\\leq n $$</p> <p><code>Proof is easy</code></p> <p>但是这个过程还是比较复杂的，并不是特别清晰简洁，还是有必要看看</p> <p>需要知道如果没有二次项就需要自己做一个平方差的变换:</p> \\[ \\left\\{ \\begin{matrix} x_{1} &amp;=&amp;y_{1}+y_{2} \\\\ x_{2} &amp;=&amp;y_{1}-y_{2} \\\\ x_{3} &amp;=&amp;y_{3} \\end{matrix} \\right. \\] <p>再根据标准形是一个对角阵得到一个小定理</p> <p>[!NOTE] 定理4.2 任意一个对称矩阵都合同于一个对角矩阵，这个对角矩阵称为对称矩阵的标准形</p> <p>并且一个二次型的标准型不唯一，也就是系数不是唯一确定的，但是标准形中不为\\(0\\)的平方项的个数是唯一确定的称为二次型的秩</p>","path":["二次型"],"tags":[]},{"location":"%E4%BB%A3%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%9E%8B/#_6","level":2,"title":"二次型的规范形","text":"","path":["二次型"],"tags":[]},{"location":"%E4%BB%A3%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%9E%8B/#_7","level":3,"title":"复数域","text":"<p>[!NOTE] 定理5.1 任意一个复二次型都可以经过非退化线性变换化为 $$ z_{1}^{2}+z_{2}^{2}+\\dots+z_{r}^{2} $$ 称为复二次型的规范形，规范形是唯一的</p> <p><code>Proof</code></p> <p>先化成标准形，再利用复数域下任何数都可以开平方做一个非退化线性变换</p> <p>那么很容易得到一个推论就是任意一个复对称矩阵都合同于形如</p> \\[ \\begin{pmatrix} &amp;1 \\\\  &amp; &amp; \\ddots\\\\ &amp;  &amp; &amp;1 \\\\ &amp;  &amp; &amp; &amp;0 \\\\ &amp;  &amp; &amp; &amp; &amp;\\ddots\\\\  &amp;  &amp; &amp;  &amp; &amp;&amp;0 \\end{pmatrix} \\] <p>的对角矩阵，其中\\(1\\)的个数就等于这个矩阵的秩</p> <p>并且还有两个\\(n\\)阶复对称矩阵合同的充分必要条件就是它们秩相等</p>","path":["二次型"],"tags":[]},{"location":"%E4%BB%A3%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%9E%8B/#_8","level":3,"title":"实数域","text":"<p>也可以化为规范形，只不过无法做到全为\\(1,0\\)，但是实数域中的正数都可以开方</p> <p>因此原本的\\(0\\)将变为\\(-1，0\\)</p> \\[ \\begin{pmatrix} &amp;1 \\\\  &amp; &amp; \\ddots\\\\ &amp;  &amp; &amp;1 \\\\ &amp;  &amp; &amp; &amp;-1 \\\\ &amp;  &amp; &amp; &amp; &amp;\\ddots\\\\  &amp;  &amp; &amp;  &amp; &amp; &amp;0 \\end{pmatrix} \\] <p>并且可以证明这个规范形也是唯一的，这里的证明比较巧妙</p> <p>其中\\(\\pm 1\\)的个数和称为这个矩阵的秩，\\(1,-1\\)分别称为这个矩阵的正、负惯性指数，正、负惯性指数的差称为符号差</p> <p>[!question] 问题 把\\(n\\)阶实对称矩阵按合同关系分类，共分几类?</p> <p>Answer=\\(\\sum\\limits_{r=0}^{n}(r+1)= \\frac{(n+2)(n+1)}{2}\\)也就是按照秩先分类然后累加即可</p>","path":["二次型"],"tags":[]},{"location":"%E4%BB%A3%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%9E%8B/#_9","level":2,"title":"正定二次型","text":"<p>如果在\\(f(x_{1},x_{2},\\dots,x_{n})=a_{11}x_{1}^{2}+2a_{12}x_{1}x_{2}+\\dots+a_{nn}x_{n}^{2}\\)中任意取自变量值，得到的函数值始终为正，那么称为正定二次型，同时它的矩阵称为正定矩阵.</p> <p>因为标准形是否正定很好判断那么就可以考虑是否能用一个二次型的标准形是否正定来判断原本的二次型是否正定?也就是非退化线性变换是否保持二次型的正定性?</p> <p>可以证明如果是正定的，那么经过非退化的线性变换仍然保持正定性不变</p> <p>可以很快得到下面的定理</p>","path":["二次型"],"tags":[]},{"location":"%E4%BB%A3%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%9E%8B/#_10","level":3,"title":"判定定理","text":"<p>[!NOTE] 定理6.1 实二次型\\(f(x_{1},x_{2},\\dots,x_{n})\\)是正定二次型\\(\\iff\\)正惯性指数为\\(n\\)</p> <p>[!NOTE] 定理6.2 实对称矩阵是正定矩阵\\(\\iff\\)它与单位矩阵合同</p> <p>合同变换保持实对称矩阵的正定性不变</p> <p>[!NOTE] 定理6.3 实对称矩阵\\(A\\)是正定矩阵\\(\\iff\\)\\(\\exists D,A=D'D\\)</p> <p>那么可以得到正定矩阵的行列式一定大于零，但是行列式大于零的实对称矩阵不一定是正定矩阵</p> <p>[!NOTE] 定理6.4 实对称矩阵\\(A\\)是正定矩阵\\(\\iff\\)\\(A\\)的顺序主子式全部大于零</p> <p>很自然的推论有:</p> <p>[!NOTE] 定理6.4 \\(A\\)是正定矩阵\\(\\iff\\)\\(A\\)的所有主子式全部大于零</p>","path":["二次型"],"tags":[]},{"location":"%E4%BB%A3%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%9E%8B/#_11","level":3,"title":"性质","text":"<p>[!NOTE] 性质 若\\(A,B\\)都是\\(n\\times n\\)正定矩阵 1. \\(A^{T}\\)是正定矩阵 2. \\(A^{-1}\\)是正定矩阵 3. \\(A+B\\)是正定矩阵 4. \\(C=(c_{ij})_{n\\times n}=(a_{ij}b_{ij})_{n\\times n}\\)是正定矩阵 5. \\(AB\\)是否正定?</p> <p>可以根据正定给出半正定的判定定理和定理等价性，也就是不严格的不等号</p> <p>相反方向思考即可得到负定矩阵、半负定矩阵和不定矩阵的概念</p> <p>如果在\\(f(x_{1},x_{2},\\dots,x_{n})=a_{11}x_{1}^{2}+2a_{12}x_{1}x_{2}+\\dots+a_{nn}x_{n}^{2}\\)中任意取自变量值，得到的函数值始终为负，那么称为负定二次型，同时它的矩阵称为正定矩阵.</p>","path":["二次型"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/","level":1,"title":"CS50x","text":"","path":["CS50x"],"tags":["CS","CS50x","国外公开课"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/#welcome","level":2,"title":"Welcome","text":"<p>This is CS50, Harvard University’s introduction to the intellectual enterprises of computer science and the art of programming, for concentrators and non-concentrators alike, with or without prior programming experience. (Two thirds of CS50 students have never taken CS before.) This course teaches you how to solve problems, both with and without code, with an emphasis on correctness, design, and style. Topics include computational thinking, abstraction, algorithms, data structures, and computer science more generally. Problem sets inspired by the arts, humanities, social sciences, and sciences. More than teach you how to program in one language, this course teaches you how to program fundamentally and how to teach yourself new languages ultimately. The course starts with a traditional but omnipresent language called C that underlies today’s newer languages, via which you’ll learn not only about functions, variables, conditionals, loops, and more, but also about how computers themselves work underneath the hood, memory and all. The course then transitions to Python, a higher-level language that you’ll understand all the more because of C. Toward term’s end, the course introduces SQL, via which you can store data in databases, along with HTML, CSS, and JavaScript, via which you can create web and mobile apps alike. Course culminates in a final project.</p>","path":["CS50x"],"tags":["CS","CS50x","国外公开课"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/#workflow","level":2,"title":"Workflow","text":"<p>采用如下工作流：</p> <ol> <li>课程提供了相当丰富的Notes几乎可以自学(bushi)</li> <li>完全可以不做笔记认真听，因为确实难度不太大</li> <li>语言debuff在经过长时间听力后可以有好转</li> </ol>","path":["CS50x"],"tags":["CS","CS50x","国外公开课"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/#my-timeline-and-some-learning-tips","level":2,"title":"My Timeline and some learning tips","text":"","path":["CS50x"],"tags":["CS","CS50x","国外公开课"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/#before-learning","level":3,"title":"Before learning","text":"<ol> <li>You can search the csdiy.wiki to get first rough information.</li> <li>Reading the syllabus in the CS50x and get a concept of the workflow.</li> </ol> <p>[!todo] Week 0 Scratch  - [x] Finish Time: 2024.12.06   - [x] Video(2h)  - [x] Problem Set 0   Have a try in problem set (not make a project but know basic operations) - [x] Scratch website</p> <p>[!todo] Week 1 C - [x] Finish Time: 2025.1.10   - [x] Video(2h)  - [x] Problem Set 1   - [x]  Hello   - [x]  mario-more   - [x]  cash   - [x]  credit</p> <p>[!todo] Week 2 Arrays - [x] Finished Time: 2025.7.4   - [x] Video(2h)   - [x] Section(1h)   - [x] Shorts  - [x] Problem Set 2   - [x] Scrabble    - [x] Readability   - [x] Caesar    - [x] Substitution</p> <p>[!todo] Week 3  Algorithms - [x] Finished Time: 2025.7.4   - [x] Video(2h)   - [x] Section   - [x] Shorts  - [x] Problem Set 3</p> <p>[!todo] Week 4 Memory - [x] Finished Time: 2025.7.4   - [x] Video(2h)   - [x] Section   - [x] Shorts  - [x] Problem Set 4</p> <p>[!todo] Week 5 Data Structures - [x] Finished Time: 2025.7.4   - [x] Video(2h)   - [x] Section   - [x] Shorts  - [x] Problem Set 5</p>","path":["CS50x"],"tags":["CS","CS50x","国外公开课"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%200%20Scratch/","level":1,"title":"Week 0 Scratch","text":"","path":["Week 0 Scratch"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%200%20Scratch/#syllabus","level":2,"title":"Syllabus","text":"<p>Computer Science. Computational Thinking. Problem Solving: Inputs, Outputs. Representation: Unary, Binary, Decimal, ASCII, Unicode, RGB. Abstraction. Algorithms. Running Times. Pseudocode. Scratch: Functions, Arguments, Return Values; Variables; Boolean Expressions, Conditionals; Loops; Events; Threads.</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%200%20Scratch/#notes","level":2,"title":"Notes","text":"","path":["Week 0 Scratch"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%200%20Scratch/#binary","level":3,"title":"Binary","text":"<p>Computer is a base-2 system we can use 0 and 1 to represent all of it.</p> <p>Case: use the hand to count the number by control the finger up and down, how many can you count?</p> <p>The answer is 31 if you start with the 0(we have \\(2^{5}\\) outcomes)</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%200%20Scratch/#bit","level":4,"title":"bit","text":"<p>For the computer, it is useful and simple because it imply the on and off.</p> <p>binary digit-BIT!</p> <p>we can make the 1 value means on and 0 means off. and use light bulb to represent the fingers' up and down.</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%200%20Scratch/#decimal","level":4,"title":"decimal","text":"<p>\\(123=100*1+10*2+1*3\\)</p> <p>And we can use this method to understand the bulbs' light and more far from it is the binary. WE can use the 0 and 1 represent the information in computer.</p> <p>More often used than bit is byte, what is byte? A byte is 8 bit(or 8 bulbs) it can represent the 255.</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%200%20Scratch/#ascii","level":3,"title":"ASCII","text":"<p>So how can we use them denote the number A? Assign every letter a number -for some reasons the A strats with 65(64+1).</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%200%20Scratch/#unicode","level":3,"title":"Unicode","text":"<p>Unicode code point U+1F602 </p> <p>Remark: The U+ is a conventional mark for unicode in computer science. </p>","path":["Week 0 Scratch"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%200%20Scratch/#color","level":3,"title":"Color","text":"<p>Zeros and ones can be used to represent color.</p> <p>Red, green, and blue (called <code>RGB</code>) is a combination of three numbers.</p> <p>One  pixel dot will ocuppy 3 bits of colors.</p> <p>We will think more things can be represent by 0's and 1's so between the input and output is what?</p> <p>It's algorithms!</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%200%20Scratch/#algorithms","level":3,"title":"Algorithms","text":"<p>Case: Find John Harvard in the book and take three algorithms.</p> <ol> <li>one step each </li> <li>two steps each</li> <li>half of the remainings </li> </ol> <p>We can solve the problem correctly and more efficiently as well.</p> <p>One graph can draw the efficientcy.</p> <pre><code>Pick up phone book\nOpen to middle of phone book\nlook at page \nIf person is on page\n    call him\nElse if person is ealier in book\n    Open to middle of left half of book\n    Go back to line 3\nElse if person is later in book\n    Open to middle of right half of book\n    Go back to line 3\nElse\n    Quit \n</code></pre> <p>They called functions and use conditions.</p> <p>Boolean expression can give two types answers (0 and 1 or something else)</p> <p>And above it's a loop can go and go.</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%200%20Scratch/#artificial-intelligence","level":3,"title":"Artificial Intelligence","text":"<p>If use simple input the binary question each an answer, it will be difficult.</p> <p>Large language models(LLMs)</p> <pre><code>#include&lt;stdio.h&gt;\n\nint main(void)\n{\n    printf(\"hello world\\n\")\n}\n</code></pre>","path":["Week 0 Scratch"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%200%20Scratch/#scratch","level":3,"title":"Scratch","text":"<p>Through dragging and dropping some puzzles to make a program.</p> <p>Very interesting parts.</p> <p>Ivy's Hardest Game --So difficult!(Can it passed?)</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%200%20Scratch/#summing-up","level":2,"title":"Summing up","text":"<p>In this lesson, you learned how this course sits in the wide world of computer science and programming. You learned…</p> <ul> <li>Few students come to this class with prior programming experience!</li> <li>You are not alone! You are part of a community.</li> <li>Problem-solving is the essence of the work of computer scientists.</li> <li>This course is not simply about programming – this course will introduce you to a new way of learning that you can apply to almost every area of life.</li> <li>How numbers, text, images, music, and video are understood and represented by computers.</li> <li>The fundamental programming skill of pseudocoding.</li> <li>Reasonable and unreasonable ways to utilize AI in this course.</li> <li>How abstraction will play a role in your future work in this course.</li> <li>The basic building blocks of programming including functions, conditionals, loops, and variables.</li> <li>How to build a project in Scratch.</li> </ul> <p>This was CS50! Welcome aboard! See you next time!</p>","path":["Week 0 Scratch"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%200%20Scratch/#problem-set-0","level":2,"title":"Problem Set 0","text":"<p>It’s time to choose your own adventure! Your assignment, quite simply, is to implement in Scratch, at scratch.mit.edu, any project of your choice, be it an interactive story, game, animation, or anything else, subject only to the following requirements:</p> <ul> <li>Your project must use at least two sprites, at least one of which must not be a cat.</li> <li>Your project must have at least three scripts total (i.e., not necessarily three per sprite).</li> <li>Your project must use at least one conditional, at least one loop, and at least one variable.</li> <li>Your project must use at least one custom block that you have made yourself (via Make a Block), which must take at least one input.</li> <li>Your project should be more complex than most of those demonstrated in lecture (many of which, though instructive, were quite short) but it can be less complex than Oscartime and Ivy’s Hardest Game.</li> </ul> <p>Due the Scratch's high freedom property I pass the problem set(Or make an easy one?). </p>","path":["Week 0 Scratch"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/","level":1,"title":"Week 1 C","text":"","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#syllabus","level":2,"title":"Syllabus","text":"<p>C. Source Code. Machine Code. Compiler. Correctness, Design, Style. Visual Studio Code. Syntax Highlighting. Escape Sequences. Header Files. Libraries. Manual Pages. Types. Conditionals. Variables. Loops. Linux. Graphical User Interface (GUI). Command-Line Interface (CLI). Constants. Comments. Pseudocode. Operators. Integer Overflow. Floating-Point Imprecision.</p>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#notes","level":2,"title":"Notes","text":"","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#machine-code","level":3,"title":"Machine Code","text":"<pre><code>#include&lt;stdio.h&gt; //standard io.h\n\nint main(void) //void -no input\n{\n    printf(\"hello world\\n\")\n}\n</code></pre> <p>The computer can onlrecy ognize the binary numbers so we need a compiler(编译器) to make the higher level language to a lower level language.</p> <p>![[compiler.svg]]</p> <p>use a cloud(best) URL or you can use VS code in your computer</p> <p>Some words you should know: GUI CLI</p>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#hello-world","level":3,"title":"Hello world","text":"<pre><code>#include&lt;stdio.h&gt;\n//pronounced \"include standard io.h\"\n\nint main(void)\n{\n    printf(\"hello world\\n\")\n}\n</code></pre> <p>Some little concepts:</p> <p><code>#include stdio.h</code> - include standard io.h <code>curly braces</code> - 大括号{} <code>printf</code> - F means formatted <code>semicolon</code> - 分号; <code>syntax</code> - 句法</p> <p>In the terminal</p> <pre><code>$ code hello.c\n$ make hello\n// not need to input hello.c make can look the folder\n// make to compile the file from source code to machine code\n$ ./hello\n\nand get the \nhello world$(\\n)\n</code></pre>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#libraryheader-files","level":3,"title":"Library(Header Files)","text":"<p>We can use the code others write before via library and for example we can find the stdio.h  Manual Pages </p> <pre><code>printf(\"hello, %s\\n\", answer)\n// %s means a place holder\n</code></pre> <p>Case 1</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    string answer = get_string(\"What's your name?\");\n    printf(\"hello, &amp;s\\n\", answer);\n}\n</code></pre> <p>Error: get_string is not claimed.</p> <p>Case 2</p> <pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    string answer = get_string(\"What's your name?\");\n    printf(\"hello, &amp;s\\n\", answer);\n}\n</code></pre> <p>Here gets so many cases and we can design the programs so that it can be more efficient.</p>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#terminal-commands","level":3,"title":"Terminal Commands","text":"<p>We can know more about them by Google.</p> <p>In the terminal window, some common command-line arguments we may use include:</p> <ul> <li><code>cd</code>, for changing our current directory (folder)</li> <li><code>cp</code>, for copying files and directories</li> <li><code>ls</code>, for listing files in a directory</li> <li><code>mkdir</code>, for making a directory</li> <li><code>mv</code>, for moving (renaming) files and directories</li> <li><code>rm</code>, for removing (deleting) files</li> <li><code>rmdir</code>, for removing (deleting) directories</li> </ul>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#types-of-the-variablews","level":3,"title":"Types of the variablews","text":"<p>Types with which you might interact during this course include:</p> <ul> <li><code>bool</code>, a Boolean expression of either true or false</li> <li><code>char</code>, a single character like a or 2</li> <li><code>double</code>, a floating-point value with more digits than a float</li> <li><code>float</code>, a floating-point value, or a real number with a decimal value</li> <li><code>int</code>, integers up to a certain size, or number of bits</li> <li><code>long</code>, integers with more bits, so they can count higher than an int</li> <li><code>string</code>, a string of characters</li> </ul> <p>Followings are make the Scratch codes to C. </p>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#conditionals","level":3,"title":"Conditionals","text":"<p>Some tips:     Don't make some unnecessary operations.     Focus on how to design the better structure of codes.</p> <pre><code>if (x &lt; y)\n{\n    printf(\"x is less than y\\n\");\n}\nelse if (x &gt; y)\n{\n    printf(\"x is greater than y\\n\");\n}\nelse\n{\n    printf(\"x is equal to y\\n\");\n}\n</code></pre> <p>But not make the three ifs because it will waste the time.</p>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#loop","level":3,"title":"Loop","text":"<p>Motivation: We want to let the vsc meows like the Scratch and how should we do? Answer: We can make a loop to decrease our codes.</p> <pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nvoid meow(int n);\n\nint main(void)\n{\n    int n;\n    do\n    {\n        n = get_int(\"Number: \");\n    }\n    while (n &lt; 1);\n    meow(n);\n}\n\n// Meow some number of times\nvoid meow(int n)\n{\n    for (int i = 0; i &lt; n; i++)\n    {\n        printf(\"meow\\n\");\n    }\n}\n</code></pre> <p>Comments Typically, each comment is a few words or more, providing the reader an opportunity to understand what is happening in a specific block of code. Further, such comments serve as a reminder for you later when you need to revise your code.</p>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#functions","level":3,"title":"Functions","text":"<p>An inspiring idea is to make the repeating parts a new role that we can use them by include or write the function's name.</p> <p>Here's a example from Mario(循环嵌套). Notice how printing a row is accomplished through a new function.</p> <pre><code>// Helper function\n\n#include &lt;stdio.h&gt;\n\nvoid print_row(int width);\n\n//void means no output , int width means we have one input\n\nint main(void)\n{\n    const int n = 3;\n    for (int i = 0; i &lt; n; i++)\n    {\n        print_row(n);\n    }\n}\n\n//Row function\nvoid print_row(int width)\n{\n    for (int i = 0; i &lt; width; i++)\n    {\n        printf(\"#\");\n    }\n    printf(\"\\n\");\n}\n</code></pre>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#calculator","level":3,"title":"Calculator","text":"<pre><code>// int\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int dollars = 1;\n    while (true)\n    {\n        char c = get_char(\"Here's $%i. Double it and give to next person? \", dollars);\n        if (c == 'y')\n        {\n            dollars *= 2;\n        }\n        else\n        {\n            break;\n        }\n    }\n    printf(\"Here's $%i.\\n\", dollars);\n}\n</code></pre> <ul> <li>Types are very important because each type has specific limits. For example, because of the limits in memory, the highest value of an <code>int</code> can be <code>4294967295</code>. If you attempt to count an <code>int</code> higher, an integer overflow will result where an incorrect value will be stored in this variable.</li> <li>The number of bits limits how high and low we can count.</li> <li>This can have catastrophic, real-world impacts.</li> <li>We can correct this by using a data type called <code>long</code>.</li> </ul> <pre><code>// long\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    long dollars = 1;\n    while (true)\n    {\n        char c = get_char(\"Here's $%li. Double it and give to next person? \", dollars);\n        if (c == 'y')\n        {\n            dollars *= 2;\n        }\n        else\n        {\n            break;\n        }\n    }\n    printf(\"Here's $%li.\\n\", dollars);\n}\n</code></pre>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#truncation","level":3,"title":"Truncation","text":"<pre><code>// Division with ints, demonstrating truncation\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    // Prompt user for x\n    int x = get_int(\"x: \");\n\n    // Prompt user for y\n    int y = get_int(\"y: \");\n\n    // Divide x by y\n    printf(\"%i\\n\", x / y);\n}\n</code></pre> <p>An integer divided by an integer will always result in an integer in C. Accordingly, the above code will often result in any digits after the decimal being thrown away.</p> <pre><code>// Floats\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    // Prompt user for x\n    float x = get_float(\"x: \");\n\n    // Prompt user for y\n    float y = get_float(\"y: \");\n\n    // Divide x by y\n    printf(\"%.50f\\n\", x / y);\n}\n</code></pre> <ul> <li>Floating point imprecision illustrates that there are limits to how precise computers can calculate numbers.</li> <li>As you are coding, pay special attention to the types of variables you are using to avoid problems within your code.</li> <li>We examined some examples of disasters that can occur through type-related errors.</li> </ul>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#summing-up","level":2,"title":"Summing up","text":"<ul> <li>How to create your first program in C.</li> <li>How to use the command line.</li> <li>About predefined functions that come natively with C.</li> <li>How to use variables, conditionals, and loops.</li> <li>How to create your own functions to simplify and improve your code.</li> <li>How to er codevaluate you on three axes: correctness, design, and style.</li> <li>How to integrate comments into your code.</li> <li>How to utilize types and operators and the implications of your choices.</li> </ul>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#problem-set-1","level":2,"title":"Problem Set 1","text":"","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#hello-its-me","level":3,"title":"Hello, It’s Me","text":"<pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    string name = get_string(\"What's your name?\");\n    printf(\"hello, %s\\n\",name);\n}\n</code></pre>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#mario-more","level":3,"title":"Mario-more,","text":"<pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int height;\n    do\n    {\n        height = get_int(\"Height= \");\n    }\n    while (height &lt; 1 || height &gt; 8);\n    int row = 0;\n    while (row &lt; height)\n    {\n        for (int i = 0; i &lt; height - row - 1; i++)\n        {\n            printf(\" \");\n        }\n        for (int j = 0; j &lt; row + 1; j++)\n        {\n            printf(\"#\");\n        }\n        printf(\"  \");\n        for (int j = 0; j &lt; row + 1; j++)\n        {\n            printf(\"#\");\n        }\n        row++;\n        printf(\"\\n\");\n    }\n}\n</code></pre>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#cash","level":3,"title":"Cash,","text":"<pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int changeOwed;\n    do\n    {\n        changeOwed = get_int(\"Change owed: \");\n    }\n    while (changeOwed &lt; 0);\n\n    int quarters;\n    int dimes;\n    int nickels;\n    int pennies;\n\n    quarters = changeOwed / 25;\n    changeOwed = changeOwed - quarters * 25;\n    dimes = changeOwed / 10;\n    changeOwed = changeOwed - dimes * 10;\n    nickels = changeOwed / 5;\n    changeOwed = changeOwed - nickels * 5;\n    pennies = changeOwed;\n\n    int k = quarters + dimes + nickels + pennies;\n    printf(\"%i\\n\", k);\n\n}\n</code></pre>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%201%20C/#credit","level":3,"title":"Credit,","text":"<pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    long checknum;\n    // get a number\n    checknum = get_long(\"Number: \");\n    // 最终求和变量\n    int checksum = 0;\n    // 指示变量\n    int digit = 1;\n    \n    // checksum part\n    int reminder;\n    int save1 = 0;\n    int save2 = 0;\n    while (checknum &gt; 0)\n    {\n        save2 = save1;\n        save1 = 0;\n        reminder = 0;\n        if (digit % 2 == 0)\n        {\n            save1 = checknum % 10;\n            reminder = checknum % 10 * 2;\n            checknum /= 10;\n            if (reminder &gt;= 10)\n            {\n                reminder = reminder % 10 + 1;\n                checksum += reminder;\n            }\n            else\n            {\n                checksum += reminder;\n            }\n        }\n        else\n        {\n            save1 = checknum % 10;\n            checksum += checknum % 10;\n            checknum /= 10;\n        }\n        digit += 1;\n    }\n    digit -= 1;\n    \n    // claim\n    if (checksum % 10 == 0)\n    {\n        if (save1 == 3 &amp;&amp; digit == 15)\n        {\n            if (save2 ==4 || save2 == 7)\n            {\n                 printf(\"AMEX\\n\");\n            }\n            else\n            {\n                printf(\"INVALID\\n\");\n            }\n        }\n        else if (save1 == 5 &amp;&amp; digit == 16)\n        {\n            if (save2 &gt;=1 &amp;&amp; save2 &lt;= 5)\n            {\n                 printf(\"MASTERCARD\\n\");\n            }\n            else\n            {\n                printf(\"INVALID\\n\");\n            }\n        }\n        else if (save1 == 4 &amp;&amp; (digit ==13 || digit == 16))\n        {\n            printf(\"VISA\\n\");\n        }\n        else\n        {\n            printf(\"INVALID\\n\");\n        }\n    }\n    else\n    {\n        printf(\"INVALID\\n\");\n    }\n}\n</code></pre>","path":["Week 1 C"],"tags":["CS50x"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/","level":1,"title":"Week 2 Arrays","text":"","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#syllabus","level":2,"title":"Syllabus","text":"<p>Preprocessing. Compiling. Assembling. Linking. Debugging. Arrays. Strings. Command-Line Arguments. Cryptography.</p>","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#notes","level":2,"title":"Notes","text":"","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#preprocessing","level":3,"title":"Preprocessing","text":"<p>Motivation: reading levels</p> <p>Recall a graph:</p> <p>Source Code -&gt; Compiler -&gt; Machine Code</p>","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#compiling","level":4,"title":"Compiling","text":"<p>What's actually happend in the process of translating?(Compiling)</p> <pre><code>clang hello.c\n./a.out\n</code></pre> <pre><code>clang -o hello hello.c -lcs50\n//If you want to use the cs50 library\n</code></pre> <p>preprocessor preprocessing step</p> <p>If you want to code C or other languages, the CPU will process the code from C into a low levlel language called assembly code.</p> <p>And focus on compiling</p> <pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    printf(\" \");\n}\n</code></pre> <p>What's the definition of linking neatly? A: the process of combining multiple object files (pieces of compiled code) generated by a compiler into a single executable program.</p> <p>Four steps of compiling: + preprocessing + compile to assembly code + assembly code translates to machine code + linking: combining multiple object files (pieces of compiled code)</p>","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#debugging","level":3,"title":"Debugging","text":"<ul> <li>Everyone will make mistakes while coding.</li> <li>Debugging is the process of locating and removing bugs from your code.</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    for (int i = 0; i &lt;  3; i++)\n    {\n        printf(\"i is %i\\n\", i);\n        printf(\"#\\n\");\n    }\n}\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#arrays","level":3,"title":"Arrays","text":"<p>Motivation: We don't want so many variables for a same type(or same purpose)</p> <pre><code>int scores[3];\nscores[0] = 72;\nscores[1] = 73;\nscores[2] = 33;\n</code></pre> <p>So this tech has an advantage that we can change it easily and sustained.</p> <pre><code>// Averages three numbers using an array, a constant, and a helper function\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\n// Constant\nconst int N = 3;\n\n// Prototype\nfloat average(int length, int array[]);\n\nint main(void)\n{\n    // Get scores\n    int scores[N];\n    for (int i = 0; i &lt; N; i++)\n    {\n        scores[i] = get_int(\"Score: \");\n    }\n\n    // Print average\n    printf(\"Average: %f\\n\", average(N, scores));\n}\n\nfloat average(int length, int array[])\n{\n    // Calculate average\n    int sum = 0;\n    for (int i = 0; i &lt; length; i++)\n    {\n        sum += array[i];\n    }\n    return sum / (float) length;\n}\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#strings","level":3,"title":"Strings","text":"<ul> <li>A <code>string</code> is simply an array of variables of type <code>char</code>: an array of characters.</li> <li>To explore <code>char</code> and <code>string</code>, type <code>code hi.c</code> in the terminal window and write code as follows:</li> </ul> <pre><code>    // Prints chars\n\n    #include &lt;stdio.h&gt;\n\n    int main(void)\n    {\n        char c1 = 'H';\n        char c2 = 'I';\n        char c3 = '!';\n\n        printf(\"%c%c%c\\n\", c1, c2, c3);\n    }\n</code></pre> <p>Notice that this will output a string of characters.</p> <p>A string is a sequence of characters like a array of the type of characters. </p> <p>NUL says string end here.</p> <pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    string words[2];\n\n    words[0] = \"HI!\";\n    words[1] = \"BYE!\";\n\n    printf(\"%c%c%c\\n\", words[0][0], words[0][1], words[0][2]);\n    printf(\"%c%c%c%c\\n\", words[1][0], words[1][1], words[1][2], words[1][3]);\n\n// arrays of arrays so strings are actually arrays\n}\n</code></pre> <p>strlen function include  <p>Since this is such a common problem within programming, other programmers have created code in the <code>string.h</code> library to find the length of a string. You can find the length of a string by modifying your code as follows:</p> <pre><code>// Determines the length of a string using a function\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void)\n{\n    // Prompt for user's name\n    string name = get_string(\"Name: \");\n    int length = strlen(name);\n    printf(\"%i\\n\", length);\n}\n</code></pre> <p>Notice that this code uses the <code>string.h</code> library, declared at the top of the file. Further, it uses a function from that library called <code>strlen</code>, which calculates the length of the string passed to it.</p> <p>ctype.h</p> <p>While the program does what we want, there is an easier way using the <code>ctype.h</code> library. Modify your program as follows:</p> <pre><code>// Uppercases string using ctype library (and an unnecessary condition)\n\n#include &lt;cs50.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void)\n{\n    string s = get_string(\"Before: \");\n    printf(\"After:  \");\n    for (int i = 0, n = strlen(s); i &lt; n; i++)\n    {\n        if (islower(s[i]))\n        {\n            printf(\"%c\", toupper(s[i]));\n        }\n        else\n        {\n            printf(\"%c\", s[i]);\n        }\n    }\n    printf(\"\\n\");\n}\n</code></pre> <p>Notice that the program iterates through each character of the string. The <code>toupper</code> function is passed <code>s[i]</code>. Each character (if lowercase) is converted to uppercase.</p>","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#command-line-arguments","level":3,"title":"Command-Line Arguments","text":"<ul> <li><code>Command-line arguments</code> are those arguments that are passed to your program at the command line. For example, all those statements you typed after <code>clang</code> are considered command line arguments. You can use these arguments in your own programs!</li> <li> <p>In your terminal window, type <code>code greet.c</code> and write code as follows:</p> <pre><code>// Uses get_string\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    string answer = get_string(\"What's your name? \");\n    printf(\"hello, %s\\n\", answer);\n}\n</code></pre> </li> </ul> <p>Notice that this says <code>hello</code> to the user.</p> <ul> <li> <p>Still, would it not be nice to be able to take arguments before the program even runs? Modify your code as follows:</p> <pre><code>// Prints a command-line argument\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(int argc, string argv[])\n{\n    if (argc == 2)\n    {\n        printf(\"hello, %s\\n\", argv[1]);\n    }\n    else\n    {\n        printf(\"hello, world\\n\");\n    }\n}\n</code></pre> </li> </ul> <p>Notice that this program knows both <code>argc</code>, the number of command line arguments, and <code>argv</code>, which is an array of the characters passed as arguments at the command line.</p> <p>Remark that one of CLAs is the name of the program!</p> <ul> <li>Therefore, using the syntax of this program, executing <code>./greet David</code> would result in the program saying <code>hello, David</code>.</li> <li>You can print each of the command-line arguments with the following:</li> </ul> <pre><code>    // Prints command-line arguments\n\n    #include &lt;cs50.h&gt;\n    #include &lt;stdio.h&gt;\n\n    int main(int argc, string argv[])\n    {\n        for (int i = 0; i &lt; argc; i++)\n        {\n            printf(\"%s\\n\", argv[i]);\n        }\n    }\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#exit-status","level":3,"title":"Exit Status","text":"<ul> <li>When a program ends, a special exit code is provided to the computer.</li> <li>When a program exits without error, a status code of <code>0</code> is provided to the computer. Often, when an error occurs that results in the program ending, a status of <code>1</code> is provided by the computer.</li> <li> <p>You could write a program as follows that illustrates this by typing <code>code status.c</code> and writing code as follows:</p> <pre><code>// Returns explicit value from main\n\n#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(int argc, string argv[])\n{\n    if (argc != 2)\n    {\n        printf(\"Missing command-line argument\\n\");\n        return 1;\n    }\n    printf(\"hello, %s\\n\", argv[1]);\n    return 0;\n}\n</code></pre> </li> </ul> <p>Notice that if you fail to provide <code>./status David</code>, you will get an exit status of <code>1</code>. However, if you do provide <code>./status David</code>, you will get an exit status of <code>0</code>.</p> <ul> <li>You can type <code>echo $?</code> in the terminal to see the exit status of the last run command.</li> <li>You can imagine how you might use portions of the above program to check if a user provided the correct number of command-line arguments.</li> </ul>","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#cryptography","level":3,"title":"Cryptography","text":"<ul> <li>Cryptography is the art of ciphering and deciphering a message.</li> <li>Now, with the building block of arrays, chars, and strings, you can cipher and decipher a message.</li> <li><code>plaintext</code> and a <code>key</code> are provided to a <code>cipher</code>, resulting in ciphered text.</li> </ul> <p>Key and Plaintext -&gt; Cipher -&gt; Ciphertext</p>","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#summing-up","level":2,"title":"Summing Up","text":"<p>In this lesson, you learned more details about compiling and how data is stored within a computer. Specifically, you learned…</p> <ul> <li>Generally, how a compiler works.</li> <li>How to debug your code using four methods.</li> <li>How to utilize arrays within your code.</li> <li>How arrays store data in back to back portions of memory.</li> <li>How strings are simply arrays of characters.</li> <li>How to interact with arrays in your code.</li> <li>How command-line arguments can be passed to your programs.</li> <li>The basic building-blocks of cryptography.</li> </ul>","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#sections","level":2,"title":"Sections","text":"<ul> <li>Arrays<ul> <li>Initialize</li> <li>assignment</li> <li>change</li> </ul> </li> <li>Strings<ul> <li>get_string</li> <li>Connection with arrays</li> <li>ASCII code(Alphabetical Exercise)</li> </ul> </li> <li>Command Line Arguments aka. CLA</li> </ul> <p>A program about CLAs:</p> <pre><code>#include &lt;cs50.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, string argv[])\n{\n    // Get user's input\n    if (argc != 2)\n    {\n        printf(\"Please provide a word.\\n\");\n        return 1;\n    }\n\n    string text = argv[1];\n    int len = strlen(text);\n\n    for (int i = 0; i &lt; len; i++)\n    {\n        if (!isalpha(text[i]))\n        {\n            printf(\"This is not a letter.\\n\");\n            return 2;\n        }\n    }\n\n    // Iterate through each element in the string\n    for (int i = 1; i &lt; len; i++)\n    {\n        if (text[i] &lt; text[i - 1])\n        {\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n    // Print out yes\n    printf(\"Yes\\n\");\n}\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#problem-set-2","level":2,"title":"Problem Set 2","text":"","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#scrabble","level":3,"title":"Scrabble","text":"<pre><code>#include &lt;cs50.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n// Points assigned to each letter of the alphabet\nint POINTS[] = {1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10};\n\nint compute_score(string word);\n\nint main(void)\n{\n    // Prompt the user for two words\n    string word1 = get_string(\"Player 1: \");\n    string word2 = get_string(\"Player 2: \");\n\n    // Compute the score of each word\n    int score1 = compute_score(word1);\n    int score2 = compute_score(word2);\n\n    // Print the winner\n    if (score1 &gt; score2)\n    {\n        printf(\"Player 1 wins!\\n\");\n    }\n    else if (score1 &lt; score2)\n    {\n        printf(\"Player 2 wins!\\n\");\n    }\n    else\n    {\n        printf(\"Tie!\\n\");\n    }\n}\n\nint compute_score(string word)\n{\n    // Keep track of score\n    int score = 0;\n\n    // Compute score for each character\n    for (int i = 0, len = strlen(word); i &lt; len; i++)\n    {\n        if (isupper(word[i]))\n        {\n            score += POINTS[word[i] - 'A'];\n        }\n        else if (islower(word[i]))\n        {\n            score += POINTS[word[i] - 'a'];\n        }\n    }\n\n    return score;\n}\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#readability","level":3,"title":"Readability","text":"<pre><code>#include &lt;ctype.h&gt;\n#include &lt;cs50.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint count_letters(string text);\nint count_words(string text);\nint count_sentences(string text);\n\nint main(void)\n{\n    // Prompt the user for some text\n    string text = get_string(\"Text: \");\n\n    // Count the number of letters, words, and sentences in the text\n    int letters = count_letters(text);\n    int words = count_words(text);\n    int sentences = count_sentences(text);\n\n    // Compute the Coleman-Liau index\n    float L = (float)letters / words * 100; // Average letters per 100 words\n    float S = (float)sentences / words * 100; // Average sentences per 100 words\n    float index_original = 0.0588 * L - 0.296 * S - 15.8; // Coleman-Liau index formula\n    // Print the grade level\n    int index = round(index_original);\n    if (index &lt; 1)\n    {\n        printf(\"Before Grade 1\\n\");\n    }\n    else if (index &gt;= 16)\n    {\n        printf(\"Grade 16+\\n\");\n    }\n    else\n    {\n        printf(\"Grade %d\\n\", index);\n    }\n}\n\nint count_letters(string text)\n{\n    // Return the number of letters in text\n    int letter_count = 0;\n    for (int i = 0, n = strlen(text); i &lt; n; i++)\n    {\n        if (isalpha(text[i]))\n        {\n            letter_count++;\n        }\n    }\n    return letter_count; // Return the count of letters\n}\n\nint count_words(string text)\n{\n    // Return the number of words in text\n    int word_count = 0;\n    for (int i = 0, n = strlen(text); i &lt; n; i++)\n    {\n        if (isspace(text[i]) || i == n - 1) // Count words by spaces or end of text\n        {\n            word_count++;\n        }\n    }\n    return word_count; // Return the count of words\n}\n\nint count_sentences(string text)\n{\n    // Return the number of sentences in text\n    int sentence_count = 0;\n    for (int i = 0, n = strlen(text); i &lt; n; i++)\n    {\n        if (text[i] == '.' || text[i] == '!' || text[i] == '?')\n        {\n            sentence_count++;\n        }\n    }\n    return sentence_count; // Return the count of sentences\n}\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#caesar","level":3,"title":"Caesar","text":"<pre><code>#include &lt;cs50.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, string argv[])\n{\n    // Make sure program was run with just one command-line argument\n    if (argc != 2)\n    {\n        printf(\"Usage: ./caesar key\\n\");\n        return 1;\n    }\n    // Make sure every character in argv[1] is a digit\n    for (int i = 0, n = strlen(argv[1]); i &lt; n; i++)\n    {\n        if (argv[1][i] &lt; '0' || argv[1][i] &gt; '9')\n        {\n            printf(\"Usage: ./caesar key\\n\");\n            return 1;\n        }\n    }\n    // Convert argv[1] from a `string` to an `int`\n    int key = atoi(argv[1]) % 26; // Ensure key is within 0-25\n    // Prompt user for plaintext\n    string plaintext = get_string(\"plaintext: \");\n    // For each character in the plaintext:\n    printf(\"ciphertext: \");\n    for (int i = 0, n = strlen(plaintext); i &lt; n; i++)\n    {\n        // Check if the character is an uppercase letter\n        if (plaintext[i] &gt;= 'A' &amp;&amp; plaintext[i] &lt;= 'Z')\n        {\n            // Rotate the character\n            printf(\"%c\", ((plaintext[i] - 'A' + key) % 26) + 'A');\n        }\n        // Check if the character is a lowercase letter\n        else if (plaintext[i] &gt;= 'a' &amp;&amp; plaintext[i] &lt;= 'z')\n        {\n            // Rotate the character\n            printf(\"%c\", ((plaintext[i] - 'a' + key) % 26) + 'a');\n        }\n        else\n        {\n            // If it's not a letter, just print it as is\n            printf(\"%c\", plaintext[i]);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS50x/Week%202%20Arrays/#substitution","level":3,"title":"Substitution","text":"<pre><code>#include &lt;cs50.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;ctype.h&gt;\n\nint main(int argc, string argv[])\n{\n    // Make sure program was run with just one command-line argument\n    if (argc != 2)\n    {\n        printf(\"Usage: ./substitution key\\n\");\n        return 1;\n    }\n\n    // Optimize: Calculate key length once\n    int key_len = strlen(argv[1]);\n    for (int i = 0; i &lt; key_len; i++)\n    {\n        // Check if the key contains only alphabetic characters\n        if (!isalpha(argv[1][i]))\n        {\n            printf(\"Key must contain 26 characters.\\n\");\n            return 1;\n        }\n    }\n\n    // Make sure argv[1] has 26 characters (Logic preserved as per original code)\n    for (int i = 0; i &lt; key_len; i++) // Use pre-calculated key_len\n    {\n        if ((argv[1][i] &lt;= 'z' &amp;&amp; argv[1][i] &gt;= 'a') || (argv[1][i] &lt;= 'Z' &amp;&amp; argv[1][i] &gt;= 'A'))\n        {\n            // Use pre-calculated key_len here as well\n            if (key_len != 26) // Use pre-calculated key_len\n            {\n                printf(\"Key must contain 26 characters.\\n\");\n                return 1;\n            }\n            else\n            {   // Check for duplicate characters in the key\n                for (int j = 0; j &lt; key_len; j++) // Use pre-calculated key_len\n                {\n                    for (int k = j + 1; k &lt; key_len; k++) // Use pre-calculated key_len\n                    {\n                        if (argv[1][j] == argv[1][k] || argv[1][j] + 32 == argv[1][k] || argv[1][j] - 32 == argv[1][k])\n                        {\n                            printf(\"Key must not contain repeated characters.\\n\");\n                            return 1;\n                        }\n                    }\n                }\n                // Prompt user for plaintext\n                string plaintext = get_string(\"plaintext: \");\n\n                // Optimize: Calculate plaintext length once\n                int plaintext_len = strlen(plaintext);\n\n                // For each character in the plaintext:\n                for (int j = 0; j &lt; plaintext_len; j++) // Use pre-calculated plaintext_len\n                {\n                    if ((plaintext[j] - 'a') &gt;= 0 &amp;&amp; (plaintext[j] - 'a') &lt;= 26) // Original condition preserved\n                    {\n                        // Convert lowercase letters\n                        plaintext[j] = argv[1][plaintext[j] - 'a'];\n                        if (plaintext[j] &gt;= 'A' &amp;&amp; plaintext[j] &lt;= 'Z')\n                        {\n                            // Convert to lowercase if necessary\n                            plaintext[j] += 32; // ASCII value adjustment\n                        }\n                    }\n                    else if ((plaintext[j] - 'A') &gt;= 0 &amp;&amp; (plaintext[j] - 'A') &lt;= 26) // Original condition preserved\n                    {\n                        // Convert uppercase letters\n                        plaintext[j] = argv[1][plaintext[j] - 'A'];\n                        if (plaintext[j] &gt;= 'a' &amp;&amp; plaintext[j] &lt;= 'z')\n                        {\n                            // Convert to uppercase if necessary\n                            plaintext[j] -= 32; // ASCII value adjustment\n                        }\n                    }\n                }\n                printf(\"ciphertext: %s\\n\", plaintext);\n                return 0;\n            }\n        }\n        else\n        {\n            printf(\"Usage: ./substitution key\\n\");\n            return 1;\n        }\n    }\n    // Note: The original code's control flow causes it to exit the main function within the first iteration\n    // of the key validation loop (if conditions are met).\n    // This final 'return 0' would only be reached if the key_len was 0 or the loop somehow finished without returning.\n    return 0;\n}\n</code></pre>","path":["Week 2 Arrays"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/","level":1,"title":"CS61A","text":"Progress Bar Example","path":["CS61A"],"tags":["国外公开课","CS"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/#_1","level":2,"title":"前言","text":"<p>存放@Eurekaimer在完成CS61A过程中的HWs/Labs/Projects的实现和一些新手可能犯的错误(因为我在学习过程中应该会都踩一遍)，相关实现请参考Github的CS61A仓库</p> <p>完成的时间轴：TBA(To be anounced)(2025.04.05-)</p> <ul> <li> 版本选用：2024spring</li> </ul> <p>由于一些版权上的问题UCB似乎向非UCB的学习者封闭了Archive的通道，所以这里建议选用国内的备份站点和B站的视频</p> <ul> <li> <p> 时间安排：预计200h</p> </li> <li> <p> 语言：Python</p> </li> <li> <p> 前置：无</p> </li> <li> <p> 参考学习顺序：videos-reading-q&amp;a-(lab/disc/hw)-project</p> </li> </ul> <p>完成的时间轴：TBA(2025.04.05-)</p> <p>以下是所有内容的完成情况(按照顺序排列):</p> <ul> <li> 61A-Week-1 2025.4.5<ul> <li> Disc 00</li> <li> Reading</li> <li> Videos(Functions)</li> <li> Lab 00</li> <li> HW 01</li> </ul> </li> <li> 61A-Week-2 2025.4.25<ul> <li> Videos(Control,Higher-Order Functions,Environments)</li> <li> Reading</li> <li> Lab 01</li> <li> Disc 01</li> <li> HW 02: Higher-Order Functions</li> <li> Hog</li> </ul> </li> <li> 61A-Week-3 2025.4.27<ul> <li> Videos(Functional Abstraction,Function Examples)</li> <li> Lab 02</li> <li> Disc 02</li> </ul> </li> <li> 61A-Week-4 2025.4.30<ul> <li> Videos(Recursion,Tree Recursion)</li> <li> HW 03</li> <li> Disc 03</li> </ul> </li> <li> 61A-Week-5 2025.5.12<ul> <li> Videos(Sequences,Containers,Data Abstraction)</li> <li> Lab 03</li> <li> Disc 04</li> <li> Cats</li> </ul> </li> <li> 61A-Week-6 2025.5.13<ul> <li> Videos</li> <li> Lab 04</li> <li> Disc 05</li> <li> HW 04</li> </ul> </li> <li> 61A-Week-7 2025.9.2<ul> <li> Videos(Iterators, Generators, Objects)</li> <li> Lab 05</li> <li> Disc 06</li> <li> HW 05</li> </ul> </li> </ul>","path":["CS61A"],"tags":["国外公开课","CS"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/#_2","level":2,"title":"资源汇总","text":"<p>CS61a的资源参考(24spring)如下： 1. ZJU课程评价平台 2. CSDIY 3. Videos/Recordings 4. 参考实现 5. Learn-CS：主要使用这个备份站点的资源(无法使用Recording) 6. 一个学习总结</p> <p>文章参考：</p> <ol> <li>CS61a学习总结</li> <li>CS61A 学习经验&amp;感想</li> </ol> <p>也可以使用24fall备份(可fork完成作业)</p>","path":["CS61A"],"tags":["国外公开课","CS"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/#question-and-feedback","level":2,"title":"Question and Feedback","text":"<p>实际上，这门课的视频几乎可以说是完全包含于textbook中了，我认为如果有一定基础完全可以不看视频直接看书本然后完成lab和hw即可</p>","path":["CS61A"],"tags":["国外公开课","CS"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/#lab-00","level":3,"title":"Lab 00","text":"<ul> <li>在线评测如何local使用OK(不通过UCBedu邮箱)的问题: 在正确的目录中(ls contains ok) type <code>python ok --local</code> in terminal</li> </ul>","path":["CS61A"],"tags":["国外公开课","CS"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/#hw-03","level":3,"title":"HW 03","text":"<ul> <li>关于匿名实现递归的信仰之跃</li> </ul>","path":["CS61A"],"tags":["国外公开课","CS"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/","level":1,"title":"Project 1-The Game of Hog","text":"<p>When students in the past have tried to implement the functions without thoroughly reading the problem description, they’ve often run into issues. 😱 Read each description thoroughly before starting to code.</p> <p>这主要是一个二人的零和博弈游戏，深究应该会涉及到博弈论相关的知识</p> <p>大约需要4h</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#rule","level":2,"title":"Rule","text":"<p>主要规则如下：</p> <ul> <li>Sow Sad. If any of the dice outcomes is a 1, the current player's score for the turn is <code>1</code>.</li> </ul> <p>In a normal game of Hog, Sow Sad is all the rules. To spice up the game, we'll include some special rules:</p> <ul> <li>Boar Brawl. A player who rolls zero dice scores three times the absolute difference between the tens digit of the opponent’s score and the ones digit of the current player’s score, or 1, whichever is higher. The ones digit refers to the rightmost digit and the tens digit refers to the second-rightmost digit. If a player's score is a single digit (less than 10), the tens digit of that player's score is 0.</li> </ul> <p>可以选择不掷色子获得自身个位数与对方十位数差的绝对值的三倍的分数(最小为1)</p> <ul> <li>Sus Fuss. We call a number sus if it has exactly 3 or 4 factors, including 1 and the number itself. If, after rolling, the current player's score is a sus number, they gain enough points such that their score instantly increases to the next prime number.</li> </ul> <p>掷色子后的分数如果恰好有三个或四个因数(包括1和本身)，那么自动将分数提高到下一个质数</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#begin","level":2,"title":"Begin","text":"<p>For the project, you'll only be making changes to <code>hog.py</code>.</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#phase-1-rules-of-the-game","level":2,"title":"Phase 1: Rules of the Game","text":"<p>In the first phase, you will develop a simulator for the game of Hog.</p> <p>值得注意的是每个Problem在正式进行代码书写前，都有一个增进理解的What printed？的项目，主要是有一个对问题的划分意识</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#problem-0-0-pt","level":3,"title":"Problem 0 (0 pt)","text":"<p>增进理解</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#problem-1-2-pt","level":3,"title":"Problem 1 (2 pt)","text":"<p>完成对于sow_sad的判断，单个回合掷色子得到的分数计算</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#problem-2-2-pt","level":3,"title":"Problem 2 (2 pt)","text":"<p>完成Boar-Brawl的实现，计算不抛掷色子情况下的得分判断</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#problem-3-2-pt","level":3,"title":"Problem 3 (2 pt)","text":"<p>题面可能说的不太清楚，输入的是三个参数，综合前两个函数即可</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#problem-4-2-pt","level":3,"title":"Problem 4 (2 pt)","text":"<p>这是为了sus规则的函数，到这里实现了所有的规则</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#problem-5-4-pt","level":3,"title":"Problem 5 (4 pt)","text":"<p>实现最核心的play函数</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#interlude-user-interfaces","level":2,"title":"Interlude: User Interfaces","text":"<p>There are no required problems in this section of the project, just some examples for you to read and understand. See Phase 2 for the remaining project problems.</p> <p>感觉是给出了项目重构的一些思路和方法，如何在原有简单代码的基础上比较好的扩展和方便改进</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#phase-2-strategies","level":2,"title":"Phase 2: Strategies","text":"<p>In this phase, you will experiment with ways to improve upon the basic strategy of always rolling five dice. A strategy is a function that takes two arguments: the current player's score and their opponent's score. It returns the number of dice the player will roll, which can be from 0 to 10 (inclusive).</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#problem-6-2-pt","level":3,"title":"Problem 6 (2 pt)","text":"<p>直接lambda实现就好了</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#problem-7-2-pt","level":3,"title":"Problem 7 (2 pt)","text":"<p>写个循环嵌套暴力遍历得了</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#problem-8-2-pt","level":3,"title":"Problem 8 (2 pt)","text":"<p>Important: To implement this function, you will need to use a new piece of Python syntax. We would like to write a function that accepts an arbitrary number of arguments, and then calls another function using exactly those arguments. Here's how it works.</p> <p>只需要使用例子中的<code>*args</code>即可</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#problem-9-2-pt","level":3,"title":"Problem 9 (2 pt)","text":"<p>下面是一个有问题的代码，笔者想了很久，发现在比较时会调用roll_dice函数，而判断后赋值调用第二次，这就会导致结果受到影响</p> <pre><code>num = 1  \nroll_num = 1  \nmake_averaged_func = make_averaged(roll_dice, samples_count)  \nmax_average = 0  \nwhile num &lt;= 10:  \n    if make_averaged_func(num, dice) &gt; max_average:  \n        max_average = make_averaged_func(num, dice)  \n        roll_num = num  \n    num += 1  \nreturn roll_num\n</code></pre> <p>可以增加一个临时的局部变量进行控制，下面是正确的代码：</p> <pre><code>num = 1  \nroll_num = 1  \nmake_averaged_func = make_averaged(roll_dice, samples_count)  \nmax_average = 0  \nwhile num &lt;= 10:  \n    average_container = make_averaged_func(num, dice)  \n    if average_container &gt; max_average:  \n        max_average = average_container  \n        roll_num = num  \n    num += 1  \nreturn roll_num\n</code></pre>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#running-experiments","level":3,"title":"Running Experiments","text":"<p>还有一个模拟胜率的模块，真是相当完善的评测机制</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#problem-10-2-pt","level":3,"title":"Problem 10 (2 pt)","text":"<p>简单的选择结构</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#problem-11-2-pt","level":3,"title":"Problem 11 (2 pt)","text":"<p>同理可得</p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%201-The%20Game%20of%20Hog/#optional-problem-12-0-pt","level":3,"title":"Optional: Problem 12 (0 pt)","text":"<p>因为没有给出色子的参数，所以如果要测试会比较麻烦，干脆给出一个比较简单的策略</p> <pre><code>return 0 if sus_update(0, score, opponent_score) &gt;= GOAL else 6\n</code></pre> <p>在绝对的运气面前策略似乎不太有效呢(欧皇发言doge)</p> <p></p>","path":["Project 1-The Game of Hog"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/","level":1,"title":"Project 2-CS 61A Autocorrected Typing Software","text":"<p>Programmers dream of Abstraction, recursion, and Typing really fast.</p> <p>In this project, you will write a program that measures typing speed. Additionally, you will implement typing autocorrect, which is a feature that attempts to correct the spelling of a word after a user types it. This project is inspired by typeracer.</p> <p>大约需要4h</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#phase-1-typing","level":2,"title":"Phase 1: Typing","text":"","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-1-1-pt","level":3,"title":"Problem 1 (1 pt)","text":"<p>Implement <code>pick</code>. This function selects which paragraph the user will type.</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-2-1-pt","level":3,"title":"Problem 2 (1 pt)","text":"<p>Implement <code>about</code>, which takes a list of <code>subject</code> words. It returns a function which takes a paragraph and returns a boolean indicating whether that paragraph contains any of the words in <code>subject</code>.</p> <p>简单的字符串匹配问题</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-3-2-pts","level":3,"title":"Problem 3 (2 pts)","text":"<p>Implement <code>accuracy</code>, which takes a <code>typed</code> paragraph and a <code>source</code> paragraph. It returns the percentage of words in <code>typed</code> that exactly match the corresponding words in <code>source</code>. Case and punctuation must match as well. \"Corresponding\" here means that two words must occur at the same indices in <code>typed</code> and <code>source</code>; the first words of both must match, the second words of both must match, and so on.</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-4-1-pt","level":3,"title":"Problem 4 (1 pt)","text":"<p>Implement <code>wpm</code>, which computes the words per minute, a measure of typing speed, given a string <code>typed</code> and the amount of <code>elapsed</code> time in seconds. Despite its name, words per minute is not based on the number of words typed, but instead the number of groups of 5 characters, so that a typing test is not biased by the length of words. The formula for words per minute is the ratio of the number of characters (including spaces) typed divided by 5 (a typical word length) to the elapsed time in minutes.</p> <p>实际上就是一个简单的算式</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#phase-2-autocorrect","level":2,"title":"Phase 2: Autocorrect","text":"","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-5-2-pts","level":3,"title":"Problem 5 (2 pts)","text":"<p>Implement <code>autocorrect</code>, which takes a <code>typed_word</code>, a <code>word_list</code>, a <code>diff_function</code>, and a <code>limit</code>. The goal of <code>autocorrect</code> is to return the word in <code>word_list</code> that is closest to the provided <code>typed_word</code>.</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-6-3-pts","level":3,"title":"Problem 6 (3 pts)","text":"<p>Implement <code>feline_fixes</code>, which is a diff function that takes two strings. It returns the minimum number of characters that must be changed in the <code>typed</code> word in order to transform it into the <code>source</code> word. If the strings are not of equal length, the difference in lengths is added to the total.</p> <p>可能需要额外注意判断字符串为空的情况避免调用报错</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-7-3-pts","level":3,"title":"Problem 7 (3 pts)","text":"<p>Implement <code>minimum_mewtations</code>, which is a diff function that returns the minimum number of edit operations needed to transform the <code>typed</code> word into the <code>source</code> word.</p> <p>实现编辑距离（Edit Distance）算法，也称为莱文斯坦距离（Levenshtein Distance）</p> <p>以 <code>typed = \"cats\"</code>，<code>source = \"scat\"</code> 为例：</p> <p>边界条件判断：</p> <pre><code>   ∅  s  c  a  t\n∅  0  1  2  3  4\nc  1  0  0  0  0\na  2  0  0  0  0\nt  3  0  0  0  0\ns  4  0  0  0  0\n</code></pre> <p>填充后得到</p> <pre><code>   ∅  s  c  a  t\n ∅ 0  1  2  3  4\n c 1  1  1  2  3\n a 2  2  2  1  2\n t 3  3  3  2  1\n s 4  3  4  3  2\n</code></pre> <p>实际上就是利用二维数组的思路，然后结合递推公式填充矩阵即可，动态规划类型.</p> <p>关于这个算法的正确性证明我翻了很多中文平台都没有看到写的比较像人的，如果理解不了为什么这样做就是最小的还是看一下这篇paper，这里也贴一个本人的理解，首先我们需要对三种操作都进行分析，三种操作分别是替换，插入，删除权重相同，并且三种操作可选取的位置都是任意的，那么就会出现一个问题，采用逆向思维，再进行最后一步操作的时候恰好两个字符串对齐，那么String1和String2的大半部分一定已经相同了(一定存在一个特别大程度相似的公共字符串)</p> <p>下面开始分类讨论：</p> <ul> <li>替换：只需要一步替换就可以完成的话，两个字符串的长度一定已经相同并且替换位点的后续已经对齐，前面也是对齐的，那么不妨假设前面有\\(i\\)个，那么问题就是前面\\(i\\)个对齐的最小次数+1</li> <li>插入、删除：长度相差1，同样对位点考虑即可，后续问题即变为一个小矩阵，以那个位点为新的顶点进行递归</li> </ul> <p>可以参考Leetcode 72虽然我觉得题解写的也不清楚</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#optional-extension-final-diff-0-pts","level":3,"title":"(Optional) Extension: Final Diff (0 pts)","text":"","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#phase-3-multiplayer","level":2,"title":"Phase 3: Multiplayer","text":"","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-8-2-pts","level":3,"title":"Problem 8 (2 pts)","text":"<p>Implement <code>report_progress</code>, which is called every time the user finishes typing a word. It takes a list of the words <code>typed</code>, a list of the words in the <code>source</code>, the user's <code>user_id</code>, and a <code>upload</code> function that is used to upload a progress report to the multiplayer server. There will never be more words in <code>typed</code> than in <code>source</code>.</p> <p>按照数据抽象使用即可</p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-9-2-pts","level":3,"title":"Problem 9 (2 pts)","text":"<p>写之前看一眼</p> <pre><code>def match(words, times):\n    \"\"\"A data abstraction containing all words typed and their times.\n\n    Arguments:\n        words: A list of strings, each string representing a word typed.\n        times: A list of lists for how long it took for each player to type\n            each word.\n            times[i][j] = time it took for player i to type words[j].\n\n    Example input:\n        words: ['Hello', 'world']\n        times: [[5, 1], [4, 2]]\n    \"\"\"\n    assert all([type(w) == str for w in words]), 'words should be a list of strings'\n    assert all([type(t) == list for t in times]), 'times should be a list of lists'\n    assert all([isinstance(i, (int, float)) for t in times for i in t]), 'times lists should contain numbers'\n    assert all([len(t) == len(words) for t in times]), 'There should be one word per time.'\n    return {\"words\": words, \"times\": times}\n\ndef get_word(match, word_index):\n    \"\"\"A utility function that gets the word with index word_index\"\"\"\n    assert 0 &lt;= word_index &lt; len(get_all_words(match)), \"word_index out of range of words\"\n    return get_all_words(match)[word_index]\n\ndef time(match, player_num, word_index):\n    \"\"\"A utility function for the time it took player_num to type the word at word_index\"\"\"\n    assert word_index &lt; len(get_all_words(match)), \"word_index out of range of words\"\n    assert player_num &lt; len(get_all_times(match)), \"player_num out of range of players\"\n    return get_all_times(match)[player_num][word_index]\n\ndef get_all_words(match):\n    \"\"\"A selector function for all the words in the match\"\"\"\n    return match[\"words\"]\n\ndef get_all_times(match):\n    \"\"\"A selector function for all typing times for all players\"\"\"\n    return match[\"times\"]\n\ndef match_string(match):\n    \"\"\"A helper function that takes in a match data abstraction and returns a string representation of it\"\"\"\n    return f\"match({get_all_words(match)}, {get_all_times(match)})\"\n</code></pre>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Project%202-CS%2061A%20Autocorrected%20Typing%20Software/#problem-10-2-pts","level":3,"title":"Problem 10 (2 pts)","text":"<p>Implement <code>fastest_words</code>, which returns which words each player typed fastest. This function is called once all players have finished typing. It takes in a <code>match</code>.</p> <p>很简单的比大小选择</p> <p></p>","path":["Project 2-CS 61A Autocorrected Typing Software"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/","level":1,"title":"Week 1","text":"","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/#summary","level":2,"title":"Summary","text":"<p>大致需要3.5h完成</p> <ol> <li>建议先看Videos再看Reading，这样对Reading的内容有一个粗略的把握看书会更快</li> <li>一定要写Lab和HW</li> <li>可以先写Lab 00再写HW01</li> </ol>","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/#disc-005min","level":2,"title":"Disc 00(5min)","text":"<ul> <li> Part 0 没有Group pass</li> <li> Part 1 没有Discord账号 pass</li> <li> Part 2 破冰小游戏 pass</li> <li> Part 3 唯一的问题(30 min)</li> </ul> <p>Imagine you can call only the following three functions: - f(x): Subtracts one from an integer x - g(x): Doubles an integer x - h(x, y): Concatenates the digits of two different positive integers x and y. For example, h(789, 12) evaluates to 78912 and h(12, 789) evaluates to 12789.</p> <p>Definition: A small expression is a call expression that contains only f, g, h, the number 5, and parentheses. All of these can be repeated. For example, h(g(5), f(f(5))) is a small expression that evaluates to 103.</p> <p>Q:What’s the shortest small expression you can find that evaluates to 2024? A:h(g(g(5)),g(g(g(f(f(5))))))?</p> <ul> <li> Part 4 拍合照/考勤/讨论Part 3的计算机实现</li> </ul>","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/#reading2h","level":2,"title":"Reading(2h)","text":"<p>Chapter 1: Building Abstractions with Functions</p> <ul> <li>1.1   Getting Started</li> <li>1.2   Elements of Programming</li> <li>1.3   Defining New Functions</li> </ul>","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/#ch-11","level":3,"title":"Ch. 1.1","text":"<p>Computers are very powerful, looking at volumes of data very quickly. Computers can perform billions of operations per second, where each operation is pretty simple. Computers are also shockingly stupid and fragile. The operations that they can do are extremely rigid, simple, and mechanical. The computer lacks anything like real insight ... it's nothing like the HAL 9000 from the movies. If nothing else, you should not be intimidated by the computer as if it's some sort of brain. It's very mechanical underneath it all. Programming is about a person using their real insight to build something useful, constructed out of these teeny, simple little operations that the computer can do.</p>","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/#ch-12","level":3,"title":"Ch. 1.2","text":"<p>As videos and some addition</p> <p>The possibility of binding names to values and later retrieving those values by name means that the interpreter must maintain some sort of memory that keeps track of the names, values, and bindings. This memory is called an environment.</p> <p>pure function:</p> <p>Pure functions have the property that applying them has no effects beyond returning a value. Moreover, a pure function must always return the same value when called twice with the same arguments.</p> <p>Non-pure function:</p> <p>In addition to returning a value, applying a non-pure function can generate side effects, which make some change to the state of the interpreter or computer. A common side effect is to generate additional output beyond the return value, using the print function.</p> <p>Remark: The value that print returns is always None, a special Python value that represents nothing. The interactive Python interpreter does not automatically print the value None. In the case of print, the function itself is printing output as a side effect of being called.</p>","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/#ch-13","level":3,"title":"Ch. 1.3","text":"<p>Defining New Functions</p> <p>Function Signatures. Functions differ in the number of arguments that they are allowed to take. A description of the formal parameters of a function is called the function's signature.</p>","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/#videos1h","level":2,"title":"Videos(1h)","text":"","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/#functions","level":3,"title":"Functions","text":"","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/#call-expression","level":4,"title":"Call expression","text":"<ul> <li>expresstion tree</li> <li>recursion</li> </ul>","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/#names-assignment-and-user-defined-functions","level":4,"title":"Names, Assignment, and User-Defined Functions","text":"<p>Discussion Qustion 1</p> <pre><code>f = min\nf = max\ng, h = min, max\nmax = g\nmax(f(2, g(h(1, 5), 3)), 4)\n</code></pre> <p>Answer: 3</p> <p></p>","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/#environment-diagrams","level":4,"title":"Environment Diagrams","text":"<p>给出了Environment Diagrams的概念，目前粗略感觉就是一个简单的可视化过程(类似单纯形表的东西)</p>","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/#defining-functions","level":4,"title":"Defining Functions","text":"<p>assignment is binding name to values and function can be more powerful to bind names to expressions.</p> <p>Execution procedure for def statements:</p> <ul> <li>create a function with signature</li> <li>set the body</li> <li>bind name to that function in the current frame</li> </ul>","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/#print-and-none","level":4,"title":"Print and None","text":"<p>Interesting case <pre><code># input\nprint(print(2), print(3))\n# output\n2\n3 \nNone  None\n</code></pre></p> <ul> <li>Pure function</li> <li>Non-pure function</li> </ul> <p></p>","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/#lab-0010min","level":2,"title":"Lab 00(10min)","text":"<p>UNIX tutorial</p> <p>纪念一下第一次使用ok的Lab</p> <p></p>","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%201/#hw0115min","level":2,"title":"HW01(15min)","text":"<p>还是比较简单的，比较有趣的是Q4是冰雹猜想，不过确实也是很多OJ上的老题了</p> <p>Remark: + Q1注意返回的是<code>f(a,b)</code>，所以你需要输入的是函数 + Q4冰雹猜想需要注意初始的数和迭代后的1也都需要print + 61A的AIdebug真的好玩，玩过头了</p>","path":["Week 1"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/","level":1,"title":"Week 2","text":"","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#summary","level":2,"title":"Summary","text":"<p>先看Videos再看Reading，需要注意的是Ch 1.6内容很多，每天的Videos只是讲解了其中的一部分内容并且有时不按顺序，可以先全部看完Videos再看Reading</p> <p>大致需要6h完成(不包括project)</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#videos2h","level":2,"title":"Videos(2h)","text":"","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#control","level":3,"title":"Control","text":"","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#multiple-environments","level":4,"title":"Multiple Environments","text":"<p>Life cycle of a User-Defined Function:</p> <ul> <li>Def statement</li> <li>Call expression</li> <li>Calling/Applying</li> </ul> <p>Names have no meaning without environments</p> <p>Names have different meanings in different environments</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#miscellaneous-python-features","level":4,"title":"Miscellaneous Python Features","text":"<ul> <li>truediv and floordiv</li> <li>mod operator</li> </ul> <p>Vim?!</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#doc-test","level":4,"title":"doc test","text":"<pre><code>from operator import floordiv, mod\n\ndef divide_exact(n,d):\n    \"\"\"Return the quotient and remainder of diving N by D.\n\n    &gt;&gt;&gt; q, r = divide_exact(2013, 10)\n    &gt;&gt;&gt; q\n    201\n    &gt;&gt;&gt; r\n    2\n    \"\"\"\n    return floordiv(n, d), mod(n, d)\n\n# We can type python3 -m doctest -v filename.py to get results \n</code></pre> <p>default value (not assignment)： 只是作为一个占位符，在没有赋值的情况下使用，并不是赋值操作</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#conditional-statements","level":4,"title":"Conditional statements","text":"<pre><code>def absolute_value(x):\n    \"\"\"Return the absolute value of x\"\"\"\n    if x &lt; 0:\n        return -x\n    elif x == 0:\n        return 0\n    else:\n        return x\n</code></pre> <p>George Boole: boolean contexts</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#iteration","level":4,"title":"Iteration","text":"<p>Iteration means repeating things</p> <pre><code>i, total = 0, 0\nwhile i &lt; 3:\n    i = i + 1\n    total = total + i\n</code></pre> <p>这个部分就是讲解简单的循环逻辑，感觉可以不用看.</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#higher-order-functions","level":3,"title":"Higher-Order Functions","text":"","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#iteration-example","level":4,"title":"Iteration Example","text":"<p>talk about Fibonacci sequence and quite trivial</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#control_1","level":4,"title":"Control","text":"<p>用一个函数来表达判断的结构</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#control-expressions","level":4,"title":"Control Expressions","text":"<p>Some expressions can be passed in Python like (left and right &amp;&amp; or) </p> <pre><code>def has_big_sqrt(x)\n    return x &gt; 0 and sqrt(x) &gt; 10\n\n# 聪明的设计，这时输入-1000 程序并不会崩溃，说明右侧程序不执行\n</code></pre> <p>精度丢失问题：</p> <pre><code>def reasionable(n):\n    return n == 0 or 1 / n != 0\n\n&gt;&gt;&gt;reasionable(10 ** 10000)\nFalse\n</code></pre>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#higher-order-functions_1","level":4,"title":"Higher-Order Functions","text":"<p>1.Generalizing Patterns with Arguments</p> <ul> <li>Find common shape</li> <li>share solving method</li> </ul> <p>assert statement:</p> <p>like <code>assert r &gt; 0, 'A length must be positive'</code></p> <p>2.Generalizing Over Computational Processes</p> \\[ \\sum\\limits_{k=1}^{5} k,\\sum\\limits_{k=1}^{5} k^{3},\\sum\\limits_{k=1}^{5}  \\frac{8}{(4k-3)(4k-1)} \\] <p>将模式抽象出来进行归纳式的解决以函数为参量，是一种很自然的想法</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#functions-as-return-values","level":4,"title":"Functions as Return Values","text":"<pre><code>def make_adder(n):\n    def adder(k):\n        return k + n # 取决于make_adder的输入\n    return adder \n\n&gt;&gt;&gt; add_three = make_adder(3)\n&gt;&gt;&gt; add_three(4)\n7\n</code></pre> <p>The purpose of Higher-Order Functions</p> <ul> <li>Express general methods of computation</li> <li>Remove repetition from programs</li> <li>Separate concerns among functions</li> </ul>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#environments","level":3,"title":"Environments","text":"","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#environments-for-higher-order-functions","level":4,"title":"Environments for Higher-Order Functions","text":"<pre><code>def apply_twice(f, x):\n    return f(f(x))\n\ndef square(x)\n    return x * x\n\nresult = apply_twice(square, 2)\n</code></pre>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#environments-for-nested-definitions","level":4,"title":"Environments for Nested Definitions","text":"<p>Mainly about how to draw environment diagram and decide the parent frame of any function. </p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#local-names","level":4,"title":"Local names","text":"<p>Formal parameters of functions have a local scope means that if we call a function but the parameter of it doesn't be defined in local frame, it will cause an error.</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#function-composition","level":4,"title":"Function Composition","text":"<p>Use some simple functions to compose a big function.</p> <pre><code>def compose1(f, g):\n    def h(x):\n        return f(g(x))\n    return h\n</code></pre>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#lambda-expressions","level":4,"title":"Lambda Expressions","text":"<p>由于它没有return部分，使用lambda只能创建简单的函数，在Python中也不经常用，但是对于其他语言常用(我学Python和R的，我可以不看吗？)</p> <p></p> <p>Only the def statement gives the function an intrinsic name. </p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#function-currying","level":4,"title":"Function Currying","text":"<pre><code>def curry2(f):\n    def g(x):\n        def h(y):\n            return f(x, y) # 调用输入的参数\n        return h # 第二步开始调用\n    return g # 第一步开始调用\n\ncurry2 = lambda f : lambda x : lambda y : f(x, y)\n</code></pre> <p>Here should be an environment diagram but none.</p> <p>more clear case: </p> <pre><code>def curried_pow(x):\n    def h(y):\n        return pow(x, y)\n    return h\n\n&gt;&gt;&gt; curried_pow(2)(3)\n8\n</code></pre>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#reading2h","level":2,"title":"Reading(2h)","text":"<p>Chapter 1: Building Abstractions with Functions</p> <ul> <li>1.4  Designing Functions</li> <li>1.5  Control </li> <li>1.6  Higher-Order Functions</li> </ul>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#ch-14","level":3,"title":"Ch. 1.4","text":"<p>Functions are an essential ingredient of all programs, large and small, and serve as our primary medium to express computational processes in a programming language.</p> <p>Good functions should obey following guidelines:</p> <ul> <li>only excute one job</li> <li>Don't repeat yourself(DRY)</li> <li>define generally</li> </ul> <p>A function definition will often include documentation describing the function, called a docstring, which must be indented along with the function body. Docstrings are conventionally triple quoted. The first line describes the job of the function in one line. The following lines can describe arguments and clarify the behavior of the function:</p> <p>When you call help with the name of a function as an argument, you see its docstring (type q to quit Python help).</p> <p>例如：<code>help(function name)</code> 就会给出文档说明</p> <p>Comment will be passed by complier but can be read by person.</p> <p><code># comments</code></p> <p>As a guideline, most data values used in a function's body should be expressed as default values to named arguments, so that they are easy to inspect and can be changed by the function caller. Some values that never change, such as the fundamental constant k, can be bound in the function body or in the global frame.</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#ch-15","level":3,"title":"Ch. 1.5","text":"<p>Instead of computing something, executing a control statement determines what the interpreter should do next.</p> <p>Compound statements: 1. header  2. suite 3. clause</p> <p>Practical Guidance. When indenting a suite, all lines must be indented the same amount and in the same way (use spaces, not tabs). Any variation in indentation will cause an error.</p> <p>Some defines: 1. Local assignment 2. Conditional statements 3. Boolean contexts 4. Boolean values 5. Boolean operators</p> <p>About boolean operators:</p> <p>These procedures exploit the fact that the truth value of a logical expression can sometimes be determined without evaluating all of its subexpressions, a feature called short-circuiting.</p> <p>Remark: not calculate all subexpressions</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#test","level":4,"title":"test","text":"<p><code>python3 -m doctest &lt;python_source_file&gt;</code></p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#ch-16","level":3,"title":"Ch. 1.6","text":"<p>To express certain general patterns as named concepts, we will need to construct functions that can accept other functions as arguments or return functions as values. Functions that manipulate functions are called higher-order functions. This section shows how higher-order functions can serve as powerful abstraction mechanisms, vastly increasing the expressive power of our language.</p> <p></p> <p>注：就好像泛函一样，只是这里叫高阶函数</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#golden-ratio-case","level":4,"title":"Golden-ratio case","text":"<pre><code># 主要以两个函数为参数\ndef improve(update, close, guess = 1):\n    while not close(guess): # 停机准则函数\n        guess = update(guess)\n    return guess\n\n# 更新guess的函数\ndef golden_update(guess):\n    return 1 / guess + 1\n\n# 以guess作为输入给出判断(实际上可以合并)\ndef square_close_to_successor(guess):\n    return approx_eq(guess * guess, guess + 1)\n\n# 停机准则函数\ndef approx_eq(x, y, tolerance=1e-3):\n    return abs(x - y) &lt; tolerance\n\nphi = improve(golden_update, square_close_to_successor)\n</code></pre>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#defining-functions-iii-nested-definitions","level":4,"title":"Defining Functions III: Nested Definitions","text":"<p>相当重要的一个东西，做一个函数嵌套</p> <p>Lexical scope. Locally defined functions also have access to the name bindings in the scope in which they are defined.</p> <p>two key advantages of lexical scoping in Python</p> <ul> <li>The names of a local function do not interfere with names external to the function in which it is defined, because the local function name will be bound in the current local environment in which it was defined, rather than the global environment.</li> <li>A local function can access the environment of the enclosing function, because the body of the local function is evaluated in an environment that extends the evaluation environment in which it was defined.</li> </ul> <p>还需要注意环境和函数的关系</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#newtons-method","level":4,"title":"Newton's Method","text":"<p>已经学了不知道多少遍了</p> <p>既然讲了Newton-Raphson Algorithm也应该讲一下Fisher-scoring Algorithm吧(From Mathematical Statistic)</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#currying","level":4,"title":"Currying(柯里化)","text":"<p>\"Currying\" 在英语中，尤其是在编程和数学领域，指的是“柯里化”。柯里化是一种将使用多个参数的函数转换为一系列使用单一参数的函数的技术。</p> <p>Currying allows us to do so without writing a specific function for each number whose powers we wish to compute.</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#lambda-function","level":4,"title":"Lambda function","text":"<p>是一种简洁的函数表示方法但是由于理解的不容易不怎么使用，在Python中更倾向于使用def而不是lambda函数(为了方便别人也为了方便自己，知道这个用法应当足够，自己的程序最好还是不要用了)</p> <p>Standard formal:</p> <p>lambda x : f(g(x)) means \"A function that  takes x  and returns  f(g(x))\"</p> <p>Case: </p> <p><code>compose1 = lambda f, g : lambda x: f(g(x))</code></p> <p>The significance of higher-order functions is that they enable us to represent these abstractions explicitly as elements in our programming language, so that they can be handled just like other computational elements.</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#function-decorators","level":4,"title":"Function Decorators","text":"<p>相当于在原本函数的基础上增加一些新的小功能并且不更改函数名和原本调用</p> <p>Question: 为什么不直接重构呢？</p> <p>以下是一些可能的原因(瞎琢磨)：</p> <ul> <li>代码复用(用一个片段一直修饰不同的函数)</li> <li>保证原本函数的简洁</li> <li>所谓的\"开闭原则\"</li> <li>方便维护和扩展(装饰器的部分应该不是函数核心的功能，如果不用或是修改的话可以直接重构多个函数)</li> </ul>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#lab-011h","level":2,"title":"Lab 01(1h)","text":"<p>[!tip] 写完一定要对答案!</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#what-would-python-display-wwpd","level":3,"title":"What Would Python Display? (WWPD)","text":"","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#q1-wwpd-control","level":4,"title":"Q1: WWPD: Control","text":"<p>注意：Python的函数在没有显式使用return的情况下默认返回None，print后就会得到None</p> <p>例子</p> <pre><code>def how_big(x):\n    if x &gt; 10: \n        print('huge') \n    elif x &gt; 5: \n        return 'big' \n    if x &gt; 0: \n        print('positive') \n    else: \n        print(0)\n\n&gt;&gt;&gt; print(how_big(12))\nline1 huge\nline2 positive\nline3 None\n</code></pre>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#q2-debugging-quiz","level":4,"title":"Q2: Debugging Quiz","text":"<p>有点搞，不知道为什么交互式做选择题比单纯做题有乐子，做题家基因觉醒了.</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#write-code","level":3,"title":"Write Code","text":"","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#q3-falling-factorial","level":4,"title":"Q3: Falling Factorial","text":"<p>唯一的问题是要把所有的doctest和题目看完，不要直接写</p> <p>答案没有专门对0判断而是用了更聪明的做法(移项可知\\(k&gt;0\\))</p> <pre><code>total, stop = 1, n-k  \nwhile n &gt; stop:  \n    total, n = total*n, n-1  \nreturn total\n</code></pre>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#q4-divisible-by-k","level":4,"title":"Q4: Divisible By k","text":"<p>相当于实现一个更完整的range函数</p> <p>感觉写的不是特别好</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#q5-sum-digits","level":4,"title":"Q5: Sum Digits","text":"<p>经典的OJ题，做法太多了</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#syllabus-quiz","level":3,"title":"Syllabus Quiz","text":"","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#q6-syllabus-quiz","level":4,"title":"Q6: Syllabus Quiz","text":"<p>做不了</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#optional-questions","level":3,"title":"Optional Questions","text":"","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#q7-wwpd-what-if","level":4,"title":"Q7: WWPD: What If?","text":"<p>非常容易不知道和前面比难在哪</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#q8-double-eights","level":4,"title":"Q8: Double Eights","text":"<p>同样非常容易，OJ老题</p> <p>这个参考答案节约了一些空间</p> <pre><code>def double_eights_alt(n):  \n    while n:  \n        if n % 10 == 8 and n // 10 % 10 == 8:  \n            return True  \n        n //= 10  \n    return False\n</code></pre>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#disc-0130min","level":2,"title":"Disc 01(30min)","text":"","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#while-and-if","level":3,"title":"While and If","text":"","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#q1-race","level":4,"title":"Q1: Race","text":"<pre><code>def race(x, y):\n    \"\"\"The tortoise always walks x feet per minute, while the hare repeatedly\n    runs y feet per minute for 5 minutes, then rests for 5 minutes. Return how\n    many minutes pass until the tortoise first catches up to the hare.\n\n    &gt;&gt;&gt; race(5, 7)  # After 7 minutes, both have gone 35 steps\n    7\n    &gt;&gt;&gt; race(2, 4) # After 10 minutes, both have gone 20 steps\n    10\n    \"\"\"\n    assert y &gt; x and y &lt;= 2 * x, 'the hare must be fast but not too fast'\n    tortoise, hare, minutes = 0, 0, 0\n    while minutes == 0 or tortoise - hare:\n        tortoise += x\n        if minutes % 10 &lt; 5:\n            hare += y\n        minutes += 1\n    return minutes\n</code></pre> <p>错误应该为乌龟超越兔子但二者行走距离不同，第二次追及</p> <p>Wrong value：(2，3),(6, 11)</p> <p>注1：直接考虑构建一个二元方程组，考虑特殊情况下运动相同距离就应该是在兔子运动时相遇，\\((10+t)x=(5+t)y\\)，此时只需要取整数解即可\\((1\\leqslant t \\leqslant 5)\\)，随便取一个好算的分数通分即可(注意不要循环起来也不要是整数比，两倍肯定相同，小技巧是选取互素的整数对(x, y)且gcd(x,5)=1，注意这样在第一轮就始终无法走相同距离)</p> <p>注2：好像应该用试的但是没忍住分析了一下</p> <p>无限运行应该是乌龟超过兔子后兔子追不上</p> <p>Runs forever：(4, 5)</p> <p>注3：延续上面的思路即可\\((10k+t)x=(5k+t)y\\)，考虑互素的情形，并且不为两倍关系直接令\\(y=5\\)，令\\(t=5\\)排除\\(x=3\\implies x=4\\)</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#q2-fizzbuzz","level":4,"title":"Q2: Fizzbuzz","text":"<p>非常简单的判断，代码参考repo</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#q3-is-prime","level":4,"title":"Q3: Is Prime?","text":"<p>经典素数筛，理论上有许多筛法，这里偷懒直接选用了一个最基本的数论结果</p> <pre><code>if n == 1:  \n    return False  \nk = 2  \nwhile k &lt; (n / 2):  \n    # save time  \n    if n % k == 0:  \n        return False  \n    k += 1  \nreturn True\n</code></pre>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#q4-unique-digits","level":4,"title":"Q4: Unique Digits","text":"<p>完成两个函数即可，第一个只需要在第二个函数基础上写while循环</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#q5-bottles","level":4,"title":"Q5: Bottles","text":"<p>pass</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#q6-double-trouble","level":4,"title":"Q6: Double Trouble","text":"","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%202/#hw0230min","level":2,"title":"HW02(30min)","text":"<p>大都比较简单，不再赘述，代码可参考仓库</p>","path":["Week 2"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/","level":1,"title":"Week 3","text":"","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#summary","level":2,"title":"Summary","text":"<p>大概需要2.5小时，Lab质量相当高，可以很好的弥补理解上的一些问题</p>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#videos1h","level":2,"title":"Videos(1h)","text":"","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#functional-abstraction","level":3,"title":"Functional Abstraction","text":"","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#lambda-function-environments","level":4,"title":"Lambda Function Environments","text":"<p>This is main case:</p> <pre><code>a = 1\ndef f(g):\n    a = 2\n    return lambda y: a * g(y)\nf(lambda y: a + y)(a)\n\n# we can get 4(2 * (1 + 1))\n</code></pre>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#return","level":4,"title":"Return","text":"<pre><code>def search(f):\n    \"\"\"找出能够返回Ture的最小非负整数\"\"\"\n    x = 0\n    while True:\n        if f(x):\n            return x\n        x += 1\n    # 下面是一个改进版本\n    while not f(x):\n        x += 1\n    return x\n\ndef inverse(f):\n    \"\"\"Return g(y) such that g(f(x)) -&gt; x.\"\"\"\n    # 找出使f(x)=y成立的最小x\n    return lambda y: search(lambda x: f(x) == y)\n\n# 找反函数\nsqrt = inverse(square) \n</code></pre>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#abstraction","level":4,"title":"Abstraction","text":"<p>Choose a name for valued function or parameters.</p> <p>Some name guideline. </p>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#errors-tracebacks","level":4,"title":"Errors &amp; Tracebacks","text":"<p>Teach you check some errors and read tracebacks</p>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#function-examples","level":3,"title":"Function Examples","text":"","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#midterm-1-review","level":4,"title":"Midterm 1 Review","text":"<ul> <li>WWPP</li> </ul> <pre><code>def delay(arg):\n    print('delayed')\n    def g():\n        return arg\n    return g\n\ndelay(delay)()(6)()\n\n# 分析\n# delay(delay) -&gt; 返回g 传入参数为delay函数 print也被调用\n# delay(delay)() -&gt; 调用g 返回delay\n# delay(delay)()(6) -&gt; 调用delay 传入参数为6 相当于delay(6)=g print也被调用\n# delay(delay)()(6)() -&gt; 调用g() 上一步知道传入参数为6 返回6\n\nprint(delay(print)()(4))\n\n# 同理分析即可\n</code></pre> <p>Last example but a litttle difficult</p> <pre><code>def horse(mask):\n    horse = mask\n    def mask(horse):\n        return horse\n    return horse(mask)\n\nmask = lambda horse: horse(2)\n\nhorse(mask)\n</code></pre> <p>有一种当年玩指针的美感(只要正确的指向就可以明白，这里的环境图确实是加进理解的一种手段)</p> <p></p>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#implementing-functions","level":4,"title":"Implementing Functions","text":"<p>Strategy:</p> <ul> <li>Read the description</li> <li>Verify the example &amp; pick a simple one</li> <li>If the template is helpful, use it</li> <li>Write cide to compute the result</li> </ul> <p>A case</p> <pre><code>def remove(n, digit):\n    kept, digits = 0, 0\n    while n &gt; 0:\n        n, last = n // 10, n % 10\n        if last != digit:\n            kept = kept + last * 10 ** digits\n            digits += 1\n    return kept\n</code></pre>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#decoraters","level":4,"title":"Decoraters","text":"<pre><code>def trace1(fn):\n\"\"\"Return a version of fn\"\"\"\n    def traced(x):\n        print('Calling', fn, 'on argument', x)\n        return fn(x)\n    return traced\n\n@trace1 # square = trace1(square)\ndef square(x):\n    return x * x\n\n@trace1\ndef sum_squares_ up_to(n):\n    k = 1\n    total = 0\n    while k &lt;= n:\n        total, k = total + square(k), k + 1\n    return total\n</code></pre>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#lab-021h","level":2,"title":"Lab 02(1h)","text":"<p>前面是一些基础的Review部分，算是强行带你复习吗?感觉还是不错的，给出了Short-circuiting这个概念详细的解释</p> <p>这里需要注意lambda表达式和def表达式的一些细微区别</p> <pre><code># A lambda expression by itself does not alter\n# the environment\nlambda x: x * x\n# We can assign lambda functions to a name\n# with an assignment statement\nsquare = lambda x: x * x\nsquare(3)\n\n# Lambda expressions can be used as an operator\n# or operand\nnegate = lambda f, x: -f(x)\nnegate(lambda x: x * x, 3)\n</code></pre> <p>Note: As we saw in the <code>lambda</code> expression section above, <code>lambda</code> functions have no intrinsic name. When drawing <code>lambda</code> functions in environment diagrams, they are labeled with the name <code>lambda</code> or with the lowercase Greek letter λ. This can get confusing when there are multiple lambda functions in an environment diagram, so you can distinguish them by numbering them or by writing the line number on which they were defined.</p>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#wwpd","level":3,"title":"WWPD","text":"","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#q1-wwpd-the-truth-will-prevail","level":4,"title":"Q1: WWPD: The Truth Will Prevail","text":"<p>If <code>and</code> and <code>or</code> do not short-circuit, they just return the last value; another way to remember this is that <code>and</code> and <code>or</code> always return the last thing they evaluate, whether they short circuit or not. Keep in mind that <code>and</code> and <code>or</code> don't always return booleans when using values other than <code>True</code> and <code>False</code>.</p> <p>Used above info.</p> <pre><code># 有点阴的例子\nprint(3) or ''\n# print会执行但是返回的None是假值，而空字符串也是假值，于是最终返回最后计算的空字符串\n# 3\n# ''\n</code></pre> <p>只要做完就会对短路求值这件事彻底理解</p>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#q2-wwpd-higher-order-functions","level":4,"title":"Q2: WWPD: Higher-Order Functions","text":"<p>这个也有点搞，需要稍微仔细一点去想返回的是函数还是调用函数</p>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#q3-wwpd-lambda","level":4,"title":"Q3: WWPD: Lambda","text":"<pre><code># case 无参数 还真没想过\n(lambda: 3)()\n</code></pre> <p>注：这个lab真是大开眼界了</p>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#coding-practice","level":3,"title":"Coding Practice","text":"","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#q4-composite-identity-function","level":4,"title":"Q4: Composite Identity Function","text":"","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#q5-count-cond","level":4,"title":"Q5: Count Cond","text":"<p>这些代码并不难，答案也没有什么很优雅的做法</p>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#environment-diagram-practice","level":3,"title":"Environment Diagram Practice","text":"","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#q6-hof-diagram-practice","level":4,"title":"Q6: HOF Diagram Practice","text":"","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#optional-questions","level":3,"title":"Optional Questions","text":"","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#q7-multiple","level":4,"title":"Q7: Multiple","text":"<p>实际上应该是找最小公倍数的问题，有很多优化算法，偷懒打个简单的</p> <pre><code>i = 1  \nwhile True:  \n    if (max(a, b) * i) % min(a, b) == 0:  \n        return max(a, b) * i  \n    else:  \n        i += 1\n</code></pre> <p>可能答案想打个遍历吧，但是显然这样复杂度对于大数来说不划算</p>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#q8-i-heard-you-liked-functions","level":4,"title":"Q8: I Heard You Liked Functions...","text":"<p>这个题目也是够套娃的...但是也还好逻辑比较简单</p> <p>Define a function <code>cycle</code> that takes in three functions <code>f1</code>, <code>f2</code>, and <code>f3</code>, as arguments. <code>cycle</code> will return another function <code>g</code> that should take in an integer argument <code>n</code> and return another function <code>h</code>. That final function <code>h</code> should take in an argument <code>x</code> and cycle through applying <code>f1</code>, <code>f2</code>, and <code>f3</code> to <code>x</code>, depending on what <code>n</code> was. Here's what the final function <code>h</code> should do to <code>x</code> for a few values of <code>n</code>:</p> <ul> <li><code>n = 0</code>, return <code>x</code></li> <li><code>n = 1</code>, apply <code>f1</code> to <code>x</code>, or return <code>f1(x)</code></li> <li><code>n = 2</code>, apply <code>f1</code> to <code>x</code> and then <code>f2</code> to the result of that, or return <code>f2(f1(x))</code></li> <li><code>n = 3</code>, apply <code>f1</code> to <code>x</code>, <code>f2</code> to the result of applying <code>f1</code>, and then <code>f3</code> to the result of applying <code>f2</code>, or <code>f3(f2(f1(x)))</code></li> <li><code>n = 4</code>, start the cycle again applying <code>f1</code>, then <code>f2</code>, then <code>f3</code>, then <code>f1</code> again, or <code>f1(f3(f2(f1(x))))</code></li> <li>And so forth.</li> </ul> <p>Hint: most of the work goes inside the most nested function.</p> <p>保险起见写了一个特别简单的版本，可以参考答案的做法</p> <pre><code>def classifier(n):  \n    def inner_loop(x):  \n        i = 1  \n        while i &lt;= n:  \n            if (i % 3) == 1:  \n                x = f1(x)  \n            elif (i % 3) == 2:  \n                x = f2(x)  \n            elif (i % 3) == 0:  \n                x = f3(x)  \n            i += 1  \n        return x  \n    return inner_loop  \nreturn classifier\n</code></pre> <p>优雅的递归解法</p> <pre><code>def g(n):  \n    def h(x):  \n        if n == 0:  \n            return x  \n        return cycle(f2, f3, f1)(n - 1)(f1(x))  \n    return h  \nreturn g\n</code></pre>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#disc-0230min","level":2,"title":"Disc 02(30min)","text":"<p>相应的测试代码在CS61A的仓库内</p>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#q1-warm-up","level":3,"title":"Q1: Warm Up","text":"<p>trivial</p>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#q2make-keeper","level":3,"title":"Q2：Make Keeper","text":"<p>也是很简单的</p> <pre><code>def cond(f):  \n    i = 1  \n    while i &lt;= n:  \n        if f(i):  \n            print(i)  \n        i += 1  \nreturn cond\n</code></pre>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#q3-digit-finder","level":3,"title":"Q3: Digit Finder","text":"<pre><code>def give_digit(x):  \n    return (x // (pow(10, k-1))) % 10  \nreturn give_digit\n</code></pre> <p>答案使用的是lambda匿名封装(效果可能差不多但是有点帅，想学)</p> <pre><code>return lambda x: (x // pow(10, k-1)) % 10\n</code></pre>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%203/#q4-match-maker","level":3,"title":"Q4: Match Maker","text":"<p>也比较简单，因为已给出了一个框架</p> <pre><code>def check(x):  \n    while x // (10 ** k) &gt; 0:  \n        if (x % 10) != (x // (10 ** k)) % 10:  \n            return False  \n        x //= 10  \n    return True  \nreturn check\n</code></pre> <p>总的来说Disc还是比较简单的</p>","path":["Week 3"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/","level":1,"title":"Week 4","text":"","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#summary","level":2,"title":"Summary","text":"<p>大概需要5小时，本次的HW很有价值</p> <p>一些小建议：</p> <ul> <li>不一定需要做笔记，理解&gt;记录(优先于)，可以先观看完后根据印象重写代码或是写一下随想</li> <li>最好定期复习，这时笔记发挥作用</li> <li>可以尝试修改一些课程的代码(实践促进理解)</li> </ul>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#videos1h","level":2,"title":"Videos(1h)","text":"","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#recursion","level":3,"title":"Recursion","text":"","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#self-reference","level":4,"title":"Self-Reference","text":"<pre><code>def print_all(x):\n    print(x)\n    return print_all\n\nprint_all(1)(2)(3)\n</code></pre> <p>sum case:</p> <pre><code>def print_sums(x):\n    print(x)\n    def next_sum(y)\n        return print_sums(x+y)\n    return next_sum\n\nprint_sums(1)(3)(5)\n</code></pre>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#recursive-functions","level":4,"title":"Recursive Functions","text":"<p>Digit Sums</p> <pre><code>def split(n):\n    return n // 10, n % 10\n\ndef sum_digits(n):\n    if n &lt; 10；\n        return n\n    else:\n        all_but_last, last = split(n)\n        return sum_digits(all_but_last) + last\n</code></pre>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#recursion-in-environment-diagrams","level":4,"title":"Recursion in Environment Diagrams","text":"<pre><code>def fact(n):\n    if n == 0:\n        return 1\n    else:\n        return n * fact(n-1)\n\nfact(3)\n</code></pre> <p>Iteration is a special case of recursion.</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#verifying-recursive-functions","level":4,"title":"Verifying Recursive Functions","text":"","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#mutual-recursion","level":4,"title":"Mutual Recursion","text":"<p>The Luhn Algorithm</p> <p>Actually, I have seen this algorithm in CS50x before and it was the optional case in problem set.</p> <p>Very Interesting!</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#recursion-and-iteration","level":4,"title":"Recursion and Iteration","text":"<p>some examples and we can change any iteration case to recursion type.</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#tree-recursion","level":3,"title":"Tree Recursion","text":"","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#order-of-recursive-calls","level":4,"title":"Order of Recursive Calls","text":"<p>cascade case:</p> <pre><code>def cascade(n):\n    print(n)\n    if n &gt;= 10:\n        cascade(n // 10)\n        print(n)\n\ndef cascade(n):\n    if n &lt; 10:\n        print(n)\n    else:\n        print(n)\n        cascade(n // 10)\n        print(n)\n</code></pre> <p>write code for people!</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#example-inverse-cascade","level":4,"title":"Example: Inverse Cascade","text":"<pre><code>def inverse_cascade(n):\n    grow(n)\n    print(n)\n    shrink(n)\n\ndef f_then_g(f, g, n):\n    if n:\n        f(n)\n        g(n)\n\ngrow = lambda n: f_then_g(grow, print, n // 10)\nshrink = lambda n: f_then_g(print, shrink, n // 10)\n</code></pre>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#tree-recursion_1","level":4,"title":"Tree Recursion","text":"<pre><code>def Fib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n         return Fib(n-1) + Fib(n-2)\n</code></pre>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#reading1h","level":2,"title":"Reading(1h)","text":"<p>Chapter 1: Building Abstractions with Functions + 1.7 Recursive Functions</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#ch-17","level":3,"title":"Ch. 1.7","text":"<p>A function is called recursive if the body of the function calls the function itself, either directly or indirectly.</p> <p>An example use recursion function to calculate sum of digits</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#the-anatomy-of-recursive-functions","level":4,"title":"The Anatomy of Recursive Functions","text":"<p>Treating a recursive call as a functional abstraction has been called a recursive leap of faith.</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#mutual-recursion_1","level":4,"title":"Mutual Recursion","text":"<p>When a recursive procedure is divided among two functions that call each other, the functions are said to be mutually recursive.</p> <pre><code>def is_even(n):\n    if n== 0:\n        return True\n    else:\n        return is_odd(n-1)\n\ndef is_odd(n):\n    if n == 0:\n        return False\n    else:\n        return is_even(n-1)\n\nresult = is_even(4)\n</code></pre> <p>No matter even or odd, the function will return iff n equals to 0.</p> <p>As such, mutual recursion is no more mysterious or powerful than simple recursion, and it provides a mechanism for maintaining abstraction within a complicated recursive program.</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#printing-in-recursive-functions","level":4,"title":"Printing in Recursive Functions","text":"<p>talk about the cascade function in videos, here is passed.</p> <p>One another case:</p> <p>As another example of mutual recursion, consider a two-player game in which there are n initial pebbles on a table. The players take turns, removing either one or two pebbles from the table, and the player who removes the final pebble wins. Suppose that Alice and Bob play this game, each using a simple strategy:</p> <ol> <li>Alice always removes a single pebble</li> <li>Bob removes two pebbles if an even number of pebbles is on the table, and one otherwise</li> </ol> <p>Use mutual recursion</p> <pre><code>def play_alice(n):\n    if n == 0:\n        print(\"Bob wins!\")\n    else:\n        play_bob(n-1)\n\ndef play_bob(n):\n    if n == 0:\n        print(\"Alice wins!\")\n    elif is_even(n):\n        play_alice(n-2)\n    else:\n        play_alice(n-1)\n</code></pre> <p>Remark: This code pattern can be used in any two-players game, and help dinner major in Math(Stat\\OR...) save a lot of time.</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#tree-recursion_2","level":4,"title":"Tree Recursion","text":"<p>Classical Fibonacci computation and use recursion algorithm.</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#example-partitions","level":4,"title":"Example: Partitions","text":"<p>The number of partitions of a positive integer n, using parts up to size m, is the number of ways in which n can be expressed as the sum of positive integer parts up to m in increasing order. For example, the number of partitions of 6 using parts up to 4 is 9.</p> <p>Obviously, we can use recursion to solve the problem and code below.</p> <p>The most important is get the recursion process, and the (n, m) can be devided two parts:</p> <ol> <li>(n, m-1) no doubt one case</li> <li>we use the m so remain n-m to devide: (n-m, m)</li> </ol> <pre><code># The number of ways to partition n using integers up to m equals\ndef partitions(n, m):\n    \"\"\"Count the ways to partition n using parts up to m\"\"\"\n    # 1. There is one way to partition 0: include no parts.\n    if n == 0:\n        return 1\n    #  There are 0 ways to partition a negative n.\n    elif n &lt; 0:\n        return 0\n    # There are 0 ways to partition any n greater than 0 using parts of size 0 or less.\n    elif m &lt;= 0: # the book use m == 0, but I think this is better.\n        return 0\n    # main recursion algorithm\n    else:\n        return partitions(n-m, m) + partitions(n, m-1)\n</code></pre>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#disc-031h30min","level":2,"title":"Disc 03(1h30min)","text":"","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#recursion_1","level":3,"title":"Recursion","text":"<p>实现均可以参考仓库</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#q1-swipe","level":4,"title":"Q1: Swipe","text":"<p>不太难</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#q2-skip-factorial","level":4,"title":"Q2: Skip Factorial","text":"<p>不太难</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#q3-is-prime","level":4,"title":"Q3: Is Prime","text":"<p>不太难</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#q4-recursive-hailstone","level":4,"title":"Q4: Recursive Hailstone","text":"<p>不太难</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#some-interesting-questions","level":3,"title":"Some interesting questions","text":"","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#q5-sevens","level":4,"title":"Q5: Sevens","text":"<p>还是比较容易的，可能判断起来有点麻烦</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#q6-karel-the-robot","level":4,"title":"Q6: Karel the Robot","text":"<p>卡在这里比较长时间，网上的答案大多也是错的</p> <pre><code>from karel.stanfordkarel import *\n\n\ndef main():\n    if front_is_clear():\n        move()\n        if front_is_clear():\n            move()\n            if front_is_clear():\n                main()\n    if front_is_blocked(): \n       turn_left()\n       turn_left()\n    move()\n</code></pre>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#hw031h30min","level":2,"title":"HW03(1h30min)","text":"","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#q1-num-eights","level":3,"title":"Q1: Num Eights","text":"<p>不难</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#q2-digit-distance","level":3,"title":"Q2: Digit Distance","text":"<p>不难，答案写的略微复杂</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#q3-interleaved-sum","level":3,"title":"Q3: Interleaved Sum","text":"<p>编写过程中会很自然意识到需要倒序递归，其实编写一个反序的就可以，有点类似第二数学归纳法的感觉</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#q4-count-coins","level":3,"title":"Q4: Count Coins","text":"<p>此事在CS50x中亦有记载</p> <p>类似之前例子中的Partitions吧(或者Catlant数?)，经典OJ题了</p> <p>不知道为什么官方写辅助函数不多写一个判断返回0，自己编写完成后查看报错发现返回了错误类型(增加判断None)，如果发现和测试对不上可以自己找案例测试一下(比如total为0应该返回1)</p> <p>编写时可以思考各个判断之间的依赖关系(可能有冗余判断)，笔者选择对特殊情况添加判断以在大数部分节约机时(但其实没有这个判断也可以跑通)</p> <p>注：本次HW的选做题比较难也比较有意思，尤其是最后一道题确实有一定难度</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#q5-towers-of-hanoi","level":3,"title":"Q5: Towers of Hanoi","text":"<p>坏孩子原本想直接使用递推式(\\(a_{n}=2a_{n-1}+1\\))，后发现还需要打印步骤，那么只好老老实实写递归</p> <p>这里有一个小技巧，如何判断除了start和end外剩余的柱子，只需要利用label做减法(6 - start - end)自然可以得到.</p> <p>主要思想是逆向思维：将下层视为没有(因为是最大的所以一定是做底的)，只需要考虑将剩余部分挪到辅助柱上，然后将最大的一层挪到3，此时剩余所有的柱子一定在2上，剩下就是将原本的1作为辅助柱，循环下去.</p> <p>编写出的代码也基本符合这一思想</p> <pre><code>if n == 1:  \n    print_move(start, end)  \nelse:  \n    other = 6 - start - end  \n    move_stack(n-1, start, other)  \n    print_move(start, end)  \n    move_stack(n-1, other, end)\n</code></pre> <p>这个时候就体现了书中“信仰之跃”的重要性，不要管怎么实现的，假设已经实现了，然后只要把简单的case定好，能够覆盖所有的收敛情况即可.</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%204/#q6-anonymous-factorial","level":3,"title":"Q6: Anonymous Factorial","text":"<p>This question demonstrates that it's possible to write recursive functions without assigning them a name in the global frame.</p> <p>实际编写：</p> <p>Step 1: 确认输入输出，输入一个数记为k，返回一个高阶函数F'以函数F为参数</p> <p>T(F): lambda F: lambda k: F(F, k)</p> <p>Step 2: 思考输入的F的构造，应当接受两个参量，k为1返回1，否则就进行一个类似递归的计算</p> <p>F = lambda f, k: 1 if k == 1 else k * f(f, k - 1) </p> <p>此处不妨假设f(f, k - 1)就是所需要的递归函数</p> <p>实际最终函数是：</p> <p>lambda k: (lambda f, k: 1 if k == 1 else k * f(f, k - 1))((lambda f, k: 1 if k == 1 else k * f(f, k - 1)), k)</p> <p>下面是可能有用的推演过程</p> <p>尝试：输入一个f直接代表递归函数，并且f只接受一个k</p> <p>lambda f: (lambda k: f(k))--(lambda k: 1 if k == 0 else k * f(k - 1)?)</p> <p>发现无法调用f,判断必须要求两个输入f, k以调用希望的f(k - 1)，那么进行修改，仍然认为f(k)是我们需要的递归函数，但是需要两个输入，增加假定f(f, k)也是我们需要的阶乘函数</p> <p>(lambda f: (lambda k: f(f, k)))--(lambda f, k: 1 if k == 0 else k * f(f, k - 1))</p> <p>仍然是信仰之跃！</p>","path":["Week 4"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/","level":1,"title":"Week 5","text":"","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#summary","level":2,"title":"Summary","text":"<p>大概需要5h，不包括完成Project的时间，终于进入了Python比较核心的部分，有了Lists, Slicing, Container等概念，发现软件老师使用的例子与61A的例子一模一样.</p> <p>总的来说，抽象化的教学还是有益的，虽然前期进展的很慢，但是培养了比较良好的习惯，比如Absraction Barriers方便后续维护的这种意识.</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#videos2h","level":2,"title":"Videos(2h)","text":"","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#sequences","level":3,"title":"Sequences","text":"","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#lists","level":4,"title":"Lists","text":"<p>Note that the begining index is 0 not 1, and elements of lists can be various </p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#containers","level":4,"title":"Containers","text":"","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#for-statements","level":4,"title":"For Statements","text":"<pre><code>&gt;&gt;&gt; range(-2, 2)\n-2 -1 0 1 \n&gt;&gt;&gt; range(4)\n&gt;&gt;&gt; 0 1 2 3\n</code></pre>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#list-comprehensions","level":4,"title":"List Comprehensions","text":"<pre><code>&gt;&gt;&gt; odds = [1, 3, 5, 7, 9]\n&gt;&gt;&gt; [x + 1 for x in odds]\n[2, 4, 6, 8, 10]\n&gt;&gt;&gt; [x for x in odds if 25 % x == 0]\n[1, 5]\n</code></pre> <pre><code>def divisions(n):\n    return [1] + [x for x in range(2, n) if n % x == 0]\n</code></pre>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#lists-slices-recursion","level":4,"title":"Lists, Slices, &amp;Recursion","text":"<pre><code># Recursion examples: sum\ndef sum_list(s):\n    if len(s) == 0:\n        return 0\n    else:\n        return s[0] + sum_list(s[1:])\n</code></pre> <p>A case more complex but can be done.</p> <pre><code>def large(s, n):\n    \"\"\"return the sublist of positive numbers s with the \n    largest sum that is less than or equal to n\"\"\"\n    if s == []:\n        return []\n    elif s[0] &gt; n:\n        return large(s[1:], n)\n    else:\n        first = s[0]\n        with_s0 = [first] + large(s[1:], n - first)\n        without_s0 = large(s[1:], n)\n        if sum_list(with_s0) &gt; sum_list(without_s0):\n            return with_s0\n        else:\n            return without_s0\n</code></pre> <p>Remark: Like conditional probability trick used in probability theory, we get complex situation easier by make proper condition or division events.</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#containers_1","level":3,"title":"Containers","text":"","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#box-and-pointer-notation","level":4,"title":"Box-and-Pointer Notation","text":"<p>Just a way like environmental diagram to explain the list operations.</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#slicing","level":4,"title":"Slicing","text":"<p>Very important skill used in python and we can see some cases:</p> <pre><code>&gt;&gt;&gt; odds = [3, 5, 7, 9, 11]\n&gt;&gt;&gt; odds[1:3]\n[5, 7]\n</code></pre>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#processing-container-values","level":4,"title":"Processing Container Values","text":"<p>sum, max and all function, and these functions can be found in R also.</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#strings","level":4,"title":"Strings","text":"<p>The native data type for text in Python is called a string, and corresponds to the constructor str.</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#dictionaries","level":4,"title":"Dictionaries","text":"<p>mentioned unhashable(leave for 61b)</p> <pre><code>{&lt;key exp&gt;: &lt;value exp&gt; for &lt;name&gt; in &lt;iter exp&gt; if &lt;filter exp&gt;}\n{x * x: x for x in [1, 2, 3, 4, 5] if x &gt; 2} evaluates to {9: 3, 16: 4, 25: 5}\n</code></pre>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#data-abstraction","level":3,"title":"Data Abstraction","text":"","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#data-abstraction_1","level":4,"title":"Data Abstraction","text":"<p>Isolate two parts of data</p> <ul> <li>How data are represented</li> <li>How data are manipulated</li> </ul>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#representing-rational-numbers","level":4,"title":"Representing Rational Numbers","text":"<pre><code> pair = [1, 2]\n x, y = pair\n &gt;&gt;&gt;x\n 1\n &gt;&gt;&gt;y\n 2\n&gt;&gt; &gt;get item(pair, 0)\n1\n</code></pre> <p>We have two ways to access the elements of list.</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#abstraction-barriers","level":4,"title":"Abstraction Barriers","text":"","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#data-representations","level":4,"title":"Data Representations","text":"<p>You can read Ch. 2.2 for more info about abstraction barriers.</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#reading2h","level":2,"title":"Reading(2h)","text":"<p>Chapter 2: Building Abstractions with Data + 2.1   Introduction + 2.2   Data Abstraction + 2.3   Sequences</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#ch-21","level":3,"title":"Ch. 2.1","text":"<p>This chapter focuses on data. The techniques we investigate here will allow us to represent and manipulate information about many different domains. Due to the explosive growth of the Internet, a vast amount of structured information is freely available to all of us online, and computation can be applied to a vast range of different problems. Effective use of built-in and user-defined data types are fundamental to data processing applications.</p> <p>Native data types have the following properties:</p> <ol> <li>There are expressions that evaluate to values of native types, called literals.</li> <li>There are built-in functions and operators to manipulate values of native types.</li> </ol> <p>Python includes three native numeric types: integers (int), real numbers (float), and complex numbers (complex).</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#ch-22","level":3,"title":"Ch. 2.2","text":"<p>We are using here a powerful strategy for designing programs: wishful thinking. We haven't yet said how a rational number is represented, or how the functions numer, denom, and rational should be implemented. Even so, if we did define these three functions, we could then add, multiply, print, and test equality of rational numbers:</p> <p>These functions are called by a higher level and implemented using a lower level of abstraction.</p> <p>The fewer functions that depend on a particular representation, the fewer changes are required when one wants to change that representation.</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#ch-23","level":3,"title":"Ch. 2.3","text":"<p>Python includes several native data types that are sequences, the most important of which is the list.</p> <p>For sequences, addition and multiplication do not add or multiply elements, but instead combine and replicate the sequences themselves.</p> <p>This pattern of binding multiple names to multiple values in a fixed-length sequence is called sequence unpacking; it is the same pattern that we see in assignment statements that bind multiple names to multiple values.</p> <pre><code>for x, y in pairs:\n    if x == y:\n        same_count = same_count + 1\n</code></pre>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#lab-0330min","level":2,"title":"Lab 03(30min)","text":"<p>Very Trivial</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#lists_1","level":3,"title":"Lists","text":"","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#q1-wwpd-lists-ranges","level":4,"title":"Q1: WWPD: Lists &amp; Ranges","text":"","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#q2-print-if","level":4,"title":"Q2: Print If","text":"","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#q3-close","level":4,"title":"Q3: Close","text":"","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#list-comprehensions_1","level":3,"title":"List Comprehensions","text":"","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#q4-wwpd-list-comprehensions","level":4,"title":"Q4: WWPD: List Comprehensions","text":"","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#q5-close-list","level":4,"title":"Q5: Close List","text":"","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#q6-squares-only","level":4,"title":"Q6: Squares Only","text":"<p>注意取整的问题</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#recursion","level":3,"title":"Recursion","text":"","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#q7-double-eights","level":4,"title":"Q7: Double Eights","text":"<p>那个答案写的怪怪的，感觉还没我写的好</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#q8-making-onions","level":4,"title":"Q8: Making Onions","text":"<p>也很简单，真的很像概率论的构造技巧</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#disc-0430min","level":2,"title":"Disc 04(30min)","text":"<p>Recursion takes practice. Please don't get discouraged if you're struggling to write recursive functions. Instead, every time you do solve one (even with help or in a group), make note of what you had to realize to make progress. Students improve through practice and reflection.</p> <p>Tree Recursion</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#q1-insect-combinatorics","level":3,"title":"Q1: Insect Combinatorics","text":"<pre><code>def paths(m, n):  \n    \"\"\"Return the number of paths from one corner of an  \n    M by N grid to the opposite corner.  \n    &gt;&gt;&gt; paths(2, 2)  \n    2    &gt;&gt;&gt; paths(5, 7)  \n    210    &gt;&gt;&gt; paths(117, 1)  \n    1    &gt;&gt;&gt; paths(1, 157)  \n    1    \"\"\"    if m == 1 or n == 1:  \n        return 1  \n    else:  \n        return paths(m-1, n) + paths(m, n-1)\n</code></pre> <p>Tree Recursion with Lists</p> <p>The most important thing to remember about lists is that a non-empty list <code>s</code> can be split into its first element <code>s[0]</code> and the rest of the list <code>s[1:]</code>.</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#q2-max-product","level":3,"title":"Q2: Max Product","text":"<pre><code>def max_product(s):  \n    \"\"\"Return the maximum product of non-consecutive elements of s.  \n\n    &gt;&gt;&gt; max_product([10, 3, 1, 9, 2])   # 10 * 9  \n    90    &gt;&gt;&gt; max_product([5, 10, 5, 10, 5])  # 5 * 5 * 5  \n    125    &gt;&gt;&gt; max_product([])                 # The product of no numbers is 1  \n    1    # 下面是自己写的测试  \n    &gt;&gt;&gt; max_product([2])  \n    2    \"\"\"    if len(s) == 0:  \n        return 1  \n    else:  \n        return max(s[0] * max_product(s[2:]), max_product(s[1:]))\n</code></pre>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%205/#q3-sum-fun","level":3,"title":"Q3: Sum Fun","text":"<pre><code>def sums(n, m):  \n    \"\"\"Return lists that sum to n containing positive numbers up to m that  \n    have no adjacent repeats.  \n    &gt;&gt;&gt; sums(5, 1)  \n    []    &gt;&gt;&gt; sums(5, 2)  \n    [[2, 1, 2]]    &gt;&gt;&gt; sums(5, 3)  \n    [[1, 3, 1], [2, 1, 2], [2, 3], [3, 2]]    &gt;&gt;&gt; sums(5, 5)  \n    [[1, 3, 1], [1, 4], [2, 1, 2], [2, 3], [3, 2], [4, 1], [5]]    &gt;&gt;&gt; sums(6, 3)  \n    [[1, 2, 1, 2], [1, 2, 3], [1, 3, 2], [2, 1, 2, 1], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]    \"\"\"    if n &lt; 0:  \n        return []  \n    if n == 0:  \n        sums_to_zero = []     # The only way to sum to zero using positives  \n        return [sums_to_zero] # Return a list of all the ways to sum to zero  \n    result = []  \n    for k in range(1, m + 1):  \n        result = result + [[k] + rest for rest in sums(n-k, m) if rest == [] or rest[0] != k ]  \n    return result\n</code></pre> <p>Remark: Slicing操作简直是为Recursion准备的，非常好用!</p>","path":["Week 5"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/","level":1,"title":"Week 6","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#summary","level":2,"title":"Summary","text":"<p>大概需要六小时</p> <p>本节总的来说出现了两个基本且重要的数据结构就是链表和树，从递归算法上说是自然的，还有Mutable Data这一在Python中非常重要的事情的讲述，很感动的是老师通过讲述A History Stroy去说明了这件事情，感觉正常学习过Python的人都会对这个部分有很深的共鸣，因为期末考老是喜欢考啊(doge)。</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#lab-0430min","level":2,"title":"Lab 04(30min)","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#dictionaries","level":3,"title":"Dictionaries","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#q1-dictionaries","level":4,"title":"Q1: Dictionaries","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#q2-divide","level":4,"title":"Q2: Divide","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#q3-buying-fruit","level":4,"title":"Q3: Buying Fruit","text":"<p>经典买菜题</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#data-abstraction","level":3,"title":"Data Abstraction","text":"<p>A data abstraction is a set of functions that compose and decompose compound values. One function called the constructor puts together two or more parts into a whole (such as a rational number; also known as a fraction), and other functions called selectors return parts of that whole (such as the numerator or denominator).</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#q4-distance","level":4,"title":"Q4: Distance","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#q5-closer-city","level":4,"title":"Q5: Closer City","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#q6-dont-violate-the-abstraction-barrier","level":4,"title":"Q6: Don't violate the abstraction barrier!","text":"<p>所谓数据抽象，抽象屏障(Abstraction Barrier)就好像递归中的信仰之跃，我们初始时不关心函数的实现细节只是使用构造的函数进行操作，只要写的代码有合适的屏障，只需要更改上游部分下游自然会发生变化.实际上就是通过函数来承载抽象的功能，所操作和修改的对象也只是函数而不是具体的values.</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#reading2h30min","level":2,"title":"Reading(2h30min)","text":"<p>Chapter 2: Building Abstractions with Data + 2.3   Sequences + 2.4   Mutable Data</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#ch-23","level":3,"title":"Ch. 2.3","text":"<p>A tree has a root label and a sequence of branches. Each branch of a tree is a tree. A tree with no branches is called a leaf. Any tree contained within a tree is called a sub-tree of that tree (such as a branch of a branch). The root of each sub-tree of a tree is called a node in that tree.</p> <p>树是一种非常基本的数据结构，这里只是做了简单的阐述，如果想要深入的了解树、二叉树、甚至线段树、红黑树最好还是学一下数据结构然后去手搓一些算法题.树本身就蕴含着recursion的思想，包括遍历的思想，学会用树应当是递归能力的一个提高节点.</p> <p>树这种东西在图论里面经常用，所以如果有OI训练的话确实有利于组合题能力提高...</p> <p>为了方便起见，再这里将所有的数据抽象列出</p> <pre><code># 基本的树抽象，要求root的值和分支也是树\ndef tree(root_label, branches=[]):\n        for branch in branches:\n            assert is_tree(branch), 'branches must be trees'\n        return [root_label] + list(branches)\n\n# 返回根节点的值\n def label(tree):\n    return tree[0]\n# 返回分支树\ndef branches(tree):\n        return tree[1:]\n\ndef is_tree(tree):\n        if type(tree) != list or len(tree) &lt; 1:\n            return False\n        for branch in branches(tree):\n            if not is_tree(branch):\n                return False\n        return True\ndef is_leaf(tree):\n        return not branches(tree)\n</code></pre> <p>然后开始了基本的链表，又是一个基本的数据结构</p> <p>However, we can also develop sequence representations that are not built into Python. A common representation of a sequence constructed from nested pairs is called a linked list.</p> <p></p> <p>Linked lists have recursive structure: the rest of a linked list is a linked list or 'empty'. We can define an abstract data representation to validate, construct, and select the components of linked lists.</p> <p>链表的第二位存储下一个链表的位置，显然也是一种递归的结构</p> <p>Recursive Construction. Linked lists are particularly useful when constructing sequences incrementally, a situation that arises often in recursive computations.</p> <p>Reference:</p> <p>洛谷-B3631单向链表</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#ch-24","level":3,"title":"Ch. 2.4","text":"<p>One powerful technique for creating modular programs is to incorporate data that may change state over time. In this way, a single data object can represent something that evolves independently of the rest of the program. The behavior of a changing object may be influenced by its history, just like an entity in the world. Adding state to data is a central ingredient of a paradigm called object-oriented programming.</p> <p>主要讲述了Python中Non local的一些问题，关于值的绑定(Non-Local Assignment)等等，尤其是Non local函数的好处进行了一些讲解</p> <p>也讲解了一些基本的编程范式，可能需要对后面的OOP进行深入学习之后会有更深的理解.</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#videos1h30min","level":2,"title":"Videos(1h30min)","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#trees","level":3,"title":"Trees","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#trees_1","level":4,"title":"Trees","text":"<p>terminologies:</p> <ul> <li>root label</li> <li>branch(each branch is a tree)</li> </ul> <p>tree is a abstraction not a representation</p> <pre><code>def tree(label, branches= []):\n    for branch in branches:\n        assert is_tree(branch)\n    return [label] + list(branches)\ndef label(tree):\n    return tree[0]\ndef branches(tree):\n    return tree[1]\n</code></pre>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#tree-processing","level":4,"title":"Tree Processing","text":"<p>sum function doesn't remove any structures.</p> <pre><code>def leaves(tree):\nif is_leaf(tree):\n    return [label(tree)]\nelse:\n    return sum([leaves(b) for b in branches(tree)], [])\n</code></pre>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#example-printing-trees","level":4,"title":"Example: Printing Trees","text":"<pre><code>def print_tree(t, indent = 0):\n    print(' ' * indent + str(label(t)))\n    for b in branches(t):\n        print_tree(b, indent+1)\n</code></pre>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#example-summing-paths","level":4,"title":"Example: Summing Paths","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#example-counting-paths","level":4,"title":"Example Counting Paths","text":"<pre><code>def count_paths(t, total):\n    if label(t) == total:\n        found = 1\n    else:\n        found = 0\n    return found + sum([count_paths(b, total - label(t)) for b in branches(t)])\n</code></pre>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#mutability","level":3,"title":"Mutability","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#objects","level":4,"title":"Objects","text":"<p>Talked about basic concepts and OOP in Python.</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#example-strings","level":4,"title":"Example: Strings","text":"<p>Show what is the Mutable Data and its usage.</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#mutation-operations","level":4,"title":"Mutation Operations","text":"<p>some examples and questions.</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#tuples","level":4,"title":"Tuples","text":"<p>Give a tuple type to show the not mutable data in python.</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#mutation","level":4,"title":"Mutation","text":"<p>Core concepts.</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#mutable-functions","level":4,"title":"Mutable Functions","text":"<p>A good application in functions used mutation.</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#disc-0530min","level":2,"title":"Disc 05(30min)","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#q1-warm-up","level":3,"title":"Q1: Warm Up","text":"<p>简单的练习</p> <p>Answer = 6</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#q2-has-path","level":3,"title":"Q2: Has Path","text":"<pre><code>def has_path(t, p):\n    \"\"\"Return whether tree t has a path from the root with labels p.\n\n    &gt;&gt;&gt; t2 = tree(5, [tree(6), tree(7)])\n    &gt;&gt;&gt; t1 = tree(3, [tree(4), t2])\n    &gt;&gt;&gt; has_path(t1, [5, 6])        # This path is not from the root of t1\n    False\n    &gt;&gt;&gt; has_path(t2, [5, 6])        # This path is from the root of t2\n    True\n    &gt;&gt;&gt; has_path(t1, [3, 5])        # This path does not go to a leaf, but that's ok\n    True\n    &gt;&gt;&gt; has_path(t1, [3, 5, 6])     # This path goes to a leaf\n    True\n    &gt;&gt;&gt; has_path(t1, [3, 4, 5, 6])  # There is no path with these labels\n    False\n    \"\"\"\n    if p == [label(t)]:  # when len(p) is 1\n        return True\n    elif label(t) != p[0]:\n        return False\n    else:\n        for b in branches(t): \n            if has_path(b, p[1:]):\n                 return True \n        return False\n</code></pre>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#q3-find-path","level":3,"title":"Q3: Find Path","text":"<pre><code>def find_path(t, x):\n    \"\"\"\n    &gt;&gt;&gt; t2 = tree(5, [tree(6), tree(7)])\n    &gt;&gt;&gt; t1 = tree(3, [tree(4), t2])\n    &gt;&gt;&gt; find_path(t1, 5)\n    [3, 5]\n    &gt;&gt;&gt; find_path(t1, 4)\n    [3, 4]\n    &gt;&gt;&gt; find_path(t1, 6)\n    [3, 5, 6]\n    &gt;&gt;&gt; find_path(t2, 6)\n    [5, 6]\n    &gt;&gt;&gt; print(find_path(t1, 2))\n    None\n    \"\"\"\n    if label(t) == x:\n        return [label(t)]\n    for b in branches(t):\n        path = find_path(b, x)\n        if path:\n            return [label(t)] + path\n    return None\n</code></pre>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#hw041h","level":2,"title":"HW04(1h)","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#sequences","level":3,"title":"Sequences","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#q1-deep-map","level":4,"title":"Q1: Deep Map","text":"<p>原地修改(in-place modification)，不需要返回值return value</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#data-abstraction_1","level":3,"title":"Data Abstraction","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#q2-mass","level":4,"title":"Q2: Mass","text":"<p>不知道有什么作用，感觉只是为了确认你的理解，但是又感觉有点多余了，不如让实现total_mass function</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#q3-balanced","level":4,"title":"Q3: Balanced","text":"<p>由定义可知：</p> <ul> <li>左右臂力矩相等</li> <li>左右臂子系统Balanced -&gt; Recursion</li> </ul> <p>利用Data Abstraction即可，然后需要注意判断尾端planet情况(函数调用要求对象为mobile所以planet会报错)</p>","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#trees_2","level":3,"title":"Trees","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%206/#q4-maximum-path-sum","level":4,"title":"Q4: Maximum Path Sum","text":"","path":["Week 6"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/","level":1,"title":"Week 7","text":"","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#summary","level":2,"title":"Summary","text":"<p>大致需要4h的时间完成，该Week任务量不大，题目也比较简单，主要是刚入门OOP，掌握OOP的设计思想和理念即可</p> <p>OOP的设计理念核心是==通过将现实世界的实体抽象为具有数据（属性）和操作（方法）的对象来构建软件系统，并利用类、封装、继承、多态等概念来模拟现实世界的逻辑，从而达到代码的模块化、可重用性、灵活性和可维护性==。它强调将数据和行为绑定在一起，并允许对象通过消息传递来相互通信，以构建复杂且易于扩展的系统。</p> <p>OOP主要有以下核心理念与概念：</p> <ul> <li>Object</li> <li>Class</li> <li>Encapsulation</li> <li>Inheritance</li> <li>Polymorphism</li> <li>Message Passing</li> </ul> <p>值得一提的是末尾附带了往年期末考试的相关试题，明显可以看出知识共享的普及(难度倒是不高)，对比神秘打印店和祖传资料高级了不少</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#reading2h","level":2,"title":"Reading(2h)","text":"<p>Chapter 4: Data Processing + 4.2 Implicit Sequences</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#ch42","level":3,"title":"Ch.4.2","text":"<p>A sequence can be represented without each element being stored explicitly in the memory of the computer. That is, we can construct an object that provides access to all of the elements of some sequential dataset without computing the value of each element in advance. Instead, we compute elements on demand.</p> <p>We want to achive the lazy computation in cs.</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#iterators","level":4,"title":"Iterators","text":"<p>Python and many other programming languages provide a unified way to process elements of a container value sequentially, called an iterator. An iterator is an object that provides sequential access to values, one by one.</p> <p>for example</p> <pre><code>r = range(3,13)\ns = iter(r)\nnext(s)\nt = iter(r) # not the same as s\nu = t\n# u and t have the same iterator\n</code></pre> <p>The usefulness of iterators is derived from the fact that the underlying series of data for an iterator may not be represented explicitly in memory. An iterator provides a mechanism for considering each of a series of values in turn, but all of those elements do not need to be stored simultaneously. Instead, when the next element is requested from an iterator, that element may be computed on demand instead of being retrieved from an existing memory source.</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#iterables","level":4,"title":"Iterables","text":"<p>Any value that can produce iterators is called an iterable value.</p> <p>Even unordered collections such as dictionaries must define an ordering over their contents when they produce iterators. Dictionaries and sets are unordered because the programmer has no control over the order of iteration, but Python does guarantee certain properties about their order in its specification.</p> <p>If a dictionary changes in structure because a key is added or removed, then all iterators become invalid.</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#built-in-iterators","level":4,"title":"Built-in Iterators","text":"<p>Just know about map function and filter, zip, reversed</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#for-statements","level":4,"title":"For Statements","text":"<pre><code>for &lt;name&gt; in &lt;expression&gt;:\n    &lt;suite&gt;\n</code></pre> <pre><code>counts = [1, 2, 3]\nitems = counts.__iter__()\ntry:\n    while True:\n        item = items.__next__()\n        print(item)\n    except StopIteration:\n        pass\n</code></pre> <p>Python 文档中的迭代器类型章节建议迭代器应具有一个返回迭代器本身的<code>__iter__</code>方法，因此所有迭代器都是可迭代的</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#generators-and-yield-statements","level":4,"title":"Generators and Yield Statements","text":"<p>A generator is an iterator returned by a special class of function called a generator function.</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#iterable-interface","level":4,"title":"Iterable Interface","text":"","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#creating-iterables-with-yield","level":4,"title":"Creating Iterables with Yield","text":"<p>for example</p> <pre><code>def all_pairs(s):\n    for item1 in s:\n        for item2 in s:\n            yield(item1, item2)\n\nlist(all_pairs([1, 2, 3]))\n&gt;&gt;&gt; [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]\n</code></pre>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#iterator-interface","level":4,"title":"Iterator Interface","text":"","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#streams","level":4,"title":"Streams","text":"<p>To Do(至25Fall该处仍然为空)</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#python-streams","level":4,"title":"Python Streams","text":"<p>SICP中叙述的有点抽象，我建议阅读官方的文档</p> <p>Chapter 2: Building Abstractions with Data + Ch.2.5 Object-Oriented Programming</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#ch25","level":3,"title":"Ch.2.5","text":"","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#objects-and-classes","level":4,"title":"Objects and Classes","text":"<p>A class serves as a template for all objects whose type is that class. Every object is an instance of some particular class.</p> <p>The attributes specific to a particular object, as opposed to all objects of a class, are called instance attributes</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#defining-classes","level":4,"title":"Defining Classes","text":"<p>You should know the example about bank and how to define your own classes in different situations.</p> <p>The function value that is created by a def statement within a class statement is bound to the declared name, but bound locally within the class as an attribute. That value is invoked as a method using dot notation from an instance of the class.</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#message-passing-and-dot-expressions","level":4,"title":"Message Passing and Dot Expressions","text":"<p>The built-in function getattr also returns an attribute for an object by name. It is the function equivalent of dot notation. Using getattr, we can look up an attribute using a string, just as we did with a dispatch dictionary.</p> <pre><code>getattr(spock_account, 'balanced')\n</code></pre> <p>We can also test whether an object has a named attribute with hasattr.</p> <pre><code>hasattr(spock_account, 'deposit')\n</code></pre> <p>Naming Conventions. Class names are conventionally written using the CapWords convention (also called CamelCase because the capital letters in the middle of a name look like humps). Method names follow the standard convention of naming functions using lowercased words separated by underscores.</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#class-attributes","level":4,"title":"Class Attributes","text":"<p>Some attribute values are shared across all objects of a given class. Such attributes are associated with the class itself, rather than any individual instance of the class.</p> <pre><code>class Account:\n    interest = 0.02 # A class attribute\n    def __init__(self, account_holder):\n        self.balance = 0\n        self.holder = account_holder\n    # Additional methods would be defined here\n</code></pre> <p>To evaluate a dot expression:</p> <ol> <li>Evaluate the <code>&lt;expression&gt;</code> to the left of the dot, which yields the object of the dot expression.</li> <li><code>&lt;name&gt;</code> is matched against the instance attributes of that object; if an attribute with that name exists, its value is returned.</li> <li>If <code>&lt;name&gt;</code> does not appear among instance attributes, then <code>&lt;name&gt;</code> is looked up in the class, which yields a class attribute value.</li> <li>That value is returned unless it is a function, in which case a bound method is returned instead.</li> </ol> <p>Changes to the class attribute interest will affect spock_account, but the instance attribute for kirk_account will be unaffected.</p> <p>In this evaluation procedure, instance attributes are found before class attributes, just as local names have priority over global in an environment.</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#inheritance","level":4,"title":"Inheritance","text":"<p>A subclass inherits the attributes of its base class, but may override certain attributes, including certain methods. With inheritance, we only specify what is different between the subclass and the base class. Anything that we leave unspecified in the subclass is automatically assumed to behave just as it would for the base class.</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#using-inheritance","level":4,"title":"Using Inheritance","text":"<p>We can define this procedure recursively. To look up a name in a class.</p> <ol> <li>If it names an attribute in the class, return the attribute value.</li> <li>Otherwise, look up the name in the base class, if there is one.</li> </ol> <p>Interfaces. It is extremely common in object-oriented programs that different types of objects will share the same attribute names. An object interface is a collection of attributes and conditions on those attributes. For example, all accounts must have deposit and withdraw methods that take numerical arguments, as well as a balance attribute. The classes Account and CheckingAccount both implement this interface. Inheritance specifically promotes name sharing in this way. In some programming languages such as Java, interface implementations must be explicitly declared. In others such as Python, Ruby, and Go, any object with the appropriate names implements an interface.</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#multiple-inheritance","level":4,"title":"Multiple Inheritance","text":"<p>Python supports the concept of a subclass inheriting attributes from multiple base classes, a language feature called multiple inheritance.</p> <p>Further reading. Python resolves this name using a recursive algorithm called the C3 Method Resolution Ordering. The method resolution order of any class can be queried using the mro method on all classes.</p> <pre><code>[c.__name__ for c in AsSeenOnTVAccount.mro()]\n</code></pre>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#the-role-of-objects","level":4,"title":"The Role of Objects","text":"<p>Abstraction barriers enforce the boundaries between different aspects of a large program.</p> <p>Object-oriented programming is particularly well-suited to programs that model systems that have separate but interacting parts.</p> <p>Learning to identify when to introduce a new class, as opposed to a new function, in order to simplify or modularize a program, is an important design skill in software engineering that deserves careful attention.</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#videos30min","level":2,"title":"Videos(30min)","text":"","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#iterators_1","level":3,"title":"Iterators","text":"<p>复述课本</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#generators","level":3,"title":"Generators","text":"<p>复述课本</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#objects","level":3,"title":"Objects","text":"<p>简单介绍了OOP编程的基本概念和结构，建议去看textbook写的比较详细</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#lab-0530min","level":2,"title":"Lab 05(30min)","text":"","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#mutability","level":3,"title":"Mutability","text":"","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#q1-wwpd-list-mutation","level":4,"title":"Q1: WWPD: List-Mutation","text":"<pre><code># 一个有趣的问题\n# 已知s = [3, 4, 5]\n&gt;&gt;&gt; s.extend([s.append(9), s.append(10)])  \n&gt;&gt;&gt; s  \n[3, 4, 5, 9, 10, None, None]\n</code></pre>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#q2-insert-items","level":4,"title":"Q2: Insert Items","text":"<p>很容易，只需要记得如果满足条件使指针向前挪动，否则<code>before == after</code>时会发生死循环</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#q3-group-by","level":4,"title":"Q3: Group By","text":"<p>如果对于SQL熟悉的话，这就相当于复现聚集函数了</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#iterators_2","level":3,"title":"Iterators","text":"","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#q4-wwpd-iterators","level":4,"title":"Q4: WWPD: Iterators","text":"","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#q5-count-occurrences","level":4,"title":"Q5: Count Occurrences","text":"","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#q6-repeated","level":4,"title":"Q6: Repeated","text":"<p>都比较容易</p> <p>Q7: Sprout Leaves</p> <p>利用树的数据抽象即可</p> <p>Q8: Partial Reverse</p> <p>比较容易</p>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#disc-0630min","level":2,"title":"Disc 06(30min)","text":"","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#generators_1","level":3,"title":"Generators","text":"<p>A generator is an iterator that is returned by calling a generator function, which is a function that contains yield statements instead of return statements</p> <p>Q1: Big Fib</p> <p>主要是要对几个内置函数有认识(相关的代码在Week 7文件夹中)</p> <p>such as map, filter, list, any, all, etc.</p> <pre><code>def gen_fib2():  \n    n, add = 0, 1  \n    while True:  \n        yield n  \n        n, add = n + add, n  \n\nnext(filter(lambda n : n &gt; 2024, gen_fib2()))\n</code></pre> <p>Q2: Something Different</p> <p>Q3： Partitions</p> <p>使用迭代器优化树结构的一个例子</p> <pre><code>def partition_gen(n, m):  \n    \"\"\"Yield the partitions of n using parts up to size m.  \n    &gt;&gt;&gt; for partition in sorted(partition_gen(6, 4)):    ...   print(partition)  \n    1 + 1 + 1 + 1 + 1 + 1    1 + 1 + 1 + 1 + 2    1 + 1 + 1 + 3    1 + 1 + 2 + 2    1 + 1 + 4    1 + 2 + 3    2 + 2 + 2    2 + 4    3 + 3    \"\"\"    assert n &gt; 0 and m &gt; 0  \n    if n == m:  \n        yield str(n)  \n    if n - m &gt; 0:  \n        for p in partition_gen(n - m, m):  \n            yield p + ' + ' + str(m)  \n    if m &gt; 1:  \n       yield from partition_gen(n, m - 1)\n</code></pre>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#hw0530min","level":2,"title":"HW05(30min)","text":"","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#q1-infinite-hailstone","level":3,"title":"Q1: Infinite Hailstone","text":"<p>练习yield from</p> <pre><code>def hailstone(n):  \n    \"\"\"Q1: Yields the elements of the hailstone sequence starting at n.  \n       At the end of the sequence, yield 1 infinitely.  \n    &gt;&gt;&gt; hail_gen = hailstone(10)    &gt;&gt;&gt; [next(hail_gen) for _ in range(10)]  \n    [10, 5, 16, 8, 4, 2, 1, 1, 1, 1]    &gt;&gt;&gt; next(hail_gen)  \n    1    \"\"\"    yield n  \n    if n == 1:  \n        yield from hailstone(n)  \n    if n % 2 == 1:  \n        yield from hailstone(n * 3 + 1)  \n    if n % 2 == 0:  \n        yield from hailstone(n // 2)\n</code></pre>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#q2-merge","level":3,"title":"Q2: Merge","text":"<pre><code>def merge(a, b):  \n    \"\"\"Q2:  \n    &gt;&gt;&gt; def sequence(start, step):    ...     while True:    ...         yield start    ...         start += step    &gt;&gt;&gt; a = sequence(2, 3) # 2, 5, 8, 11, 14, ...    &gt;&gt;&gt; b = sequence(3, 2) # 3, 5, 7, 9, 11, 13, 15, ...    &gt;&gt;&gt; result = merge(a, b) # 2, 3, 5, 7, 8, 9, 11, 13, 14, 15    &gt;&gt;&gt; [next(result) for _ in range(10)]  \n    [2, 3, 5, 7, 8, 9, 11, 13, 14, 15]    \"\"\"    next_a, next_b = next(a), next(b)  \n    while True:  \n        if next_a == next_b:  \n            yield next_a  \n            next_a, next_b = next(a), next(b)  \n        elif next_a &lt; next_b:  \n            yield next_a  \n            next_a = next(a)  \n        else:  \n            yield next_b  \n            next_b = next(b)\n</code></pre>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/CS61A/Week%207/#q3-yield-paths","level":3,"title":"Q3: Yield Paths","text":"<p>不知道为什么代码注释写的是Q4，合理怀疑之前还有一道题删除之后没有更改下一道题的注释</p> <pre><code>def yield_paths(t, value):  \n    \"\"\"Q4: Yields all possible paths from the root of t to a node with the label  \n    value as a list.  \n    &gt;&gt;&gt; t1 = tree(1, [tree(2, [tree(3), tree(4, [tree(6)]), tree(5)]), tree(5)])    &gt;&gt;&gt; print_tree(t1)  \n    1      2        3        4          6        5      5    &gt;&gt;&gt; next(yield_paths(t1, 6))  \n    [1, 2, 4, 6]    &gt;&gt;&gt; path_to_5 = yield_paths(t1, 5)    &gt;&gt;&gt; sorted(list(path_to_5))  \n    [[1, 2, 5], [1, 5]]  \n    &gt;&gt;&gt; t2 = tree(0, [tree(2, [t1])])    &gt;&gt;&gt; print_tree(t2)  \n    0      2        1          2            3            4              6            5          5    &gt;&gt;&gt; path_to_2 = yield_paths(t2, 2)    &gt;&gt;&gt; sorted(list(path_to_2))  \n    [[0, 2], [0, 2, 1, 2]]    \"\"\"    if label(t) == value:  \n        yield [label(t)]  \n    for b in branches(t):  \n        for subpath in yield_paths(b, value):  \n            yield [label(t)] + subpath\n</code></pre>","path":["Week 7"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/","level":1,"title":"分布式存储与计算","text":"<p>[!tldr] 课程简介 所属大学：南开大学 主讲教师：王奎(Wang Kui) 先修要求：None 课程难度：⭐⭐ 预计学时：100h 给分情况： 考试难度： 修读时间：Fall 25</p> <p>LAB文档</p>","path":["分布式存储与计算"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/","level":1,"title":"分布式存储与计算_LAB","text":"","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#lab-1","level":2,"title":"Lab 1","text":"<p>[!NOTE] 第一次上机实验  目的：熟悉Linux系统和基本命令 实验环境：Linux操作系统(可以使用Ubuntu on windows,iOS系统中的Term)</p> <p>对于大多数未曾使用过Linux操作系统的人来说，使用WSL是一种捷径，使用Ubuntu则可以更好的修改各种错误(因为大多数人都使用这一发行版，并且本教程也基于Ubuntu)</p> <p>跳过WSL的安装，因为实在是没有难度，你当然也可以使用虚拟机，我推荐你使用Virtual Box，只需要修改教程相关的路径部分即可，但是我需要提醒你不要吝啬虚拟机的内存，否则会出现节点资源不足而停摆的情况</p>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#0","level":3,"title":"0.帮助命令","text":"<p>比如查看ls命令的帮助，可以输入 </p> <pre><code>man ls &amp; ls --help \n</code></pre>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#1","level":3,"title":"1.文件操作命令的使用","text":"<ul> <li>查看文件与目录ls 进入Linux系统，输入 ls 回车(回车后命令运行，此后的说明中省略回车 尝试ls的其它参数</li> </ul> <pre><code>ls -a\nls -l\nls -lrth\n</code></pre> <ul> <li>用vim或者vi编辑器新建一个test.txt文件(使用方式请自行搜索)，在文件中键入任意内容：比如 this is test 保存，退出</li> </ul> <pre><code>vi test.txt\n// 如果安装了vim可以直接使用vim\nvim test.txt\n// 按i进入insert模式\nthis is test\n// 保存并退出\n:wq\n</code></pre> <ul> <li> <p>ls查看当前目录下新生成的文件test.txt </p> </li> <li> <p>显示文件内容cat </p> </li> </ul> <pre><code>cat test.txt \n</code></pre> <ul> <li>复制文件test.txt 到文件</li> </ul> <pre><code>cp test.txt test1.txt\ncp test.txt test2.txt \n</code></pre> <ul> <li> <p>删除命令rm，输入 rm testl.txt </p> </li> <li> <p>移动命令,输入 mv test2.txt test1.txt </p> </li> </ul>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#2","level":3,"title":"2.目录命令的使用","text":"<ul> <li>cd命令（该命令用来改变当前目录）</li> </ul> <pre><code>cd mytest\n</code></pre> <ul> <li>mkdir命令（用于在当前目录下建立一个子目录）</li> </ul> <pre><code>mkdir mytest\n</code></pre> <ul> <li>rmdir命令（移除当前目录下的目录）</li> </ul> <pre><code>rmdir mytest1\n</code></pre> <ul> <li>pwd（显示当前路径）</li> </ul> <pre><code>pwd\n</code></pre> <ul> <li>移动test.txt文件（假设该文件在~/目录下)到当前目录下</li> </ul> <pre><code>mv test.txt ./ cd ~ rmdir mytest\\\nrm -rf mytest\n</code></pre>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#3","level":3,"title":"3.重定向输入输出，比较&gt;和&gt;&gt;的作用","text":"<pre><code> cat test1.txt \n cat test1.txt &gt; test.txt \n cat test.txt test1.txt &gt; test2.txt \n cat test2.txt \n cat test.txt test1.txt &gt;&gt; test2.txt \n</code></pre>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#4","level":3,"title":"4.管道命令","text":"<pre><code> cat test2.txt|wc \n cat test2.txt|awk '{print $3}'\n</code></pre>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#lab-2","level":2,"title":"Lab 2","text":"<p>这个部分老师的操作文档写的非常混乱，我结合林子雨老师的教材和自己的经验进行一些修改以便于操作(也修改了一些安装顺序)，下面是修改后的安装步骤</p>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#1hadoop","level":3,"title":"1.创建新的hadoop账户","text":"<pre><code>// sudo adduser &lt;username&gt;\nsudo adduser hadoop\nsudo vim /etc/sudoers\n// insert module\nhadoop ALL=(ALL:ALL) ALL\n// 加入位置可以选择在sudo下方\n</code></pre> <p>切换账户</p> <pre><code>su hadoop\n</code></pre> <p>新建两个文件夹用来后续操作</p> <pre><code>mkdir software\nmkdir module\n</code></pre>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#2_1","level":3,"title":"2.安装两个基本文件","text":"<ul> <li>JDK8</li> <li>Hadoop3.4.2</li> </ul> <p>[!warning] 软件版本 需要注意的是，软件是会随着时间迭代的，因此版本号和文件名显然也会跟着改变，所以下面的一切与这两个文件有关的命令都需要注意修改对应的版本号进行操作</p> <ul> <li>JDK的安装</li> </ul> <p>首先进入网址：JDK_downloads，你可以在Java achieve中找到对应的版本，例如我使用JDK8就使用了jdk-8u451-linux-x64.tar.gz，安装在windows下即可</p> <ul> <li>Hadoop的安装</li> </ul> <p>直接进入官网安装即可，选择Binary版本，同样安装在windows下</p> <p>安装之后需要记住位置，后续需要在wsl中通过mnt来进行传输</p> <p>如何传输？</p> <p>假设您的文件在 Windows 路径为 <code>D:\\Users\\YourName\\Documents\\my_file.txt</code>，并且您想把它转移到 WSL 中当前用户的家目录 (<code>~</code>) 下</p> <p>示例路径：</p> <p>windows：D:\\Users\\YourName\\Documents\\my_file.txt</p> <p>wsl：/mnt/d/Users/YourName/Documents/my_file.txt</p> <p>[!tip] 窍门 只需要在前面加上/mnt，在哪个盘就在后面跟上盘符，例如D盘就加上/d，后面只需要改变反斜杠即可</p> <p>然后就是mv命令，前面是原位置，后面是移动后希望文件所处的位置</p> <pre><code>mv /mnt/d/Users/YourName/Documents/my_file.txt ~/target_directory/\n</code></pre> <p>将那两个安装包从windows下移动到 <code>~/software</code> 下(注意文件名需要根据你下载到的实际文件修改，路径也需要根据实际所处的位置修改)</p> <p>以 <code>hadoop-3.4.2.tar.gz</code> 为例</p> <pre><code>mv /mnt/d/Users/lenovo/Desktop/hadoop-3.4.2.tar.gz ~/software/\n</code></pre> <p>使用ls命令会得到如下结果</p> <pre><code>hadoop@Eurekaimer:~/software$ ls\nhadoop-3.4.2.tar.gz  jdk-8u451-linux-x64.tar.gz\n</code></pre> <p>然后将这两个压缩包解压到 <code>module</code> 文件夹下</p> <p>以 <code>jdk-8u451-linux-x64.tar.gz</code> 为例</p> <pre><code>tar -xvzf jdk-8u451-linux-x64.tar.gz -C ~/module\n</code></pre> <p>关于上面命令的 <code>-xvzf</code> 中的四个选项的含义可以直接搜索，在此不赘述</p>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#3_1","level":3,"title":"3.配置环境变量","text":"<ul> <li>先配置JDK的环境变量，首先回到最初的目录，然后使用vim打开配置文件</li> </ul> <pre><code>cd\nvim ~/.bashrc\n</code></pre> <p>加入以下内容(推荐加入位置在末尾，内容需要根据实际文件名修改)</p> <p>注：可以在 <code>module</code> 目录下使用ls得到</p> <pre><code>hadoop@Eurekaimer:~/module$ ls\nhadoop-3.4.2  jdk1.8.0_451\n</code></pre> <p>添加内容：</p> <pre><code>export JAVA_HOME=/home/hadoop/module/jdk1.8.0_451\nexport PATH=$PATH:$JAVA_HOME/bin\n// 加入后保存退出\n:wq\n</code></pre> <pre><code>// 运行source使得配置生效\nsource ~/.bashrc\n// 测试安装是否成功\njava -version\n</code></pre> <ul> <li>配置Hadoop环境变量</li> </ul> <p>类似的</p> <pre><code>cd\nvim ~/.bashrc\n</code></pre> <p>加入以下内容(推荐加入位置在末尾，内容需要根据实际文件名修改)</p> <p>注：可以在 <code>module</code> 目录下使用ls得到</p> <pre><code>hadoop@Eurekaimer:~/module$ ls\nhadoop-3.4.2  jdk1.8.0_451\n</code></pre> <p>添加内容：</p> <pre><code>export HADOOP_HOME=/home/hadoop/module/hadoop-3.4.2\nexport PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin\n// 加入后保存退出\n:wq\n</code></pre> <pre><code>// 运行source使得配置生效\nsource ~/.bashrc\n// 测试安装是否成功\nhadoop version\n</code></pre>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#4ssh","level":3,"title":"4.设置ssh免密登录","text":"<p>需要先安装openssh</p> <pre><code>sudo apt-get install openssh-server pdsh\n</code></pre> <p>可以先创建一个文件夹 <code>~/.ssh</code></p> <pre><code>cd ~\nmkdir .ssh\ncd ~/.ssh\nssh-keygen -t rsa \ncd \ncat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys\n</code></pre> <p>验证是否能够免密登录</p> <pre><code>ssh localhost\n</code></pre> <p>这个步骤不应输入密码，结束后退出</p> <pre><code>exit\n</code></pre> <p>[!tip] 关于免密登录的目的 为什么要免密登录？ 想要体会这一点应当在设置免密登录之前直接进行一次 <code>ssh localhost</code> 操作，我们会发现登录需要输入密码，而输入密码对于多节点的操作而言是非常麻烦的，因此我们需要设置免密登录</p>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#5","level":3,"title":"5.修改配置文件","text":"<p>主要是三个文件</p> <ul> <li>core-site.xml</li> </ul> <pre><code>vim core-site.xml\n</code></pre> <p><code>&lt;configuration&gt;</code> 和 <code>&lt;/configuration&gt;</code> 之间加入</p> <p>注意缩进(类似html标签)</p> <pre><code>&lt;property&gt;\n    &lt;name&gt;fs.defaultFS&lt;/name&gt;\n    &lt;value&gt;hdfs://localhost:9820&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;\n    &lt;value&gt;/home/hadoop/module/hadoop-3.3.6/tmp&lt;/value&gt;\n&lt;/property&gt;\n</code></pre> <ul> <li>hdfs-site.xml</li> </ul> <pre><code>vim hdfs-site.xml\n</code></pre> <p>仍然是 <code>&lt;configuration&gt;</code> 和 <code>&lt;/configuration&gt;</code> 之间加入</p> <pre><code>&lt;property&gt;\n    &lt;name&gt;dfs.replication&lt;/name&gt;\n    &lt;value&gt;1&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n    &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;\n    &lt;value&gt;localhost:9868&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n    &lt;name&gt;dfs.namenode.http-address&lt;/name&gt;\n    &lt;value&gt;localhost:9870&lt;/value&gt;\n&lt;/property&gt;\n</code></pre> <ul> <li>hadoop-env.sh</li> </ul> <pre><code>vim hadoop-env.sh\n</code></pre> <p>加入以下</p> <pre><code>export JAVA_HOME=/home/hadoop/module/jdk1.8.0_451\nexport HDFS_NAMENODE_USER=hadoop\nexport HDFS_DATANODE_USER=hadoop\nexport HDFS_SECONDARYNAME_USER=hadoop\n</code></pre>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#6hdfs","level":3,"title":"6.格式化HDFS文件系统","text":"<pre><code>hdfs namenode -format\n</code></pre>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#7","level":3,"title":"7.启动集群","text":"<pre><code>start-dfs.sh\njps\n</code></pre> <p>查看服务，打开浏览器输入 <code>http://localhost:9870</code></p>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#8","level":3,"title":"8.运行例子","text":"<pre><code>cd\nmkdir input\ncd input\n</code></pre> <p>使用vim生成测试文件 <code>test1.txt</code> 和 <code>test2.txt</code>，每个文件输入若干单词</p> <p>将目录上传到hdfs文件系统</p> <pre><code>hdfs dfs -put ~/input /input\ncd $HADOOP_HOME/share/hadoop/mapreduce\nhadoop jar hadoop-mapreduce-examples-3.4.2.jar wordcount /input /output\n</code></pre> <p>查看输出目录</p> <pre><code>hdfs dfs -ls /output\n</code></pre> <p>查看最终结果</p> <pre><code>hdfs dfs -cat /output/part-r-00000\n</code></pre> <p></p> <p>[!NOTE] 彩蛋 如果统计结果正确，那么说明你的 Hadoop 伪分布式集群就搭建成功并验证完成了！ 我写的是microsoft love linux!</p>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#lab-3","level":2,"title":"Lab 3","text":"<p>第四次上机实验的内容为YARN的配置，具体内容如下：</p> <ul> <li>配置并启动YARN</li> <li>Yarn中添加队列small,并将任务提交至small队列运行<ul> <li>修改capacity-scheduler.xml文件（最好提前备份该文件cp capacity-scheduler.xml capacity-scheduler.xml.bak).修改内容包括增加所有和small队列相关的属性，并且分配default队列和small队列之间的资源占有比例。</li> <li>向指定队列提交任务     $hadoop jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-example-3.4.2.jar pi -Dmapreduce.job.queuename=small 10 10</li> <li>在yarn的web服务页面查看提交的任务情况和队列情况</li> </ul> </li> </ul>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#1-yarnhdfs","level":3,"title":"1. YARN环境配置（承接HDFS配置）","text":"<p>主要是修改三个文件</p> <ul> <li>mapred-site.xml</li> <li>yarn-site.xml</li> <li>hadoop-env.sh</li> </ul> <p>\\(\\mathbf{Remark:}\\)下面的软件版本都是我的版本，相应的使用需修改</p> <p>配置第一个</p> <pre><code>cd $HADOOP_HOME/etc/hadoop\n# 备份可以不备\ncp mapred-site.xml.template mapred-site.xml\nvim mapred-site.xml\n</code></pre> <p>在两个&lt; configuratkion &gt;插入&lt; property &gt; 最后如下：</p> <pre><code>&lt;configuration&gt;\n    &lt;property&gt;\n        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;\n        &lt;value&gt;yarn&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property&gt;\n        &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt;\n        &lt;value&gt;HADOOP_MAPRED_HOME=/home/hadoop/module/hadoop-3.4.2&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property&gt;\n        &lt;name&gt;mapreduce.map.env&lt;/name&gt;\n        &lt;value&gt;HADOOP_MAPRED_HOME=/home/hadoop/module/hadoop-3.4.2&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property&gt;\n        &lt;name&gt;mapreduce.reduce.env&lt;/name&gt;\n        &lt;value&gt;HADOOP_MAPRED_HOME=/home/hadoop/module/hadoop-3.4.2&lt;/value&gt;\n    &lt;/property&gt;\n    # 后面两条可以不插入\n    # 关于端口的部分都可以不插入，因为有默认值\n    &lt;property&gt;\n        &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;\n        &lt;value&gt;localhost:10020&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property&gt;\n        &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;\n        &lt;value&gt;localhost:19888&lt;/value&gt;\n    &lt;/property&gt;\n&lt;/configuration&gt;\n</code></pre> <p>配置第二个</p> <pre><code>vim yarn-site.xml\n</code></pre> <pre><code>&lt;configuration&gt;\n    &lt;property&gt;\n        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;\n        &lt;value&gt;Eurekaime&lt;/value&gt; # 这里是你的hostname主机名(主机名是@后面的)\n    &lt;/property&gt;\n    &lt;property&gt;\n        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;\n        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;\n    &lt;/property&gt;\n    # 同理端口可以不接入\n    &lt;property&gt;\n        &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;\n        &lt;value&gt;Eurekaimer:8088&lt;/value&gt;# 这里仍然是主机名\n    &lt;/property&gt;\n&lt;/configuration&gt;\n</code></pre> <p>第一个property主机名(hostname)</p> <p>配置第三个</p> <pre><code>vim hadoop-env.sh\n</code></pre> <p>末尾添加：</p> <pre><code>export YARN_RESOURCEMANAGER_USER=hadoop\nexport YARN_NODEMANAGER_USER=hadoop\n</code></pre>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#2-yarn","level":3,"title":"2. 启动Yarn服务","text":"<pre><code># 如果之前启动过的关闭\n$HADOOP_HOME/sbin/stop-all.sh\n# 启动HDFS和YARN\n$HADOOP_HOME/sbin/start-dfs.sh\n$HADOOP_HOME/sbin/start-yarn.sh\n$HADOOP_HOME/sbin/mr-jobhistory-daemon.sh start historyserver\n</code></pre> <p>第三条命令报错是因为给出的这个命令是Hadoop2.x版本的，但是它会自动转换为3.x</p> <p>如果在 <code>$HADOOP_HOME</code> 目录下：</p> <pre><code>stop-all.sh\n# HDFS\nstart-dfs.sh\n# Yarn\nstart-yarn.sh\n# 历史服务器\nmr-jobhistory-daemon.sh start historyserver\n</code></pre> <p>检查：</p> <pre><code>jps\n</code></pre> <p>896 DataNode 1793 JobHistoryServer 1137 SecondaryNameNode 769 NameNode 1570 NodeManager 2439 ResourceManager 2735 Jps</p> <p>应该能看到至少以下进程：<code>NameNode</code>，<code>DataNode</code>，<code>ResourceManager</code>，<code>NodeManager</code>，<code>JobHistoryServer</code></p>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#3-small","level":3,"title":"3. 配置并启动 <code>small</code> 队列","text":"<p>修改 <code>capacity-scheduler.xml</code> 文件</p> <pre><code>cd $HADOOP_HOME/etc/hadoop\n# 备份仍然可以不用打\ncp capacity-scheduler.xml capacity-scheduler.xml.bak\nvim capacity-scheduler.xml\n</code></pre> <p>这个是比较麻烦的，你需要在文件的 <code>&lt;configuration&gt;</code> 和 <code>&lt;/configuration&gt;</code> 标签之间，加入以下内容。这些配置定义了 <code>root</code> 队列下的子队列 <code>default</code> 和 <code>small</code>，并分配了资源比例（70% 给 <code>default</code>，30% 给 <code>small</code>）(比例可以调，只需要加和100%即可)</p> <pre><code>&lt;property&gt;\n    &lt;name&gt;yarn.scheduler.capacity.root.queues&lt;/name&gt;\n    &lt;value&gt;default,small&lt;/value&gt;# 这行加入small队列\n&lt;/property&gt;\n\n# default\n&lt;property&gt;\n    &lt;name&gt;yarn.scheduler.capacity.root.default.capacity&lt;/name&gt;\n    &lt;value&gt;70&lt;/value&gt;# 调整比例\n&lt;/property&gt;\n&lt;property&gt;\n    &lt;name&gt;yarn.scheduler.capacity.root.default.maximum-capacity&lt;/name&gt;\n    &lt;value&gt;100&lt;/value&gt;\n&lt;/property&gt;\n\n# small\n&lt;property&gt;\n    &lt;name&gt;yarn.scheduler.capacity.root.small.capacity&lt;/name&gt;\n    &lt;value&gt;30&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n    &lt;name&gt;yarn.scheduler.capacity.root.small.maximum-capacity&lt;/name&gt;\n    &lt;value&gt;30&lt;/value&gt;\n&lt;/property&gt;\n</code></pre> <p>保险起见应该给每个property标签都类似定义相关的small队列的版本，例如上面的部分就是两个default和两个small，但是使用时其他属性都存在默认值，所以不配置small的标签也可以跑通</p> <pre><code># 确保配置small队列能够使用(刷新)\nyarn rmadmin -refreshQueues\n</code></pre>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#4_1","level":3,"title":"4. 提交任务","text":"<pre><code>hadoop jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.4.2.jar pi -Dmapreduce.job.queuename=small 10 10\n</code></pre> <p>精度相当差，如果要更高的精度可以调整后面参数(10 10)</p> <p></p> <p>如果要使用web端的话，检查一下端口：</p> <pre><code>sudo vim /etc/hosts\n</code></pre> <p>打开之后进行配置</p> <pre><code># This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:\n# [network]\n# generateHosts = false\n127.0.0.1       localhost\n# 主机名 ip需要统一\n127.0.0.1       Eurekaimer.     Eurekaimer\n# 用户名\n127.0.0.1       hadoop          hadoop\n</code></pre> <p>重启一下：</p> <pre><code>stop-yarn.sh\nstart-yarn.sh\nyarn rmadmin -refreshQueues\n</code></pre> <p>然后尝试访问http://localhost:8088</p> <p>有时候因为防火墙无法访问，所以采取http协议，或者把电脑防火墙关掉</p> <p>[!warning] 关于最后一步提交之后但是无法开始任务 也就是一直卡在提交结束，但是任务迟迟没有开始，有可能是因为你的任务需求内存大于你的节点能够提供的内存，对于这种情况(如果使用虚拟机)，你需要调整节点最大可用内存，或者降低任务需要内存，也可以虚报内存(所以说安装虚拟机的时候不要把自己的内存配置写的太小了)</p>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#lab-4","level":2,"title":"Lab 4","text":"<p>一切文件版本和路径根据自己情况调整</p>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#1spark-342","level":3,"title":"1.安装Spark 3.4.2","text":"<p>使用之前需要Java和Hadoop环境(很好安装，在之前的Lab中已经安装过)</p> <p>注：下面需要根据自己的Java/Hadoop/Spark版本进行，可以使用下面的命令查看</p> <pre><code>cat ~/.bashrc\n\n# 这是我的输出\nexport JAVA_HOME=/home/hadoop/module/jdk1.8.0_451\nexport PATH=$PATH:$JAVA_HOME/bin\nexport HADOOP_HOME=/home/hadoop/module/hadoop-3.4.2\nexport PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin\n\n# 解读：\n# Java 版本: jdk1.8.0_451\n# Hadoop 版本:hadoop-3.4.2\n# Spark 版本（假设下载）: spark-3.4.2-bin-without-hadoop.tgz\n</code></pre> <p>由于老师的安装文档比较老因此使用的是比较古老的Spark版本，只能去Apache Archive下载(这是本次实验耗时最久的地方)，然后就是正常移动文件(WSL)，如果是虚拟机或是本地Linux正常移动即可</p> <pre><code>mv /mnt/e/spark-3.4.2-bin-without-hadoop.tgz ~/software/\n</code></pre> <p>解压</p> <pre><code>tar -xvzf ~/software/spark-3.4.2-bin-without-hadoop.tgz -C ~/module/\n</code></pre> <p>PPT复制下来-C前面横线格式不对</p> <p>移动解压文件并改名spark</p> <pre><code>mv ~/module/spark-3.4.2-bin-without-hadoop/ ~/module/spark\n</code></pre>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#_1","level":4,"title":"本地模式","text":"<p>然后开始配置文件<code>spark-env.sh</code></p> <pre><code># 仍然备份，但是改动较少不太可能改错\ncd ~/module/spark/conf\ncp spark-env.sh.template spark-env.sh\nvim spark-env.sh\n</code></pre> <p>在最后加上(老师的课件需要打开两次，这里方便就把后续的配置文件一起写上)</p> <pre><code># 这是原本的\nexport SPARK_DIST_CLASSPATH=$(/home/hadoop/module/hadoop-3.3.6/bin/hadoop classpath)\n# 这是后面的\nexport JAVA_HOME=/home/hadoop/module/jdk1.8.0_451 \n# 指定 Hadoop 配置文件的目录，用于YARN和HDFS集成\nexport HADOOP_CONF_DIR=/home/hadoop/module/hadoop-3.4.2/etc/hadoop \n# Standalone Master 的主机名和端口\nSPARK_MASTER_HOST=localhost \nSPARK_MASTER_PORT=7077\n</code></pre> <p>由此可以使用本地模式，如果要使用HDFS则需要提前打开Hadoop</p>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#standalone","level":4,"title":"Standalone模式","text":"<p>仍然是那个<code>conf</code>文件夹</p> <pre><code> cp workers.template workers\n vim workers\n # 里面的改为\n localhost\n # 里面的默认应该就是，这步没必要做\n</code></pre> <p>启动Standalone模式，没必要运行，不想运行直接跳过</p> <pre><code># 需要在spark目录下\n ./sbin/start-master.sh\n ./sbin/start-workers.sh spark://localhost:7077\n jps \n# 应该能看到 Master 和 Worker 进程\n\n # 不在目录下可以如下操作，但是需要把下面的环境变量$SPARK_HOME先配置好(或者键入正确的目录)\n # 1. 启动 Master 进程 [cite: 281]\n$SPARK_HOME/sbin/start-master.sh\n# 2. 启动 Worker 进程，连接到 Master [cite: 282]\n$SPARK_HOME/sbin/start-workers.sh spark://localhost:7077\n# 3. 检查进程\njps \n# 应该能看到 Master 和 Worker 进程\n</code></pre> <p>配置环境变量：</p> <pre><code>vim ~/.bashrc\n\n# 加入\nexport SPARK_HOME=/home/hadoop/module/spark\nexport PATH=$PATH:$SPARK_HOME/bin\n\n# 使得新配置生效\nsource ~/.bashrc\n\n# 然后应该就可以使用Spark了\nspark-shell\n# 应该就可以使用spark了，这个需要确认一下，确认完了ctrl C退出\n</code></pre>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#2sbt","level":3,"title":"2.安装sbt并配置环境","text":"<p>sbt（Simple Build Tool）用于打包 Scala 编写的 Spark 应用程序</p> <p>安装的话：Github，官网</p> <p>安装好了仍然解压安装包</p> <pre><code>tar -xvzf ~/software/sbt-1.9.9.tgz -C ~/module/sbt\n# 配置环境\nvim ~/.bashrc\n# 末尾加入\nexport PATH=$PATH:~/module/sbt/bin\n# 使配置生效\nsource ~/.bashrc\n</code></pre>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#3_2","level":3,"title":"3.创建任务","text":"<p>创建文件夹</p> <pre><code>mkdir ~/sparkapp\nmkdir –p ~/sparkapp/src/main/scala\n</code></pre> <p>撰写代码</p> <pre><code>vim ~/sparkapp/src/main/scala/SimpleApp.scala\n</code></pre> <p>加入下面的代码</p> <pre><code>import org.apache.spark.SparkContext\nimport org.apache.spark.SparkContext._\nimport org.apache.spark.SparkConf\n\nobject SimpleApp {\n  def main(args: Array[String]) {\n    val logFile = \"file:///home/hadoop/module/spark/README.md\" // 用于统计的文本文件 [cite: 789]\n    val conf = new SparkConf().setAppName(\"Simple Application\") \n    val sc = new SparkContext(conf)\n    val logData = sc.textFile(logFile, 2).cache()\n    val numAs = logData.filter(line =&gt; line.contains(\"a\")).count()\n    val numBs = logData.filter(line =&gt; line.contains(\"b\")).count()\n    println(\"Lines with a: %s, Lines with b: %s\".format(numAs, numBs)) \n    sc.stop() // 补充 sc.stop() 确保程序正常退出，老师课件没写\n  }\n}\n</code></pre> <p>声明该应用程序的信息以及与Spark的依赖关系</p> <pre><code>vim ~/sparkapp/simple.sbt\n\n# 加入\nname := \"Simple Project\"\nversion := \"1.0\"\nscalaVersion := \"2.12.18\" // 与 Spark 3.4.2 兼容的 Scala 版本\nlibraryDependencies += \"org.apache.spark\" %% \"spark-core\" % \"3.4.2\" % \"provided\" // Spark 依赖版本\n</code></pre> <p>打包</p> <pre><code>cd ~/sparkapp \n# 2. 编译并打包应用程序 (sbt package)\nsbt package \n# 第一次运行时 sbt 会下载依赖包，耗时较久\n# 成功后，生成的 JAR 包应当位于 ~/sparkapp/target/scala-2.12/simple-project_2.12-1.0.jar\n</code></pre> <p>应该会生成一个jar包</p>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#4_2","level":3,"title":"4.提交任务","text":"<pre><code>#建议使用下面的命令 注意$前面还有$ 并非笔误，那个老师的提交命令又有毛病，class和master前面的横线都少了一个\n$SPARK_HOME/bin/spark-submit \\\n--class \"SimpleApp\" \\\n--master spark://localhost:7077 \\\n~/sparkapp/target/scala-2.12/simple-project_2.12-1.0.jar\n</code></pre> <p>你应该会在日志中找到这样一个句子</p> <pre><code>2025-11-11 09:25:08,414 INFO scheduler.DAGScheduler: Job 1 finished: count at SimpleApp.scala:12, took 0.157960 s\nLines with a: 72, Lines with b: 39\n</code></pre> <p>这说明成功了</p>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%A1%E7%AE%97_LAB/#5_1","level":3,"title":"5.快速签字检查","text":"<p>一键打开所有</p> <pre><code>start-all.sh\n</code></pre> <pre><code>cd ~/module/spark\n./sbin/start-master.sh\n./sbin/start-workers.sh spark://localhost:7077\njps\n</code></pre> <pre><code>~/module/spark/bin/spark-submit \\\n    --class \"SimpleApp\" \\\n    --master spark://localhost:7077 \\\n    ~/sparkapp/target/scala-2.12/simple-project_2.12-1.0.jar\n</code></pre> <p>到这里所有的需要上机签字的部分就结束了(算平时分的部分)，但是对于想要学好分布式的同学来说，熟悉Scala语法和代码实现也是不得不品的一环，但是由于本人比较懒就跳过后续的两次Scala语言的上机作业了，因为在LLM的时代下，你写不出正确的代码说明这门科目不是很适合你了！！！</p>","path":["分布式存储与计算_LAB"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/","level":1,"title":"实用教程","text":"<p>主要存放一些markdown格式的有用的教程(有些是Github上的仓库文件下载的，有些是自己写的)</p>","path":["实用教程"],"tags":["CS"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","level":1,"title":"数据挖掘与机器学习","text":"<p>[!tldr] 课程简介 所属大学：南开大学 主讲教师：付盛(Fu Sheng) 先修要求：数学分析+高等代数+初等概率论+初等数理统计 课程难度：⭐⭐⭐ 预计学时：100h 给分情况：60%闭卷+20%大作业+20%实验 考试难度： 修读时间：Fall 25</p> <ul> <li>References<ul> <li></li> <li>CS229 Lecture Notes</li> </ul> </li> <li>Optional documents<ul> <li>More about SGD(Notes)</li> </ul> </li> </ul>","path":["数据挖掘与机器学习"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/#_2","level":2,"title":"章节内容","text":"<p>去除Lecture0(Introduction and Preface)</p> <p>对于数学基础的回顾(线性代数和概率论数理统计)，关于线性代数的内容可以参考cs229-linear-algebra-review(写的非常详尽)，概率论请参考cs229-probability</p> <ul> <li>Linear-Algebra<ul> <li>Basic concepts and notation</li> <li>Matrix multiplication</li> <li>Operations and properties</li> <li>Matrix calculus</li> </ul> </li> <li>Probability-Theory<ul> <li>Elements of probability</li> <li>Random variables</li> <li>Two random variables</li> <li>Multiple random variables</li> <li>The multivariable Gaussian distribution</li> <li>Recommend the textbook(Sheldon Ross)</li> </ul> </li> </ul> <p>Chapter 3: 信息论基础</p> <p>Chapter 9: 判别分析</p> <p>Chapter 12：KNN</p> <p>Chapter 13：神经网络基础</p>","path":["数据挖掘与机器学习"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/#24fall","level":2,"title":"24Fall","text":"<p>这里还从一个Github仓库中摘取了另一位老师的24年在DMML课程上的Slides，并且交给Gemini3进行处理后做成了简单的笔记用于对比学习和复习</p> <p>DMML_24Fall_Re</p>","path":["数据挖掘与机器学习"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/","level":1,"title":"DMML_24Fall_Re","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#lecture1-","level":2,"title":"Lecture1 - 绪论 &amp; 基础复习","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#1","level":3,"title":"1. 课程考核与大作业 (关键信息)","text":"<ul> <li> 成绩构成: 闭卷考试 (60%) + 实验 (20%) + 大作业 (20%)</li> <li> 大作业 (四选一, 15-18周展示):<ol> <li>遥感图像飞机检测: 目标检测 (Object Detection).</li> <li>“福”字识别: 图像分类, 重点解决类别不平衡 (Class Imbalance).</li> <li>台风预报: 序列预测/回归, 需处理时空数据.</li> <li>图像区域分割提取: 语义分割, 核心难点是保持空间相关性.</li> </ol> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#2-data-mining-fundamentals","level":3,"title":"2. 数据挖掘核心概念 (Data Mining Fundamentals)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#21-technical-challenges","level":4,"title":"2.1 新数据的挑战 (Technical Challenges)","text":"<p>传统的统计分析面临新数据的四大挑战，这也是引入机器学习算法的动机：</p> <ul> <li>可伸缩性 (Scalability): 数据无法一次性放入内存，需要 Out-of-core 或分布式算法.</li> <li>高维性 (High Dimensionality): 维度灾难 (Curse of Dimensionality), 数据稀疏.</li> <li>异构性 (Heterogeneous): 混合属性 (非结构化文本, 图像, 时间序列).</li> <li>分布性 (Distributed): 数据地理分布, 需解决隐私与通信代价.</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#22-taxonomy","level":4,"title":"2.2 任务分类 (Taxonomy)","text":"<p>根据目标变量的存在与否及类型划分：</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#a-predictive-supervised","level":5,"title":"A. 预测性任务 (Predictive) - Supervised","text":"<p>利用训练数据学习映射函数 \\(y=f(x|\\theta)\\)</p> <ol> <li>分类 (Classification)<ul> <li>输入: 样本 \\(\\mathbf{x} \\in \\mathbb{R}^n\\), 标签 \\(c\\) (离散).</li> <li>目标: 学习判别界面或概率分布.</li> <li>常用算法: Decision Tree, KNN, SVM, ANN, Naive Bayes.</li> </ul> </li> <li>回归 (Regression)<ul> <li>输入: 样本 \\(\\mathbf{x}\\), 标签 \\(y\\) (连续).</li> <li>目标: 最小化预测误差.</li> <li>公式: \\((w^*, b^*) = \\arg\\min_{w,b} \\sum_{i=1}^{m} (f(x_i) - y_i)^2\\) (以线性回归MSE为例).</li> </ul> </li> <li>异常检测 (Anomaly Detection)<ul> <li>目标: 识别显著偏离分布的 \\(x\\). 应用于欺诈检测、网络入侵.</li> </ul> </li> </ol>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#b-descriptive-unsupervised","level":5,"title":"B. 描述性任务 (Descriptive) - Unsupervised","text":"<p>发现数据内在结构，无标签 \\(y\\).</p> <ol> <li>聚类 (Clustering)<ul> <li>目标: 最大化类间距离 (Inter-cluster), 最小化类内距离 (Intra-cluster).</li> <li>度量: 常用欧氏距离 (Euclidean Distance).</li> </ul> </li> <li>关联规则 (Association Rule)<ul> <li>形式: \\(A \\rightarrow B\\) (蕴含关系).</li> <li>应用: 购物篮分析 (Market Basket Analysis).</li> </ul> </li> <li>序列模式 (Sequential Pattern)<ul> <li>关联规则 + 时间维度 (Time attribute).</li> </ul> </li> </ol>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#3-process","level":3,"title":"3. 机器学习系统构建流程 (Process)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#31-abstraction-","level":4,"title":"3.1 问题抽象化 (Abstraction) - 以“鱼类分类”为例","text":"<ul> <li>输入: 物理对象 (鱼).</li> <li>特征工程 (Feature Extraction):<ul> <li>物理特征 \\(\\rightarrow\\) 数值特征向量 \\(\\mathbf{x} = [x_1, x_2]^T\\) (如 \\(x_1\\)=长度, \\(x_2\\)=亮度).</li> <li>特征优选: 权衡特征数量 (维度) 与 计算复杂度/过拟合风险.</li> </ul> </li> <li>类别抽象: \\(\\omega_1\\) (鲑鱼), \\(\\omega_2\\) (鲈鱼).</li> <li>决策规则 (Decision Rule):<ul> <li>设定阈值 \\(x_0\\) (Threshold).</li> <li>Rule: If \\(x &lt; x_0\\) then \\(\\omega_1\\), else \\(\\omega_2\\).</li> <li>高维情况表现为特征空间中的超平面划分.</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#32-dataset-splitting-exam-point","level":4,"title":"3.2 数据集划分 (Dataset Splitting) [Exam Point]","text":"<p>严谨的ML流程必须包含三部分：</p> <ol> <li>训练集 (Training Set): 用于拟合模型参数 (Parameters, e.g., 权重 \\(w\\)).</li> <li>验证集 (Validation Set):<ul> <li>用途: 调整超参数 (Hyper-parameters), 模型选择.</li> <li>注意: 在此阶段评估模型性能，决定是否停止训练.</li> </ul> </li> <li>测试集 (Test Set):<ul> <li>用途: 评估最终模型的泛化能力 (Generalization).</li> <li>铁律: 绝对不能在测试集上调参 (No Peeking)! 测试集仅用于最后一次的 \"Unseen data\" 模拟.</li> </ul> </li> </ol>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#4-vs","level":3,"title":"4. 监督 vs 无监督 (对比总结)","text":"维度 监督学习 (Supervised) 无监督学习 (Unsupervised) Data \\((x, y)\\), \\(y\\) is label \\(x\\), Just data Goal Learn a function \\(x \\rightarrow y\\) Learn structure/distribution of data Examples Classification, Regression, Object Detection Clustering, Dim-Reduction, Generative Models","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#5-checklist","level":3,"title":"5. 复习Checklist","text":"<ul> <li> 理解 4V 特点对算法设计的影响 (内存/计算效率).</li> <li> 能够用数学语言描述分类 (\\(c=f(x)\\)) 与 回归 (Loss Function) 的区别.</li> <li> 牢记 Train/Val/Test 的功能区别 (特别是验证集的作用).</li> <li> 熟悉大作业中提到的四类问题对应的 ML 任务类型 (检测/不平衡分类/时序/分割).</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#lecture2-","level":2,"title":"Lecture2 - 数据处理","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#1-data-representation","level":3,"title":"1. 数据的基本概念与表示 (Data Representation)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#_1","level":4,"title":"数据定义与矩阵表示","text":"<p>数据挖掘是在大型数据存储库中自动发现有用信息的过程。从数学角度看，数据集通常表示为数据矩阵 (Data Matrix)。</p> <ul> <li>对象 (Objects/Samples): 行向量，表示实体（如记录、点、向量、模式）。</li> <li>属性 (Attributes/Features): 列向量，表示对象的维度。</li> <li> <p>矩阵表示:     设数据集 \\(D\\) 包含 \\(m\\) 个对象，每个对象有 \\(n\\) 个属性，则 \\(D\\) 可表示为 \\(m \\times n\\) 矩阵：</p> \\[ D = \\begin{pmatrix} x_{11} &amp; x_{12} &amp; \\cdots &amp; x_{1n} \\\\ x_{21} &amp; x_{22} &amp; \\cdots &amp; x_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ x_{m1} &amp; x_{m2} &amp; \\cdots &amp; x_{mn} \\end{pmatrix} \\] <p>其中第 \\(i\\) 行代表第 \\(i\\) 个对象，第 \\(j\\) 列代表第 \\(j\\) 个属性。</p> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#_2","level":4,"title":"属性类型","text":"<ul> <li>离散 (Discrete): 具有有限或无限可数个值。</li> <li>连续 (Continuous): 取实数值。</li> <li>非对称属性 (Asymmetric Attributes): 只有非零值才是重要的（常见于稀疏数据）。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#_3","level":4,"title":"特殊数据类型的数学结构","text":"<ol> <li>文档数据 (Document Data):<ul> <li>表示为词 (Term) 向量。</li> <li>每个分量对应词在文档中出现的频率（TF）。</li> <li>通常导致高维稀疏矩阵。</li> </ul> </li> <li>图数据 (Graph Data): 包含对象间的结构关系（邻接矩阵）。</li> <li>时序数据 (Temporal/Sequence Data): 数据间存在序关系 \\(t_1, t_2, \\dots, t_n\\)。</li> <li>图像数据:<ul> <li>数学表示: \\(f(x, y, \\lambda, t)\\)<ul> <li>\\((x, y)\\): 2-D 空间坐标。</li> <li>\\(\\lambda\\): 波长（对应颜色/光谱）。</li> <li>\\(t\\): 时间（对应视频帧）。</li> </ul> </li> <li>离散化后为像素矩阵，像素值代表亮度（灰度值）。</li> </ul> </li> </ol>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#2-general-characteristics","level":3,"title":"2. 数据集的一般特性 (General Characteristics)","text":"<ul> <li>维度 (Dimensionality): 属性的数量。<ul> <li>维数灾难 (Curse of Dimensionality): 随着维度增加，数据在空间中变得极其稀疏，距离度量（如欧氏距离）失效，模型泛化能力下降。</li> </ul> </li> <li>稀疏性 (Sparsity): 对象的大部分属性值为0。</li> <li>分辨率 (Resolution): 数据的聚合程度，不同的分辨率可能表现出不同的统计模式。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#3-summary-statistics","level":3,"title":"3. 汇总统计 (Summary Statistics)","text":"<p>用于捕捉数据分布特征的度量。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#_4","level":4,"title":"频率与众数","text":"<ul> <li>频率: 给定属性值 \\(v_i\\)，其频率为具有该值的对象数除以总对象数 \\(m\\)。</li> <li>众数 (Mode): 频率最高的值。<ul> <li>注: 对连续属性，众数通常无意义（除非离散化），主要用于填充缺失值。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#location-measures","level":4,"title":"位置度量 (Location Measures)","text":"<ul> <li>均值 (Mean): \\(\\bar{x} = \\frac{1}{m} \\sum_{i=1}^{m} x_i\\)<ul> <li>缺点: 对离群点 (Outliers) 敏感。</li> </ul> </li> <li> <p>中位数 (Median):</p> \\[ \\text{median}(x) = \\begin{cases}  x_{(r+1)} &amp; \\text{若 } m \\text{ 为奇数, } m=2r+1 \\\\ \\frac{1}{2}(x_{(r)} + x_{(r+1)}) &amp; \\text{若 } m \\text{ 为偶数, } m=2r \\end{cases} \\] <ul> <li>特点: 鲁棒性强 (Robust)。</li> <li>截断均值 (Trimmed Mean): 去掉两端 \\(p\\%\\) 的极端值后计算的均值。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#dispersion-measures","level":4,"title":"散布度量 (Dispersion Measures)","text":"<ul> <li>极差 (Range): \\(\\text{range}(x) = \\max(x) - \\min(x)\\)</li> <li>方差 (Variance): \\(s_x^2 = \\frac{1}{m-1} \\sum_{i=1}^{m} (x_i - \\bar{x})^2\\)</li> <li>绝对平均偏差 (AAD): \\(\\text{AAD}(x) = \\frac{1}{m} \\sum_{i=1}^{m} |x_i - \\bar{x}|\\)</li> <li>中位数绝对偏差 (MAD): \\(\\text{MAD}(x) = \\text{median}(\\{|x_1 - \\bar{x}|, \\dots, |x_m - \\bar{x}|\\})\\)<ul> <li>注: MAD 对离群点非常鲁棒。</li> </ul> </li> <li>四分位数极差 (IQR): \\(IQR = x_{75\\%} - x_{25\\%}\\)</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#4-data-quality","level":3,"title":"4. 数据质量与噪声 (Data Quality)","text":"<ul> <li>噪声 (Noise): 测量误差的随机部分。<ul> <li>数学模型: \\(Observed = Signal + Noise\\)。</li> <li>处理: 信号处理、鲁棒算法。</li> </ul> </li> <li>离群点 (Outlier): 特征显著不同于其他大部分数据的对象。<ul> <li>可能是异常（Anomalous）对象，也可能是合法的高价值对象（如欺诈检测）。</li> </ul> </li> <li>缺失值处理策略:<ul> <li>删除对象/属性。</li> <li>估计/插值（均值、众数、回归）。</li> <li>加权填补（用所有可能值代替，以可能性为权重）。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#5-data-preprocessing","level":3,"title":"5. 数据预处理 (Data Preprocessing)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#51","level":4,"title":"5.1 聚集与抽样","text":"<ul> <li>聚集 (Aggregation): 转换标度（如从天到月），减少数据变异性 (Variability)，提高稳定性。</li> <li>抽样 (Sampling): 选择子集进行分析。<ul> <li>动机: 克服计算资源限制（与统计学中“获取数据成本高”的动机不同，数据挖掘关注的是“处理全量数据成本高”）。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#52-discretization-binarization","level":4,"title":"5.2 离散化与二元化 (Discretization &amp; Binarization)","text":"<p>将连续属性转换为分类属性，或将多分类转换为二元属性。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#_5","level":5,"title":"非监督离散化","text":"<ul> <li>等宽 (Equal Width)。</li> <li>等频 (Equal Frequency)。</li> <li>K-means 聚类离散化。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#entropy-based","level":5,"title":"监督离散化：基于熵 (Entropy-based)","text":"<p>利用类标号 (Class Labels) 信息，通过最小化熵来寻找最佳分割点。</p> <ul> <li> <p>区间熵的计算:     设 \\(k\\) 为类标号数，\\(m_i\\) 是第 \\(i\\) 个区间中值的总数，\\(m_{ij}\\) 是第 \\(i\\) 个区间中属于类 \\(j\\) 的值的数量。     第 \\(i\\) 个区间的熵 \\(e_i\\) 定义为：</p> \\[ e_i = - \\sum_{j=1}^{k} p_{ij} \\log_2 p_{ij} \\] <p>其中 \\(p_{ij} = \\frac{m_{ij}}{m_i}\\) 是第 \\(i\\) 个区间中类 \\(j\\) 的概率。</p> </li> <li> <p>总熵 (分割质量度量):     该分割的总熵 \\(e\\) 是每个区间熵的加权平均：</p> \\[ e = \\sum_{i=1}^{n} w_i e_i \\] <p>其中 \\(w_i = \\frac{m_i}{m}\\) 是第 \\(i\\) 个区间样本占总样本的比例，\\(n\\) 是区间个数。 算法逻辑: 寻找使总熵 \\(e\\) 最小的分割点，递归进行。</p> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#53-variable-transformation","level":4,"title":"5.3 变量变换 (Variable Transformation)","text":"<ul> <li>函数变换: \\(\\log(x), e^x, |x|\\) 等，用于改变数据分布。</li> <li>标准化/归一化 (Normalization):<ul> <li>Z-score: \\(x' = \\frac{x - \\bar{x}}{s}\\) (利用均值和标准差)。</li> <li>鲁棒标准化: 使用中位数代替均值，绝对标准差代替标准差。</li> <li>目的: 消除量纲影响，保持数值稳定性（对神经网络等基于梯度的算法至关重要）。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#6-feature-engineering","level":3,"title":"6. 特征工程 (Feature Engineering)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#_6","level":4,"title":"特征创建与提取","text":"<ul> <li>特征提取 (Feature Extraction): 针对具体领域（如图像、音频），由原始数据构建新特征。</li> <li>特征映射: 将数据映射到新空间（如傅立叶变换检测周期性模式）。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#dimensionality-reduction","level":4,"title":"维归约 (Dimensionality Reduction)","text":"<ul> <li>动机:<ul> <li>避免维数灾难。</li> <li>降低噪声（删除不相关特征）。</li> <li>降低时间/空间复杂度。</li> <li>可视化需求。</li> </ul> </li> <li>常用方法:<ul> <li>PCA (主成分分析): 线性、非监督，寻找最大方差方向。</li> <li>LDA (线性判别分析): 线性、监督，寻找最大类间距离方向。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#_7","level":4,"title":"原始特征的问题","text":"<ul> <li>相关性低: 特征与分类问题无关。</li> <li>病态矩阵: 特征过多且样本有限时，计算逆矩阵或参数估计时容易出现数值不稳定（病态矩阵问题）。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#lecture3-dimensionality-reduction-concept-learning","level":2,"title":"Lecture3 - 降维与概念学习 (Dimensionality Reduction &amp; Concept Learning)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#1_1","level":3,"title":"1. 降维技术概述","text":"<p>数据预处理中的核心步骤，旨在解决维数灾难 (Curse of Dimensionality)。</p> <ul> <li>目的:<ul> <li>提高算法的时间和内存效率。</li> <li>去除不相关特征与噪声，提升模型泛化能力。</li> <li>数据可视化 (通常降至2维或3维)。</li> </ul> </li> <li>分类:<ol> <li>特征提取 (Feature Extraction): 通过数学变换将原始特征空间映射到新的低维空间 (如 PCA, LDA)。</li> <li>特征选择 (Feature Selection): 从原始特征集中选出一个最佳子集 (如 Filter, Wrapper, Embedded)。</li> </ol> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#2-feature-extraction","level":3,"title":"2. 特征提取 (Feature Extraction)","text":"<p>将 \\(M\\) 个原始特征通过线性或非线性组合，转换为 \\(m\\) 个新特征 (\\(m &lt; M\\))。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#21-pca-","level":4,"title":"2.1 主成分分析 (PCA) - 无监督","text":"<ul> <li>核心思想: 将数据投影到方差最大的方向上。<ul> <li>方差 (Variance) 被视为信息的度量，方差越大，包含的信息（区分度）越大。</li> </ul> </li> <li>数学原理:<ul> <li>寻找正交变换矩阵 \\(A\\)，使得新特征 \\(y = A^T x\\) 的协方差矩阵对角化。</li> <li>选取协方差矩阵的前 \\(m\\) 个最大特征值对应的特征向量作为主成分。</li> </ul> </li> <li>优缺点:<ul> <li>优点: 无参数限制，计算快，正交去相关。</li> <li>缺点: 无监督（不利用类别标签），方差大的方向未必是分类效果最好的方向。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#22-lda-","level":4,"title":"2.2 线性判别分析 (LDA) - 有监督","text":"<ul> <li>核心思想 (Fisher 投影准则): 寻找最佳投影方向，使得投影后满足：<ul> <li>类内散度 (Intra-class scatter) 最小: 同类样本尽可能聚集。</li> <li>类间散度 (Inter-class scatter) 最大: 不同类样本尽可能分开。</li> </ul> </li> <li> <p>优化目标:     最大化广义瑞利商:</p> \\[ J(w) = \\frac{w^T S_B w}{w^T S_W w} \\] <p>其中 \\(S_B\\) 为类间散度矩阵，\\(S_W\\) 为类内散度矩阵。</p> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#3-feature-selection","level":3,"title":"3. 特征选择 (Feature Selection)","text":"<p>直接筛选特征子集，保留特征的原始物理含义。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#31","level":4,"title":"3.1 特征类型","text":"<ul> <li>冗余特征 (Redundant): 信息被其他特征包含（如“购买价格”与“含税价格”）。</li> <li>不相关特征 (Irrelevant): 对任务完全无用（如“学生ID”预测“成绩”）。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#32","level":4,"title":"3.2 选择策略 (三大类)","text":"<ol> <li>过滤法 (Filter)<ul> <li>机制: 在学习算法运行前进行，独立于具体模型。</li> <li>Relief 算法: 设计“相关统计量”。<ul> <li>计算样本与同类近邻 (Near-hit) 和异类近邻 (Near-miss) 的距离差。</li> <li>如果特征能让同类更近、异类更远，则权重增加。</li> </ul> </li> </ul> </li> <li>包装法 (Wrapper)<ul> <li>机制: 将学习算法作为“黑盒”，直接用模型的性能（如准确率）来评价特征子集。</li> <li>LVW (Las Vegas Wrapper): 随机采样特征子集 \\(\\rightarrow\\) 交叉验证评估 \\(\\rightarrow\\) 寻找最优。</li> <li>特点: 效果通常比过滤法好，但计算开销极大。</li> </ul> </li> <li>嵌入法 (Embedded)<ul> <li>机制: 特征选择过程与学习器训练过程融为一体。</li> <li>L1 正则化 (LASSO):<ul> <li>优化目标: \\(\\min \\sum (y_i - w^T x_i)^2 + \\lambda \\|w\\|_1\\)</li> <li>几何解释: L1范数 (\\(|w_1| + |w_2| \\le C\\)) 的等值线是方形，与损失函数的切点容易落在坐标轴上，导致部分系数 \\(w_i\\) 变为 0，从而实现稀疏化（特征选择）。</li> <li>对比: L2范数（圆形）通常只让权重变小，不易减为0。</li> </ul> </li> </ul> </li> </ol>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#4-concept-learning","level":3,"title":"4. 概念学习 (Concept Learning)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#41","level":4,"title":"4.1 基础定义","text":"<ul> <li>定义: 从训练样例中逼近一个布尔函数（目标概念）的过程。</li> <li>术语:<ul> <li>实例集合 (X): 总体。</li> <li>目标概念 (c): \\(c: X \\rightarrow \\{0, 1\\}\\) (待学习的真理)。</li> <li>训练样例 (D): 样本对 \\(\\langle x, c(x) \\rangle\\)。</li> <li>假设 (h): 学习器给出的估计函数，\\(h \\in H\\) (假设空间)。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#42-partial-ordering","level":4,"title":"4.2 偏序关系 (Partial Ordering)","text":"<p>假设空间存在“一般”与“特殊”的层级结构： *   More General (\\(\\ge_g\\)): 如果假设 \\(h_j\\) 覆盖的实例集合包含 \\(h_k\\) 覆盖的集合，则称 \\(h_j\\) 比 \\(h_k\\) 更一般。 *   作用: 使得我们可以通过搜索（而非枚举）来寻找目标假设。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#43","level":4,"title":"4.3 经典算法","text":"<ol> <li> <p>Find-S 算法</p> <ul> <li>策略: 寻找与正例一致的极大特殊 (Maximally Specific) 假设。</li> <li>流程: 初始化 \\(h\\) 为全 \\(\\emptyset\\) (最特殊)。每遇到一个正例，将 \\(h\\) 中不匹配的属性约束放宽（泛化）以覆盖该正例。</li> <li>缺点: 忽略反例，无法判断是否存在多个一致假设，对噪声敏感。</li> </ul> </li> <li> <p>候选消除算法 (Candidate-Elimination)</p> <ul> <li>变型空间 (Version Space): 假设空间 \\(H\\) 中所有与训练集 \\(D\\) 一致的假设集合。</li> <li>边界表示:<ul> <li>S集: 极大特殊边界 (Specific Boundary)。</li> <li>G集: 极大一般边界 (General Boundary)。</li> <li>变型空间即为 \\(S\\) 与 \\(G\\) 之间的所有假设。</li> </ul> </li> <li>流程:<ul> <li>正例 \\(\\rightarrow\\) 泛化 \\(S\\) (使其更一般)，移除 \\(G\\) 中不一致的。</li> <li>反例 \\(\\rightarrow\\) 特殊化 \\(G\\) (使其更特殊)，移除 \\(S\\) 中不一致的。</li> </ul> </li> <li>收敛: 当 \\(S\\) 和 \\(G\\) 收敛到同一个假设时，找到目标概念。</li> </ul> </li> </ol>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#5-inductive-bias-nfl","level":3,"title":"5. 归纳偏置与理论 (Inductive Bias &amp; NFL)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#51-inductive-bias","level":4,"title":"5.1 归纳偏置 (Inductive Bias)","text":"<ul> <li>定义: 学习算法在学习过程中对某种类型假设的偏好或预先假定。</li> <li>重要性: 如果没有归纳偏置，算法无法对未见样本 (Unseen Instances) 进行分类（即无法进行归纳推理）。</li> <li>类型:<ul> <li>奥卡姆剃刀 (Occam's Razor): 偏好简单的假设（若多个假设与观察一致，选最简单的）。</li> <li>限制偏置: 限制假设空间的形式（如只允许合取式）。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#52-nfl","level":4,"title":"5.2 没有免费的午餐定理 (NFL)","text":"<ul> <li>内容: 如果对所有可能的问题（所有可能的分布）求平均，所有学习算法（包括随机猜测）的期望性能是相同的。</li> <li> \\[ \\sum_f E_{ote}(\\mathcal{L}_a | X, f) = \\sum_f E_{ote}(\\mathcal{L}_b | X, f) \\] </li> <li>启示:<ul> <li>不存在“万能”的最佳算法。</li> <li>算法的优劣取决于其归纳偏置是否与具体问题的特征相匹配。</li> <li>研究机器学习必须关注具体的问题背景。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#lecture4-machine-learning-basics-image-features","level":2,"title":"Lecture4 - 机器学习基础与图像特征 (Machine Learning Basics &amp; Image Features)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#1_2","level":3,"title":"1. 机器学习的基本过程","text":"<p>机器学习的本质是寻找一个函数 (Looking for a Function)，通过数据拟合输入与输出之间的映射关系。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#11","level":4,"title":"1.1 一般流程","text":"<ol> <li>特征提取 (Feature Extraction): 将原始数据（如图像像素、音频波形）转化为计算机可理解的特征向量。</li> <li>定义模型集合 (Define a Set of Functions): 选定一个假设空间（如线性模型、神经网络）。</li> <li>确定最优准则 (Goodness of Function): 定义损失函数（Loss Function）来评估模型的好坏。</li> <li>选择最优映射 (Pick the Best Function): 利用学习算法（如梯度下降）在假设空间中搜索最优解。</li> </ol>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#12","level":4,"title":"1.2 举例","text":"<ul> <li>图像识别: \\(f(\\text{Image}) = \\text{\"Cat\"}\\)</li> <li>语音识别: \\(f(\\text{Audio}) = \\text{\"How are you\"}\\)</li> <li>围棋: \\(f(\\text{Board State}) = \\text{Next Move}\\)</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#2-image-features","level":3,"title":"2. 图像特征基础 (Image Features)","text":"<p>特征是连接原始数据与机器学习算法的桥梁。根据人类视觉系统的感知，图像特征分为三个层次：</p> <ol> <li>低层特征 (Low-level Features): 描述图像的视觉属性（外观、边缘、纹理、形状）。</li> <li>中层语义 (Mid-level Representations): 连接低层与高层的纽带，如视觉词袋 (BoW)。</li> <li>高层语义特征 (High-level Semantic Features): 场景、行为、情感等抽象概念。</li> </ol>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#3","level":3,"title":"3. 常见的图像特征描述子","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#31-color-features","level":4,"title":"3.1 颜色特征 (Color Features)","text":"<ul> <li>颜色矩 (Color Moments):<ul> <li>利用一阶矩（均值 \\(\\mu\\)）、二阶矩（标准差 \\(\\sigma\\)）、三阶矩（偏度 \\(s\\)）来描述颜色分布。</li> <li>通常在 RGB 空间计算，共 9 个分量（3个通道 \\(\\times\\) 3个矩）。</li> </ul> </li> <li>颜色直方图 (Color Histogram):<ul> <li>统计图像中不同颜色出现的频率。</li> <li>特点: 对图像旋转、平移、缩放具有不变性，但丢失了空间信息。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#32-shape-features","level":4,"title":"3.2 形状特征 (Shape Features)","text":"<ul> <li>Hu 不变矩 (Hu Moments):<ul> <li>利用二阶和三阶中心矩构造出的 7 个不变矩（\\(\\phi_1 \\sim \\phi_7\\)）。</li> <li>特点: 对平移、旋转、尺度缩放具有不变性 (Translation, Rotation, Scale Invariant)。</li> <li>常用于简单的物体识别（如商标、二值图像）。</li> </ul> </li> <li>傅里叶描述子 (Fourier Descriptors):<ul> <li>将物体边界视为封闭曲线，通过傅里叶变换将边界坐标转换为频域系数。</li> <li>低频系数描述整体形状，高频系数描述细节。</li> </ul> </li> <li>Hough 变换 (Hough Transform):<ul> <li>用于检测直线、圆等参数化形状。</li> <li>核心思想: 将图像空间的点映射到参数空间（投票机制）。</li> <li>直线检测: 利用极坐标方程 \\(\\rho = x \\cos\\theta + y \\sin\\theta\\)。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#33-texture-features","level":4,"title":"3.3 纹理特征 (Texture Features)","text":"<ul> <li>灰度共生矩阵 (GLCM):<ul> <li>统计像素对 \\((i, j)\\) 在特定方向 \\(\\theta\\) 和距离 \\(d\\) 下同时出现的概率。</li> <li>基于 GLCM 可计算能量、熵、对比度、相关性等统计量。</li> </ul> </li> <li>局部二值模式 (LBP):<ul> <li>比较中心像素与 \\(3 \\times 3\\) 邻域像素的大小，生成二进制编码。</li> <li>特点: 计算简单，对光照变化具有较强的鲁棒性，常用于人脸识别和纹理分类。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#34-bag-of-words-bow","level":4,"title":"3.4 中层语义特征：视觉词袋模型 (Bag-of-Words, BoW)","text":"<ul> <li>灵感: 源于文本处理（统计文档中关键词的频率）。</li> <li>流程:<ol> <li>特征提取: 提取图像局部特征（如 SIFT）。</li> <li>生成码书 (Codebook Generation): 利用 K-means 聚类将特征量化为“视觉单词 (Visual Words)”。</li> <li>特征编码: 统计图像中每个视觉单词出现的频率，生成直方图向量。</li> </ol> </li> <li>应用: 图像检索、场景分类。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#lecture5-model-assessment-and-selection","level":2,"title":"Lecture5 - 模型评估与选择 (Model Assessment and Selection)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#1-loss-risk","level":3,"title":"1. 损失函数与风险 (Loss &amp; Risk)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#11-loss-function","level":4,"title":"1.1 损失函数 (Loss Function)","text":"<p>损失函数 \\(L(y, f(x))\\) 用于度量模型预测值 \\(f(x)\\) 与真实值 \\(y\\) 之间的差异。常见的损失函数包括： *   0-1 损失 (0-1 loss): 用于分类问题，预测错误为1，正确为0。 *   平方损失 (Quadratic loss): \\(L(y, f(x)) = (y - f(x))^2\\)，常用于回归。 *   绝对损失 (Absolute loss): \\(L(y, f(x)) = |y - f(x)|\\)。 *   对数损失 (Logarithmic loss): \\(L(y, P(y|x)) = -\\log P(y|x)\\)，常用于概率预测。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#12-risk-function","level":4,"title":"1.2 风险函数 (Risk Function)","text":"<ul> <li>期望风险 (Expected Risk / Risk Function): \\(R_{exp}(f)\\) 是模型在联合分布 \\(P(X,Y)\\) 下的平均损失，代表模型在总体样本上的表现（理论值，通常未知）。</li> <li> <p>经验风险 (Empirical Risk): \\(R_{emp}(f)\\) 是模型在训练数据集上的平均损失。</p> \\[ R_{emp}(f) = \\frac{1}{N} \\sum_{i=1}^{N} L(y_i, f(x_i)) \\] </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#13","level":4,"title":"1.3 模型选择策略","text":"<ul> <li>经验风险最小化 (ERM): 直接最小化训练误差。当样本量较小时，易导致过拟合 (Overfitting)。</li> <li>结构风险最小化 (SRM): 在经验风险的基础上加入正则化项 \\(\\lambda J(f)\\)，平衡模型的拟合能力与复杂度，防止过拟合。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#2-performance-measures","level":3,"title":"2. 性能度量 (Performance Measures)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#21","level":4,"title":"2.1 分类任务的基础指标","text":"<ul> <li>错误率 (Error Rate): 误分类样本占比。</li> <li>准确率 (Accuracy): 正确分类样本占比。<ul> <li>局限性: 在样本不平衡（如正样本极少）的情况下，准确率会失效（例如全部预测为负类也能得到极高准确率）。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#22","level":4,"title":"2.2 混淆矩阵与衍生指标","text":"<p>混淆矩阵 (Confusion Matrix) 将预测结果分为四类：TP (真反), FN (假负), FP (假正), TN (真负)。</p> <ul> <li>查准率/精度 (Precision): \\(P = \\frac{TP}{TP + FP}\\)。预测为正的样本中有多少是真的正样本。</li> <li>查全率/召回率 (Recall/Sensitivity): \\(R = \\frac{TP}{TP + FN}\\)。所有正样本中有多少被预测出来了。</li> <li> <p>F1 度量: Precision 和 Recall 的调和平均数，用于综合评估。</p> \\[ F_1 = \\frac{2 \\times P \\times R}{P + R} \\] </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#23-p-r-roc","level":4,"title":"2.3 P-R 曲线与 ROC 曲线","text":"<ul> <li>P-R 曲线: 以查准率 P 为纵轴，查全率 R 为横轴。</li> <li>ROC 曲线 (Receiver Operating Characteristic):<ul> <li>纵轴: 真正率 (TPR) = Recall = \\(\\frac{TP}{TP + FN}\\)</li> <li>横轴: 假正率 (FPR) = \\(\\frac{FP}{TN + FP}\\) (负样本中被误判为正的比例)</li> <li>优势: 相比 P-R 曲线，ROC 曲线对样本类别比例不敏感。</li> </ul> </li> <li>AUC (Area Under ROC Curve): ROC 曲线下的面积。AUC 越大，模型性能越好（理想值为1，随机猜测为0.5）。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#3_1","level":3,"title":"3. 模型检验与比较方法","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#31-evaluation-methods","level":4,"title":"3.1 评估方法 (Evaluation Methods)","text":"<ul> <li>留出法 (Hold-out): 将数据集划分为互斥的训练集和验证集（如 2/3 训练，1/3 验证）。需保持数据分布一致性，通常采用多次随机划分取平均。</li> <li>交叉验证法 (Cross Validation):<ul> <li>K折交叉验证: 将数据分 K 份，轮流用 K-1 份训练，1 份测试。</li> <li>留一法 (LOO): K 等于样本数，每次只留一个样本做测试。准确但计算量大。</li> </ul> </li> <li>自助法 (Bootstrapping): 有放回采样，适合小数据集。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#32-hypothesis-testing","level":4,"title":"3.2 统计假设检验 (Hypothesis Testing)","text":"<p>用于判断两个模型性能的差异是否具有统计学意义，而非仅仅是随机波动。 *   二项检验 / t 检验: 比较单个或两个模型在特定数据集上的表现。 *   McNemar 检验: 比较两个分类器在同一测试集上的分类结果差异。 *   Friedman 检验 &amp; Nemenyi 检验: 用于多个算法在多个数据集上的性能比较与排序。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#4-bias-variance-decomposition","level":3,"title":"4. 偏差-方差分解 (Bias-Variance Decomposition)","text":"<p>泛化误差可以分解为三部分： $$ E(f; D) = \\text{Bias}^2 + \\text{Variance} + \\text{Noise} $$</p> <ul> <li>偏差 (Bias): 学习算法的期望预测与真实结果的偏离程度。度量了算法的拟合能力。<ul> <li>欠拟合 (Underfitting): 偏差主导，模型太简单，连训练集都学不好。</li> </ul> </li> <li>方差 (Variance): 同样大小的训练集的变动所导致的学习性能的变化。度量了算法的稳定性。<ul> <li>过拟合 (Overfitting): 方差主导，模型太复杂，对训练数据的微小扰动极其敏感。</li> </ul> </li> <li>噪声 (Noise): 数据本身的固有误差，是学习性能的上限（无法克服）。</li> </ul> <p>权衡 (Trade-off): *   增加模型复杂度（如增加多项式阶数）：偏差减小，方差增大（易过拟合）。 *   降低模型复杂度（如正则化）：偏差增大，方差减小（易欠拟合）。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#lecture6-linear-classifiers-and-optimization-criteria","level":2,"title":"Lecture6 - 线性分类器与优化准则 (Linear Classifiers and Optimization Criteria)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#1-linear-classifier-basics","level":3,"title":"1. 线性分类器基础 (Linear Classifier Basics)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#11_1","level":4,"title":"1.1 基本概念","text":"<ul> <li>定义: 通过一个线性判别函数（直线、平面或超平面）将特征空间一分为二的分类器。</li> <li>判别函数:     $$ g(x) = w^T x + w_0 $$     其中 \\(w\\) 为权向量，\\(w_0\\) 为阈值（或偏置）。</li> <li>决策规则:<ul> <li>若 \\(g(x) &gt; 0\\)，判为正类 (\\(\\omega_1\\))。</li> <li>若 \\(g(x) &lt; 0\\)，判为负类 (\\(\\omega_2\\))。</li> <li>若 \\(g(x) = 0\\)，位于决策面上（边界）。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#12-augmented-transformation","level":4,"title":"1.2 增广变换 (Augmented Transformation)","text":"<p>为了简化数学处理，将权向量 \\(w\\) 和偏置 \\(w_0\\) 合并： *   增广样本向量: \\(y = [1, x_1, x_2, \\dots, x_d]^T\\) (维数 \\(D+1\\))。 *   增广权向量: \\(a = [w_0, w_1, w_2, \\dots, w_d]^T\\)。 *   新判别函数: \\(g(x) = a^T y\\)。决策面变为过原点的超平面 \\(a^T y = 0\\)。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#2-perpendicular-bisector-classifier","level":3,"title":"2. 垂直平分分类器 (Perpendicular Bisector Classifier)","text":"<p>又称最小距离分类器 (Minimum Distance Classifier)。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#21_1","level":4,"title":"2.1 设计思路","text":"<ul> <li>基于两类样本的均值向量 (\\(m_1, m_2\\))。</li> <li>决策面是连接两类均值点线段的垂直平分面。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#22_1","level":4,"title":"2.2 数学形式","text":"<ul> <li> <p>判别函数:</p> \\[ g(x) = (m_1 - m_2)^T x - \\frac{1}{2}(m_1 - m_2)^T (m_1 + m_2) \\] </li> <li> <p>等价形式:</p> \\[ d(x, m_1) &lt; d(x, m_2) \\Rightarrow x \\in \\omega_1 \\] <p>即样本距离哪个类的均值更近，就判为哪一类。</p> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#23","level":4,"title":"2.3 特点","text":"<ul> <li>计算简单，无须复杂的优化过程。</li> <li>非最佳决策: 仅考虑均值，未考虑样本的分布方差（离散度）。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#3-fisher-fisher-linear-discriminant","level":3,"title":"3. Fisher 线性判别分析 (Fisher Linear Discriminant)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#31_1","level":4,"title":"3.1 核心思想","text":"<p>将高维样本投影到一维直线上，使得投影后的样本： *   类内距离最小 (Within-class scatter minimized): 同类样本尽可能聚集。 *   类间距离最大 (Between-class scatter maximized): 不同类样本尽可能分开。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#32-fisher","level":4,"title":"3.2 Fisher 准则函数","text":"\\[ J_F(w) = \\frac{( \\tilde{m}_1 - \\tilde{m}_2 )^2}{\\tilde{S}_1^2 + \\tilde{S}_2^2} \\] <p>其中 \\(\\tilde{m}\\) 为投影后的均值，\\(\\tilde{S}^2\\) 为投影后的类内离散度。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#33","level":4,"title":"3.3 最佳投影方向","text":"<p>通过对 \\(J_F(w)\\) 求导并令其为 0 (使用 Lagrange 乘子法)，得到最佳投影方向 \\(w^*\\)：</p> \\[ w^* = S_W^{-1} (m_1 - m_2) \\] <p>其中 \\(S_W\\) 为总类内离散度矩阵。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#4-perceptron-criterion","level":3,"title":"4. 感知器准则 (Perceptron Criterion)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#41_1","level":4,"title":"4.1 适用前提","text":"<p>样本集必须是线性可分 (Linearly Separable) 的，即存在一个超平面能将两类完全分开。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#42","level":4,"title":"4.2 规范化","text":"<p>为了统一处理，将所有负类 (\\(\\omega_2\\)) 样本的增广向量乘以 -1。 *   规范化后目标: 寻找权向量 \\(a\\)，使得对所有样本 \\(y_i\\)，都有 \\(a^T y_i &gt; 0\\)。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#43_1","level":4,"title":"4.3 准则函数","text":"<p>感知器准则函数只关注被错误分类的样本集合 \\(Y_{error}\\)：</p> \\[ J_p(a) = \\sum_{y \\in Y_{error}} (-a^T y) \\] <ul> <li>若所有样本正确分类，\\(Y_{error}\\) 为空，\\(J_p(a) = 0\\) (极小值)。</li> <li>若有错分，错分样本的 \\(a^T y &lt; 0\\)，则 \\(-a^T y &gt; 0\\)，导致 \\(J_p(a) &gt; 0\\)。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#44","level":4,"title":"4.4 优化算法 (梯度下降)","text":"<p>使用梯度下降法迭代求解 \\(a\\)：</p> \\[ a(k+1) = a(k) + \\rho_k \\sum_{y \\in Y_{error}} y \\] <ul> <li>物理意义: 当出现错分样本时，用该样本向量去“修正”权向量，直到所有样本都被正确分类。</li> <li>收敛性: 若样本线性可分，感知器算法保证收敛。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#lecture7-bayesian-classifiers","level":2,"title":"Lecture7 - 贝叶斯分类器 (Bayesian Classifiers)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#1_3","level":3,"title":"1. 贝叶斯理论基础","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#11_2","level":4,"title":"1.1 核心公式","text":"<ul> <li> <p>贝叶斯公式 (Bayes' Theorem):</p> \\[ P(\\omega_i | x) = \\frac{P(x | \\omega_i) P(\\omega_i)}{P(x)} \\] <ul> <li>\\(P(\\omega_i)\\): 先验概率 (Prior)，类别 \\(\\omega_i\\) 在观察到数据前发生的概率。</li> <li>\\(P(x | \\omega_i)\\): 类条件概率 (Class-Conditional Probability) / 似然 (Likelihood)，在类别 \\(\\omega_i\\) 下观察到特征 \\(x\\) 的概率。</li> <li>\\(P(\\omega_i | x)\\): 后验概率 (Posterior)，在观察到特征 \\(x\\) 后，样本属于类别 \\(\\omega_i\\) 的概率。</li> <li>\\(P(x)\\): 证据因子 (Evidence)，归一化常数，\\(P(x) = \\sum_j P(x | \\omega_j) P(\\omega_j)\\)。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#12-vs","level":4,"title":"1.2 频率派 vs 贝叶斯派","text":"<ul> <li>频率派 (Frequentist): 认为参数 \\(\\theta\\) 是固定但未知的常数，通过最大化似然函数 \\(P(X; \\theta)\\) 来估计参数 (MLE)。</li> <li>贝叶斯派 (Bayesian): 认为参数 \\(\\theta\\) 是随机变量，服从某个先验分布，通过最大化后验概率 \\(P(\\theta | X)\\) 来估计参数 (MAP)。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#2-bayes-minimum-error-rate","level":3,"title":"2. 最小错误率 Bayes 决策 (Minimum Error Rate)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#21_2","level":4,"title":"2.1 决策规则","text":"<p>目标是使分类错误的概率最小化。 *   规则: 将样本 \\(x\\) 分配给后验概率最大的类别。</p> <pre><code>$$ \\text{Decide } \\omega_i \\text{ if } P(\\omega_i | x) &gt; P(\\omega_j | x), \\forall j \\neq i $$\n</code></pre> <ul> <li>等价规则:<ul> <li>比较分子 (忽略 \\(P(x)\\)): \\(p(x | \\omega_i) P(\\omega_i) &gt; p(x | \\omega_j) P(\\omega_j)\\)</li> <li>似然比检验: \\(\\frac{p(x | \\omega_i)}{p(x | \\omega_j)} &gt; \\frac{P(\\omega_j)}{P(\\omega_i)}\\)</li> <li>对数似然比: \\(\\ln p(x | \\omega_i) + \\ln P(\\omega_i) &gt; \\ln p(x | \\omega_j) + \\ln P(\\omega_j)\\)</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#22_2","level":4,"title":"2.2 特点","text":"<ul> <li>在概率意义上是最优的。</li> <li>需要知道先验概率和类条件概率密度（通常难以准确获得）。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#3-bayes-minimum-risk","level":3,"title":"3. 最小风险 Bayes 决策 (Minimum Risk)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#31_2","level":4,"title":"3.1 问题的提出","text":"<p>最小错误率假设所有错误的代价是一样的。但在实际应用中（如癌症诊断），漏报 (False Negative) 的代价通常远高于 误报 (False Positive)。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#32_1","level":4,"title":"3.2 风险函数","text":"<ul> <li>损失函数 \\(\\lambda(\\alpha_i, \\omega_j)\\): 真实类别为 \\(\\omega_j\\) 但决策为 \\(\\alpha_i\\) 时的代价。</li> <li>条件风险 \\(R(\\alpha_i | x)\\): 对于特定样本 \\(x\\)，采取决策 \\(\\alpha_i\\) 的期望损失。     $$ R(\\alpha_i | x) = \\sum_{j=1}^C \\lambda(\\alpha_i, \\omega_j) P(\\omega_j | x) $$</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#33_1","level":4,"title":"3.3 决策规则","text":"<ul> <li> <p>规则: 选择使条件风险最小的决策。</p> \\[ \\alpha^* = \\arg \\min_{\\alpha_i} R(\\alpha_i | x) \\] </li> <li> <p>与最小错误率的关系: 当采用 0-1 损失函数 (对错分惩罚为1，正确为0) 时，最小风险决策等价于最小错误率决策。</p> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#4-minimax-decision","level":3,"title":"4. 最小最大决策 (Minimax Decision)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#41_2","level":4,"title":"4.1 适用场景","text":"<p>当先验概率 \\(P(\\omega_i)\\) 未知或不确定时，传统的贝叶斯决策无法直接使用。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#42_1","level":4,"title":"4.2 核心思想","text":"<ul> <li>设计一个分类器，使得在最坏的先验概率分布下，风险也是最小的。</li> <li>博弈论视角：假设“大自然”会选择一个让分类器风险最大的先验分布，而分类器的目标是最小化这个最大风险。</li> <li>这是一种保守的策略，保证了性能的下限。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#5-bayes","level":3,"title":"5. 正态分布下的 Bayes 分类器","text":"<p>当类条件概率密度 \\(p(x | \\omega_i)\\) 服从多维正态分布 \\(N(\\mu_i, \\Sigma_i)\\) 时，判别函数可以写成二次型形式：</p> \\[ g_i(x) = -\\frac{1}{2}(x - \\mu_i)^T \\Sigma_i^{-1} (x - \\mu_i) - \\frac{1}{2} \\ln |\\Sigma_i| + \\ln P(\\omega_i) \\]","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#_8","level":4,"title":"特殊情况下的决策面","text":"<ol> <li>\\(\\Sigma_i = \\sigma^2 I\\) (各维度独立等方差): 决策面是线性的，退化为最小欧氏距离分类器（考虑先验修正）。</li> <li>\\(\\Sigma_i = \\Sigma\\) (各类协方差矩阵相同): 决策面是线性的 (Linear Discriminant Analysis, LDA)。</li> <li>\\(\\Sigma_i\\) 任意: 决策面是二次曲面 (Quadratic Discriminant Analysis, QDA)，如双曲线、椭圆、抛物线等。</li> </ol>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#lecture8-advanced-linear-classifiers","level":2,"title":"Lecture8 - 线性分类器进阶 (Advanced Linear Classifiers)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#1-minimum-squared-error-criterion","level":3,"title":"1. 最小错分样本数准则 (Minimum Squared Error Criterion)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#11_3","level":4,"title":"1.1 问题的提出","text":"<ul> <li>感知器准则要求样本集必须是线性可分的，否则无法收敛。</li> <li>在实际应用中，完全线性可分的情况很少见。</li> <li>目标: 寻找一个权向量，使得被错误分类的样本数量最少。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#12_1","level":4,"title":"1.2 准则函数","text":"<ul> <li> <p>准则一: 直接最小化错分样本的模长。</p> \\[ J(a) = || Ya - b ||^2 \\] <ul> <li>\\(Y\\): 样本矩阵。</li> <li>\\(b\\): 正常数向量（如全1向量）。</li> <li>准则二: 利用不等式约束。</li> </ul> \\[ \\max J(a) = \\sum_{i=1}^N \\frac{1 + \\text{sgn}(a^T y_i)}{2} \\] <ul> <li>\\(\\text{sgn}(u) = 1\\) 若 \\(u \\ge 0\\)，否则为 -1。</li> <li>该函数直接统计正确分类的样本数，但难以优化（非连续、不可导）。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#13_1","level":4,"title":"1.3 求解方法","text":"<ul> <li>通常采用启发式搜索或近似算法。</li> <li>特点: 设计过程复杂，计算量大。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#2-minimum-squared-error-mse","level":3,"title":"2. 最小平方误差准则 (Minimum Squared Error, MSE)","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#21_3","level":4,"title":"2.1 核心思想","text":"<p>将分类问题转化为回归问题。</p> <ul> <li>将不等式约束 \\(a^T y_i &gt; 0\\) 转化为等式约束 \\(a^T y_i = b_i\\) (\\(b_i &gt; 0\\))。</li> <li>目标是使实际输出 \\(a^T y_i\\) 与期望输出 \\(b_i\\) 之间的均方误差最小。</li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#22_3","level":4,"title":"2.2 准则函数","text":"\\[ J(a) = || Ya - b ||^2 = \\sum_{i=1}^N (a^T y_i - b_i)^2 \\] <p>其中 \\(Y\\) 是样本矩阵（每一行为一个样本），\\(b\\) 是目标向量（通常设为全1）。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#23_1","level":4,"title":"2.3 极值解","text":"<p>通过对 \\(J(a)\\) 求导并令其为 0，可得解析解：</p> \\[ a^* = (Y^T Y)^{-1} Y^T b \\] <ul> <li>\\(Y^\\dagger = (Y^T Y)^{-1} Y^T\\) 被称为 \\(Y\\) 的伪逆矩阵 (Pseudo-Inverse)。</li> <li>特点:<ul> <li>解析解存在且唯一（若 \\(Y^T Y\\) 可逆）。</li> <li>计算简单，无需迭代。</li> <li>即使样本线性不可分，也能得到一个解（MSE 意义下的最优解）。</li> </ul> </li> </ul>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#3_2","level":3,"title":"3. 总结与回顾","text":"","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#31_3","level":4,"title":"3.1 线性分类器对比","text":"准则 适用条件 优点 缺点 垂直平分 无 简单直观 仅考虑均值，未考虑分布，非最优 Fisher 无 考虑了类内离散度，类间距离最大化 需计算逆矩阵，投影后可能重叠 感知器 线性可分 保证收敛到解 不可分时不收敛，解不唯一 MSE 无 有解析解，计算快 对离群点敏感，非分类错误率最小","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DMML_24Fall_Re/#32_2","level":4,"title":"3.2 实验与应用","text":"<ul> <li>实验1: 手写LBP特征提取。LBP (Local Binary Pattern) 是一种纹理特征，对光照变化鲁棒。</li> <li>实验2: 垂直平分分类器编程实现。</li> </ul> <p>Final Note: 线性分类器是机器学习的基石。虽然现代深度学习模型（如 CNN, Transformer）在复杂任务上表现更好，但线性模型因其可解释性强、计算效率高，在很多场景下仍然是首选基准模型。</p>","path":["DMML_24Fall_Re"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A0%87%E7%AD%BE%E4%BD%93%E7%B3%BB%E4%B8%8B%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7%E8%AF%81%E6%98%8E/","level":1,"title":"关于二分类问题中两种标签体系下逻辑斯谛回归损失函数的等价性证明","text":"<p>主要是老师要求让我顺手写一个Note，于是有了这篇小笔记</p>","path":["关于二分类问题中两种标签体系下逻辑斯谛回归损失函数的等价性证明"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A0%87%E7%AD%BE%E4%BD%93%E7%B3%BB%E4%B8%8B%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7%E8%AF%81%E6%98%8E/#_2","level":2,"title":"问题陈述","text":"<p>在二分类问题中，我们通常采用两种标签体系：\\(y \\in \\{0, 1\\}\\) 或 \\(y' \\in \\{-1, +1\\}\\)。此Note旨在严格证明：对于逻辑斯谛回归（Logistic Regression）模型，基于这两种不同标签体系定义的负对数似然损失函数在本质上是完全等价的。我们将首先证明单个样本的损失函数等价（见引理1），进而证明基于经验风险最小化（ERM）的整体优化目标函数完全等价，因此最终求解出的模型参数\\(\\theta\\)是完全相同的（见定理1）。</p>","path":["关于二分类问题中两种标签体系下逻辑斯谛回归损失函数的等价性证明"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A0%87%E7%AD%BE%E4%BD%93%E7%B3%BB%E4%B8%8B%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7%E8%AF%81%E6%98%8E/#_3","level":2,"title":"符号与基础设定","text":"<p>为保证清晰，我们首先统一符号：</p> <ul> <li>令 \\(x_i\\) 表示第 \\(i\\) 个样本的特征向量。</li> <li>令 \\(s_i = \\theta^T x_i\\) 为模型对样本 \\(x_i\\) 的原始线性输出（logit）。</li> <li>使用Sigmoid函数 \\(\\sigma(s) = \\frac{1}{1 + \\exp(-s)}\\) 将原始输出映射为概率。</li> <li>我们有两个标签体系：<ul> <li>体系一: \\(y_i \\in \\{0, 1\\}\\)</li> <li>体系二: \\(y'_i \\in \\{-1, +1\\}\\)</li> </ul> </li> </ul>","path":["关于二分类问题中两种标签体系下逻辑斯谛回归损失函数的等价性证明"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A0%87%E7%AD%BE%E4%BD%93%E7%B3%BB%E4%B8%8B%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7%E8%AF%81%E6%98%8E/#y_i-in-0-1","level":2,"title":"体系一：\\(y_i \\in \\{0, 1\\}\\) 下的损失函数","text":"<p>在此体系下，模型的预测概率被定义为：</p> \\[P(y_i=1 | s_i) = \\sigma(s_i) = \\frac{1}{1 + \\exp(-s_i)}\\] \\[P(y_i=0 | s_i) = 1 - \\sigma(s_i) = \\frac{1}{1 + \\exp(s_i)}\\] <p>为了方便计算，我们可以将这两个概率用一个统一的伯努利分布表达式表示：</p> \\[P(y_i | s_i) = [\\sigma(s_i)]^{y_i} [1 - \\sigma(s_i)]^{1-y_i}\\] <p>该模型的损失函数通常由负对数似然（Negative Log-Likelihood）函数给出。对于单个样本 \\(i\\)，其损失 \\(L_1\\) 为：</p> \\[L_1(y_i, s_i) = -\\log P(y_i | s_i) = -[y_i \\log(\\sigma(s_i)) + (1-y_i)\\log(1-\\sigma(s_i))]\\] <p>将 \\(\\sigma(s_i)\\) 的定义代入并化简，最终形式为：</p> \\[ L_1(y_i, s_i) = \\log(1+\\exp(s_i)) - y_i s_i \\]","path":["关于二分类问题中两种标签体系下逻辑斯谛回归损失函数的等价性证明"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A0%87%E7%AD%BE%E4%BD%93%E7%B3%BB%E4%B8%8B%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7%E8%AF%81%E6%98%8E/#y_i-in-1-1","level":2,"title":"体系二：\\(y'_i \\in \\{-1, +1\\}\\) 下的损失函数","text":"<p>在此体系下，一个非常巧妙的技巧是将概率统一表示为 \\(P(y'_i | s_i) = \\sigma(y'_i s_i)\\)。 * 当 \\(y'_i = +1\\) 时: \\(P(y'_i=+1 | s_i) = \\sigma(s_i)\\)。 * 当 \\(y'_i = -1\\) 时: \\(P(y'_i=-1 | s_i) = \\sigma(-s_i) = \\frac{1}{1+\\exp(s_i)}\\)。</p> <p>同样，我们基于负对数似然来定义单个样本的损失函数 \\(L_2\\)：</p> \\[L_2(y'_i, s_i) = -\\log P(y'_i | s_i) = -\\log(\\sigma(y'_i s_i))\\] <p>代入Sigmoid函数的定义并化简：</p> \\[ \\begin{aligned} L_2(y'_i, s_i) &amp;= -\\log\\left(\\frac{1}{1+\\exp(-y'_i s_i)}\\right) \\\\ &amp;= \\log(1+\\exp(-y'_i s_i)) \\end{aligned} \\] <p>这个形式非常简洁。</p>","path":["关于二分类问题中两种标签体系下逻辑斯谛回归损失函数的等价性证明"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A0%87%E7%AD%BE%E4%BD%93%E7%B3%BB%E4%B8%8B%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7%E8%AF%81%E6%98%8E/#_4","level":2,"title":"等价性证明","text":"<p>现在，我们来证明 \\(L_1(y_i, s_i)\\) 和 \\(L_2(y'_i, s_i)\\) 是等价的。这两种标签体系可以通过一个简单的线性变换进行转换：</p> \\[y'_i = 2y_i - 1\\] <p>反之，\\(y_i = \\frac{y'_i + 1}{2}\\)。</p> <p>我们通过分情况讨论来证明，在标签一一对应的情况下，两种损失函数的计算结果完全相同。</p> <p>[!NOTE] 引理1 对于任意样本\\(x_{i}\\)​，其在两种标签体系下的标签\\(y_i ​\\in \\{0,1\\}\\) 和 \\(y_{i}'​\\in\\{−1,+1\\}\\) 满足线性变换关系\\(y_{i}'​=2y_i​−1\\)。那么，为该样本定义的两种损失函数\\(L_1​(y_i​,s_i​)\\) 和\\(L_2​(y_{i}',s_{i}'​)\\)的计算结果完全相等。</p> <p><code>Proof.</code></p>","path":["关于二分类问题中两种标签体系下逻辑斯谛回归损失函数的等价性证明"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A0%87%E7%AD%BE%E4%BD%93%E7%B3%BB%E4%B8%8B%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7%E8%AF%81%E6%98%8E/#y_i-1-iff-y_i-1","level":3,"title":"情况一：\\(y_i = 1 \\iff y'_i = +1\\)","text":"<p>计算 \\(L_1\\)：</p> \\[L_1(1, s_i) = \\log(1+\\exp(s_i)) - (1) \\cdot s_i = \\log(1+\\exp(-s_i))\\] <p>计算 \\(L_2\\)：</p> \\[L_2(+1, s_i) = \\log(1+\\exp(-(+1) \\cdot s_i)) = \\log(1+\\exp(-s_i))\\] <p>在此情况下，\\(L_1 = L_2\\)。</p>","path":["关于二分类问题中两种标签体系下逻辑斯谛回归损失函数的等价性证明"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A0%87%E7%AD%BE%E4%BD%93%E7%B3%BB%E4%B8%8B%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7%E8%AF%81%E6%98%8E/#y_i-0-iff-y_i-1","level":3,"title":"情况二：\\(y_i = 0 \\iff y'_i = -1\\)","text":"<p>计算 \\(L_1\\)：</p> \\[L_1(0, s_i) = \\log(1+\\exp(s_i)) - (0) \\cdot s_i = \\log(1+\\exp(s_i))\\] <p>计算 \\(L_2\\)：</p> \\[L_2(-1, s_i) = \\log(1+\\exp(-(-1) \\cdot s_i)) = \\log(1+\\exp(s_i))\\] <p>在此情况下，\\(L_1 = L_2\\)。</p>","path":["关于二分类问题中两种标签体系下逻辑斯谛回归损失函数的等价性证明"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A0%87%E7%AD%BE%E4%BD%93%E7%B3%BB%E4%B8%8B%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7%E8%AF%81%E6%98%8E/#_5","level":2,"title":"整体优化问题与参数估计的等价性","text":"<p>[!tip] 定理1 对于逻辑斯谛回归模型，分别在 y∈{0,1} 和 y′∈{−1,+1} 两种标签体系下，其基于经验风险最小化（ERM）原则所构建的整体优化目标函数是等价的。因此，通过优化求解得到的模型最优参数估计 θ^ 是完全相同的。</p> <p><code>Proof.</code></p> <p>在逻辑斯谛回归中，我们的目标是找到参数 θ 以最小化在整个数据集上的平均损失，即经验风险。</p> <p>体系一的整体目标函数\\(J_1​(\\theta)\\)为：</p> \\[J_1(\\theta) = \\frac{1}{n}\\sum_{i=1}^{n} L_1(y_i, \\theta^T x_i) = \\frac{1}{n}\\sum_{i=1}^{n} \\left[ \\log(1+\\exp(\\theta^T x_i)) - y_i (\\theta^T x_i) \\right]\\] <p>其最优参数\\(\\hat{\\theta}_1\\)为：</p> \\[\\hat{\\theta}_1 = \\arg\\min_{\\theta} J_1(\\theta)\\] <p>体系二 的整体目标函数\\(J_2​(\\theta)\\)为：</p> \\[J_2(\\theta) = \\frac{1}{n}\\sum_{i=1}^{n} L_2(y'_i, \\theta^T x_i) = \\frac{1}{n}\\sum_{i=1}^{n} \\log(1+\\exp(-y'_i (\\theta^T x_i)))\\] <p>其最优参数\\(\\hat{\\theta}_2\\)为：</p> \\[\\hat{\\theta}_2 = \\arg\\min_{\\theta} J_2(\\theta)\\] <p>根据引理1，对于每一个样本\\(i\\)，其损失函数就是相等的，即：</p> \\[L_1(y_i, \\theta^T x_i) = L_2(y'_i, \\theta^T x_i)\\] <p>因此，两个整体目标函数中求和的每一项都完全对应相等。这直接导出两个整体目标函数对于任意\\(\\theta\\)都是恒等的：</p> \\[J_1(\\theta) = J_2(\\theta), \\quad \\forall \\theta\\] <p>由于两个优化问题有着完全相同的目标函数，它们必然拥有相同的最优解。即：</p> \\[\\hat{\\theta}_1 = \\hat{\\theta}_2\\] <p>定理得证。</p>","path":["关于二分类问题中两种标签体系下逻辑斯谛回归损失函数的等价性证明"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A0%87%E7%AD%BE%E4%BD%93%E7%B3%BB%E4%B8%8B%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7%E8%AF%81%E6%98%8E/#_6","level":2,"title":"最终结论","text":"<p>通过以上证明，我们得出结论：在逻辑斯谛回归中，无论选择\\(y \\in \\{0, 1\\}\\)还是\\(y' \\in \\{-1, +1\\}\\)作为标签体系，其最终的优化目标函数是完全一致的。这意味着，两种标签体系的选择不会对模型参数的学习结果产生任何影响，最终会得到完全相同的模型。</p> <p>因此，选择哪种标签形式，仅仅是出于数学表达、推导或计算上的便利与习惯。</p>","path":["关于二分类问题中两种标签体系下逻辑斯谛回归损失函数的等价性证明"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture12%20KNN/","level":1,"title":"Chapter 12 KNN","text":"<p>[!tldr] Outline + KNN分类 + KNN回归 + 优缺点分析</p> <p>所谓KNN就是K近邻法(K-nearest neighbor, KNN)是一种有监督的统计学习算法，利用对于距离的度量及选择合适的K值对数据进行分类或回归</p>","path":["Chapter 12 KNN"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture12%20KNN/#knn","level":2,"title":"KNN分类","text":"","path":["Chapter 12 KNN"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture12%20KNN/#model-setting","level":3,"title":"Model Setting","text":"<p>假设响应变量\\(Y\\in \\left[ 1:J \\right]\\)即有\\(J\\)类，\\(q_{j}\\)为第\\(j\\)类的先验概率，特征向量为\\(X=(X_{1},\\dots,X_{p})^{T}\\)，假设\\(f_{j}(x)=\\mathbb{P}(X=x|Y=j)\\)表示密度函数，然后根据Bayes方法，我们可以得到：</p> \\[ \\mathbb{P}(Y=j|X=x)= \\frac{q_{j}f_{j}(x)}{\\sum\\limits_{i=1}^{J} q_{i}f_{i}(x)}=:p_{j}(x) \\] <p>其中\\(p_{j}(x)\\)为\\(X=x\\)的观测属于\\(j\\)的后验概率</p> <p>思路就是把一个给定的观测样本分类到估计的条件概率最大的类别中</p>","path":["Chapter 12 KNN"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture12%20KNN/#_1","level":3,"title":"算法描述","text":"<p>给定训练的样本集\\(D=\\left\\{ (x_{i},y_{i}),i=1,\\dots,n \\right\\}\\)和正整数\\(K\\)，计算每个样本点的特征向量\\(x_{i}\\)到测试特征向量\\(x_{0}\\)的距离，然后选取最近的K个样本点，记为\\(N_{0}\\)</p> <p>计算条件概率估计为：</p> \\[ \\hat{p}_{j}= \\frac{1}{K} \\sum\\limits_{x_{i}\\in N_{0}}I(y_{i}=j) \\] <p>根据条件概率估计的大小进行分类，将观测值\\(x_{0}\\)分到概率\\(\\hat{p}_{j}\\)最大的类中</p> <p></p> <p>显然K的选择是非常重要的，如果\\(K=1\\)称为最近邻算法，容易过拟合，而\\(K\\)取的过大则是容易欠拟合</p> <p>[!question] 如何选择最优的K + 方法：偏差、方差权衡，利用数据驱动的CV方法，绘制U型曲线，选择使得测试集上错误率最小的K + 选择合适的距离度量：欧氏距离、Manhattan距离、马氏距离 + 调整距离占比权重</p>","path":["Chapter 12 KNN"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture12%20KNN/#knn_1","level":2,"title":"KNN回归","text":"<p>仍然是原本的记号，增加一个假设数据来自下面的非参数回归模型</p> \\[ y_{i}=g(x_{i})+\\varepsilon_{i},i=1,\\dots,n \\] <p>模型误差满足Gauss-Markov假设：\\(E(\\varepsilon_{i})=0,Var(\\varepsilon_{i})=\\sigma^{2}&lt;\\infty\\)</p> <p>算法步骤类似</p> <p>将距离\\(x\\)最近的\\(K\\)个样本点集合记为\\(N_{K}(x)\\)，取平均：</p> \\[ \\hat{g}(x)= \\frac{1}{K} \\sum\\limits_{x_{i}\\in N_{K}(x)}y_{i} \\] <p>可以计算MSE：</p> \\[ \\begin{aligned} \\mathbb{E}(y_{0}- \\hat{g}(x_{0}))^{2}&amp;=\\sigma^{2}+[Bias^{2}(\\hat{g}(x_{0}))+Var(\\hat{g}(x_{0}))]\\\\ &amp;=\\sigma^{2}+ \\left[ g(x_{0})- \\frac{1}{K}\\sum\\limits_{i=1}^{K}g(x_{(l)})  \\right]^{2}+ \\frac{\\sigma^{2}}{K}  \\end{aligned} \\] <p>对于上面的MSE进行分析，即可知道，\\(K\\)小时偏差较小，但是方差变大，容易过拟合，\\(K\\)大周围样本点多，偏差大，方差小，容易欠拟合</p> <p>进行方差，偏差权衡：</p> \\[ \\hat{K}_{opt}=arg\\min_{K}MSE(\\hat{g}(x_{0}))=arg \\min_{K}[Bias^{2}(\\hat{g}(x_{0}))+Var(\\hat{g}(x_{0}))] \\]","path":["Chapter 12 KNN"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture12%20KNN/#_2","level":2,"title":"优缺点分析","text":"<ul> <li>优点<ul> <li>实现简单</li> <li>对于非线性数据拟合好</li> <li>非参数方法，无参数假设</li> <li>稳健性好</li> <li>预测效果好</li> </ul> </li> <li>缺点<ul> <li>K值的选取影响很大</li> <li>计算成本高</li> <li>维数灾难</li> </ul> </li> </ul> <p>下面是一个动态图示(可以玩一玩)：</p>","path":["Chapter 12 KNN"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture13%20NNs/","level":1,"title":"Chapter 13 神经网络基础","text":"<p>[!tldr] Outline + 人工神经网络概述 + 感知机模型 + 前馈神经网络 + 反向传播算法 + 神经网络正则化</p> <p>[!cite] References 统计学习方法 李航(2022) 西瓜书 周志华(2016) 统计学习 李高荣(2024)</p>","path":["Chapter 13 神经网络基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture13%20NNs/#_1","level":2,"title":"人工神经网络概述","text":"<p>人工神经网络(artificial neural network, ANN)或神经网络(nerual network, NN)：</p> <p>指一系列受生物学和神经科学启发而发明的数学模型，主要是通过对人脑的神经元网络进行抽象,构建人工神经元,按照一定的拓扑结构建立人工神经元之间的连接，来模拟生物神经网络.</p> <p>前馈神经网络(feedforward neural network, FNN)：</p> <p>最具代表性的神经网络，主要用于监督学习，例如回归和分类.</p> <p>[!tip] 深度学习 所谓的深度学习实际上基本是深层神经网络的代名词，它的起源应当是追溯到AlexNet，其中展现了很多在现在使用很多的技术</p> <p>机器学习定义可以参考CMU的Tom Michael Mitchell教授的Machine Learning(事实上，世界上第一个机器学习系来自CMU)：</p> <p>如果一个程序可以在任务\\(T\\)上，随着经验\\(E\\)的增加，效果\\(P\\)也可以随之增加，则称该程序可以从经验中学习</p> <p>ANN的发展历程：</p> <ul> <li>1943 McCulloch-Pitts神经元模型</li> <li>1956 感知机(Perceptron)</li> <li>1986 分布式计算</li> <li>1986 反向传播算法 BP</li> <li>1994 长短记忆网络 LSTM</li> <li>2006 深读信念网络 DBN</li> <li>2007 卷积神经网络 CNN</li> <li>2012 AlexNet</li> <li></li> </ul>","path":["Chapter 13 神经网络基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture13%20NNs/#_2","level":2,"title":"感知机模型","text":"","path":["Chapter 13 神经网络基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture13%20NNs/#_3","level":2,"title":"前馈神经网络","text":"","path":["Chapter 13 神经网络基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture13%20NNs/#_4","level":2,"title":"反向传播算法","text":"","path":["Chapter 13 神经网络基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture13%20NNs/#_5","level":2,"title":"神经网络正则化","text":"","path":["Chapter 13 神经网络基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture3%20%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/","level":1,"title":"DMML Lecture3 信息论基础","text":"<p># Chapter 3 信息论基础</p> <p>[!tldr] Outline + 引言 + 信息熵 + KL散度：分布差异的度量 + 互信息：变量相关性的度量</p> <p>[!cite] References + Stanford EE376A  + Shannon entropy in the context of machine learning and AI + Lecture Slides(NKU_DMML, Lecturer: Fu)</p> <p>关于Stanford EE376A 本人很推荐，写的很有趣，开篇是三个信息论在工程学中的应用，然后对于信息论的一些基本概念也都有所提及，且讲述的很详细</p> <p>[!cite] Birth It is among the few disciplines fortunate to have a precise date of birth: 1948, with the publication of Claude E. Shannon’s paper entitled A Mathematical Theory of Communication. Shannon’s Information theory had a profound impact on our understanding of the concepts in communication.</p>","path":["DMML Lecture3 信息论基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture3%20%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/#some-applications","level":2,"title":"Some applications","text":"<p>A few representative examples which try to give a flavour of the problems which can be addressed using information theory</p> <ul> <li>无损压缩</li> <li>信道编码</li> <li>有损压缩</li> </ul> <p>[!tip] 扩展 关于上述的这三个例子在Stanford的Notes的后续章节中都有一个Chapter进行了比较详细的介绍，如果对于上述例子比较感兴趣且想更加深入的了解的话，建议仔细阅读后续的章节</p>","path":["DMML Lecture3 信息论基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture3%20%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/#lossless-compression","level":3,"title":"Lossless compression","text":"<p>Think about a source that emits a sequence of symbols \\(U_{1},U_{2}\\dots\\) with \\(U_{i}\\in \\left\\{ a,b,c \\right\\}\\)</p> \\[ \\begin{aligned} P(U=a)&amp;=0.7\\\\ P(U=b)&amp;=P(U=c)=0.15 \\end{aligned} \\] <p>Compare with traditional encoding way, a = 00 b = 01 c = 10, however, we can use a = 0 due to the lettter appears more often, b = 10 c = 11. Such that, we can find that this code satisfies the prefix condition, meaning no codeword is the prefix of another codeword, which allows us to decode a message consisting of stream of bits without any ambiguity.</p> \\[ \\overline{L}=1 \\times P(U=a)+2\\times P(U=b)+2\\times P(U=c)=1.3 \\] <p>Can we do it better? Yes! We can encode two values at a time instead of encoding each value individually.</p> source symbols probability encoding aa 0.49 0 ab 0.105 100 ac 0.105 111 ba 0.105 101 ca 0.105 1100 bb 0.0225 110100 bc 0.0225 110101 cb 0.0225 110110 cc 0.0225 110111 <p>If we use the above encoding scheme the the expected number of bits used per source symbol is 1.1975</p> <p>推广上述思想，我们可以考虑一族以整数\\(k\\)为索引的编码方案。给定一个整数\\(k\\)，我们可以用一个满足前缀条件的方案一次编码\\(k\\)个值，并将较短的码字分配给更多的普通符号。在某种最优编码方案下，每个值的期望比特数会随着\\(k\\)的增加而减少，这似乎是合理且work的</p> <p>那么很自然的我们会想到这个\\(\\overline{L}\\)是否会有一个下界(Lower bound)，Shannon证明了对于任意给定的源，他所能达到的最优下界称为该源的熵(Entropy) \\(H(U)\\)，定义为：</p> \\[ H(U)\\overset{\\Delta}{=}\\sum\\limits_{u\\in U}p(u)\\log_{2} \\frac{1}{p(u)} \\] <p>Note that the statements of the theorems here will be informal; they will be made rigorous in later lectures.</p> <p>[!tip] Theorem \\(\\forall\\) families of encoding schemes, the average codeword length, \\(\\overline{L}\\geqslant H(U)\\)</p> <p>For our example, the lower bound is thus</p> \\[ 0.7 \\times \\log_{2} \\frac{1}{0.7}+ 2\\times 0.15 \\times \\log_{2} \\frac{1}{0.15}\\approx 1.181 \\] <p>We will also show an upper bound, namely</p> <p>\\(\\forall \\varepsilon &gt;0\\), \\(\\exists\\) family of schemes, such that the average codeword length, \\(\\overline{L}\\leqslant H(U)+\\varepsilon\\)</p>","path":["DMML Lecture3 信息论基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture3%20%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/#channel-coding","level":3,"title":"Channel coding","text":"<p>仍然考虑一个源向外发射信号，但是这次只有两个可能\\(U_{i}\\in \\left\\{ 0,1 \\right\\}\\)，服从伯努利分布，此外增加噪声，有\\(q&lt; \\frac{1}{2}\\)的概率使得原本的编码反转，因此令最终的输出为\\(Y_{i}\\)</p> <p>$$ Y_{i}=X_{i} \\oplus W_{i},W_{i}\\sim Ber(q) $$ where \\(\\oplus\\) is the \\(XOR\\) operator</p> <p>令\\(p_{e}=q&lt; \\frac{1}{2}\\)作为每个信源比特发生错误的概率，自然会想到我们希望能够降低\\(p_{e}\\)的值，我们可以采用重复编码的方法，例如对某个接收到的比特发送\\(k\\)次，将其中接收到的出现次数最多的比特作为真实值接受，由此可以降低错误发生率</p> <p>但是我们还需要考虑重复编码使用的信道空间扩大的问题，因此引入比特率(bit rate)的概念，记为\\(R\\)，在重复发送3次的例子中我们认为比特率为\\(\\frac{1}{3}\\)，而不重复编码时比特率为\\(1\\)</p> <p>[!tip] Theorem(Bit rate limitation) \\(\\exists C&gt;0\\) and \\(\\exists\\) family of schemes with \\(R&lt;C\\) satisfying \\(p_{e}\\to 0\\)</p> <p>In fact, the largest such C is known as the channel capacity of a channel, which represents the largest bit rate ( the largest C ) that still allows for reliable communication.</p> <p>[!example] Two examples + Binary Symmtric Channel The channel capacity of a binary symmetric channel with bit-flipping probability \\(q\\) is \\(1-H(X),X\\sim Ber(q)\\). Moreover if we let \\(X\\sim Ber(q)\\) and \\(Y\\sim Ber(p_{e})\\), we will see that a bit rate \\(R\\) such that \\(R&lt; \\frac{1-H(X)}{1-H(Y)}\\) is achievable + Additive White Gaussian Noise (AWGN) Channel Assumptions are like before, and we think \\(Y_{i}=X_{i}+N_{i},N_{i}\\sim N(0,\\sigma^{2})\\). We want to develop a scheme so that we can reliably reconstruct \\(U_i\\) from the given \\(Y_i\\). One idea is make \\(X_{i}\\) a large positive value if \\(U_{i}=1\\) and \\(X_i\\) is a large negative value if \\(U_{i}=0\\). Usually, we suppose there is an additional constraint on the average power of the tansmitted signal, s.t. we require \\(\\frac{1}{n}\\sum\\limits_{i=1}^{n}X_{i}^{2}\\leq p\\)</p> <p>For a given value \\(p\\), in fact, we will see that</p> <p>[!tip] Theorem If the rate of transmission is \\(&lt; \\frac{1}{2}\\log_{2}\\left( 1+ \\frac{p}{\\sigma^{2}} \\right)\\), then \\(\\exists\\) family of schemes that communicate reliably. And if the rate of transmission is \\(&gt; \\frac{1}{2}\\log_{2}\\left( 1+ \\frac{p}{\\sigma^{2}} \\right)\\), then there is no family of schemes which communicates reliably.</p> <p>The RATIO \\(\\frac{p}{\\sigma^{2}}\\) is reffered to as SNR(signal-to-noise ratio)/信噪比</p>","path":["DMML Lecture3 信息论基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture3%20%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/#lossy-compression","level":3,"title":"Lossy compression","text":"<p>Let \\(B_{1},B_{2}\\dots\\) be the bits sent. One natural scheme is to set</p> \\[ B_{i}= \\left\\{ \\begin{matrix} 1&amp; if\\ \\ U_{i}\\geqslant 0\\\\  0 &amp; if\\ \\ U_{i } &lt; 0 \\end{matrix} \\right. \\] <p>After receiving the bits, let \\(V_1, V_2,\\dots\\) be the reconstructed values. The distortion of the scheme is defined as</p> \\[ D\\overset{\\Delta}{=}\\mathbb{E}[(U_{i}-V_{i})^{2}] \\] <p>而根据一个常见的结论可以知道使得均方误差(MSE)最小的一个解就是取条件期望(The optimal estimation rule for minimum mean squared error is the conditional expectation)</p> \\[ \\begin{aligned} D&amp;=\\mathbb{E}[(U_{i}-V_{i})^{2}]\\\\ &amp;=Var(U_{i}|B_{i})\\\\ &amp;=0.5\\times Var(U_{i}|B_{i}=1)+0.5\\times Var(U_{i}|B_{i}=0)\\\\ &amp;=Var(U_{i}|B_{i}=1)\\\\ &amp;=\\mathbb{E}[U_{i}^{2}|B_{i}=1]-(\\mathbb{E}[U_{i}|B_{i}=1])^{2}\\\\ &amp;=\\sigma^{2}\\left( 1- \\frac{2}{\\pi} \\right) \\end{aligned} \\] <p>正如我们所看到的，部分例子表明信息论对通信领域的有用性。在接下来的几个部分中，我们将尝试建立信息论理论的数学基础，这将使我们在以后的应用中更加方便。</p>","path":["DMML Lecture3 信息论基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture3%20%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/#introduction","level":2,"title":"Introduction","text":"","path":["DMML Lecture3 信息论基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture3%20%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/#what-is-information","level":3,"title":"What is information","text":"<p>信息是需要有上下文(context)，有使用价值，经过处理后能够变得有意义，所谓价值就是能够影响决策和行为，具有消除不确定性的好处；它还需要建立在数据(data)基础上，因此我们可以给出信息的粗略定义：原始数据在被接收、解释和赋予上下文后，才能变成有用的信息；而信息的价值又体现在消除不确定性，因此我们可以认为信息的多少也取决于不确定性的大小</p>","path":["DMML Lecture3 信息论基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture3%20%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/#what-is-information-theory","level":3,"title":"What is information theory","text":"<p>[!cite] Background 信息论由Claude Shannon(1916 - 2001)于1948年创立，核心任务是研究信息如何量化、存储与运输，探索其基本极限</p> <p>几个关键概念：</p> <ul> <li>熵(Entropy)：刻画不确定性的大小</li> <li>信息量与互信息：度量信息的多少与变量间的相关性</li> <li>传输效率与极限：信息如何高效、可靠地传递</li> </ul> <p>所以我们可以认为信息论=研究如何度量与利用信息的不确定性</p> <p>几个典型应用：特征选择、模型评估、正则化、生成模型</p> <p>[!tip] 信息量的三大规律  1. 函数性： \\(I(x_{i})=f[p(x_{i})]\\)  2. 单调性： \\(p(x_{i})\\downarrow \\implies I(x_{i})\\uparrow\\)  3. 可加性： 独立事件的信息量可加</p> \\[I(x_{1}x_{2}\\dots)=\\sum\\limits_{i}I(x_{i})\\]","path":["DMML Lecture3 信息论基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture3%20%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/#_1","level":2,"title":"熵以及相关概念","text":"<p>本章节将给出一些有关于信息度量(measures of information)的关键概念，如熵、交叉熵、互信息、KL散度(在通信系统中也叫做相对熵)</p> <p>在详细的介绍熵之前，我们有必要先引入惊奇函数(surprise function)</p> <p>[!NOTE] Definition(surprise function) 这个函数用于衡量对于结果的“惊奇程度”，故名思义，该事件发生的概率越小，惊奇函数的值越大</p> \\[s(u) \\overset{\\Delta}{=}\\log \\frac{1}{p(u)}\\] <p>以下是一个与惊奇函数完全等价的概念，自信息：我们认为发生概率越小的事件所带来的信息是越多的，因此惊奇程度也越高</p> <p>The fundamental concept behind Shannon entropy is the so-called self-information of an event, sometimes called surprisal.</p>","path":["DMML Lecture3 信息论基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture3%20%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/#self-information","level":3,"title":"自信息(Self-Information)","text":"<p>[!NOTE] Definition(Self-information) 对于离散随机变量\\(X\\)取值\\(x\\)，其自信息为：</p> \\[I(x)=f(P(x))=-\\log_{b}P(x)\\] <p>其中\\(P(x)\\)为事件\\(X=x\\)的概率，\\(b\\)为对数底 </p> <p>根据定义式即可得到一些有关于自信息的性质：</p> <ul> <li>非负性：根据定义即可得到(概率总是小于等于1)</li> <li>单调性：越可能发生的事件所拥有的自信息越小(事件越可能发生，信息量越少)</li> <li>确定事件</li> <li>不可能事件</li> </ul>","path":["DMML Lecture3 信息论基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture3%20%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/#_2","level":3,"title":"香农熵","text":"<p>我们从上面可以知道自信息是衡量单个事件发生的惊讶度，而香农熵\\(H(X)\\)则用于衡量整个随机变量的平均不确定性，也叫做微分熵，信息熵</p> <p>[!NOTE] Definition(香农熵) 离散随机变量的香农熵: 设离散随机变量\\(X\\sim \\mathcal{X}=\\left\\{ x_{1},x_{2},\\dots,x_{n} \\right\\}\\)，概率分布为\\(P(X)=\\left\\{ p(x_{1}),p(x_{2}),\\dots,p(x_{n}) \\right\\}\\)，香农熵的定义为：</p> \\[H(X)=\\mathbb{E}[I(X)]=\\sum\\limits_{i=1}^{n} p(x_{i})I(x_{i})=-\\sum\\limits_{i=1}^{n} p(x_{i})\\log p(x_{i})\\] <p>连续随机变量的微分熵: 对于连续随机变量\\(X\\)的概率密度函数\\(p(x)\\)，微分熵的定义为</p> \\[H(X)=-\\int_{-\\infty}^{\\infty} p(x)\\log p(x) \\, dx \\] <p>物理意义来讲\\(H(X)\\)代表编码随机变量\\(X\\)所需最小的平均比特数</p> <p>离散香农熵的性质：</p> <ul> <li>非负性 根据定义可以很显然的得到</li> <li>最大值性质：系数均匀分布均为 \\(\\frac{1}{n}\\) 的情况</li> </ul> <p>可以使用Jensen不等式来得到有关熵的一个上界：</p> <p>$$ \\begin{aligned} H(U)&amp;=\\mathbb{E}\\left[ \\log \\frac{1}{p(u)} \\right]\\ &amp;\\leqslant \\log \\mathbb{E}\\left[  \\frac{1}{p(u)} \\right]\\ &amp;=\\log \\sum\\limits_{u}p(u) \\frac{1}{p(u)}\\ &amp;=\\log m(WLOG,\\mathcal{U}=\\left{ 1,2\\dots m \\right} ) \\end{aligned} $$ 根据Jensen不等式的取等条件当且仅当\\(P(u)= \\frac{1}{m}\\forall u\\)</p> <p>对于一个概率质量函数\\(q\\)，被当作\\(p\\)定义在相同的字母表，定义</p> <p>$$ H_{q}(U)\\overset{\\Delta}{=}\\sum\\limits_{u\\in \\mathcal{U}}p(u) \\log \\frac{1}{q(u)} $$ 这个时候我们会更加“惊奇”，数学形式上就是：</p> <p>$$ H(U)\\leqslant H_{q}(U) $$ 当且仅当\\(q=p\\)时取等</p> <p><code>Proof.</code></p> \\[ \\begin{aligned} H(U)-H_{q}(U)&amp;\\leqslant \\log \\mathbb{E}\\left[  \\frac{q(u)}{p(u)} \\right]\\\\ &amp;=\\log \\sum\\limits_{u\\in \\mathcal{U}}p(u) \\frac{q(u)}{p(u)}\\\\ &amp;=0 \\end{aligned} \\] <p>按照课程讲义中这里直接引入联合熵，但是EE376A选择直接进入Relative Entropy，个人认为后者有其合理性，因为这里引用的有关错误识别的性质在Relative Entropy中有更加生动的解释——KL散度始终大于等于0，当且仅当\\(p=q\\)时取到零</p> <p>所以不妨先写下定义(剧透)：</p> <p>[!NOTE] Definition(Relative Entropy/KL divergence) An important measure of distance between probability measures is relative entropy, or the \\(Kullback-Leibler\\) divergence</p> \\[D(p||q)\\overset{\\Delta}{=}\\sum\\limits_{u\\in \\mathcal{U}}p(u)\\log \\frac{p(u)}{q(u)}=\\mathbb{E}\\left[ \\log \\frac{p(u)}{q(u)} \\right]\\] <p>更加深入的内容在后续补充</p>","path":["DMML Lecture3 信息论基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture3%20%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/#joint-entropy","level":3,"title":"联合熵(Joint Entropy)","text":"<p>[!NOTE] Definition(Joint Entropy) 设\\((X,Y)\\)是联合离散随机变量，其联合分布为\\(p(x,y)\\)</p> \\[H(X,Y)=-\\sum\\limits_{x,y}p(x,y)\\log p(x,y)\\] <p>联合熵是用于衡量同时观测\\(X,Y\\)的不确定性，若是两个随机变量相互独立，显然可以得到\\(H(X,Y)=H(X)+H(Y)\\)，推广到任意多个随机变量的联合熵(Obviously)</p>","path":["DMML Lecture3 信息论基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture3%20%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/#conditional-entropy","level":3,"title":"条件熵(Conditional Entropy)","text":"<p>[!NOTE] Definition(Conditional Entropy) 条件熵\\(H(Y|X)\\)定义为(一般使用第二个表达式)：</p> \\[\\begin{aligned} H(Y|X)&amp;=-\\sum\\limits_{x,y}p(x,y)\\log p(y|x)\\\\ &amp;=\\sum\\limits_{x}p(x)H(Y|X=x) \\end{aligned}\\] <p>也相当显然，表示已知\\(X\\)的条件下，\\(Y\\)仍然存在的不确定性，若\\(X,Y\\)独立，则\\(H(Y|X)=H(Y)\\)，若是\\(Y\\)由\\(X\\)决定则\\(H(Y|X)=0\\)</p> <p>[!tip] 联合熵与条件熵的关系 可以将这些信息熵当作概率处理，而条件熵就对应条件概率，因此我们可以提出一套链式法则(Chain Rule for Entropy)：</p> \\[H(X,Y)=H(X)+H(Y|X)=H(Y)+H(X|Y)\\] <p>也就是说联合不确定性可以分解为一个变量的不确定性+另一个变量在其条件下的不确定性，然后我们可以得出 互信息(Mutual Information) 的概念</p> \\[ I(X;Y)=H(X)-H(X|Y)=H(Y)-H(Y|X) \\] <p>相当于它们所共有的一部分信息，而互信息就是为了衡量通过已知一个变量来减少另一个变量不确定性的量</p>","path":["DMML Lecture3 信息论基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture3%20%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/#kl","level":2,"title":"\\(KL\\)散度","text":"<p>[!tip] \\(KL\\ Divergence\\)(Kullback and Leibler, 1951) 用于衡量真实分布\\(P\\)与近似分布\\(Q\\)之间的差异：</p> \\[ \\begin{aligned} D_{KL}(P||Q)&amp;=\\sum\\limits_{x\\in \\mathcal{X}}P(x)\\log \\frac{P(x)}{Q(x)}\\\\ &amp;=\\sum\\limits_{x}P(x)\\log P(x) - \\sum\\limits_{x}P(x)\\log Q(x) \\end{aligned}\\] <p>前一部分代表\\(-H(P)\\)，后一部分代表\\(-H(P;Q)\\)，\\(D_{KL}(P||Q)=H(P;Q)-H(P)\\)，其中\\(H(P;Q)\\)即为交叉熵</p>","path":["DMML Lecture3 信息论基础"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture9%20%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90/","level":1,"title":"Chapter 9 判别分析","text":"<p>[!tldr] Outline + 垂直平分分类器 + 判别分析准则 + 两总体的判别 + 多总体的判别</p> <p>先给出下面关于线性分类器的基础知识，再过度到垂直平分分类器</p>","path":["Chapter 9 判别分析"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture9%20%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90/#_1","level":2,"title":"线性分类器","text":"<p>所谓判别分析就是基于分类问题的一种方法</p> <p>我们先来看最为简单的线性分类器，它的使用依赖于一个线性决策边界，将数据分为不同的类别</p> <p>决策边界公式如下：</p> \\[ w^{T}x+b=0 \\] <p>其中\\(w\\)是权重向量，\\(b\\)是偏置</p> <p>判别规则就是\\(w^{T}x+b\\)与\\(0\\)的大小关系，大于0即为1，小于0即为-1，这种判别规则也应用于支持向量机(SVM)、感知机、逻辑回归等</p>","path":["Chapter 9 判别分析"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture9%20%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90/#_2","level":2,"title":"垂直平分分类器","text":"<p>通过划分两类样本中心的垂直平面实现分类，做法相当简单：</p> <p>先计算得到两类样本的均值：</p> \\[ \\mu_{1}= \\frac{1}{n_{1}}\\sum\\limits_{i\\in C_{1}}x_{i},\\mu_{2}= \\frac{1}{n_{2}}\\sum\\limits_{i\\in C_{2}}x_{i} \\] <p>决策边界为(实际上这里看出与线性分类器的联系)：</p> \\[ w=\\mu_{1}-\\mu_{2},b=- \\frac{1}{2}(\\mu_{1}^{T}\\mu_{1}-\\mu_{2}^{T}\\mu_{2}) \\] <p>决策函数：</p> \\[ g(x)=w^{T}x+b \\] <p>分类的规则仍然是判断与0的关系分为\\(\\pm 1\\)，实际上本质是比较\\(\\lVert x-\\mu_{1} \\rVert^{2},\\lVert x-\\mu_{2} \\rVert^{2}\\)的距离远近</p> <p>[!cite] 垂直平分分类器的主要特点 别名：最小距离分类器，是可以解决两类分类问题的线性分类器，本质上对于样本集无特殊要求。没有采用准则函数求极值解(非最佳的决策)，它假设两类数据的分布形状（协方差）是圆形的且相等的，如果数据是椭圆分布或两类分布松散程度不同，效果很差。算法简单，实现容易</p>","path":["Chapter 9 判别分析"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture9%20%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90/#_3","level":2,"title":"判别分析准则","text":"","path":["Chapter 9 判别分析"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture9%20%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90/#_4","level":3,"title":"判别分析","text":"<p>[!cite] 判别分析(discrimination analysis) 使用具有类别信息的观测数据建立一个分类器或分类法则，其能够最大可能区分事先定义的类，需要注意它是一种有监督的统计学习方法，应用时经常将判别分析与分类结合起来</p> <p>先给出一些基本的记号和假设：</p> <p>对于两个总体的情况，存在两个总体\\(\\pi_{1},\\pi_{2}\\)给定一个个体的测量值向量\\(x=(x_{1},\\dots,x_{p})^{T}\\)，判断该个体是来自总体\\(\\pi_{1},\\pi_{2}\\)? 判别分析的做法是找到一种判别方法，将\\(\\mathbb{R}^{p}\\)空间分为两个区域\\(R_{1},R_{2}\\)，记为\\(R=(R_{1},R_{2})\\)，如果个体的观测值向量\\(x\\in R_{1}\\)，归为\\(\\pi_{1}\\)</p> <p>那么显然根据假设会知道可能会有两种错误发生：</p> <ul> <li>\\(C(2| 1)\\): 个体来自\\(\\pi_{1}\\)，却被误判为\\(\\pi_{2}\\)的损失</li> <li>\\(C(1| 2)\\): 个体来自\\(\\pi_{2}\\)，却被误判为\\(\\pi_{1}\\)的损失</li> </ul> <p>很自然的我们会将错判带来的损失最小作为好的判别方法的评判标准</p> <p>一些记号：</p> <ul> <li>先验概率：\\(q_{1},q_{2}\\)是来自\\(\\pi_{1},\\pi_{2}\\)的观测值的先验概率，满足\\(q_{1}+q_{2}=1\\)</li> <li>密度函数：\\(\\pi_{1}\\sim f_{1}(x),\\pi_{2}\\sim f_{2}(x)\\)</li> <li>正确判别概率：\\(\\mathbb{P}(1|1,R)=\\int_{R_{1}}f_{1}(x)dx,dx=dx_{1}\\dots dx_{p}\\)</li> <li>错判概率：\\(\\mathbb{P}(2|1,R)=\\int_{R_{2}}f_{1}(x)dx\\)</li> </ul>","path":["Chapter 9 判别分析"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture9%20%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90/#bayes","level":3,"title":"Bayes判别准则","text":"<p>这里需要用到一个很重要的准则ECM(Expected Cost of Misclassification)</p> \\[ ECM(R_{1},R_{2})=C(2| 1)\\mathbb{P}(2|1,R)q_{1}+C(1| 2)\\mathbb{P}(1|2,R)q_{2} \\] <p>对于给定先验概率\\(q_{1},q_{2}\\)使得错判的平均损失ECM达到最小的方法称为Bayes判别方法</p> <p>理论上，能够使得\\(ECM(R_{1},R_{2})\\)最小的Bayes判别准则是一个最优的黄金准则，在实际应用中，需要给定密度函数、错判损失、先验概率，如果密度函数未知可以通过训练样本进行估计然后应用判别分析的方法</p> <p>根据ECM的目的是使得平均损失最小，我们很自然会想不同的错判损失是否相同，显然在大多数应用场景下损失是完全不同的，例如关于假阳性的判别和忽略阳性患者所带来的负面影响是完全不同的，因此对于原本的定义式推导如下：</p> \\[ \\begin{aligned} ECM(R_{1},R_{2})&amp;=C(2| 1)\\mathbb{P}(2|1,R)q_{1}+C(1| 2)\\mathbb{P}(1|2,R)q_{2}\\\\ &amp;=q_{1}C(2|1)\\int_{R_{2}}f_{1}dx+q_{2}C(1|2)\\int_{R_{1}}f_{2}dx\\\\ &amp;=q_{1}C(2|1)\\left( 1-\\int_{R_{1}}f_{1}dx \\right)+q_{2}C(1|2)\\int_{R_{1}}f_{2}dx\\\\ &amp;=q_{1}C(2|1)+\\int_{R_{1}}q_{2}C(1|2)f_{2}-q_{1}C(2|1)f_{1}dx \\end{aligned} \\] <p>因此我们想要使得积分部分尽量小，也就是内部函数小于0时，应该划入\\(R_{1}\\)：</p> \\[ q_{2}C(1|2)f_{2}-q_{1}C(2|1)f_{1}&lt;0\\implies \\frac{f_{1}}{f_{2}}&gt; \\frac{q_{2}}{q_{1}} \\frac{C(1|2)}{C(2|1)} \\] <p>实质就是做似然比检验</p>","path":["Chapter 9 判别分析"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture9%20%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90/#fisher","level":3,"title":"Fisher判别分析","text":"<p>对于[[#两个多元正态总体-同方差]]的情况，我们先考虑协方差矩阵的无偏估计：</p> \\[ \\begin{aligned} \\hat{\\Sigma}&amp;=S= \\frac{V^{(1)}+V^{(2)}}{n_{1}+n_{2}-2}\\\\ V^{(1)}&amp;=\\sum\\limits_{i=1}^{n_{1}} (x_{i}^{(1)}-\\overline{x}^{(1)})(x_{i}^{(1)}-\\overline{x}^{(1)})^{T}\\\\ V^{(2)}&amp;=\\sum\\limits_{i=1}^{n_{2}} (x_{i}^{(2)}-\\overline{x}^{(2)})(x_{i}^{(2)}-\\overline{x}^{(2)})^{T} \\end{aligned} \\] <p>\\(V^{(1)},V^{(2)}\\)为两组训练样本的样本离差矩阵</p> <p>把参数估计的结果代入线性判别函数可以得到下面的\\(Fisher\\)线性判别函数：</p> \\[ W(x)=x^{T}S^{-1}(\\overline{x}^{(1)}-\\overline{x}^{(2)})- \\frac{1}{2}( \\overline{x}^{(1)}+ \\overline{x}^{(2)})^{T}S^{-1}(\\overline{x}^{(1)}- \\overline{x}^{(2)}) \\] <p>如果先验概率给定，我们得到Fisher线性判别准则为：</p> \\[ R_{1}=\\left\\{ x:W(x)\\geqslant \\log k \\right\\},k = \\frac{q_{2}C(1|2)}{q_{1}C(2|1)} \\] <p>需要注意，Fisher线性判别函数仅仅是估计的最优准则，无法保证\\(ECM(R_{1},R_{2})\\)最小，在大样本情形下，\\(\\overline{x}^{(1)}, \\overline{x}^{(2)},S\\)为\\(\\mu_{1},\\mu_{2},\\Sigma\\)的强相合估计，此时判别准则渐近最优</p> <p>[!tip] Fisher判别的思路和方法 将一个\\(p\\)维向量\\(X=(X_{1},\\dots,X_{p})^{T}\\)投影到某个方向，使得其最容易判别</p> <p>考虑\\(Y=\\xi^{T}X\\)，使得</p> \\[ \\frac{[E_{1}(\\xi^{T}X)-E_{2}(\\xi^{T}X)]^{2}}{Var(\\xi^{T}X)}= \\frac{\\xi^{T}(\\mu_{1}-\\mu_{2})(\\mu_{1}-\\mu_{2})^{T}\\xi}{\\xi^{T}\\Sigma \\xi} \\] <p>达到最大</p> <p>我们的目标是使得上方分式最大，使用代换\\(\\beta=\\Sigma^{1/2}\\xi\\)，运用Cauchy-Schwarz不等式，可以知道分子最大时必须存在比例关系，\\(\\beta=a\\Sigma^{-1/2}(\\mu_{1}-\\mu_{2})\\)，由此我们可以得到\\(\\xi=a\\Sigma^{-1}(\\mu_{1}-\\mu_{2}):= a\\theta\\)</p> <p>其中\\(a\\)只是尺度参数，不影响判别方向，且Fisher判别不要求假设\\(\\pi_{1},\\pi_{2}\\)来自正态分布，只需要有相同的协方差矩阵即可</p> <p>下面的内容主要是利用Bayes判别准则、Fisher判别准则的不同情形下的结果</p>","path":["Chapter 9 判别分析"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture9%20%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90/#_5","level":2,"title":"两总体的判别","text":"","path":["Chapter 9 判别分析"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture9%20%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90/#-","level":3,"title":"两个多元正态总体-同方差","text":"\\[ f_{j}(x)= \\frac{1}{(2\\pi)^{p /2}\\lvert \\Sigma_{j} \\rvert ^{1 / 2}}\\exp \\left[ - \\frac{1}{2}(x-\\mu_{j})^{T}\\Sigma_{j}^{-1}(x-\\mu_{j}) \\right]  \\] <p>则似然比可以显然得到，利用同方差即\\(\\Sigma_{1}=\\Sigma_{2}=\\Sigma\\)：</p> \\[ \\begin{aligned} \\frac{f_{1}}{f_{2}}&amp;=\\exp \\left\\{  - \\frac{1}{2}[(x-\\mu_{1})^{T}\\Sigma^{-1}(x-\\mu_{1})-(x-\\mu_{2})^{T}\\Sigma^{-1}(x-\\mu_{2})] \\right\\} \\\\ \\frac{f_{1}}{f_{2}}&amp;\\geqslant k,R_{1}\\in \\pi_{1}\\\\ &amp;\\implies x^{T}\\Sigma^{-1}(\\mu_{1}-\\mu_{2})- \\frac{1}{2}(\\mu_{1}+\\mu_{2})^{T}\\Sigma^{-1}(\\mu_{1}-\\mu_{2}) \\geqslant \\log k \\end{aligned} \\] <p>仍然令\\(k= \\frac{q_{2}C(1|2)}{q_{1}C(2|1)}\\)即可(先验概率已知的情况)</p>","path":["Chapter 9 判别分析"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture9%20%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90/#-_1","level":3,"title":"两个多元正态总体-异方差","text":"<p>使用似然比检验方法简单计算后得到：</p> \\[ R_{1}=\\left\\{ x: -\\frac{1}{2}x^{T}(\\Sigma_{1}^{-1}- \\Sigma_{2}^{-1})x+(\\mu_{1}^{T}\\Sigma^{-1}_{1}-\\mu_{2}^{T}\\Sigma_{2}^{-1})x- \\zeta \\geqslant \\log k\\right\\}  \\] <p>其中\\(k= \\frac{q_{2}C(1|2)}{q_{1}C(2|1)}\\)，\\(\\zeta= \\frac{1}{2}\\log\\left(  \\frac{\\lvert \\Sigma_{1} \\rvert}{\\lvert \\Sigma_{2} \\rvert} \\right)+ \\frac{1}{2}(\\mu_{1}^{T}\\Sigma_{1}^{-1}\\mu_{1}-\\mu_{2}^{T}\\Sigma_{2}^{-1}\\mu_{2})\\)</p> <p>将整体记为\\(\\delta(x)\\)</p> \\[ \\delta(x)= -\\frac{1}{2}x^{T}(\\Sigma_{1}^{-1}- \\Sigma_{2}^{-1})x+(\\mu_{1}^{T}\\Sigma^{-1}_{1}-\\mu_{2}^{T}\\Sigma_{2}^{-1})x- \\zeta \\] <p>由于函数中含有二次项，因此记为二次判别函数</p>","path":["Chapter 9 判别分析"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture9%20%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90/#_6","level":3,"title":"先验概率不存在的情形","text":"<p>重点讨论协方差矩阵相等的情形，\\(\\Sigma_{1}=\\Sigma_{2}=\\Sigma\\)</p> <p>先验概率未知带来的最大问题就是\\(\\log k=c\\)未知，为了进行判别分析，我们应当想办法确定\\(c\\)，定义一个随机变量\\(U\\)</p> <p>$$ U=X^{T}\\Sigma^{-1}(\\mu_{1}-\\mu_{2})- \\frac{1}{2}(\\mu_{1}+\\mu_{2})^{T} \\Sigma^{-1}(\\mu_{1}-\\mu_{2}) $$ 如果\\(X\\sim N_{p}(\\mu_{1},\\Sigma)\\)，那么有\\(E_{1}(U)= \\frac{1}{2}(\\mu_{1}-\\mu_{2})^{T}\\Sigma^{-1}(\\mu_{1}-\\mu_{2})\\)，同理可知方差(\\(N_{p}(\\mu_{1},\\Sigma)\\)和\\(N_{p}(\\mu_{2},\\Sigma)\\)之间的马氏距离)</p> \\[Var_{1}(U)=(\\mu_{1}-\\mu_{2})^{T}\\Sigma^{-1}(\\mu_{1}-\\mu_{2})=\\Delta^{2}\\] <p>此时关于\\(c\\)的给定可以使用Neyman-Pearson准则</p>","path":["Chapter 9 判别分析"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Assets/DMML_Lecture9%20%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90/#_7","level":2,"title":"多总体的判别","text":"<p>应用前面的记号和方法，容易得到：</p> \\[ \\begin{aligned} ECM(R_{1},\\dots,R_{J})&amp;=\\sum\\limits_{j=1}^{J} q_{j}\\left\\{ \\sum\\limits_{k=1,k\\neq j}^{J}C(k|j)\\mathbb{P}(k|j,R) \\right\\}  \\end{aligned} \\] <p>若是有\\(q_{i}f_{i}&gt;q_{k}f_{k},k\\neq i\\)，那么将\\(x\\)划归为\\(\\pi_{i}\\)</p> <p>基本上方法和思想是雷同的，不想赘述，只给出一些结论</p> <ul> <li>多正态总体 异方差</li> <li>多正态总体 同方差</li> <li>Fisher判别分析 多总体</li> </ul> <p>[!tip] Fisher判别分析-多总体，最优投影方向\\(\\hat{\\xi}\\)： 当\\(W\\)可逆时，有</p> \\[\\hat{\\xi}=arg \\sup\\limits_{\\lVert \\xi \\rVert _{2}=1} \\frac{\\xi^{T}B\\xi}{\\xi^{T}W\\xi}= \\hat{e}_{1}\\] <p>其中\\(\\hat{e}_{1}\\)为矩阵\\(W^{-1}B\\)的最大特征值对应的单位正交特征向量，\\(B\\)为样本的类间离差矩阵，\\(W\\)为类内离差矩阵</p> <p>记\\(W^{-1}B\\)的所有非零特征值分别为\\(\\hat{\\lambda}_{1}\\geqslant \\hat{\\lambda}_{2}\\geqslant \\dots \\geqslant \\hat{\\lambda}_{s}&gt; 0\\)，其中\\(s\\leqslant \\min(J-1,p)\\)，当\\(\\hat{\\xi}_{1}= \\hat{e}_{1}\\)，把\\(\\hat{\\xi}_{1}^{T}x\\)称为样本第一判别函数，其判别效率为\\(\\hat{\\lambda}_{1}\\)，以此类推，最多有\\(\\min(J-1,p)\\)个样本判别函数</p> <p>\\(\\mathbf{Fisher判别准则}:\\forall i\\neq j\\)</p> \\[ \\sum\\limits_{k=1}^{r} (\\hat{y}_{k}- \\overline{y}_{k}^{(j)})^{2}=\\sum\\limits_{k=1}^{r} [\\hat{\\xi}_{k}^{T}(x- \\overline{x}^{(j)})]^{2} \\leqslant \\sum\\limits_{k=1}^{r}[\\hat{\\xi}_{k}^{T}(x- \\overline{x}^{(i)})]^{2}  \\] <p>成立，那么把观测样本\\(x\\)划归为\\(\\pi_{j}\\)</p> <p>给出一个例子：</p> <p>[!example] 使用Fisher判别准则 $$ X^{(1)}=\\begin{pmatrix} -2 &amp; 5 \\ 0 &amp; 3  \\ -1 &amp; 1 \\end{pmatrix},X^{(2)}= \\begin{pmatrix} 0 &amp; 6 \\ 2 &amp; 4 \\  1 &amp; 2 \\end{pmatrix},X^{(3)}=\\begin{pmatrix} 1 &amp; -2 \\ 0 &amp; 0 \\ -1 &amp; -4 \\end{pmatrix} $$</p> <p>试建立Fisher样本判别函数，并对新的观测样本\\(x_{0}=(1,3)^{T}\\)，用建立的判别函数分类</p> \\[ \\overline{x}^{(1)}=\\begin{pmatrix} -1 \\\\ 3 \\end{pmatrix}, \\overline{x}^{(2)} = \\begin{pmatrix} 1 \\\\ 4 \\end{pmatrix}, \\overline{x}^{(3)}= \\begin{pmatrix} 0 \\\\ -2  \\end{pmatrix}, \\overline{x}= \\begin{pmatrix} 0 \\\\ \\frac{5}{3} \\end{pmatrix} \\] <p>计算样本的类内/类间离差矩阵：</p> \\[ \\begin{aligned} B&amp;=\\sum\\limits_{j=1}^{3} (\\overline{x}^{(j)}-\\overline{x})(\\overline{x}^{(j)}-\\overline{x})^{T}=\\begin{pmatrix} 2 &amp; 1  \\\\ 1 &amp; \\frac{62}{3} \\end{pmatrix}\\\\ W&amp;= \\sum\\limits_{j=1}^{3} \\sum\\limits_{i=1}^{n_{j}} (x_{i}^{(j)}- \\overline{x}^{(j)})(x_{i}^{(j)}- \\overline{x}^{(j)})^{T}=(9-3)S= \\begin{pmatrix} 6 &amp; -2 \\\\ -2 &amp; 24 \\end{pmatrix} \\end{aligned} \\] <p>那么我们计算：</p> \\[ \\lvert W^{-1}B -\\lambda I_{2}\\rvert = \\begin{vmatrix} 0.3571-\\lambda &amp; 0.4667 \\\\ 0.0714 &amp; 0.9000-\\lambda \\end{vmatrix} =0 \\implies \\hat{\\lambda}_{1}=0.9556, \\hat{\\lambda}_{2}=0.3015 \\] <p>在约束条件\\(\\hat{\\xi}_{j}^{T}S \\hat{\\xi}_{j}=1\\)，求解\\((W^{-1}B- \\hat{\\lambda}_{j}I_{2}) \\hat{\\xi}_{j}=0\\)，得到相应特征向量：</p> \\[\\hat{\\xi}_{1}=(0.386,0.495)^{T}, \\hat{\\xi}_{2}=(0.938,-0.112)^{T}\\] <p>可以得到\\(\\hat{y}_{1}=\\hat{\\xi}_{1}^{T}x=0.386x_{1}+0.495x_{2},\\hat{y}_{2}=\\hat{\\xi}_{2}^{T}x=0.938x_{1}-0.112x_{2}\\)</p> <p>再代入\\(x_{0}=(1,3)^{T}\\)，然后就可以得到相应的一系列数值，最后得到划归为\\(\\pi_{2}\\)</p>","path":["Chapter 9 判别分析"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/","level":1,"title":"统计与大数据软件","text":"<p>由于各种原因，下架原本上传的作业部分，只保留了自己撰写的复习笔记</p>","path":["统计与大数据软件"],"tags":["Python"]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","level":1,"title":"统计与大数据软件","text":"","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#py-lecture-1","level":1,"title":"Py-Lecture-1 基本操作","text":"<p>[!tldr] Goal + 基本语法 + 数据类型 + 数据结构</p>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_2","level":2,"title":"基本语法","text":"","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_3","level":3,"title":"输出与表达式","text":"","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#print-function","level":4,"title":"print function","text":"<pre><code># 输出字符串\nprint(\"Hello Python world!\")  \nname = \"Alice\"\n# 拼接变量\nprint(\"Hello, \" + name)       \n</code></pre> <pre><code>Hello Python world!\nHello, Alice\n</code></pre>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_4","level":4,"title":"运算","text":"<pre><code>a = 10 \nb = 5\n</code></pre> <pre><code>a + b\n</code></pre> <pre><code>15\n</code></pre> <pre><code>a - b\n</code></pre> <pre><code>5\n</code></pre> <pre><code>a * b\n</code></pre> <pre><code>50\n</code></pre> <pre><code>a / b\n</code></pre> <pre><code>2.0\n</code></pre> <pre><code>a ** b\n</code></pre> <pre><code>100000\n</code></pre> <pre><code>a //b\n</code></pre> <pre><code>2\n</code></pre>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_5","level":3,"title":"变量与赋值","text":"","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_6","level":4,"title":"变量名命名规则","text":"<ol> <li>变量名只能包含字母、数字和下划线</li> <li>变量名不能包含空格，但可使用下划线来分隔其中的单词</li> <li>不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词</li> <li>变量名应既简短又具有描述性</li> <li>慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0</li> </ol>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_7","level":4,"title":"动态类型重试重试","text":"<p>无需声明类型，直接赋值</p> <pre><code># 整数\na = 5        \nprint(a)\n# 字符串（自动类型转换）\na = \"string\" \nprint(a)\n</code></pre> <pre><code>5\nstring\n</code></pre>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#str","level":3,"title":"字符串(str)","text":"","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_8","level":4,"title":"定义方式","text":"<p>单引号、双引号或三引号包裹，支持多行字符串：</p> <pre><code>str1 = '单引号字符串'\nprint(str1,\"\\n\")\nstr2 = \"包含'单引号'的字符串\"\nprint(str2,\"\\n\")\nstr3 = '''\n多行字符串\n支持换行\n'''\nprint(str3)\n</code></pre> <pre><code>单引号字符串\n\n包含'单引号'的字符串\n\n\n多行字符串\n支持换行\n</code></pre>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_9","level":4,"title":"常用操作","text":"<p>name = \"ada lovelace\" print(name.title())</p> <pre><code>print(name.upper())\nprint(name.lower())\n</code></pre> <pre><code>ALICE\nalice\n</code></pre> <pre><code># 利用\\n换行\nprint(\"Languages:\\n\\tPython\\n\\tC\\n\\tJavaScript\")\n</code></pre> <pre><code>Languages:\n    Python\n    C\n    JavaScript\n</code></pre> <pre><code># 原生字符串\nprint(r\"Languages:\\n\\tPython\\n\\tC\\n\\tJavaScript\") \n</code></pre> <pre><code>Languages:\\n\\tPython\\n\\tC\\n\\tJavaScript\n</code></pre>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_10","level":4,"title":"字符串拼接","text":"<pre><code>first_name = \"ada\"\nlast_name = \"lovelace\"\nfull_name = first_name + \" \" + last_name\nprint(full_name)\n</code></pre> <pre><code>ada lovelace\n</code></pre>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_11","level":4,"title":"索引与切片","text":"<p>可以将string类型视作是一个列表，根据list数据类型进行索引</p> <pre><code>first_name[0]\n</code></pre> <pre><code>'a'\n</code></pre> <p>然后是切片(Slicing)操作</p> <pre><code>first_name[0:2] \n</code></pre> <pre><code>'ad'\n</code></pre> <pre><code># 间隔切片\nfull_name[::2] \n</code></pre> <pre><code>'aalvlc'\n</code></pre> <p>在 Python 中，切片（Slicing）是一种强大的序列操作，可用于提取或修改列表、元组、字符串等有序序列的部分元素。以下是切片操作的详细解析(个人总结)：</p> <p>基本用法 sequence[start:stop:step]</p> <ul> <li>start：起始索引（包含，默认为 0）</li> <li>stop：结束索引（不包含，默认为序列长度）</li> <li>step：步长（默认为 1，可为负数，表示反向切片）</li> </ul> <p>正向切片（step 为正数）</p> <pre><code># 截取部分元素\nlst = [10, 20, 30, 40, 50]\nprint(\"截取部分元素\")\nprint(lst[1:3])   # 输出: [20, 30]（索引1到2）\nprint(lst[:3])    # 输出: [10, 20, 30]（从头开始到索引2）\nprint(lst[2:])    # 输出: [30, 40, 50]（从索引2到末尾）\n\n# 使用负数索引\n# 负数索引表示从序列末尾开始计数：\nprint(\"使用负数索引\")\nprint(lst[-3:-1]) # 输出: [30, 40]（倒数第3到倒数第2）\nprint(lst[-2:])   # 输出: [40, 50]（最后两个元素）\n\n# 步长的使用\n# 步长决定了切片的间隔：\nprint(\"步长的使用\")\nprint(lst[::2])   # 输出: [10, 30, 50]（每隔一个元素取一个）\nprint(lst[1::2])  # 输出: [20, 40]（从索引1开始，每隔一个取一个）\n</code></pre> <pre><code>截取部分元素\n[20, 30]\n[10, 20, 30]\n[30, 40, 50]\n使用负数索引\n[30, 40]\n[40, 50]\n步长的使用\n[10, 30, 50]\n[20, 40]\n</code></pre> <p>反向切片（step 为负数）</p> <pre><code># 反转序列\n# 反向切片可以起到反转列表的效果\nprint(lst[::-1])  \n# 反转后也可以间隔切片\nprint(lst[::-2])  \n</code></pre> <pre><code>[50, 40, 30, 20, 10]\n[50, 30, 10]\n</code></pre> <p>切片赋值（仅适用于可变序列）</p> <pre><code># 可通过切片修改列表的部分元素：\nlst = [10, 20, 30, 40, 50]\nlst[1:3] = [200, 300]  # 将索引1和2替换为新值\nprint(lst)  # 输出: [10, 200, 300, 40, 50]\n\nlst[2:4] = []  # 删除索引2和3的元素\nprint(lst)  # 输出: [10, 200, 50]\n\nlst[1:1] = [150, 170]  # 在索引1插入元素\nprint(lst)  # 输出: [10, 150, 170, 200, 50]\n</code></pre> <pre><code>[10, 200, 300, 40, 50]\n[10, 200, 50]\n[10, 150, 170, 200, 50]\n</code></pre> <p>字符串切片(字符串也支持切片，常用于提取子串)</p> <pre><code>s = \"HelloWorld\"\nprint(s[2:5])    # 输出: \"llo\"\nprint(s[::-1])   # 输出: \"dlroWolleH\"（反转字符串）\nprint(s[1:7:2])  # 输出: \"elW\"（从索引1到6，步长2）\n</code></pre> <pre><code>llo\ndlroWolleH\nelW\n</code></pre> <p>切片操作是 Python 中最灵活的序列处理工具之一，通过合理组合 start、stop 和 step，可以高效完成元素提取、序列反转、子串截取等常见任务。熟练掌握切片能显著提升代码的简洁性和可读性。</p> <p>注意：</p> <ul> <li>索引越界：切片不会因索引越界报错，超出范围的索引会自动处理</li> <li>步长方向与起止索引的一致性：若步长为正，start 必须小于 stop；若步长为负，start 必须大于 stop，否则返回空列表</li> <li>切片生成新对象：切片操作返回原序列的副本，修改切片不会影响原序列（字符串、元组等不可变类型始终如此）</li> </ul>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_12","level":2,"title":"数据类型","text":"","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_13","level":3,"title":"数值类型","text":"<ul> <li>整数（int）：如5、-10，支持无限精度。</li> <li>浮点数（float）：如4.5、3.14，注意浮点运算精度问题（如3*0.2=0.6000000000000001）。</li> </ul> <pre><code>pi = 3.14159\nint(pi)   # → 3（向下取整）\nprint(pi)\nstr(pi)   # → \"3.14159\"（转为字符串）\n</code></pre> <pre><code>3.14159\n\n\n\n\n\n'3.14159'\n</code></pre> <pre><code>print(pi)\n</code></pre> <pre><code>3.14159\n</code></pre>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#bool","level":3,"title":"布尔值(bool)","text":"<ol> <li>取值：True（真）和False（假），首字母必须大写。</li> <li>用途：条件判断、循环控制，如:</li> </ol> <pre><code>a = True\nif a:\n    print(\"条件为真\")\n</code></pre> <pre><code>条件为真\n</code></pre>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_14","level":2,"title":"数据结构","text":"<p>Python的基本数据结构包括：列表（list），元组（tuple），字典（dict），集合（set）</p> <ul> <li>列表是动态的，长度大小不固定，可以随意增/删/修元素</li> <li>元组是静态的，长度大小固定，无法增/删/修元素</li> <li>相对于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成</li> <li>集合和字典基本相同，区别是集合没有键和值的配对，是一系列无序的、唯一的元素集合</li> </ul>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#list","level":3,"title":"列表(list)","text":"<p>可变序列，列表由一系列按特定顺序排列的元素组成，类似于C++中的数组，由方括号包裹，元素可重复、可修改，支持混合类型，并且支持切片操作：</p> <pre><code>mylist = ['a', 3, 'string', 4.5]\n</code></pre> <pre><code>bicycles = ['trek', 'cannondale', 'redline', 'specialized']\nprint(bicycles[0]) #下标从0开始\n</code></pre> <pre><code>trek\n</code></pre> <p>常用操作有：</p> <ul> <li>添加元素</li> <li>删除元素</li> <li>排序</li> <li>反转</li> <li>复制列表</li> </ul>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_15","level":4,"title":"添加元素","text":"<p>主要有两种方法(method)：append、insert</p> <pre><code>motorcycles = ['honda', 'yamaha', 'suzuki']\nmotorcycles.append('ducati')\nprint(motorcycles)\n</code></pre> <pre><code>['honda', 'yamaha', 'suzuki', 'ducati']\n</code></pre> <pre><code>motorcycles = ['honda', 'yamaha', 'suzuki']\nmotorcycles.insert(1, 'ducati')\nprint(motorcycles)\n</code></pre> <pre><code>['honda', 'ducati', 'yamaha', 'suzuki']\n</code></pre>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_16","level":4,"title":"删除元素","text":"<p>主要有三种方法：del、pop、remove</p> <pre><code>motorcycles = ['honda', 'yamaha', 'suzuki']\ndel motorcycles[0]\nprint(motorcycles)\n</code></pre> <pre><code>['yamaha', 'suzuki']\n</code></pre> <pre><code>motorcycles = ['honda', 'yamaha', 'suzuki']\nmotorcycles.pop(0)\nprint(motorcycles)\n</code></pre> <pre><code>['yamaha', 'suzuki']\n</code></pre> <p>注意pop方法默认删除的是最后一个</p> <pre><code>motorcycles = ['honda', 'yamaha', 'suzuki']\nmotorcycles.pop()\nprint(motorcycles)\n</code></pre> <pre><code>['honda', 'yamaha']\n</code></pre> <pre><code>motorcycles = ['honda', 'yamaha', 'suzuki']\nmotorcycles.remove('honda') #方法remove()只删除第一个指定的值\nprint(motorcycles)\n</code></pre> <pre><code>['yamaha', 'suzuki']\n</code></pre> <pre><code># 一个综合例子\nmotorcycles = ['honda', 'yamaha', 'suzuki']\nlast_owned = motorcycles.pop()\nprint(\"The last motorcycle I owned was a \" + last_owned.title() + \".\")\n</code></pre> <pre><code>The last motorcycle I owned was a Suzuki.\n</code></pre>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_17","level":4,"title":"排序","text":"<p>主要是两种方法sort、sorted的辨别，sort是永久排序，sorted是返回一个修改过的列表，原列表不变</p> <pre><code>cars = ['bmw', 'audi', 'toyota', 'subaru']\ncars.sort()\nprint(cars)\ncars.sort(reverse=True)\nprint(cars)\nprint(sorted(cars))\nprint(cars)\n# 打印列表时值变为None，因为该方法只做修改不返回值\nprint(cars.sort())\n</code></pre> <pre><code>['audi', 'bmw', 'subaru', 'toyota']\n['toyota', 'subaru', 'bmw', 'audi']\n['audi', 'bmw', 'subaru', 'toyota']\n['toyota', 'subaru', 'bmw', 'audi']\nNone\n</code></pre> <pre><code>print(cars)\ncars.reverse() #反转列表\nprint(cars)\nlen(cars) #列表长度\n</code></pre> <pre><code>['audi', 'bmw', 'subaru', 'toyota']\n['toyota', 'subaru', 'bmw', 'audi']\n\n\n\n\n\n4\n</code></pre>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_18","level":4,"title":"复制列表","text":"<pre><code>a = [1, 2, 3, 4, 5]\nb = a.copy()\nprint(b)\nc = a[:]\nprint(c)\nb.append(6)\nprint(b)\n</code></pre> <pre><code>[1, 2, 3, 4, 5]\n[1, 2, 3, 4, 5]\n[1, 2, 3, 4, 5, 6]\n</code></pre> <pre><code># 直接赋值b = a为引用赋值，修改a会影响b；需用.copy()或切片创建独立副本。\nc = a\na.append(6)\nprint(a)\nprint(c)\n</code></pre> <pre><code>[1, 2, 3, 4, 5, 6]\n[1, 2, 3, 4, 5, 6]\n</code></pre>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#tuple","level":3,"title":"元组(tuple)","text":"<p>不可变序列，括号包裹，元素不可修改，但内部可变元素（如列表）可修改：</p> <pre><code>dimensions = (200, 50)       # 不可变元组\ntest = (1, [2, 3], 5)        # 包含列表的元组，可修改列表：test[1].append(4)\nprint(test)\ntest[1].append(4)\nprint(test)\n# test[0] = 20\n# print(test)\n# You will get 'tuple' object does not support item assignment\n</code></pre> <pre><code>(1, [2, 3], 5)\n(1, [2, 3, 4], 5)\n</code></pre>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/Py-Lecture-1%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#_19","level":4,"title":"访问与解包","text":"<pre><code>a, b, c = (1, 2, 3)  # 解包元组\nprint(a, b, c)       # → 1 2 3\n</code></pre> <pre><code>1 2 3\n</code></pre> <p>元组整体不可修改，若需更新需重新赋值整个元组（如dimensions = (400, 100)）</p>","path":["统计与大数据软件"],"tags":[]},{"location":"%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E8%A5%BF%E7%93%9C%E4%B9%A6/","level":1,"title":"实用教程","text":"<p>主要存放一些markdown格式的有用的教程(有些是Github上的仓库文件下载的，有些是自己写的)</p>","path":["实用教程"],"tags":["CS"]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/","level":1,"title":"科研竞赛","text":"<p>主要存放一下我参加科研训练和一些竞赛的记录，后续有学弟学妹问时方便我本人回忆</p>","path":["科研竞赛"],"tags":["科研","竞赛"]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/#_2","level":2,"title":"科研经历","text":"<ul> <li>Experience<ul> <li>2025.6 - present undergraduate RA</li> </ul> </li> <li>Talks:<ul> <li>Inference_GLM</li> <li>Minimax_Adaptive</li> <li>SHIFT</li> </ul> </li> </ul>","path":["科研竞赛"],"tags":["科研","竞赛"]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/LaTeX/","level":1,"title":"LaTeX 资料","text":"","path":["LaTeX资料"],"tags":["工具","LaTeX"]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/LaTeX/LaTeX(VScode)/","level":1,"title":"LaTeX(VScode)","text":"<p>对于每个学习理工科的学生而言，熟练使用\\(\\LaTeX\\)都是一项必备的技能点，下面将介绍如何在VScode上使用\\(\\LaTeX\\)以及环境配置</p> <p>主要步骤如下：</p> <ul> <li>安装VScode</li> <li>下载Texlive</li> <li>在VScode中配置Tex环境(如今你甚至可以让AI帮你写配置文件，每个custom参数的含义可以自行查询)</li> </ul>","path":["LaTeX(VScode)"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/LaTeX/LaTeX(VScode)/#vscode","level":2,"title":"下载VScode","text":"<p>[!NOTE] 小记 向世界上最伟大的IDE致敬</p> <p>只需要在官网下载即可</p> <p>下载结束之后安装一些基本的扩展：</p> <ul> <li>Chinese(Simplified)</li> <li>LaTeX Workshop</li> <li>GitHub Copilot</li> </ul>","path":["LaTeX(VScode)"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/LaTeX/LaTeX(VScode)/#texlive","level":2,"title":"下载texlive","text":"<p>关于texlive的基本知识可以在大多数有关LaTeX书籍上找到，在此不做过多的赘述，笔者这里选择清华源下载</p> <p>得到一个基本的iso文件后安装即可</p> <p>主要参考这篇文章即可(知乎文章)</p>","path":["LaTeX(VScode)"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/LaTeX/LaTeX(VScode)/#_1","level":2,"title":"环境配置","text":"<pre><code>{\n    \"latex-workshop.latex.autoBuild.run\": \"onFileChange\",\n    \"latex-workshop.showContextMenu\": true,\n    \"latex-workshop.intellisense.package.enabled\": true,\n    \"latex-workshop.message.error.show\": false,\n    \"latex-workshop.message.warning.show\": false,\n    \"latex-workshop.latex.tools\": [\n        {\n            \"name\": \"xelatex\",\n            \"command\": \"xelatex\",\n            \"args\": [\n                \"-synctex=1\",\n                \"-interaction=nonstopmode\",\n                \"-file-line-error\",\n                \"%DOCFILE%\"\n            ]\n        },\n        {   \n            \"name\": \"pdflatex\",\n        \"command\": \"pdflatex\",\n        \"args\": [\n            \"-synctex=1\",\n            \"-interaction=nonstopmode\",\n            \"-file-line-error\",\n            \"%DOC%\"\n        ]\n        },\n        {\n            \"name\": \"latexmk\",\n            \"command\": \"latexmk\",\n            \"args\": [\n                \"-synctex=1\",\n                \"-interaction=nonstopmode\",\n                \"-file-line-error\",\n                \"-pdf\",\n                \"-outdir=%OUTDIR%\",\n                \"%DOCFILE%\"\n            ]\n        },\n        {\n            \"name\": \"bibtex\",\n            \"command\": \"bibtex\",\n            \"args\": [\n                \"%DOCFILE%\"\n            ]\n        }\n    ],\n    \"latex-workshop.latex.recipes\": [\n        {\n            \"name\": \"XeLaTeX\",\n            \"tools\": [\n                \"xelatex\"\n            ]\n        },\n        {\n            \"name\": \"PDFLaTeX\",\n            \"tools\": [\n                \"pdflatex\"\n            ]\n        },\n        {\n            \"name\": \"BibTeX\",\n            \"tools\": [\n                \"bibtex\"\n            ]\n        },\n        {\n            \"name\": \"LaTeXmk\",\n            \"tools\": [\n                \"latexmk\"\n            ]\n        },\n        {\n            \"name\": \"xelatex -&gt; bibtex -&gt; xelatex*2\",\n            \"tools\": [\n                \"xelatex\",\n                \"bibtex\",\n                \"xelatex\",\n                \"xelatex\"\n            ]\n        },\n        {\n            \"name\": \"pdflatex -&gt; bibtex -&gt; pdflatex*2\",\n            \"tools\": [\n                \"pdflatex\",\n                \"bibtex\",\n                \"pdflatex\",\n                \"pdflatex\"\n            ]\n        },\n    ],\n    \"latex-workshop.latex.clean.fileTypes\": [\n        \"*.bbl\",\n        \"*.blg\",\n        \"*.idx\",\n        \"*.ind\",\n        \"*.lof\",\n        \"*.lot\",\n        \"*.out\",\n        \"*.acn\",\n        \"*.acr\",\n        \"*.alg\",\n        \"*.glg\",\n        \"*.glo\",\n        \"*.gls\",\n        \"*.ist\",\n        \"*.fls\",\n        \"*.log\",\n        \"*.fdb_latexmk\"\n    ],\n    \"latex-workshop.latex.autoClean.run\": \"never\",\n    \"latex-workshop.latex.recipe.default\": \"lastUsed\", //lastUsed\n    \"latex-workshop.view.pdf.internal.synctex.keybinding\": \"double-click\",\n}\n</code></pre> <p>补一个笔者自己的配置，只想快速使用LaTeX不需要配置</p>","path":["LaTeX(VScode)"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/LaTeX/LaTeX(VScode)/#snippets","level":2,"title":"Snippets配置(可选)","text":"<pre><code>{\n    // LaTeX snippets\n    // This file contains LaTeX snippets for various mathematical symbols, operations, and environments.\n    // Each snippet has a prefix, body, description, and scope.\n    // The prefix is the shortcut to trigger the snippet, the body is the actual LaTeX code,\n    // the description explains what the snippet does, and the scope indicates where the snippet can be used.\n    // The snippets are organized into categories for better organization.\n\n    \"Math mode inline\": {\n        \"prefix\": \"mk\",\n        \"body\": \"$$0$\",\n        \"description\": \"Math mode - inline with placeholder 0\",\n        \"scope\": \"latex\"\n    },\n    \"Math mode display\": {\n        \"prefix\": \"dm\",\n        \"body\": \"$$\\n$0\\n$$\",\n        \"description\": \"Math mode - display with placeholder 0\",\n        \"scope\": \"latex\"\n    },\n    \"Begin environment\": {\n        \"prefix\": \"beg\",\n        \"body\": \"\\\\begin{$1}\\n$0\\n\\\\end{$1}\",\n        \"description\": \"Begin and end LaTeX environment\",\n        \"scope\": \"latex\"\n    },\n//--------------------------------------------------------------\n//--------------------------------------------------------------\n//--------------------------------------------------------------\n\"IID\": {\n    \"prefix\": \"IID\",\n    \"body\": \"\\\\overset{IID}{\\\\sim}\",\n    \"description\": \"Independently and identically distributed symbol\",\n},\n\"meato\": {\n    \"prefix\": \"meato\",\n    \"body\": \"\\\\Rightarrow\",\n    \"description\": \"converges in measure to\",\n\n},\n\"likehood\": {\n    \"prefix\": \"likehood\",\n    \"body\": \"f(x_{1},x_{2},\\\\dots,x_{n}|\\\\theta)\",\n    \"description\": \"likehood function\",\n\n},\n//--------------------------------------------------------------\n//--------------------------------------------------------------\n//--------------------------------------------------------------\n\"@a\": {\n    \"prefix\": \"@a\",\n    \"body\": \"\\\\alpha\",\n    \"description\": \"Greek letter alpha\",\n\n},\n\"eta\": {\n    \"prefix\": \"eta\",\n    \"body\": \"\\\\eta\",\n    \"description\": \"Greek letter eta\",\n\n},\n\"@b\": {\n    \"prefix\": \"@b\",\n    \"body\": \"\\\\beta\",\n    \"description\": \"Greek letter beta\",\n\n},\n\"@g\": {\n    \"prefix\": \"@g\",\n    \"body\": \"\\\\gamma\",\n    \"description\": \"Greek letter gamma\",\n\n},\n\"@G\": {\n    \"prefix\": \"@G\",\n    \"body\": \"\\\\Gamma\",\n    \"description\": \"Capital Greek letter Gamma\",\n\n},\n\"@d\": {\n    \"prefix\": \"@d\",\n    \"body\": \"\\\\delta\",\n    \"description\": \"Greek letter delta\",\n\n},\n\"@D\": {\n    \"prefix\": \"@D\",\n    \"body\": \"\\\\Delta\",\n    \"description\": \"Capital Greek letter Delta\",\n\n},\n\"@e\": {\n    \"prefix\": \"@e\",\n    \"body\": \"\\\\varepsilon\",\n    \"description\": \"Greek letter epsilon\",\n\n},\n\"@z\": {\n    \"prefix\": \"@z\",\n    \"body\": \"\\\\zeta\",\n    \"description\": \"Greek letter zeta\",\n\n},\n\"@t\": {\n    \"prefix\": \"@t\",\n    \"body\": \"\\\\theta\",\n    \"description\": \"Greek letter theta\",\n\n},\n\"@T\": {\n    \"prefix\": \"@T\",\n    \"body\": \"\\\\Theta\",\n    \"description\": \"Capital Greek letter Theta\",\n\n},\n\":t\": {\n    \"prefix\": \":t\",\n    \"body\": \"\\\\vartheta\",\n    \"description\": \"Variant of Greek letter theta\",\n\n},\n\"@i\": {\n    \"prefix\": \"@i\",\n    \"body\": \"\\\\iota\",\n    \"description\": \"Greek letter iota\",\n\n},\n\"@k\": {\n    \"prefix\": \"@k\",\n    \"body\": \"\\\\kappa\",\n    \"description\": \"Greek letter kappa\",\n\n},\n\"@l\": {\n    \"prefix\": \"@l\",\n    \"body\": \"\\\\lambda\",\n    \"description\": \"Greek letter lambda\",\n\n},\n\"@L\": {\n    \"prefix\": \"@L\",\n    \"body\": \"\\\\Lambda\",\n    \"description\": \"Capital Greek letter Lambda\",\n\n},\n\"@s\": {\n    \"prefix\": \"@s\",\n    \"body\": \"\\\\sigma\",\n    \"description\": \"Greek letter sigma\",\n\n},\n\"@S\": {\n    \"prefix\": \"@S\",\n    \"body\": \"\\\\Sigma\",\n    \"description\": \"Capital Greek letter Sigma\",\n\n},\n\"@u\": {\n    \"prefix\": \"@u\",\n    \"body\": \"\\\\upsilon\",\n    \"description\": \"Greek letter upsilon\",\n\n},\n\"@U\": {\n    \"prefix\": \"@U\",\n    \"body\": \"\\\\Upsilon\",\n    \"description\": \"Capital Greek letter Upsilon\",\n\n},\n\"@o\": {\n    \"prefix\": \"@o\",\n    \"body\": \"\\\\omega\",\n    \"description\": \"Greek letter omega\",\n\n},\n\"@O\": {\n    \"prefix\": \"@O\",\n    \"body\": \"\\\\Omega\",\n    \"description\": \"Capital Greek letter Omega\",\n\n},\n\"ome\": {\n    \"prefix\": \"ome\",\n    \"body\": \"\\\\omega\",\n    \"description\": \"Greek letter omega\",\n\n},\n\"Ome\": {\n    \"prefix\": \"Ome\",\n    \"body\": \"\\\\Omega\",\n    \"description\": \"Capital Greek letter Omega\",\n\n},\n//--------------------------------------------------------------\n//--------------------------------------------------------------\n//--------------------------------------------------------------\n\n    \"Text environment - text\": {\n        \"prefix\": \"text\",\n        \"body\": \"\\\\text{$0}$1\",\n        \"description\": \"Text environment with placeholder 0 and 1\",\n\n    },\n    \"Text environment - quote\": {\n        \"prefix\": \"\\\"\",\n        \"body\": \"\\\\text{$0}$1\",\n        \"description\": \"Text environment with placeholder 0 and 1\",\n\n    },\n    \"Basic operation - square\": {\n        \"prefix\": \"sr\",\n        \"body\": \"^{2}\",\n        \"description\": \"Square exponent\",\n\n    },\n    \"Basic operation - cube\": {\n        \"prefix\": \"cb\",\n        \"body\": \"^{3}\",\n        \"description\": \"Cube exponent\",\n\n    },\n    \"Basic operation - general exponent\": {\n        \"prefix\": \"rd\",\n        \"body\": \"^{$0}$1\",\n        \"description\": \"General exponent with placeholders 0 and 1\",\n\n    },\n    \"Basic operation - general subscript\": {\n        \"prefix\": \"_\",\n        \"body\": \"_{$0}$1\",\n        \"description\": \"General subscript with placeholders 0 and 1\",\n\n    },\n    \"Basic operation - text subscript\": {\n        \"prefix\": \"sts\",\n        \"body\": \"_\\\\text{$0}\",\n        \"description\": \"Text subscript with placeholder 0\",\n\n    },\n    \"Basic operation - sqrt\": {\n        \"prefix\": \"sq\",\n        \"body\": \"\\\\sqrt{ $0 }$1\",\n        \"description\": \"Square root with placeholder 0 and 1\",\n\n    },\n    \"Basic operation - fraction\": {\n        \"prefix\": \"//\",\n        \"body\": \"\\\\frac{$0}{$1}$2\",\n        \"description\": \"Fraction with placeholders 0, 1 and 2\",\n\n    },\n    \"Basic operation - binomial\": {\n        \"prefix\": \"bino\",\n        \"body\": \"\\\\binom{$0}{$1}$2\",\n        \"description\": \"Binomial coefficient with placeholders 0, 1 and 2\",\n\n    },\n    \"Basic operation - exponential\": {\n        \"prefix\": \"ee\",\n        \"body\": \"e^{$1}$0\",\n        \"description\": \"Exponential with base e and placeholders 0 and 1\",\n\n    },\n    \"Basic operation - inverse\": {\n        \"prefix\": \"invs\",\n        \"body\": \"^{-1}\",\n        \"description\": \"Inverse exponent\",\n\n    },\n    \"Basic operation - conjugate\": {\n        \"prefix\": \"conj\",\n        \"body\": \"^{*}\",\n        \"description\": \"Complex conjugate symbol\",\n\n    },\n    \"Basic operation - real part\": {\n        \"prefix\": \"Re\",\n        \"body\": \"\\\\mathrm{Re}\",\n        \"description\": \"Real part operator\",\n\n    },\n    \"Basic operation - imaginary part\": {\n        \"prefix\": \"Im\",\n        \"body\": \"\\\\mathrm{Im}\",\n        \"description\": \"Imaginary part operator\",\n\n    },\n    \"Basic operation - boldface\": {\n        \"prefix\": \"bf\",\n        \"body\": \"\\\\mathbf{$0}\",\n        \"description\": \"Boldface with placeholder 0\",\n\n    },\n    \"Basic operation - roman\": {\n        \"prefix\": \"rm\",\n        \"body\": \"\\\\mathrm{$0}$1\",\n        \"description\": \"Roman font with placeholder 0 and 1\",\n\n    },\n//--------------------------------------------------------------\n//--------------------------------------------------------------\n//--------------------------------------------------------------\n\n    \"Linear algebra - trace\": {\n        \"prefix\": \"trace\",\n        \"body\": \"\\\\mathrm{Tr}\",\n        \"description\": \"Trace operator\",\n\n    },\n    \"More operation - hat (regex)\": {\n        \"prefix\": \"([a-zA-Z])hat\",\n        \"body\": \"\\\\hat{[[0]]}\",\n        \"description\": \"Hat over letter\",\n        \"regex\": true\n    },\n    \"More operation - bar (regex)\": {\n        \"prefix\": \"([a-zA-Z])bar\",\n        \"body\": \"\\\\bar{[[0]]}\",\n        \"description\": \"Bar over letter\",\n        \"regex\": true\n    },\n        \"prefix\": \"bar\",\n        \"body\": \"\\\\overline{$0}$1\",\n        \"description\": \"Bar over placeholder 0 with placeholder 1\",\n\n    },\n    \"More operation - bar\": {\n        \"prefix\": \"Bar\",\n        \"body\": \"\\\\bar{$0}$1\",\n        \"description\": \"Bar over placeholder 0 with placeholder 1\",\n\n    },\n    \"More operation - dot\": {\n        \"prefix\": \"dot\",\n        \"body\": \"\\\\dot{$0}$1\",\n        \"description\": \"Dot over placeholder 0 with placeholder 1\",\n\n    },\n    \"More operation - ddot\": {\n        \"prefix\": \"ddot\",\n        \"body\": \"\\\\ddot{$0}$1\",\n        \"description\": \"Double dot over placeholder 0 with placeholder 1\",\n\n    },\n    \"More operation - cdot\": {\n        \"prefix\": \"cdot\",\n        \"body\": \"\\\\cdot\",\n        \"description\": \"Dot multiplication symbol\",\n\n    },\n    \"More operation - tilde\": {\n        \"prefix\": \"tilde\",\n        \"body\": \"\\\\tilde{$0}$1\",\n        \"description\": \"Tilde over placeholder 0 with placeholder 1\",\n\n    },\n    \"More operation - underline\": {\n        \"prefix\": \"und\",\n        \"body\": \"\\\\underline{$0}$1\",\n        \"description\": \"Underline placeholder 0 with placeholder 1\",\n\n    },\n    \"More operation - vec\": {\n        \"prefix\": \"vec\",\n        \"body\": \"\\\\vec{$0}$1\",\n        \"description\": \"Vector arrow over placeholder 0 with placeholder 1\",\n\n    },\n//--------------------------------------------------------------\n//--------------------------------------------------------------\n//--------------------------------------------------------------\n\n    \"Symbol - emptyset\": {\n        \"prefix\": \"emp\",\n        \"body\": \"\\\\emptyset\",\n        \"description\": \"Empty set symbol\",\n\n    },\n    \"Symbol - xnn\": {\n        \"prefix\": \"xnn\",\n        \"body\": \"x_{n}\",\n        \"description\": \"Subscripted variable x_n\",\n\n    },\n    \"Symbol - xii\": {\n        \"prefix\": \"\\\\xii\",\n        \"body\": \"x_{i}\",\n        \"description\": \"Subscripted variable x_i\",\n\n    },\n    \"Symbol - xjj\": {\n        \"prefix\": \"xjj\",\n        \"body\": \"x_{j}\",\n        \"description\": \"Subscripted variable x_j\",\n\n    },\n    \"Symbol - xp1\": {\n        \"prefix\": \"xp1\",\n        \"body\": \"x_{n+1}\",\n        \"description\": \"Subscripted variable x_{n+1}\",\n\n    },\n    \"Symbol - ynn\": {\n        \"prefix\": \"ynn\",\n        \"body\": \"y_{n}\",\n        \"description\": \"Subscripted variable y_n\",\n\n    },\n    \"Symbol - yii\": {\n        \"prefix\": \"yii\",\n        \"body\": \"y_{i}\",\n        \"description\": \"Subscripted variable y_i\",\n\n    },\n    \"Symbol - yjj\": {\n        \"prefix\": \"yjj\",\n        \"body\": \"y_{j}\",\n        \"description\": \"Subscripted variable y_j\",\n\n    },\n    \"Symbol - infinity\": {\n        \"prefix\": \"ooo\",\n        \"body\": \"\\\\infty\",\n        \"description\": \"Infinity symbol\",\n\n    },\n    \"Symbol - sum\": {\n        \"prefix\": \"sum\",\n        \"body\": \"\\\\sum\\\\limits_{$1}^{$2} $0\",\n        \"description\": \"Sum symbol with limits\",\n\n    },\n    \"Symbol - prod\": {\n        \"prefix\": \"prod\",\n        \"body\": \"\\\\prod\",\n        \"description\": \"Product symbol\",\n\n    },\n    \"Symbol - bigcup\": {\n        \"prefix\": \"bigcup\",\n        \"body\": \"\\\\bigcup\",\n        \"description\": \"Union symbol\",\n\n    },\n    \"Symbol - bigcap\": {\n        \"prefix\": \"bigcap\",\n        \"body\": \"\\\\bigcap\",\n        \"description\": \"Intersection symbol\",\n\n    },\n    \"Symbol - sum with limits\": {\n        \"prefix\": \"\\\\sum\\\\limits\",\n        \"body\": \"\\\\sum\\\\limits_{${0:i}=${1:1}}^{${2:N}} $3\",\n        \"description\": \"Sum with default indices\",\n\n    },\n    \"Symbol - prod with limits\": {\n        \"prefix\": \"\\\\prod\",\n        \"body\": \"\\\\prod_{${0:i}=${1:1}}^{${2:N}} $3\",\n        \"description\": \"Product with default indices\",\n\n    },\n    \"Symbol - bigcup with limits\": {\n        \"prefix\": \"\\\\bigcup\",\n        \"body\": \"\\\\bigcup\\\\limits_{${0:i}=${1:1}}^{${2:\\\\infty}} $3\",\n        \"description\": \"Union with default indices\",\n\n    },\n    \"Symbol - bigcap with limits\": {\n        \"prefix\": \"\\\\bigcap\",\n        \"body\": \"\\\\bigcap\\\\limits_{${0:i}=${1:1}}^{${2:\\\\infty}} $3\",\n        \"description\": \"Intersection with default indices\",\n\n    },\n    \"Symbol - limit\": {\n        \"prefix\": \"limt\",\n        \"body\": \"\\\\lim\\\\limits_{ ${0:n} \\\\to ${1:\\\\infty} } $2\",\n        \"description\": \"Limit with default variable and infinity\",\n\n    },\n    \"Symbol - suplim\": {\n        \"prefix\": \"suplim\",\n        \"body\": \"\\\\varlimsup\\\\limits_{ ${0:n} \\\\to ${1:\\\\infty} } $2\",\n        \"description\": \"Limit superior with default variable and infinity\",\n\n    },\n    \"Symbol - inflim\": {\n        \"prefix\": \"inflim\",\n        \"body\": \"\\\\varliminf\\\\limits_{ ${0:n} \\\\to ${1:\\\\infty} } $2\",\n        \"description\": \"Limit inferior with default variable and infinity\",\n\n    },\n    \"Symbol - plusminus\": {\n        \"prefix\": \"+-\",\n        \"body\": \"\\\\pm\",\n        \"description\": \"Plus-minus symbol\",\n\n    },\n    \"Symbol - minusplus\": {\n        \"prefix\": \"-+\",\n        \"body\": \"\\\\mp\",\n        \"description\": \"Minus-plus symbol\",\n\n    },\n    \"Symbol - dots\": {\n        \"prefix\": \"...\",\n        \"body\": \"\\\\dots\",\n        \"description\": \"Ellipsis symbol\",\n\n    },\n    \"Symbol - nabla\": {\n        \"prefix\": \"nabl\",\n        \"body\": \"\\\\nabla\",\n        \"description\": \"Nabla operator\",\n\n    },\n    \"Symbol - del\": {\n        \"prefix\": \"del\",\n        \"body\": \"\\\\nabla\",\n        \"description\": \"Nabla operator\",\n\n    },\n    \"Symbol - times\": {\n        \"prefix\": \"xx\",\n        \"body\": \"\\\\times\",\n        \"description\": \"Multiplication cross symbol\",\n\n    },\n    \"Symbol - cdot\": {\n        \"prefix\": \"**\",\n        \"body\": \"\\\\cdot\",\n        \"description\": \"Dot multiplication symbol\",\n\n    },\n    \"Symbol - parallel\": {\n        \"prefix\": \"para\",\n        \"body\": \"\\\\parallel\",\n        \"description\": \"Parallel symbol\",\n\n    },\n    \"Symbol - equiv\": {\n        \"prefix\": \"===\",\n        \"body\": \"\\\\equiv\",\n        \"description\": \"Equivalence symbol\",\n\n    },\n    \"Symbol - neq\": {\n        \"prefix\": \"!=\",\n        \"body\": \"\\\\neq\",\n        \"description\": \"Not equal symbol\",\n\n    },\n    \"Symbol - min\": {\n        \"prefix\": \"min\",\n        \"body\": \"\\\\min\",\n        \"description\": \"Minimum operator\",\n\n    },\n    \"Symbol - max\": {\n        \"prefix\": \"max\",\n        \"body\": \"\\\\max\",\n        \"description\": \"Maximum operator\",\n\n    },\n    \"Symbol - geqslant\": {\n        \"prefix\": \"gedeng\",\n        \"body\": \"\\\\geqslant\",\n        \"description\": \"Greater than or equal to symbol\",\n\n    },\n    \"Symbol - leqslant\": {\n        \"prefix\": \"ledeng\",\n        \"body\": \"\\\\leqslant\",\n        \"description\": \"Less than or equal to symbol\",\n\n    },\n    \"Symbol - geqslant2\": {\n        \"prefix\": \"&gt;=\",\n        \"body\": \"\\\\geqslant\",\n        \"description\": \"Greater than or equal to symbol\",\n\n    },\n    \"Symbol - leqslant2\": {\n        \"prefix\": \"&lt;=\",\n        \"body\": \"\\\\leqslant\",\n        \"description\": \"Less than or equal to symbol\",\n\n    },\n    \"Symbol - gg\": {\n        \"prefix\": \"&gt;&gt;\",\n        \"body\": \"\\\\gg\",\n        \"description\": \"Much greater than symbol\",\n\n    },\n    \"Symbol - ll\": {\n        \"prefix\": \"&lt;&lt;\",\n        \"body\": \"\\\\ll\",\n        \"description\": \"Much less than symbol\",\n\n    },\n    \"Symbol - sim\": {\n        \"prefix\": \"simm\",\n        \"body\": \"\\\\sim\",\n        \"description\": \"Tilde symbol\",\n\n    },\n    \"Symbol - simeq\": {\n        \"prefix\": \"sim=\",\n        \"body\": \"\\\\simeq\",\n        \"description\": \"Approximately equal symbol\",\n\n    },\n    \"Symbol - propto\": {\n        \"prefix\": \"prop\",\n        \"body\": \"\\\\propto\",\n        \"description\": \"Proportional to symbol\",\n\n    },\n    \"Symbol - leftrightarrow\": {\n        \"prefix\": \"&lt;-&gt;\",\n        \"body\": \"\\\\leftrightarrow \",\n        \"description\": \"Left-right arrow\",\n\n    },\n    \"Symbol - to\": {\n        \"prefix\": \"-&gt;\",\n        \"body\": \"\\\\to\",\n        \"description\": \"Right arrow\",\n\n    },\n    \"Symbol - mapsto\": {\n        \"prefix\": \"!&gt;\",\n        \"body\": \"\\\\mapsto\",\n        \"description\": \"Maps to arrow\",\n\n    },\n    \"Symbol - implies\": {\n        \"prefix\": \"=&gt;\",\n        \"body\": \"\\\\implies\",\n        \"description\": \"Implies arrow\",\n\n    },\n    \"Symbol - impliedby\": {\n        \"prefix\": \"=&lt;\",\n        \"body\": \"\\\\impliedby\",\n        \"description\": \"Implied by arrow\",\n\n    },\n    \"Symbol - cap\": {\n        \"prefix\": \"and\",\n        \"body\": \"\\\\cap\",\n        \"description\": \"Intersection symbol\",\n\n    },\n    \"Symbol - cup\": {\n        \"prefix\": \"orr\",\n        \"body\": \"\\\\cup\",\n        \"description\": \"Union symbol\",\n\n    },\n    \"Symbol - in\": {\n        \"prefix\": \"inn\",\n        \"body\": \"\\\\in\",\n        \"description\": \"Element of symbol\",\n\n    },\n    \"Symbol - notin\": {\n        \"prefix\": \"notin\",\n        \"body\": \"\\\\not\\\\in\",\n        \"description\": \"Not an element of symbol\",\n\n    },\n    \"Symbol - setminus\": {\n        \"prefix\": \"\\\\\\\\\\\\\",\n        \"body\": \"\\\\setminus\",\n        \"description\": \"Set minus symbol\",\n\n    },\n    \"Symbol - subseteq\": {\n        \"prefix\": \"sub=\",\n        \"body\": \"\\\\subseteq\",\n        \"description\": \"Subset or equal symbol\",\n\n    },\n    \"Symbol - supseteq\": {\n        \"prefix\": \"sup=\",\n        \"body\": \"\\\\supseteq\",\n        \"description\": \"Superset or equal symbol\",\n\n    },\n    \"Symbol - eset\": {\n        \"prefix\": \"eset\",\n        \"body\": \"\\\\emptyset\",\n        \"description\": \"Empty set symbol\",\n\n    },\n    \"Symbol - sete\": {\n        \"prefix\": \"sete\",\n        \"body\": \"\\\\{ $0 \\\\}$1\",\n        \"description\": \"Set notation\",\n\n    },\n    \"Symbol - exists\": {\n        \"prefix\": \"cunz\",\n        \"body\": \"\\\\exists\",\n        \"description\": \"Exists quantifier\",\n\n    },\n    \"Ker\": {\n        \"prefix\": \"Ker\",\n        \"body\": \"\\\\mathrm{Ker}\",\n        \"description\": \"Kernel operator\",\n\n    },\n    \"Im\": {\n        \"prefix\": \"Im\",\n        \"body\": \"\\\\mathrm{Im}\",\n        \"description\": \"Image operator\",\n\n    },\n    \"dim\": {\n        \"prefix\": \"dim\",\n        \"body\": \"\\\\mathrm{dim}\",\n        \"description\": \"Dimension operator\",\n\n    },\n    \"LL\": {\n        \"prefix\": \"LL\",\n        \"body\": \"\\\\mathcal{L}\",\n        \"description\": \"Calligraphic L\",\n\n    },\n    \"HH\": {\n        \"prefix\": \"HH\",\n        \"body\": \"\\\\mathcal{H}\",\n        \"description\": \"Calligraphic H\",\n\n    },\n    \"CC\": {\n        \"prefix\": \"CC\",\n        \"body\": \"\\\\mathbb{C}\",\n        \"description\": \"Blackboard bold C (complex numbers)\",\n\n    },\n    \"QQ\": {\n        \"prefix\": \"QQ\",\n        \"body\": \"\\\\mathbb{Q}\",\n        \"description\": \"Blackboard bold Q (rational numbers)\",\n\n    },\n    \"RR\": {\n        \"prefix\": \"RR\",\n        \"body\": \"\\\\mathbb{R}\",\n        \"description\": \"Blackboard bold R (real numbers)\",\n\n    },\n    \"ZZ\": {\n        \"prefix\": \"ZZ\",\n        \"body\": \"\\\\mathbb{Z}\",\n        \"description\": \"Blackboard bold Z (integers)\",\n\n    },\n    \"NN\": {\n        \"prefix\": \"NN\",\n        \"body\": \"\\\\mathbb{N}\",\n        \"description\": \"Blackboard bold N (natural numbers)\",\n\n    },\n    \"EE\": {\n        \"prefix\": \"EE\",\n        \"body\": \"\\\\mathbb{E}\",\n        \"description\": \"Blackboard bold E (expectation)\",\n\n    },\n    \"PP\": {\n        \"prefix\": \"PP\",\n        \"body\": \"\\\\mathbb{P}\",\n        \"description\": \"Blackboard bold P (probability)\",\n\n    },\n    \"xdot\": {\n        \"prefix\": \"xdot\",\n        \"body\": \"x_{1},x_{2},\\\\dots,x_{n}\",\n        \"description\": \"Sequence of x variables\",\n\n    },\n    \"ydot\": {\n        \"prefix\": \"ydot\",\n        \"body\": \"y_{1},y_{2},\\\\dots,y_{n}\",\n        \"description\": \"Sequence of y variables\",\n\n    },\n    \"par\": {\n        \"prefix\": \"par\",\n        \"body\": \"\\\\frac{ \\\\partial ${0:y} }{ \\\\partial ${1:x} } $2\",\n        \"description\": \"Partial derivative with placeholders\"\n    },\n    \"paPartial\": {\n        \"prefix\": \"pa([A-Za-z])([A-Za-z])\",\n        \"body\": \"\\\\frac{ \\\\partial [[0]] }{ \\\\partial [[1]] } \",\n        \"description\": \"Partial derivative shorthand\",\n        \"regex\": true\n    },\n    \"ddt\": {\n        \"prefix\": \"ddt\",\n        \"body\": \"\\\\frac{d}{dt} \",\n        \"description\": \"Total derivative with respect to t\"\n    },\n    \"int\": {\n        \"prefix\": \"\\\\int\",\n        \"body\": \"\\\\int $0 \\\\, d${1:x} $2\",\n        \"description\": \"Integral with placeholders\"\n    },\n    \"dint\": {\n        \"prefix\": \"dint\",\n        \"body\": \"\\\\int_{${0:0}}^{${1:1}} $2 \\\\, d${3:x} $4\",\n        \"description\": \"Definite integral with placeholders\"\n    },\n    \"oint\": {\n        \"prefix\": \"oint\",\n        \"body\": \"\\\\oint\",\n        \"description\": \"Contour integral symbol\"\n    },\n    \"iint\": {\n        \"prefix\": \"iint\",\n        \"body\": \"\\\\iint\",\n        \"description\": \"Double integral symbol\"\n    },\n    \"iiint\": {\n        \"prefix\": \"iiint\",\n        \"body\": \"\\\\iiint\",\n        \"description\": \"Triple integral symbol\"\n    },\n    \"oinf\": {\n        \"prefix\": \"oinf\",\n        \"body\": \"\\\\int_{0}^{\\\\infty} $0 \\\\, d${1:x} $2\",\n        \"description\": \"Integral from 0 to infinity\"\n    },\n    \"infi\": {\n        \"prefix\": \"infi\",\n        \"body\": \"\\\\int_{-\\\\infty}^{\\\\infty} $0 \\\\, d${1:x} $2\",\n        \"description\": \"Integral from negative to positive infinity\"\n    },\n    \"trigBackslash\": {\n        \"prefix\": \"arcsin|sin|arccos|cos|arctan|tan|csc|sec|cot\",\n        \"body\": \"\\\\\\\\$0\",\n        \"description\": \"Add backslash before trigonometric functions\",\n        \"regex\": true\n    },\n    \"trigSpace\": {\n        \"prefix\": \"(arcsin|sin|arccos|cos|arctan|tan|csc|sec|cot)([A-Za-gi-z])\",\n        \"body\": \"\\\\\\\\$1 $2\",\n        \"description\": \"Add space after trigonometric functions (skips h)\",\n        \"regex\": true\n    },\n    \"trigHyperSpace\": {\n        \"prefix\": \"(sinh|cosh|tanh|coth)([A-Za-z])\",\n        \"body\": \"\\\\\\\\$1 $2\",\n        \"description\": \"Add space after hyperbolic trigonometric functions\",\n        \"regex\": true\n    },\n    \"visualUnderbrace\": {\n        \"prefix\": \"U\",\n        \"body\": \"\\\\underbrace{ ${VISUAL} }_{ $0 }\",\n        \"description\": \"Underbrace with placeholder\"\n    },\n    \"visualOverbrace\": {\n        \"prefix\": \"O\",\n        \"body\": \"\\\\overbrace{ ${VISUAL} }^{ $0 }\",\n        \"description\": \"Overbrace with placeholder\"\n    },\n    \"visualUnderset\": {\n        \"prefix\": \"B\",\n        \"body\": \"\\\\underset{ $0 }{ ${VISUAL} }\",\n        \"description\": \"Underset with placeholder\"\n    },\n    \"visualCancel\": {\n        \"prefix\": \"C\",\n        \"body\": \"\\\\cancel{ ${VISUAL} }\",\n        \"description\": \"Cancel with visual placeholder\"\n    },\n    \"visualCancelto\": {\n        \"prefix\": \"K\",\n        \"body\": \"\\\\cancelto{ $0 }{ ${VISUAL} }\",\n        \"description\": \"Cancel to with visual placeholder\"\n    },\n    \"visualSqrt\": {\n        \"prefix\": \"S\",\n        \"body\": \"\\\\sqrt{ ${VISUAL} }\",\n        \"description\": \"Square root with visual placeholder\"\n    },\n    \"kbt\": {\n        \"prefix\": \"kbt\",\n        \"body\": \"k_{B}T\",\n        \"description\": \"Boltzmann constant times temperature\"\n    },\n    \"msun\": {\n        \"prefix\": \"msun\",\n        \"body\": \"M_{\\\\odot}\",\n        \"description\": \"Solar mass\"\n    },\n    \"dag\": {\n        \"prefix\": \"dag\",\n        \"body\": \"^{\\\\dagger}\",\n        \"description\": \"Dagger symbol\"\n    },\n    \"oPlus\": {\n        \"prefix\": \"o+\",\n        \"body\": \"\\\\oplus \",\n        \"description\": \"Direct sum symbol\"\n    },\n    \"oTimes\": {\n        \"prefix\": \"ox\",\n        \"body\": \"\\\\otimes \",\n        \"description\": \"Tensor product symbol\"\n    },\n    \"bra\": {\n        \"prefix\": \"bra\",\n        \"body\": \"\\\\bra{$0} $1\",\n        \"description\": \"Bra notation\"\n    },\n    \"ket\": {\n        \"prefix\": \"ket\",\n        \"body\": \"\\\\ket{$0} $1\",\n        \"description\": \"Ket notation\"\n    },\n    \"brk\": {\n        \"prefix\": \"brk\",\n        \"body\": \"\\\\braket{ $0 | $1 } $2\",\n        \"description\": \"Bra-ket notation\"\n    },\n    \"outer\": {\n        \"prefix\": \"outer\",\n        \"body\": \"\\\\ket{${0:\\\\psi}} \\\\bra{${0:\\\\psi}} $1\",\n        \"description\": \"Outer product notation\"\n    },\n    \"pu\": {\n        \"prefix\": \"pu\",\n        \"body\": \"\\\\pu{ $0 }\",\n        \"description\": \"SI unit with placeholder\"\n    },\n    \"cee\": {\n        \"prefix\": \"cee\",\n        \"body\": \"\\\\ce{ $0 }\",\n        \"description\": \"Chemical formula with placeholder\"\n    },\n    \"he4\": {\n        \"prefix\": \"he4\",\n        \"body\": \"{}^{4}_{2}He \",\n        \"description\": \"Helium-4 isotope\"\n    },\n    \"he3\": {\n        \"prefix\": \"he3\",\n        \"body\": \"{}^{3}_{2}He \",\n        \"description\": \"Helium-3 isotope\"\n    },\n    \"iso\": {\n        \"prefix\": \"iso\",\n        \"body\": \"{}^{${0:4}}_{${1:2}}${2:He}\",\n        \"description\": \"Isotope notation with placeholders\"\n    },\n    \"pmat\": {\n        \"prefix\": \"pmat\",\n        \"body\": \"\\\\begin{pmatrix}\\n$0\\n\\\\end{pmatrix}\",\n        \"description\": \"Parenthesis matrix environment\"\n    },\n    \"bmat\": {\n        \"prefix\": \"bmat\",\n        \"body\": \"\\\\begin{bmatrix}\\n$0\\n\\\\end{bmatrix}\",\n        \"description\": \"Bracket matrix environment\"\n    },\n    \"Bmat\": {\n        \"prefix\": \"Bmat\",\n        \"body\": \"\\\\begin{Bmatrix}\\n$0\\n\\\\end{Bmatrix}\",\n        \"description\": \"Brace matrix environment\"\n    },\n    \"vmat\": {\n        \"prefix\": \"vmat\",\n        \"body\": \"\\\\begin{vmatrix}\\n$0\\n\\\\end{vmatrix}\",\n        \"description\": \"Vertical bar matrix environment\"\n    },\n    \"Vmat\": {\n        \"prefix\": \"Vmat\",\n        \"body\": \"\\\\begin{Vmatrix}\\n$0\\n\\\\end{Vmatrix}\",\n        \"description\": \"Double vertical bar matrix environment\"\n    },\n    \"matrix\": {\n        \"prefix\": \"matrix\",\n        \"body\": \"\\\\begin{matrix}\\n$0\\n\\\\end{matrix}\",\n        \"description\": \"Plain matrix environment\"\n    },\n    \"cases\": {\n        \"prefix\": \"cases\",\n        \"body\": \"\\\\begin{cases}\\n$0\\n\\\\end{cases}\",\n        \"description\": \"Cases environment\"\n    },\n    \"align\": {\n        \"prefix\": \"align\",\n        \"body\": \"\\\\begin{aligned}\\n$0\\n\\\\end{aligned}\",\n        \"description\": \"Align environment\"\n    },\n    \"array\": {\n        \"prefix\": \"array\",\n        \"body\": \"\\\\begin{array}\\n$0\\n\\\\end{array}\",\n        \"description\": \"Array environment\"\n    },\n    \"avg\": {\n        \"prefix\": \"avg\",\n        \"body\": \"\\\\langle $0 \\\\rangle $1\",\n        \"description\": \"Angle brackets with placeholder\"\n    },\n    \"norm\": {\n        \"prefix\": \"norm\",\n        \"body\": \"\\\\lvert $0 \\\\rvert $1\",\n        \"description\": \"Single vertical bars with placeholder\"\n    },\n    \"Norm\": {\n        \"prefix\": \"Norm\",\n        \"body\": \"\\\\lVert $0 \\\\rVert $1\",\n        \"description\": \"Double vertical bars with placeholder\"\n    },\n    \"ceil\": {\n        \"prefix\": \"ceil\",\n        \"body\": \"\\\\lceil $0 \\\\rceil $1\",\n        \"description\": \"Ceiling brackets with placeholder\"\n    },\n    \"floor\": {\n        \"prefix\": \"floor\",\n        \"body\": \"\\\\lfloor $0 \\\\rfloor $1\",\n        \"description\": \"Floor brackets with placeholder\"\n    },\n    \"mod\": {\n        \"prefix\": \"mod\",\n        \"body\": \"|$0|$1\",\n        \"description\": \"Modulus with placeholder\"\n    },\n    \"lr(\": {\n        \"prefix\": \"lr(\",\n        \"body\": \"\\\\left( $0 \\\\right) $1\",\n        \"description\": \"Left-right parentheses with placeholder\"\n    },\n    \"lr{\": {\n        \"prefix\": \"lr{\",\n        \"body\": \"\\\\left\\\\{ $0 \\\\right\\\\} $1\",\n        \"description\": \"Left-right braces with placeholder\"\n    },\n    \"lr[\": {\n        \"prefix\": \"lr[\",\n        \"body\": \"\\\\left[ $0 \\\\right] $1\",\n        \"description\": \"Left-right brackets with placeholder\"\n    },\n    \"lr|\": {\n        \"prefix\": \"lr|\",\n        \"body\": \"\\\\left| $0 \\\\right| $1\",\n        \"description\": \"Left-right vertical bars with placeholder\"\n    },\n    \"lra\": {\n        \"prefix\": \"lra\",\n        \"body\": \"\\\\left&lt; $0 \\\\right&gt; $1\",\n        \"description\": \"Left-right angle brackets with placeholder\"\n    },\n    \"tayl\": {\n        \"prefix\": \"tayl\",\n        \"body\": \"${0:f}(${1:x} + ${2:h}) = ${0:f}(${1:x}) + ${0:f}'(${1:x})${2:h} + ${0:f}''(${1:x}) \\\\frac{${2:h}^{2}}{2!} + \\\\dots$3\",\n        \"description\": \"Taylor expansion with placeholders\"\n    },\n    \"iden3\": {\n        \"prefix\": \"iden3\",\n        \"body\": \"\\\\begin{pmatrix}\\n1 &amp; 0 &amp; 0 \\\\\\\\\\n0 &amp; 1 &amp; 0 \\\\\\\\\\n0 &amp; 0 &amp; 1\\n\\\\end{pmatrix}\",\n        \"description\": \"3x3 identity matrix\"\n    },\n    \"iden4\": {\n        \"prefix\": \"iden4\",\n        \"body\": \"\\\\begin{pmatrix}\\n1 &amp; 0 &amp; 0 &amp; 0 \\\\\\\\\\n0 &amp; 1 &amp; 0 &amp; 0 \\\\\\\\\\n0 &amp; 0 &amp; 1 &amp; 0 \\\\\\\\\\n0 &amp; 0 &amp; 0 &amp; 1\\n\\\\end{pmatrix}\",\n        \"description\": \"4x4 identity matrix\"\n    }\n}\n</code></pre>","path":["LaTeX(VScode)"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/Python/Python%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/","level":1,"title":"安装","text":"","path":["安装"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/Python/Python%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/#python","level":1,"title":"Python安装和配置","text":"<ul> <li>Python本体安装</li> <li>pip配置</li> <li>安装Pycharm</li> <li>VSC的Python环境配置</li> <li>Anaconda安装与配置</li> </ul>","path":["安装"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/Python/Python%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/#_2","level":2,"title":"本体安装","text":"<p>直接去官方网站下载，如果速度偏慢可以使用国内镜像</p> <p>测试安装成功方法：<code>win</code>+<code>R</code> type <code>cmd</code> 进入shell type python 若是返回版本则说明安装成功</p>","path":["安装"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/Python/Python%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/#pip","level":2,"title":"pip配置","text":"<p>换为国内镜像源(可以永久，在需要使用官方时再临时换源)</p> <pre><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n</code></pre> <p>检测换源成功与否</p> <pre><code>pip config list\n</code></pre> <p>应该会返回</p> <pre><code>global.index-url='https://pypi.tuna.tsinghua.edu.cn/simple'\n</code></pre>","path":["安装"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/Python/Python%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/#pycharm","level":2,"title":"安装Pycharm","text":"","path":["安装"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/Python/Python%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/#anaconda","level":2,"title":"安装Anaconda","text":"<p>可以参考博客园的这一教程</p> <p>先安装Anaconda或者Miniconda：官网链接 速度较慢可以使用清华源</p> <p>下载前可以先按时间排序选择最新的版本，不要下载一些很古老的版本</p> <p>下载安装过程中可以勾选一下Recommend的选项</p> <p>检验方式是在<code>Anaconda Powershell</code>中 type <code>conda --version</code></p> <p>因为新版Anaconda不建议你直接将Anaconda添加入PATH变量(出于自我保护的目的)，因此如果你想要添加到PATH可能需要自己设置</p> <p>在PATH中加入以下三条即可：</p> <pre><code>#文件路径取决于你的Anaconda安装在哪\nD:\\Anaconda\nD:\\Anaconda\\Scripts\nD:\\Anaconda\\Library\\bin\n</code></pre> <p>[!info] 验证效果 如果添加到PATH你可以直接在cmd或是终端中使用conda --version以及conda相关的命令，如果不添加你可以在Anaconda Powershell中使用，官方应该是不建议直接添加到PATH的，为了隔离环境和安全性的考虑笔者也不建议这么做，但是如果是新手可以考虑直接添加，日后删除即可。</p>","path":["安装"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/Python/Python%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/#_3","level":3,"title":"相关的命令","text":"<pre><code>#换源\n #添加源\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --set show_channel_urls yes\n#检验\nconda config --show\n\n#添加虚拟环境路径\nconda config --add envs_dirs *newdir*\n#注意除了查看.condarc文件中的envs_dirs参数外还需要对新的envs文件夹的权限进行设置\n#需要修改对象为All Users以及完全控制和写入权限\n\n#创建虚拟环境\nconda create -n *name* python=3.10\n#删除虚拟环境\nconda remove -n *name* --all\n#切换环境\nconda activate *name*\n#列出当前环境所有的包\nconda list\n#列出所有环境\nconda env list\n#安装Jupyter Notebook\n#可以直接使用Anaconda Navigator\n#或者使用命令行\nconda install ipykernel\n#注意：安装之后还需要进行注册内核\npython -m ipykernel install --user --name my_data_env --display-name \"My Data Analysis Environment\"\n#这么操作之后你才可以进行Select Kernel\n</code></pre>","path":["安装"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/Tools/Obsidian_Chain/","level":1,"title":"安装 #工作流","text":"","path":["安装 #工作流"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/Tools/Obsidian_Chain/#obsidian_chain","level":1,"title":"Obsidian_Chain","text":"","path":["安装 #工作流"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/Tools/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/","level":1,"title":"安装","text":"","path":["安装"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/Tools/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/#_2","level":1,"title":"图床搭建","text":"<p>[!info] 方案讲解 这里选择的是PicGo+GitHub的方案(返璞归真)</p> <p>主要的安装和配置步骤如下：</p> <ol> <li>先下载PicGo软件</li> <li>配置GitHub图床</li> </ol>","path":["安装"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/Tools/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/#picgo","level":2,"title":"下载PicGo软件","text":"<p>官方链接在这：链接</p> <p>可以使用腾讯云COS的这个链接下载：https://github.com/Molunerfinn/PicGo/releases</p>","path":["安装"],"tags":[]},{"location":"%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/Tools/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/#github","level":2,"title":"配置GitHub图床","text":"<p>配置的手法主要来自于官方的配置手册</p> <pre><code>{\n  \"repo\": \"\", // 仓库名，格式是username/reponame\n  \"token\": \"\", // github token\n  \"path\": \"\", // 自定义存储路径，比如img/\n  \"customUrl\": \"\", // 自定义域名，注意要加http://或者https://\n  \"branch\": \"\" // 分支名，默认是main\n}\n</code></pre> <p>[!tip] 使用什么平台？ 建议使用GitHub因为不需要为内存和安全付费，而且操作也比较简单</p> <p>[!warning] token 关于如何获取token在官方的配置手册中已经说的比较详细了，在此不再赘述，但是需要注意一定要对token文件进行备份，因为后续如果需要进行多设备配置仍然需要使用这一token(本人在台式机上配置图床上传工具时就遇到了这一问题)，但是没有备份也没有关系，只需要重新生成然后修改之前配置的token即可。</p> <p></p> <p>[!info] 注意 由于版本更新的比较快，只需要对于PicGo软件自身的一些设置进行选择就可以达到比较好的使用体验，所以在此删除其他复杂的配置 给出一些建议勾选的部分： + 开机自启 + 上传前重命名(如果你是一个对于命名法要求不高的“粗糙”的使用者，你可以只选择时间戳重命名) + 时间戳重命名 + 上传后自动复制URL</p>","path":["安装"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/","level":1,"title":"回归分析","text":"","path":["回归分析"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/#lecture","level":1,"title":"回归分析(Lecture)","text":"<p>[!tldr] 课程简介 所属大学：南开大学 主讲教师：刘民千(Liu Minqian) 先修要求：数学分析+高等代数+初等概率论+初等数理统计 课程难度：⭐⭐⭐ 预计学时：200h 给分情况：70%的期末+30%平时成绩 考试难度： 修读时间：Fall 25</p> <ul> <li>References<ul> <li>线性模型 王松桂</li> <li>Slides</li> </ul> </li> <li>Extensions<ul> <li>近代非线性回归分析 韦博成</li> <li>矩阵论 詹兴致</li> </ul> </li> </ul>","path":["回归分析"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/#_2","level":2,"title":"前言","text":"<p>笔者于大二暑假时在此写下这篇笔记(2025.8.4)</p> <p>出于对于本人纯粹统计学科基础的补充和对于即将到来的科研学习的准备，我希望能在暑假期间学习完王松桂先生(卒于2025.4.25)的回归分析一书，作为对于自己升上大三前的一个交代，也是对于老前辈的一个怀念(本书的撰写与立意都简洁深刻，不像其他书籍全是奇技淫巧或是满篇荒唐)，关于老先生的事迹可在北师大的这篇文章查询到， 在此不再赘述</p> <p>此书的篇幅短小，但内容精悍，读完可以说对于回归分析(书名线性统计模型)有一个初步的认知，笔记内容陈述如下</p>","path":["回归分析"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/#_3","level":2,"title":"章节内容","text":"<p>本笔记旨在记录笔者在暑假期间自学王松桂先生的回归分析一书所遇到的困难和心得体会，权且当作一本初学者的手册或是一些参考，由于笔者也是初学这一课程，所记述内容大概率有瑕疵，需要辩证看待。众所周知，习题是一本教材的重要组成部分，为了检验自己的学习成果，笔者也将把自己关于这本书的习题解答和相关思考记录在笔记中，以期掌握深刻，最后希望能汇总得到一份\\(\\LaTeX\\)版本的PDF笔记。</p> <p>以下是书中内容的一个小目录，根据目录来回顾内容是我喜欢的方法：</p> <ul> <li>前言<ul> <li>线性统计模型包含线性回归模型、方差分析模型等应用十分广泛的模型，并且线性模型的理论和方法也是学习和研究其他统计方法的基础，因此线性统计模型有其学习的价值</li> <li>Prequest：本书主要为需要学习线性统计模型基础知识的各专业学生提供一本教材，因此预备知识并不多，只需要掌握工科的微积分、线性代数、初等概率统计即可</li> <li>大致结构是前两章为预备性知识，后三四五章对线性回归模型的估计和检验做了系统讨论，第六章介绍方差分析模型，第七章则是给出几类在其他领域颇为有用的线性回归模型</li> </ul> </li> <li>引论<ul> <li>线性回归模型</li> <li>方差分析模型</li> <li>应用概述</li> </ul> </li> <li>随机向量<ul> <li>均值向量与协方差阵</li> <li>随机向量的二次型</li> <li>正态随机向量</li> <li>\\(\\chi^{2}\\)分布</li> </ul> </li> <li>回归参数的估计</li> <li>假设检验与预测</li> <li>回归方程的选择</li> <li>方差分析模型</li> <li>其它线性回归模型</li> </ul> <p>[[第一章-引论-王松桂]]</p> <p>[[第二章-随机向量-王松桂]]</p> <p>[[第三章-回归参数的估计-王松桂]]</p> <p>[[第四章-假设检验与预测-王松桂]]</p> <p>[[第五章-回归方程的选择-王松桂]]</p> <p>[[第六章-方差分析模型-王松桂]]</p> <p>[[第七章-含定性变量的回归模型-王松桂]]</p> <p>下面这一章内容不考</p> <p>[[第八章-非线性回归模型-王松桂]]</p>","path":["回归分析"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/#_4","level":2,"title":"作业部分","text":"<p>下面的题号基本是参考王松桂老师的书，然后部分参考老师讲义的部分可以在我的笔记中找到标注</p> <p>[!question] HW1 1.4、2.3、2.8、2.10、2.17</p> <p>[!question] HW2 3.2、3.3、3.6、3.7、3.8</p> <p>[!question] HW3 3.9、3.10、3.11、3.12</p> <p>[!question] HW4 HW4-1、3.13、3.14、3.18</p> <p>HW4-1</p> <p>设\\(X=\\left(\\begin{array}{c}x_1^{\\prime}\\\\\\vdots\\\\x_n^{\\prime}\\end{array}\\right).\\) 其中\\(\\boldsymbol{x}_{i}=(1,x_{i1},\\ldots,x_{i\\:p-1})^{\\prime}\\) 并记\\(h_{ii}=\\boldsymbol{x}_{i}^{\\prime}\\left(\\boldsymbol{X}^{\\prime}\\boldsymbol{X}\\right)^{-1}x_{i}\\) </p> <p>试利用分块矩阵的逆矩阵公式证明：</p> \\[h_{ii}=\\frac{1}{n}+(\\widetilde{\\boldsymbol{x}}_{i}-\\bar{\\boldsymbol{x}})'(\\boldsymbol{X}_{c}'\\boldsymbol{X}_{c})^{-1}(\\widetilde{\\boldsymbol{x}}_{i}-\\bar{\\boldsymbol{x}}),\\] <p>其中\\(\\left.\\widetilde{\\boldsymbol{x}}_{i}=(x_{i1},\\ldots,x_{i\\:p-1})^{\\prime},\\:\\bar{\\boldsymbol{x}}=(\\bar{x}_{1},\\ldots,\\bar{x}_{p-1})^{\\prime},\\boldsymbol{X}_{c}=\\left(\\begin{array}{cccc}{{x_{11}-\\bar{x}_{1}}}&amp;{\\ldots}&amp;{{x_{1\\:p-1}-\\bar{x}_{p-1}}}\\\\{\\ldots}&amp;{\\ldots}&amp;{\\ldots}\\\\{{x_{n1}-\\bar{x}_{1}}}&amp;{\\ldots}&amp;{{x_{n\\:p-1}-\\bar{x}_{p-1}}}\\end{array}\\right.\\right)\\)</p> <p><code>Proof.</code></p> <p>由题意可知：</p> \\[ X=\\begin{pmatrix} 1_{n \\times 1}  &amp; X_{0} \\end{pmatrix}\\implies(X'X)^{-1}= \\begin{pmatrix} n &amp; 1'X_{0} \\\\ X_{0}'1 &amp; X_{0}'X_{0} \\end{pmatrix}^{-1}=\\begin{pmatrix} n &amp; n \\overline{x}' \\\\ n \\overline{x} &amp; X_{0}'X_{0} \\end{pmatrix}^{-1} \\] <p>利用分块矩阵的逆矩阵公式(Schur)得到右下角逆为\\(X_{0}'X_{0}-n \\overline{x} \\ \\overline{x}'\\)，并且有：</p> \\[ X_{c}'X_{c}=(X_{0}-1 \\overline{x}')'(X_{0}-1 \\overline{x}')=X_{0}'X_{0}- n \\overline{x}\\ \\overline{x}' \\] <p>由此可知：</p> \\[ (X'X)^{-1}= \\begin{pmatrix}  \\frac{1}{n}+\\overline{x}'(X_{c}'X_{c})^{-1} \\overline{x} &amp; - \\overline{x}' (X_{c}'X_{c})^{-1} \\\\ -(X_{c}'X_{c})^{-1} \\overline{x} &amp; (X_{c}'X_{c})^{-1} \\end{pmatrix} \\] <p>再令\\(x_{i}=\\begin{pmatrix}1\\\\ \\widetilde{x_{i}}\\end{pmatrix}\\)，代入即得</p> \\[ \\begin{aligned} h_{ii}&amp;= x_{i}'(X'X)^{-1}x_{i}\\\\ &amp;=[ \\frac{1}{n}+\\overline{x}'(X_{c}'X_{c})^{-1} \\overline{x}]- \\overline{x}' (X_{c}'X_{c})^{-1}\\widetilde{x_{i}}-\\widetilde{x_{i}}'(X_{c}'X_{c})^{-1} \\overline{x}+\\widetilde{x_{i}}' (X'_{c}X_{c})^{-1}\\widetilde{x_{i}}\\\\ &amp;=\\frac{1}{n}+(\\widetilde{\\boldsymbol{x}}_{i}-\\bar{\\boldsymbol{x}})'(\\boldsymbol{X}_{c}'\\boldsymbol{X}_{c})^{-1}(\\widetilde{\\boldsymbol{x}}_{i}-\\bar{\\boldsymbol{x}}) \\end{aligned} \\] <p>[!question] HW5 4.1、4.4、4.6</p> <p>[!question] HW6 4.7、4.9</p> <p>[!question] HW7 5.2、定理5.1.4</p> <p>定理 5.1.4(Slides): 假设全模型正确, 证明: 当 \\(\\operatorname{Cov}(\\hat{\\boldsymbol{\\beta}}_{t}) \\geq \\beta_{t} \\boldsymbol{\\beta}_{t}^{\\prime}\\) 时, 有  </p> \\[ M S E P ( \\hat { y } _ { 0 } ) \\geq M S E P ( \\tilde { y } _ { 0 } ) . \\] <p>根据Slides上的记号，将\\(X,\\beta\\)分块表示：</p> \\[ X_{n\\times p}=\\begin{pmatrix} X_{q} &amp; X_{t} \\end{pmatrix},\\beta'=\\begin{pmatrix} \\beta_{q}' &amp; \\beta_{t}' \\end{pmatrix} \\] <p><code>Proof.</code></p> <p>先考虑全模型\\(MSEP(\\hat{y}_{0})\\)：</p> \\[ \\begin{aligned} \\tilde{y}_{0}&amp;=x_{0}'\\hat{\\beta},y_{0}=x_{0}'\\beta+\\varepsilon_{0}\\\\ \\tilde{e}&amp;=\\tilde{y}_{0}-y_{0}=x_{0}'(\\tilde{\\beta}-\\beta)-\\varepsilon_{0}\\\\ MSEP(\\hat{y}_{0})&amp;=\\operatorname{Var}(\\hat{e})\\\\ &amp;=\\operatorname{Var}(\\mathbf{x}_{0}'(\\hat{\\boldsymbol{\\beta}}-\\boldsymbol{\\beta})-\\varepsilon_{0})\\\\ &amp;=\\operatorname{Var}(\\mathbf{x}_{0}'\\hat{\\boldsymbol{\\beta}})+\\operatorname{Var}(\\varepsilon_{0})\\\\ &amp;=\\mathbf{x}_{0}'\\operatorname{Cov}(\\hat{\\boldsymbol{\\beta}})\\mathbf{x}_{0}+\\sigma^{2}\\\\ &amp;=\\sigma^{2}\\mathbf{x}_{0}'(X'X)^{-1}\\mathbf{x}_{0}+\\sigma^{2}\\\\ &amp;=\\sigma^{2}\\left( 1+ \\begin{pmatrix} \\mathbf{x}_{0q}'  &amp; \\mathbf{x}_{0t}'\\\\ \\end{pmatrix}\\begin{pmatrix} X_{q}'X_{q} &amp; X_{q}'X_{t} \\\\ X_{t}'X_{q} &amp; X_{t}'X_{t} \\end{pmatrix}^{-1} \\begin{pmatrix} \\mathbf{x}_{0q} \\\\ \\mathbf{x}_{0t} \\end{pmatrix} \\right) \\end{aligned} \\] <p>再考虑选模型\\(MSEP(\\tilde{y}_{0})\\)：</p> \\[ \\begin{aligned} \\tilde{y}_{0} - y_{0} &amp;= (\\tilde{y}_{0} - E[\\tilde{y}_{0}]) + (E[\\tilde{y}_{0}] - E[y_{0}]) + (E[y_{0}] - y_{0}) \\\\ &amp;= (\\tilde{y}_{0} - E[\\tilde{y}_{0}]) + (E[\\tilde{y}_{0}] - \\eta_{0}) - (y_{0} - \\eta_{0}) \\\\ &amp;= (\\tilde{y}_{0} - E[\\tilde{y}_{0}]) + \\operatorname{Bias}(\\tilde{y}_{0}) - \\varepsilon_{0} \\end{aligned} \\] \\[ \\begin{aligned} MSEP(\\tilde{y}_{0})&amp;=E[\\tilde{y}_{0}-y_{0}]^{2}\\\\ &amp;=Var(\\tilde{y}_{0})+\\sigma^{2}+(Bias(\\tilde{y}_{0}))^{2} \\end{aligned} \\] \\[ \\begin{aligned} MSEP(\\hat{y}_{0})-MSEP(\\tilde{y}_{0})&amp;=x_{0}'Cov(\\hat{\\beta})x_{0}+\\sigma^{2}-\\sigma^{2}-Var(\\tilde{y}_{0})-(Bias(\\tilde{y}_{0}))^{2}\\\\ &amp;=[\\sigma^{2}x_{0}'(X'X)^{-1}x_{0}]-\\sigma^{2}x_{0q}'(X_{q}'X_{q})^{-1}x_{0q}-\\beta_{t}'cc'\\beta_{t}\\\\ c'&amp;=x_{0q}'(X'_{q}X_{q})^{-1}X_{q}'X_{t}-x_{0t}' \\end{aligned} \\] <p>不妨令</p> \\[ (X'X)^{-1}= \\begin{pmatrix} C_{qq} &amp; C_{qt} \\\\ C_{tq} &amp; C_{tt} \\end{pmatrix} \\] <p>那么我们可以得到</p> \\[ \\begin{aligned} x_{0}'(X'X)^{-1}x_{0}&amp;=\\begin{pmatrix} x_{0q}' &amp; x_{0t}' \\end{pmatrix} \\begin{pmatrix} C_{qq} &amp; C_{qt} \\\\ C_{tq} &amp; C_{tt} \\end{pmatrix}\\begin{pmatrix} x_{0q} \\\\ x_{0t} \\end{pmatrix}\\\\&amp;=x'_{0q}C_{qq}x_{0q}+x'_{0q}C_{qt}x_{0t}+x'_{0t}C_{tq}x_{0q}+x'_{0t}C_{tt}x_{0t} \\end{aligned} \\] <p>代入即可得到：</p> \\[ \\begin{aligned} MSEP(\\hat{y}_{0})-MSEP(\\tilde{y}_{0})&amp;=c'Cov(\\hat{\\beta}_{t})c-\\beta'_{t}cc'\\beta_{t}\\\\ &amp;=c'(Cov(\\hat{\\beta}_{t})-\\beta_{t}\\beta_{t}')c\\\\ &amp;\\geqslant 0 \\end{aligned} \\] <p>[!question] HW8 5.1</p> <p>[!question] HW9 HW9-1、6.3</p> <p>[!question] HW10 Contents</p> <p>[!question] HW11 Contents</p>","path":["回归分析"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/#_5","level":2,"title":"往年试卷","text":"","path":["回归分析"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/#_6","level":2,"title":"附注","text":"<p>为了完整起见，我将完成本书所有习题并发布相应的解答在博客上，其他平台暂未有计划</p>","path":["回归分析"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA-%E7%8E%8B%E6%9D%BE%E6%A1%82/","level":1,"title":"第一章 引论","text":"<p>[!info] 动机 许多量有线性关系，非线性关系可以进行变换得到线性关系，线性关系是数学中最基本的关系，容易处理，本章通过给出一些实例引入线性统计模型，由此使读者对于背景有一定的认识，对于后面的统计概念和方法的理解大有裨益。</p> <ul> <li>线性回归模型</li> <li>方差分析模型</li> <li>应用概述</li> <li>习题1</li> </ul>","path":["第一章 引论"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA-%E7%8E%8B%E6%9D%BE%E6%A1%82/#_2","level":2,"title":"线性回归模型","text":"","path":["第一章 引论"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA-%E7%8E%8B%E6%9D%BE%E6%A1%82/#_3","level":3,"title":"引入","text":"<p>对于简单的二元关系进行分解，对相关关系建立线性回归模型，将因变量(响应变量)与自变量(预报变量)的关系建模如下：</p> \\[ Y=f(X)+e \\] <p>主要由两部分组成，其中的\\(e\\)表示未考虑的部分，看作是随机误差(有理由要求其均值为0 -&gt; \\(E(e)=0\\))</p> <p>若\\(f(X)\\)是线性函数，那么很自然的会得到一个接近直线方程的模型，由此下式称为线性回归模型或线性回归方程：</p> \\[ Y=\\beta_{0}+\\beta_{1}X+e \\] <p>Remark: 关于回归(Regression)的含义在后面再进行介绍</p> <p>如果假定满足这种关系，应用适当的统计方法即可估计出\\(\\hat{\\beta_{0}},\\hat{\\beta_{1}}\\)，代入即可得到经验回归直线，也称作经验回归方程，经验表示这个回归直线是基于观测数据获得的，在许多文献中，人们则将经验两字省略掉，经过适当的统计检验后，我们可以认为\\(Y=\\hat{\\beta_{0}}+ \\hat{\\beta_{1}}X\\)描述了两个变量的相关关系。</p>","path":["第一章 引论"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA-%E7%8E%8B%E6%9D%BE%E6%A1%82/#_4","level":3,"title":"多元线性回归模型","text":"<p>假设有如下关系：</p> \\[ Y=\\beta_{0}+\\beta_{1}X_{1}+\\dots+\\beta_{p-1}X_{p-1}+e \\] <p>其中\\(\\beta_{0}\\)为常数项，\\(\\beta_{1},\\dots,\\beta_{p-1}\\)为回归系数，\\(e\\)为随机误差</p> <p>对\\(Y\\)中的每一个\\(y_{i}\\)进行分析即可得到：\\(y_{i}=\\beta_{0}+x_{i 1}\\beta_{1}+\\dots+x_{i,p-1}\\beta_{p-1}+e_{i}\\)</p> <p>引入矩阵记号：</p> \\[ y=\\begin{bmatrix} y_{1} \\\\ y_{2} \\\\ \\dots \\\\ y_{n}  \\end{bmatrix},X=\\begin{bmatrix} 1 &amp; x_{11}\\dots &amp; x_{1,p-1} \\\\ 1 &amp; x_{21}\\dots &amp; x_{2,p-1} \\\\ \\dots &amp; \\dots &amp; \\dots \\\\ 1 &amp; x_{n1}\\dots &amp; x_{n,p-1} \\end{bmatrix},\\beta= \\begin{bmatrix} \\beta_{0} \\\\ \\beta_{1} \\\\ \\dots \\\\ \\beta_{p-1} \\end{bmatrix},e=\\begin{bmatrix} e_{1} \\\\ e_{2} \\\\ \\dots \\\\ e_{n} \\end{bmatrix} \\] <p>可以整合为</p> \\[ y=X\\beta+e \\] <p>其中\\(y\\)为观测向量，\\(X\\)为设计矩阵，\\(\\beta\\)为未知参数向量，\\(e\\)为随机误差向量</p> <p>[!info] 常用基本假设(Gauss-Markov假设) 1. 误差项均值为0，即\\(E(e_{i})=0,i=1,\\dots,n\\) 2. 误差项具有等方差，即\\(Var(e_{i})=\\sigma^{2},i=1,\\dots,n\\) 3. 误差是彼此不相关的，即\\(Cov(e_{i},e_{j})=0,i\\neq j , i,j=1,\\dots ,n\\)</p> <p>[!Example] Cobb-Douglas Function 取对数即可，\\(Q_{t},L_{t},K_{t}\\)为\\(t\\)年的产值、劳力投入量和资金投入量</p> \\[Q_{t} = aL_{t}^{b}K_{t}^{c}\\]","path":["第一章 引论"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA-%E7%8E%8B%E6%9D%BE%E6%A1%82/#_5","level":2,"title":"方差分析模型","text":"<p>与上节的线性回归模型不同，方差分析模型涉及的自变量不再是连续变量，而是示性变量，因为我们研究的基本目的则是寻求因变量与自变量之间客观存在的依赖关系，所以我们试图以示性变量取值表示因素效应的存在性。</p> <p>这种比较因素效应的统计分析又称为方差分析</p>","path":["第一章 引论"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA-%E7%8E%8B%E6%9D%BE%E6%A1%82/#_6","level":2,"title":"应用概述","text":"<ul> <li>描述变量之间的关系</li> <li>分析变量之间的相互关系</li> <li>预测<ul> <li>点预测</li> <li>区间预测</li> </ul> </li> </ul>","path":["第一章 引论"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA-%E7%8E%8B%E6%9D%BE%E6%A1%82/#_7","level":2,"title":"习题","text":"<p>[!tip] 注意 本部分的习题不难，主要以巩固概念掌握为主，熟练使用变换手段将所给出的函数变换为线性回归模型，熟练掌握Gauss-Markov假设下的随机误差</p> <p>[!question] 1.1 假设一个物体长度为\\(\\mu\\)，但\\(\\mu\\)是未知的。我们做\\(N\\)次测量，于是测量值\\(y_{1}​,…,y_{N}\\)​。如果测量过程没有系统误差，我们可以认为\\(y_1​,…,y_N\\)​ 为来自正态总体\\(N(\\mu,\\sigma^{2})\\)的一组随机样本。试将这些观测数据表成线性模型的形式。</p> <p><code>Sol.</code></p> <p>沿用Gauss-Markov假设</p> \\[ \\begin{aligned} y_{i}&amp;=\\mu+e_{i},i=1,2,\\dots,n\\\\ \\varepsilon_{i}&amp;\\sim N(0,\\sigma^{2}),i=1,2,\\dots,n \\end{aligned} \\] <p>[!question] 1.2 某公司采用一项新技术试验以提高产品质量。设在试验前，随机抽取的\\(n_1\\)件产品的质量指标值为\\(y_1,...,y_{n_1}\\)，它们可以看成来自正态总体\\(N(\\mu_1,\\sigma^2)\\)的一组随机样本。而在试验之后，随机抽取的\\(n_2\\)件产品的质量指标值为\\(z_1,...,z_{n_2}\\)，它们可以看成来自正态总体\\(N(\\mu_2,\\sigma^2)\\)的一组随机样本。为了考察这项新技术的效果，需要比较\\(\\mu_1\\)和\\(\\mu_2\\)。因此需要先估计它们。</p> <p>(1) 试将这些数据表成线性模型的形式。 (2) 在实际问题中，如果\\(z_1,...,z_{n_2}\\)的值相比\\(y_1,...,y_{n_1}\\)有很大不同，往往它们的变异程度也就不同。于是我们不能再假定这两个正态总体有公共的方差。这时认为它们分别来自正态总体\\(N(\\mu_1,\\sigma_1^2)\\)和\\(N(\\mu_2,\\sigma_2^2)\\)比较适宜。试问这时(1)中所表示的线性模型应该有怎样的修正?</p> <p><code>Sol.</code></p> <p>(1)(2)</p> <p>为了方便起见直接给出(2)，(1)只需要令\\(\\sigma_{1}=\\sigma_{2}\\)</p> \\[ \\begin{pmatrix} Y \\\\ Z \\end{pmatrix}= \\begin{pmatrix} 1 &amp; 0 \\\\ \\dots \\\\ 1 &amp; 0 \\\\ 0 &amp; 1 \\\\ \\dots\\\\ 0 &amp; 1 \\end{pmatrix} \\begin{pmatrix} \\mu_{1} \\\\ \\mu_{2}  \\end{pmatrix}+\\begin{pmatrix} e_{11} \\\\ \\dots \\\\ e_{1n_{1}} \\\\ e_{21} \\\\ \\dots \\\\ e_{2n_{2}} \\end{pmatrix} \\] <p>\\(e_{1i}\\sim N(0,\\sigma_{1}^{2}),e_{2j}\\sim N(0,\\sigma_{2}^{2})\\)</p> <p>[!question] 1.3 用两台仪器测量同一批材料的各 3 件样品的某种成分的含量。记测量值分别为\\(y_{11},y_{12},y_{13}\\)和\\(y_{21},y_{22},y_{23}\\)，由于两台仪器可能存在着性能上的差异，在表示这些数据时需要考虑仪器的效应，记之为\\(a_1\\)和\\(a_2\\)，试将这些测量数据表成成分含量\\(\\mu\\)和\\(a_1,a_2\\)的线性模型。</p> <p><code>Sol.</code></p> <p>方差分析模型：</p> \\[ Y= \\begin{pmatrix} 1 &amp; 1  &amp; 0\\\\ \\dots \\\\ 1 &amp;1 &amp;  0 \\\\ 1 &amp; 0 &amp; 1 \\\\ \\dots\\\\  1 &amp; 0 &amp; 1\\\\ \\end{pmatrix} \\begin{pmatrix} \\\\ \\mu\\\\ a_{1} \\\\ a_{2}  \\end{pmatrix}+\\begin{pmatrix} e_{11} \\\\ \\dots \\\\ e_{13} \\\\ e_{21} \\\\ \\dots \\\\ e_{23} \\end{pmatrix} \\] <p>根据Gauss-Markov假设，可以认为\\(e_{ij}\\sim N(0,\\sigma^{2})\\)</p> <p>[!question] 1.4 下面的模型是否表示一般线性模型? 如果不是，能否通过适当的变换使之成为线性模型? </p> <p>(1) \\(y_i = \\beta_0 + \\beta_1 x_i + \\beta_2 x_i^2 + \\beta_3 \\ln x_i^2 + e_i\\) (2) \\(y_i = e^{\\beta_0 + \\beta_1 x_i} e^{\\beta_2 x_i^2}\\) (3) \\(y_i = [1 + \\exp(\\beta_0 + \\beta_1 x_i + e_i)]^{-\\frac{1}{2}}\\) (4) \\(y_i = \\beta_0 + \\beta_1(x_{i1} + x_{i2}) + \\beta_2 e^{x_{i1}+x_{i 2}} + \\beta_3 \\ln(x_{i1}^2) + e_i\\) </p> <p><code>Sol.</code></p> <p>(1) 令\\(x_{i}=x_{i_{1}},x_{i}^{2}=x_{i2},\\ln x_{i}^{2}=x_{i3}\\)</p> <p>(2)</p> <p>令\\(Y_{i}=\\ln y_{i}\\)，即可得到：</p> \\[ Y_{i}=\\beta_{0}+ \\beta_{1}x_{i}+\\beta_{2}x_{i}^{2} \\] <p>按照例子变换即可</p> <p>(3)</p> \\[ \\ln\\left(  \\frac{1}{y_{i}^{2}}-1 \\right)=\\beta_{0}+\\beta_{1}x_{i}+e_{i} \\] <p>令\\(Y_{i}=\\ln\\left( \\frac{1}{y_{i}^{2}}-1 \\right)\\)即可</p> <p>(4)</p> <p>令\\(X_{i 1}=x_{i 1}+x_{i 2},X_{i 2}= e^{x_{i 1}+ x_{i 2}},X_{i 3}=\\ln(x_{i 1}^{2})\\)即可</p> <p>[!question] 1.5 考虑如下两因素设计模型：</p> \\[y_{ij}=\\mu+\\alpha_{i}+\\beta_{j}+e_{ij},i=1,\\dots,I,j=1,\\dots,J\\] <p>其中\\(\\mu,\\alpha_{i},\\beta_{j}\\)为未知参数，试将其表示为矩阵形式的线性模型\\(y=X\\beta+e\\)，并写出其设计矩阵\\(X\\)</p> <p><code>Sol.</code></p> \\[ \\begin{pmatrix} y_{11} \\\\ \\dots \\\\ y_{1 J} \\\\ y_{2 1} \\\\ \\dots \\\\ \\dots \\\\ y_{IJ} \\end{pmatrix}=\\begin{pmatrix} 1 &amp; 1 &amp; 0 &amp; \\dots  &amp; 0&amp; 1 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\\\ 1 &amp; 1 &amp; 0 &amp; \\dots  &amp; 0&amp; 0 &amp; 1 &amp; 0 &amp; \\dots  &amp; 0 \\\\ \\dots \\\\ \\dots \\\\ 1 &amp; 0 &amp; \\dots &amp;   &amp; 1&amp;0  &amp; 0 &amp; \\dots &amp; 1 \\end{pmatrix}\\begin{pmatrix} \\mu \\\\ a_{1} \\\\ \\dots \\\\ a_{I} \\\\ \\beta_{1} \\\\ \\dots \\\\ \\beta_{J} \\end{pmatrix}+\\begin{pmatrix} e_{11} \\\\ \\dots \\\\ e_{1J} \\\\ \\dots \\\\ e_{I1} \\\\ \\dots \\\\ e_{IJ} \\end{pmatrix} \\]","path":["第一章 引论"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/","level":1,"title":"数理统计(Lecture)","text":"<p>[!tldr] 课程简介 所属大学：南开大学 主讲教师：周永道(Yongdao Zhou) 先修要求：数学分析+高等代数+初等概率论 课程难度：⭐⭐⭐⭐ 预计学时：250h 给分情况：⭐⭐⭐⭐⭐ 考试难度：⭐⭐⭐⭐ 修读时间：Spring 25</p> <ul> <li>课程质量<ul> <li>大多是copy的茆诗松</li> <li>建议自学</li> <li>助教很能捞</li> </ul> </li> <li>参考书目<ul> <li>数理统计教程 王兆军 邹长亮</li> <li>数理统计 101计划 王兆军 邹长亮 周永道 冯龙</li> <li>概率论与数理统计 茆诗松</li> <li>数理统计 邵军</li> <li>数理统计 陈希孺</li> </ul> </li> <li>推荐资源<ul> <li>USTC的B站网课</li> </ul> </li> </ul> <p>准备做一个整合笔记和tex讲义(with 茆)</p>","path":["数理统计(Lecture)"],"tags":["统计学"]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/#_1","level":2,"title":"基本概念","text":"","path":["数理统计(Lecture)"],"tags":["统计学"]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/#_2","level":2,"title":"点估计","text":"","path":["数理统计(Lecture)"],"tags":["统计学"]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/#_3","level":2,"title":"点估计","text":"","path":["数理统计(Lecture)"],"tags":["统计学"]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/#_4","level":2,"title":"作业部分","text":"<p>由于老师留下的作业题大多出自茆诗松老师的《概率论与数理统计》和王兆军老师的《数理统计教程》，而且两本书都已经有了比较完整的答案，虽然答案的质量仍然有待提高，但是总体上还是可供参考的，故如果是直接引用的茆和王书上的习题就不再赘述(经典问题还是会摘录出来以供复习，作业题号会保留以供参考).</p> <p>总的来说留下的作业质量还是稍微高一些的，其中有一些比较经典的问题也会专门摘录出来整理成markdown文档和LaTeX笔记的形式发布.</p>","path":["数理统计(Lecture)"],"tags":["统计学"]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/#_5","level":2,"title":"往期试卷","text":"<ul> <li>25数理统计期中</li> </ul>","path":["数理统计(Lecture)"],"tags":["统计学"]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/#_6","level":2,"title":"祖师爷归位","text":"","path":["数理统计(Lecture)"],"tags":["统计学"]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/25%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E6%9C%9F%E4%B8%AD/","level":1,"title":"25数理统计期中","text":"<p>PDF</p> <p>因为基本是书本上的课后习题和考研题就不写解答了(第六题可以参考韦博成的高等数理统计)</p> <p>[!question] 1(15分) 已知\\(X_{1},X_{2},\\dots ,X_{n}\\overset{IID}{\\sim}B(1,p)\\)，设其中\\(0&lt;p&lt;1\\)，\\(\\theta=p^{2}\\) (1) 试求\\(\\theta\\)的无偏估计的C-R下界 (2) 试求\\(\\theta\\)的极大似然估计\\(\\hat\\theta_{ML}\\) (3) 试证明\\(E(\\hat{\\theta}_{ML})\\neq\\theta\\)，问\\(\\hat{\\theta}_{ML}\\)是向上偏还是向下偏</p> <p>[!question] 2(15分) 设总体\\(X\\sim N(\\mu_{1},\\sigma_{1}^{2}),Y\\sim N(\\mu_{2},\\sigma_{2}^{2})\\)中分别抽取容量为\\(n_{1}=10,n_{2}=15\\)的独立样本，可计算得\\(\\overline{x}=82,s_{x}^{2}=56.5,\\overline{y}=76,s_{y}^{2}=52.4\\)</p> <p>(1)若已知\\(\\sigma_{1}^{2}=64,\\sigma_{2}^{2}=49\\)，求\\(\\mu_{1}-\\mu_{2}\\)的置信水平为95%的置信区间 (2)若已知\\(\\sigma_{1}^{2}=\\sigma_{2}^{2}\\)，求\\(\\mu_{1}-\\mu_{2}\\)的置信水平为95%的置信区间 (3)若对\\(\\sigma_{1}^{2},\\sigma_{2}^{2}\\)一无所知，求\\(\\mu_{1}-\\mu_{2}\\)的置信水平为95%的近似置信区间 (4)求\\(\\frac{\\sigma_{1}^{2}}{\\sigma_{2}^{2}}\\)置信水平为95%的置信区间</p> <p>[!question] 3(15分) 在买面包作早点的男女消费者中，男性购买者的比例\\(p\\)未知，但知道\\(\\frac{1}{3}\\leqslant p\\leqslant  \\frac{1}{2}\\)，设在70个购买者中发现12个是男性，58个是女性，试求\\(p\\)的MLE.如果对\\(p\\)没有限制，试求\\(p\\)的MLE</p> <p>[!question] 4(15分) 已知\\(X_{1},X_{2},\\dots,X_{n}\\overset{IID}{\\sim}N(\\mu,\\sigma^{2})\\)，其中\\(\\mu\\in R\\)为未知参数，\\(\\sigma^{2}&gt;0\\)为已知参数 (1) 试求\\(\\mu^{3},\\mu^{4}\\)的UMVUE (2)试求概率\\(P(X_{1}\\leqslant t)\\)和\\(\\frac{\\partial}{\\partial t}P(X_{1}\\leqslant t)\\)的UMVUE，其中\\(t\\in R\\)为给定常数</p> <p>[!question] 5(15分) 设随机样本\\(X_{1},X_{2},\\dots,X_{n}\\)来自分布\\(f(x,\\theta)=\\theta^{2}x\\exp(-\\theta x),x&gt;0,\\theta&gt;0\\) (1) 试证明\\(T=\\sum\\limits_{i=1}^{n}X_{i}\\)为\\(\\theta\\)的充分完备统计量 (2) 试求\\(E\\left( \\frac{1}{T} \\right)\\)</p> <p>[!question] 6(15分) 设\\(X_{1},X_{2},\\dots,X_{m}\\overset{IID}{\\sim}N(\\theta,\\sigma^{2})\\)，我们需求出\\(\\theta^{2}\\)的估计，下面提供三种不同的估计序列：</p> \\[ \\begin{aligned} \\delta_{1,n}&amp;=\\overline{X}^{2}- \\frac{\\sigma^{2}}{n},\\sigma^{2} \\text{已知}\\\\ \\delta_{2,n}&amp;=\\overline{X}^{2}- \\frac{s^{2}}{n(n-1)},\\sigma^{2} \\text{未知}\\\\ \\delta_{3,n}&amp;=\\overline{X}^{2},\\sigma^{2} \\text{已知或未知} \\end{aligned} \\] <p>(1) 试给出\\(\\delta_{i,n}\\)的渐进分布 (2) 试证明\\(\\delta_{1.n}\\)和\\(\\delta_{2,n}\\)是渐进无偏的，而\\(\\delta_{3,n}\\)是渐进有偏的.</p> <p>[!question] 7(10分) 设\\(X_{1},X_{2},\\dots,X_{n}\\overset{IID}{\\sim}F(x)\\)，对于固定的\\(x\\in R\\)，试求总体分布\\(F(x)\\)的置信水平近似为\\(1-\\alpha\\)的大样本置信区间</p>","path":["25数理统计期中"],"tags":["Exams"]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/","level":1,"title":"假设检验——显著性检验","text":"<p>首先先对假设检验进行一个简单的阐述，假设检验(hypothesis testing)最早由K.Pearson于1900年提出，之后由Fisher进行细化发展，最终由Neyman，E.Pearson发展成熟，后又由A.Wald发展为统计决策理论.</p> <p>参数假设检验主要包含：显著性检验(significance test)和最大功效检验(most powerful test)两部分，本章介绍的就是显著性检验，下一章介绍最大功效检验</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#_2","level":2,"title":"基本概念","text":"<p>主要是对下面的概念有一个认识：</p> <ul> <li>显著性检验</li> <li>根据样本推断正确与否的命题称为假设或统计假设</li> <li>零假设，备择假设</li> <li>简单假设，复杂假设(根据假设的参数空间决定)</li> <li>第一类错误，第二类错误(拒真，纳伪)</li> <li>拒绝域，接收域</li> <li>势函数，功效函数</li> </ul> <p>关于势函数的定义如下：</p> \\[ \\beta_{\\psi}(\\theta)=P_{\\theta}(X\\in W),\\forall\\theta\\in\\Theta \\] <p>根据一类错误和二类错误的定义可以知道：</p> <p>\\(\\theta\\in\\Theta_{0}\\)时有犯一类错误的概率为\\(\\beta_{\\psi}(\\theta)\\)，那么由于拒绝域是拒绝原假设的，那么对于\\(\\theta\\in\\Theta_{1}\\)的情况就有犯二类错误的概率为\\(1-\\beta_{\\psi}(\\theta)\\)</p> <p>注：关于拒绝域的部分有一个思想，类似数学中证明命题，一个例子的成立不能说明整个命题成立，但是否定一个命题只需要举出一个反例，所以在假设检验问题中我们通常关心拒绝域的情况.</p> <p>并且无法使得一类错误和二类错误都尽可能小，这就提出了一个要求：应该首先控制哪一种错误，根据Neyman提出的原则，我们优先控制第一类错误，使得犯第一类错误的概率不大于\\(\\alpha\\)，也就是显著性水平的定义</p> <p>[!NOTE] 定义 显著性水平 对于检验\\(\\psi\\)和事先给定的\\(\\alpha\\in(0,1)\\)，若是满足\\(P_{\\theta}\\left\\{ X\\in W \\right\\}\\leqslant \\alpha,\\forall\\theta\\in\\Theta_{0}\\)，则称\\(\\alpha\\)为检验\\(\\psi\\)的显著性水平，也称\\(\\psi\\)为显著性水平为\\(\\alpha\\)的检验</p> <p>我们称只控制检验犯一类错误的概率的检验为显著性检验，那么如何求假设的显著性检验呢，这里先给出基本步骤</p> <p>一般而言，求取某假设的显著性检验的步骤为：</p> <ol> <li>根据实际问题建立假设，\\(H_{0}\\longleftrightarrow H_{1}\\)</li> <li>选取合适的统计量\\(T(X)\\)，使当\\(H_{0}\\)成立时，\\(T(X)\\)的分布已知，并且与参数\\(\\theta\\)无关，称该分布为\\(T\\)的零分布</li> <li>根据\\(H_{0},H_{1}\\)的特点，确定拒绝域的区间形式</li> <li>对于给定的显著性水平，确定拒绝域\\(W\\)</li> <li>根据样本观测值\\(x\\)，计算统计量\\(T(x)\\)的值，根据\\(T(x)\\)是否属于\\(W\\)，做出判断</li> </ol>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#_3","level":2,"title":"单样本正态总体参数的显著性检验","text":"<p>始终假设\\(X_{1},X_{2},\\dots,X_{n}\\)为来自正态总体\\(N(\\mu,\\sigma^{2})\\)的\\(IID\\)样本</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#_4","level":3,"title":"单样本正态总体均值的检验","text":"<p>下面是对所有感兴趣的可能情况的一个汇总：</p> \\[ \\begin{aligned} H_{0}:\\mu=\\mu_{0}\\longleftrightarrow H_{1}:\\mu\\neq \\mu_{0}\\\\ H_{0}:\\mu=\\mu_{0}\\longleftrightarrow H_{1}:\\mu&lt; \\mu_{0}\\\\ H_{0}:\\mu=\\mu_{0}\\longleftrightarrow H_{1}:\\mu&gt;\\mu_{0}\\\\ H_{0}:\\mu \\leqslant\\mu_{0}\\longleftrightarrow H_{1}:\\mu&gt;\\mu_{0}\\\\ H_{0}:\\mu \\geqslant\\mu_{0}\\longleftrightarrow H_{1}:\\mu&lt; \\mu_{0} \\end{aligned} \\] <p>注意\\(\\mu_{0}\\)是已知的常数，上述假设有单侧、双侧的，简单、复杂的，\\(\\sigma^{2}\\)的已知与否也会对问题有影响，主要体现在统计量零分布的确定上，因此分类讨论\\(\\sigma^{2}\\)是否已知</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#sigma2sigma_02","level":4,"title":"\\(\\sigma^{2}=\\sigma_{0}^{2}\\)已知","text":"<p>由于感兴趣的是总体均值\\(\\mu\\)，挑选样本均值\\(\\overline{X}\\)构造相关的统计量(良好的点估计)，并且当上述第一个命题的原假设成立时有\\(\\mu=\\mu_{0}\\)，考虑利用\\(\\lvert \\overline{X}-\\mu_{0} \\rvert\\)的值做一个检验，符合直觉的是，只有当偏离一定程度时才认为原假设不成立，也就是\\(\\lvert \\overline{X}-\\mu_{0} \\rvert&gt;c\\)时，有理由拒绝原假设\\(H_{0}\\)认为\\(H_{1}\\)成立</p> <p>下面这个统计量也称为\\(U\\)统计量，检验也叫做\\(U\\)检验：</p> \\[ U(X)= \\frac{\\sqrt{ n }(\\overline{X}-\\mu_{0})}{\\sigma_{0}} \\] <p>根据上面的分析认为拒绝域为\\(W=\\left\\{ x:\\lvert U(x) \\rvert&gt;c \\right\\}\\)，由于是双侧检验加上绝对值，常数\\(c\\)需要根据显著性水平确认，当\\(H_{0}\\)成立的时候有\\(U(X)\\sim N(0,1)\\)，那么可以取\\(c=u_{\\frac{\\alpha}{2}}\\)</p> <p>对于单侧的情况类比可知：\\(c=u_{\\alpha}\\)</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#sigma2","level":4,"title":"\\(\\sigma^{2}\\)未知","text":"<p>由于\\(\\sigma^{2}\\)未知考虑利用\\(S^{2}\\)替代，这就想到了使用\\(t\\)分布</p> <p>构造\\(T\\)统计量\\(T(X)= \\frac{\\sqrt{ n }(\\overline{X}-\\mu_{0})}{S_{n}}\\sim t(n-1)\\)，采用它作为检验统计量，检验称为\\(t\\)检验</p> <p>对于双侧情况容易得到拒绝域应该是\\(\\left\\{ x:\\lvert T(x) \\rvert&gt;t_{\\frac{\\alpha}{2}}(n-1) \\right\\}\\)，单侧情况也是同理的</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#_5","level":4,"title":"总结","text":"<p>对于这种分类明显的问题，一表足矣</p> <p></p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#_6","level":3,"title":"单样本正态总体方差的检验","text":"<p>仍然是仿照之前的列出所有情况</p> \\[ \\begin{aligned} H_{0}:\\sigma^{2}=\\sigma^{2}_{0}\\longleftrightarrow H_{1}:\\sigma^{2}\\neq \\sigma^{2}_{0}\\\\ H_{0}:\\sigma^{2}=\\sigma^{2}_{0}\\longleftrightarrow H_{1}:\\sigma^{2}&lt; \\sigma^{2}_{0}\\\\ H_{0}:\\sigma^{2}=\\sigma^{2}_{0}\\longleftrightarrow H_{1}:\\sigma^{2}&gt;\\sigma^{2}_{0}\\\\ H_{0}:\\sigma^{2}\\leqslant\\sigma^{2}_{0}\\longleftrightarrow H_{1}:\\sigma^{2}&gt;\\sigma^{2}_{0}\\\\ H_{0}:\\sigma^{2}\\geqslant\\sigma^{2}_{0}\\longleftrightarrow H_{1}:\\sigma^{2}&lt; \\sigma^{2}_{0} \\end{aligned} \\]","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#mumu_0","level":4,"title":"\\(\\mu=\\mu_{0}\\)已知","text":"<p>利用\\(\\dfrac{\\sum\\limits_{i=1}^{n}(X_{i}-\\mu_{0})^{2}}{n}\\)作为一个\\(\\sigma_{0}^{2}\\)的点估计，当\\(H_{0}\\)成立时，\\(\\dfrac{\\sum\\limits_{i=1}^{n}(X_{i}-\\mu_{0})^{2}}{\\sigma^{2}}\\sim \\chi^{2}(n)\\)，选取检验统计量为\\(\\chi^{2}=\\dfrac{\\sum\\limits_{i=1}^{n}(X_{i}-\\mu_{0})^{2}}{\\sigma_{0}^{2}}\\)，在这种情况下拒绝域为\\(W=\\left\\{ \\chi^{2}&lt;c_{1} \\right\\}\\bigcup \\left\\{ \\chi^{2}&gt;c_{2} \\right\\}\\)，其中有\\(c_{1}&lt;c_{2}\\)，并且根据显著性水平应有\\(P_{H_{0}}\\left\\{ \\chi^{2}&lt;c_{1} \\right\\}+P_{H_{0}}\\left\\{ \\chi^{2}&gt;c_{2} \\right\\}\\leqslant \\alpha\\)</p> <p>常用的取法是左右拒绝概率各一半显著性水平，也就是\\(c_{1}=\\chi^{2}_{1-\\frac{\\alpha}{2}}(n),c_{2}=\\chi^{2}_{\\frac{\\alpha}{2}}(n)\\)</p> <p>当零假设为\\(\\sigma^{2}\\leqslant\\sigma_{0}^{2}\\)，根据备择假设的特点，构造拒绝域的形式为\\(\\left\\{ \\chi^{2}&gt;c \\right\\}\\)那么还应有\\(P_{H_{0}}\\left\\{ \\chi^{2}&gt;c \\right\\}\\leqslant \\alpha\\)</p> \\[ \\begin{aligned} \\alpha&amp;\\geqslant P_{H_{0}}\\left\\{ \\chi^{2}&gt;c \\right\\} \\\\ &amp;=P_{H_{0}}\\left\\{ \\frac{\\sum\\limits_{i=1}^{n} (X_{i}-\\mu_{0})^{2}}{\\sigma_{0}^{2}}&gt;c \\right\\} \\\\ &amp;=P_{H_{0}}\\left\\{ \\frac{\\sum\\limits_{i=1}^{n} (X_{i}-\\mu_{0})^{2}}{\\sigma^{2}}&gt; \\frac{c\\sigma_{0}^{2}}{\\sigma^{2}} \\right\\} \\end{aligned} \\] <p>由于原假设是\\(\\sigma_{0}\\geqslant\\sigma^{2}\\)，那么只要\\(c\\)满足</p> \\[ \\alpha \\geqslant P_{H_{0}}\\left\\{ \\frac{\\sum\\limits_{i=1}^{n} (X_{i}-\\mu_{0})^{2}}{\\sigma^{2}}&gt; c\\right\\} \\] <p>即可，因为\\(P_{H_{0}}\\left\\{ \\frac{\\sum\\limits_{i=1}^{n} (X_{i}-\\mu_{0})^{2}}{\\sigma^{2}}&gt; c\\right\\}\\geqslant P_{H_{0}}\\left\\{ \\frac{\\sum\\limits_{i=1}^{n} (X_{i}-\\mu_{0})^{2}}{\\sigma^{2}}&gt; \\frac{c\\sigma_{0}^{2}}{\\sigma^{2}} \\right\\}\\)</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#mu","level":4,"title":"\\(\\mu\\)未知","text":"<p>仍然是按照\\(\\chi^{2}\\)统计量的方法，只需要将自由度改为\\(n-1\\)即可，统计量为\\(\\chi^{2}=\\dfrac{\\sum\\limits_{i=1}^{n}(X_{i}- \\overline{X})^{2}}{\\sigma_{0}^{2}}\\)</p> <p>注意到这些做法类似枢轴量法的构造方式</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#_7","level":2,"title":"两样本正态总体参数的显著性检验","text":"","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#_8","level":3,"title":"两样本正态总体均值的显著性检验","text":"\\[ \\begin{aligned} H_{0}:\\mu_{1}=\\mu_{2}\\longleftrightarrow H_{1}:\\mu_{1}\\neq \\mu_{2}\\\\ H_{0}:\\mu_{1}\\leqslant\\mu_{2}\\longleftrightarrow H_{1}:\\mu_{1}&gt; \\mu_{2}\\\\ H_{0}:\\mu_{1}\\geqslant\\mu_{2}\\longleftrightarrow H_{1}:\\mu_{1}&lt;\\mu_{2}\\\\ \\end{aligned} \\] <p>如果\\(\\sigma_{1}^{2},\\sigma^{2}_{2}\\)未知，就将均值差的估计称为Behrens-Fisher问题</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#sigma_12sigma_22","level":4,"title":"\\(\\sigma_{1}^{2},\\sigma_{2}^{2}\\)均已知","text":"<p>由于\\(\\overline{X},\\overline{Y}\\)是\\(\\mu_{1},\\mu_{2}\\)的良好的点估计，有理由用两样本均值差\\(\\overline{X}-\\overline{Y}\\)来反映\\(\\mu_{1},\\mu_{2}\\)的差，构造\\(U\\)统计量为\\(U=\\frac{\\overline{X}-\\overline{Y}}{\\sqrt{ \\frac{\\sigma_{1}^{2}}{m}+ \\frac{\\sigma^{2}_{2}}{n} }}\\sim N(0,1)\\)</p> <p>拒绝域形如\\(W=\\left\\{ \\lvert U \\rvert&gt;c \\right\\}\\)，选取\\(c=u_{\\frac{\\alpha}{2}}\\)即可，单侧情况\\(\\mu_{1}\\leqslant\\mu_{2}\\)如下</p> <p>由于\\(H_{0}\\)成立时有\\(\\mu_{1}\\leqslant\\mu_{2}\\)：</p> \\[ \\begin{aligned} P_{H_{0}}(U&gt;u_{\\alpha})&amp;=P_{H_{0}}\\left( \\frac{\\overline{X}-\\overline{Y}}{\\sqrt{ \\frac{\\sigma_{1}^{2}}{m}+ \\frac{\\sigma_{2}^{2}}{n} }}&gt;u_{\\alpha} \\right)\\\\ &amp;=P_{H_{0}}\\left( \\frac{\\overline{X}-\\overline{Y}-(\\mu_{1}-\\mu_{2})}{\\sqrt{ \\frac{\\sigma_{1}^{2}}{m}+ \\frac{\\sigma_{2}^{2}}{n} }}&gt;u_{\\alpha} - \\frac{\\mu_{1}-\\mu_{2}}{\\sqrt{ \\frac{\\sigma_{1}^{2}}{m}+ \\frac{\\sigma_{2}^{2}}{n} }}\\right)\\\\ &amp;\\leqslant P_{H_{0}}\\left( \\frac{\\overline{X}-\\overline{Y}-(\\mu_{1}-\\mu_{2})}{\\sqrt{ \\frac{\\sigma_{1}^{2}}{m}+ \\frac{\\sigma_{2}^{2}}{n} }}&gt;u_{\\alpha} \\right)=\\alpha \\end{aligned} \\]","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#sigma_12sigma_22sigma2","level":4,"title":"\\(\\sigma_{1}^{2}=\\sigma_{2}^{2}=\\sigma^{2}\\)未知","text":"<p>对于相等的原假设，构造\\(T\\)统计量如下</p> \\[ T= \\frac{(\\overline{X}-\\overline{Y})\\left[ \\sigma \\sqrt{ \\frac{m+n}{mn} } \\right] }{\\sqrt{ \\frac{(m+n-2)S^{*}_{mn}}{\\sigma^{2}(m+n-2)} }}=\\sqrt{ \\frac{mn}{m+n} } \\frac{\\overline{X}-\\overline{Y}}{S^{*}_{mn}} \\] <p>可以选择拒绝域为：\\(W=\\left\\{ \\lvert T \\rvert&gt;t_{\\frac{\\alpha}{2}}(m+n-2) \\right\\}\\)</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#_9","level":4,"title":"一般情况","text":"<p>对于一般情况下两样本正态总体均值的显著性检验问题，给出如下(不加证明)：</p> <ol> <li>\\(m,n\\)充分大</li> </ol> <p>采用的统计量均为：\\(U= \\frac{\\overline{X}-\\overline{Y}}{\\sqrt{ \\frac{S_{1m}^{2}}{m}+ \\frac{S_{2n}^{2}}{n} }}\\)</p> <p>三大假设的拒绝域为：\\(\\left\\{ \\lvert U \\rvert&gt; u_{\\frac{\\alpha}{2}} \\right\\},\\left\\{ U&gt;u_{\\alpha} \\right\\},\\left\\{ U&lt;-u_{\\alpha} \\right\\}\\)</p> <ol> <li>\\(m,n\\)都不是很大</li> </ol> <p>无法使用大样本近似，\\(U\\)统计量近似服从自由度为\\(r\\)的\\(t\\)分布，对于\\(r\\)有如下计算公式：</p> \\[ r= \\frac{S_{mn}^{2}}{\\frac{S_{1m}^{4}}{m^{2}(m-1)}+ \\frac{S_{2n}^{4}}{n^{2}(n-1)}} \\] <p>三大假设的拒绝域为：\\(\\left\\{ \\lvert T \\rvert&gt; t_{\\frac{\\alpha}{2}}(r) \\right\\},\\left\\{ T&gt;t_{\\alpha}(r) \\right\\},\\left\\{ T&lt;-t_{\\alpha} (r)\\right\\}\\)</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#_10","level":3,"title":"两样本正态总体方差的显著性检验","text":"<p>仍然总结一下感兴趣的情况：</p> \\[ \\begin{aligned} H_{0}:\\sigma_{1}^{2}=\\sigma^{2}_{2}\\longleftrightarrow H_{1}:\\sigma^{2}_{1}\\neq \\sigma^{2}_{2}\\\\ H_{0}:\\sigma^{2}_{1}\\leqslant\\sigma^{2}_{2}\\longleftrightarrow H_{1}:\\sigma^{2}_{1}&gt; \\sigma^{2}_{2}\\\\ H_{0}:\\sigma^{2}_{1}\\geqslant\\sigma^{2}_{2}\\longleftrightarrow H_{1}:\\sigma^{2}_{1}&lt;\\sigma^{2}_{2}\\\\ \\end{aligned} \\]","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#mu_1mu_2","level":4,"title":"\\(\\mu_{1},\\mu_{2}\\)均已知","text":"<p>构造\\(F\\)统计量：\\(F=\\frac{S_{1m}^{'2}}{S_{2n}^{'2}}= \\frac{\\sum\\limits_{i=1}^{m}(X_{i}-\\mu_{1})^{2}/m}{\\sum\\limits_{i=1}^{n}(Y_{i}-\\mu_{2})^{2}/n}\\)</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#mu_1mu_3","level":4,"title":"\\(\\mu_{1},\\mu_{2}\\)均未知","text":"<p>仍然是\\(F\\)统计量，只不过需要修改自由度为\\((m-1,n-1)\\)</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#_11","level":2,"title":"单参数指数型分布族的显著性检验","text":"","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#_12","level":3,"title":"单参数指数型分布族的性质","text":"<p>[!NOTE] 定理 对于单参数指数分布族\\(f(x,\\theta)=c(\\theta)\\exp(Q(\\theta)T(x))h(x)\\)，\\(II D\\)样本\\(X_{1},X_{2},\\dots,X_{n}\\)，如果\\(Q(\\theta)\\)是严格增的，\\(\\psi(T(X))\\)是\\(T(X)\\)的非降函数，那么有\\(E_{\\theta}\\left[ \\psi(T) \\right]\\)也是\\(\\theta\\)的非降函数</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#_13","level":3,"title":"单参数指数型分布族的假设检验","text":"","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#bernoulli","level":3,"title":"Bernoulli分布的假设检验","text":"<p>这一部分实际就是应用的问题</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#_14","level":2,"title":"似然比检验","text":"<p>相当重要的一个部分，相当于\\(MLE\\)在点估计中的地位</p> <p>先给出似然比统计量的定义，记号不赘述：</p> <p>我们考虑的是最一般的假设，也就是\\(H_{0}:\\theta\\in\\Theta_{0}\\longleftrightarrow H_{1}:\\theta\\in\\Theta_{1}=\\Theta-\\Theta_{0}\\)</p> \\[ \\lambda(X)= \\frac{\\sup\\limits_{\\theta\\in\\Theta_{0}}f(X,\\theta)}{\\sup\\limits_{\\theta\\in\\Theta}f(X,\\theta)} \\] <p>从定义中不难看出，如果该统计量的值很小，就说明在\\(\\Theta_{0}\\)中的概率小，有理由认为\\(H_{0}\\)不成立</p> <p>那么似然比检验的定义就很自然了：</p> <p>[!NOTE] 定义 似然比检验 利用\\(\\lambda(X)\\)作为检验统计量，取拒绝域为\\(\\left\\{ \\lambda(x)\\leqslant c \\right\\}\\)，其中临界值\\(c\\)满足\\(P_{\\theta}(\\lambda(X)\\leqslant c)\\leqslant \\alpha,\\forall\\theta\\in\\Theta_{0}\\)，称其为显著性水平\\(\\alpha\\)的似然比检验(LRT)</p> <p>掌握这个思想！</p> <p>这里面有很多很复杂也很有趣的问题，由于是知识性的笔记在此先不扩展太多.</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/#p","level":2,"title":"\\(p\\)值","text":"<p>实际上就是先前显著性检验的一个等价形式(USTC版本的课本将\\(p\\)值放在显著性检验的后面，将假设检验全部使用两种方法进行求解，对于\\(p\\)值如果陌生可以参考USTC课本)，根据它的定义就可以看出</p> <p>[!NOTE] 定义 \\(p\\)值 对于拒绝域形如\\(W=\\left\\{ X:T(X)&gt;c \\right\\},W=\\left\\{ X:T(X)&lt;c \\right\\}\\)的单侧检验，给定样本的观测值\\(x^{0}\\)后即可代入原本检验的检验统计量得出相应的值(在下面的定理中会给出更好的解释)，称\\(p(x^{0})=\\sup\\limits_{\\theta\\in\\Theta_{0}}P_{\\theta}(T(X)\\geqslant T(x^{0}))\\)或是\\(p(x^{0})=\\sup\\limits_{\\theta\\in\\Theta_{0}}P_{\\theta}(T(X)\\leqslant T(x^{0}))\\)为此检验的\\(p\\)值</p> <p>定理：样本值\\(x^{0}\\)落入显著性水平为\\(\\alpha\\)的拒绝域\\(W=\\left\\{ X:T(X)&gt;c \\right\\}\\)的充要条件为此样本的\\(p\\)值小于\\(\\alpha\\)</p> <p>\\(p\\)值的好处在于不需要知道显著性水平，只要大于\\(p\\)值的显著性水平\\(\\alpha\\)，犯一类错误的概率都不超过\\(\\alpha\\)</p> <p>而双侧\\(p\\)值的形式可以为：</p> <p>\\(p(x^{0})=2\\min\\left\\{ \\sup\\limits_{\\theta\\in\\Theta_{0}}P_{\\theta}(T(X)\\leqslant T(x^{0})) ,\\sup\\limits_{\\theta\\in\\Theta_{0}}P_{\\theta}(T(X)\\geqslant T(x^{0}))\\right\\}\\)</p>","path":["假设检验——显著性检验"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","level":1,"title":"基本概念","text":"<p>[!tldr] 重点 1. 三大分布 ⭐⭐⭐⭐⭐ 2. 抽样定理 ⭐⭐⭐⭐⭐ 3. 充分统计量 ⭐⭐⭐⭐ 4. 因子分解定理 ⭐⭐⭐⭐</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_2","level":2,"title":"总体与样本","text":"","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_3","level":3,"title":"总体与个体","text":"<p>抛开实际背景，用一个概率分布去描述和归纳总体也是合理的，那么可以说总体就是一个分布，以后从总体中抽样与从某分布中抽样是一个意思．</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_4","level":3,"title":"样本","text":"<p>样本的所谓二重性： + 样本是随机变量，在抽样前不可知 + 观测后就是确定的值，可以用数列表示</p> <p>为方便起见，样本无论是样本本身还是所谓观测值都是用\\(x_{1},x_{2},\\dots,x_{n}\\)表示</p> <p>简单随机抽样方法可以得到简单随机样本，这种方法需要满足一定的基本假设：也就是随机性和独立性，还需要排除人为的干扰.显然的，在样本量很大的条件下应当认为不放回的抽样方式也满足独立性.</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_5","level":2,"title":"样本数据的整理与显示","text":"","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_6","level":3,"title":"经验分布函数","text":"<p>关于经验分布函数的重要性，一般可以通过它对于分布函数有良好的逼近性质阐述，而且这种逼近性质中的点点收敛可以通过SLLN证明，另一个一致收敛性则是另一个定理的内容：</p> <p>下面就是这个很重要的定理，但是大多数数理统计书没有给出严格的证明，可是它的重要性在Wikipedia中的一段话可见一斑(甚至有时叫做统计学基本定理)：</p> <p>In the theory of probability, the Glivenko–Cantelli theorem (sometimes referred to as the Fundamental Theorem of Statistics), named after Valery Ivanovich Glivenko and Francesco Paolo Cantelli, describes the asymptotic behaviour of the empirical distribution function as the number of independent and identically distributed observations grows. Specifically, the empirical distribution function converges uniformly to the true distribution function almost surely.</p> <p>[!NOTE] Glivenko-Cantelli theorem \\(X_{1},X_{2},\\dots X_{n} \\overset{IID}{\\sim}F(x)\\implies F_{n}(x)\\overset{a.s.}{\\to} F(x)(SL LN)\\), and this result is used Strong Law of Large Numbers, however, this theorem(Glivenko-Cantelli Theorem) strength this result by proving uniform convergence(a.s.) of \\(F_{n}\\to F\\) </p> <p><code>Proof.</code></p> <p>假设是连续的情形，然后假设选取\\(n\\)个样本点，并且满足\\(-\\infty=x_{0}\\leq x_{1}\\leq x_{2}\\dots \\leq x_{n}=\\infty\\)</p> <p>这种假设会给出\\(F_{n}(x_{j+1})-F_{n}(x_{j})=\\frac{1}{n}\\)，并且给出一对放缩式\\(x\\in \\left[ x_{j-1},x_{j} \\right]\\)</p> \\[ \\begin{align} F_{n}(x)-F(x)&amp;\\leq F_{n}(x_{j})-F(x_{j-1})=F_{n}(x_{j-1})-F(x_{j-1})+\\frac{1}{n}\\\\ F_{n}(x)-F(x)&amp;\\geq F_{n}(x_{j-1})-F(x_{j})=F_{n}(x_{j})-F(x_{j})-\\frac{1}{n} \\end{align} \\] <p>那么我们将得到\\(\\forall x,\\lVert F_{n}(x)-F(x) \\rVert=\\sup\\limits_{{x\\in R}}\\lvert F_{n}(x)-F(x) \\rvert\\leq \\max\\limits_{j=\\left\\{ 1,2,\\dots,n \\right\\}}\\lvert F_{n}(x_{j})-F(x_{j}) \\rvert+\\frac{1}{n}\\implies Q.E.D\\)</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_7","level":3,"title":"频数频率分布表","text":"","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_8","level":3,"title":"样本数据的图形显示","text":"<ul> <li>直方图</li> <li>茎叶图</li> </ul> <p>我们在小学二年级学过这些内容了</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_9","level":2,"title":"统计量及其分布","text":"","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_10","level":3,"title":"统计量与抽样分布","text":"<p>主要是两个基本概念</p> <p>若是样本函数\\(T\\)中不含有任何未知参数，称为统计量，统计量的分布称为抽样分布.</p> <p>Remark：统计量和抽样分布的概念在后面的内容中都有涉及</p> <p>以下就是几个重要统计量和它们的延申概念的介绍</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_11","level":3,"title":"样本均值及其抽样分布","text":"<p>很容易给出样本均值的定义(算术平均值)：\\(\\overline{x}= \\frac{\\sum\\limits_{i=1}^{n}x_{i}}{n}\\)就是样本均值</p> <p>并且它还具有以下性质(Proof is trivial) 1. \\(\\sum\\limits_{i=1}^{n}(x_{i}-\\overline{x})=0\\) 2. \\(\\forall c, \\sum\\limits(x_{i}-c)^{2}\\geq \\sum\\limits(x_{i}-\\overline{x})^{2}\\) 3. \\(\\overline{x}\\sim N\\left( \\mu, \\frac{\\sigma^{2}}{n} \\right)\\)</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_12","level":3,"title":"样本方差与样本标准差","text":"<p>样本方差(无偏方差):\\(s^{2}=\\frac{1}{n-1}\\sum\\limits_{i=1}^{n}(x_{i}-\\overline{x})^{2}\\)</p> <p>而且我们还可以说明它为什么是无偏的也就是\\(E(s^{2})=\\sigma^{2}\\)</p> <p><code>Proof.</code></p> \\[ E\\left( \\sum\\limits_{i=1}^{n} (x_{i}-\\overline{x})^{2} \\right)=nE(x_{i}^{2})-nE(\\overline{x}^{2})=n(\\mu^{2}+\\sigma^{2})-n\\left( \\mu^{2}+\\frac{\\sigma^{2}}{n} \\right) =(n-1)\\sigma^{2} \\] <p>若是有偏的也是一种估计，并且叫做极大似然估计(MLE)</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_13","level":3,"title":"样本矩及其函数","text":"<p>常见统计量除了样本均值与样本方差外的更一般推广是样本矩： + \\(k\\)阶原点矩：\\(a_{k}=\\frac{1}{n}\\sum\\limits_{i=1}^{n}x_{i}^{k}\\) + \\(k\\)阶中心矩：\\(b_{k}=\\frac{1}{n}\\sum\\limits_{i=1}^{n}\\left( x_{i}-\\overline{x} \\right)^{k}\\)</p> <p>关于样本中心距还有样本偏度和样本峰度两个重要的指标，也是中心距函数： + 样本偏度：\\(\\hat{\\beta_{s}}=\\frac{b_{3}}{b_{2}^{\\frac{3}{2}}}\\)      + 反映总体分布密度曲线与对称性的偏离方向和程度 + 样本峰度：\\(\\hat{\\beta_{k}}=\\frac{b_{4}}{b_{2}^{2}}-3\\)      + 反映总体分布密度曲线在其峰值附近的陡峭程度和尾部粗细</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_14","level":3,"title":"次序统计量及其分布","text":"<p>简单来说按照大小顺序将样本排序并编号就可以称作次序统计量</p> <p>我们关心次序统计量的分布情况，为简单起见先讨论单个次序统计量的分布如下：</p> <p>其中第\\(k\\)个次序统计量\\(x_{(k)}\\)的密度函数为(\\(p(x)\\)为总体\\(X\\)的密度函数)</p> \\[ p_{k}(x)=\\frac{n!}{(k-1)!(n-k)!}\\left( F(x) \\right)^{k-1}\\left( 1-F(x) \\right) ^{n-k}p(x)  \\] <p>很容易理解前面的系数计算的是置换数，然后根据类似指标函数的概率的做法得到后面的\\(F\\)和\\(1-F\\)，再加上取该点的概率值</p> <p>然后再讨论多个次序统计量的分布：下面讨论的是任意两个次序统计量的分布，其余同理</p> \\[ p_{ij}(x)=\\frac{n!}{(i-1)!(j-i-1)!(n-j)!}\\left[ F(y) \\right]^{i-1}\\left[ F(z)-F(y) \\right] ^{j-i-1}\\left[ 1-F(z) \\right] ^{n-j}p(y)p(z)  \\] <p>同样可以按照一元的情形类似讨论即可</p> <p>实际问题中也会用到一些有关次序统计量的函数\\(R_{n}=x_{(n)}-x_{(1)}\\)称为样本极差</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_15","level":3,"title":"样本分位数与样本中位数","text":"<p>样本中位数是比较常见的统计量并且表示起来也简单，我们将直接给出更一般的\\(p\\)分位数\\(m_{p}\\)的定义（包括不加证明的给出\\(n\\to \\infty\\)时的渐进分布）</p> <p>中位数</p> \\[ \\begin{align} m_{0.5}=\\left\\{ \\begin{matrix} x_{\\left( \\frac{n+1}{2} \\right) }&amp;,2\\nmid n \\\\ \\frac{1}{2}\\left( x_{\\left( \\frac{n}{2} \\right)}+x_{\\left( \\frac{n}{2}+1 \\right)} \\right) &amp;,2\\mid n \\end{matrix} \\right.  \\end{align} \\] <p>\\(p\\)分位数</p> \\[ \\begin{align} m_{p}=\\left\\{ \\begin{matrix} x_{\\left( \\lceil np+1  \\rceil  \\right) }&amp;,np\\not\\in \\mathbb{Z} \\\\ \\frac{1}{2}\\left( x_{\\left( np  \\right) }+x_{\\left( np+1  \\right) } \\right) &amp;,np\\in \\mathbb{Z} \\end{matrix} \\right.  \\end{align} \\] <p>渐进分布的一个定理： 总体密度函数为\\(p(x)\\)，\\(x_{p}\\)为\\(p\\)分位数，且有连续性和非负性，那么\\(n\\to \\infty\\)的样本\\(p\\)分位数为\\(m_{p}\\)的渐进分布为：</p> \\[ m_{p}\\sim N\\left( x_{p}, \\frac{p(1-p)}{n\\cdot p^{2}(x_{p})} \\right),m_{0.5}\\sim N\\left( x_{p}, \\frac{1}{4n\\cdot p^{2}(x_{0.5})} \\right) \\] <p>中位数相比样本均值有更好的对极端值的抗干扰性，也叫做稳健性</p> <p>以下是次序统计量的应用部分：五数概括与箱线图(Box-Whisker plot)</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_16","level":3,"title":"五数概括与箱线图","text":"<p>所谓五数概括就是指最小观测值，最大观测值，第一、三四分位数，中位数</p> <p>利用这五个数可以大致表现样本数据分布的形状，箱线图大致分为 + 左偏分布 + 右偏分布 + 对称分布</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_17","level":2,"title":"三大抽样分布","text":"<p>统计学的三大分布都是利用正态分布导出的，充分体现了正态分布的重要性，三大分布的导出方式也需要记住和掌握，还需要多利用三大分布完成习题.</p> <p>下面再额外给出三大分布有关的工具(分布族)</p> <p>统计分布常用于总体的建模，因此我们处理的往往不是单个的分布，而是一族分布。一个分布族共用一个函数形式，其中包含一个或多个参数，用以确定具体的分布。</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#gamma","level":3,"title":"\\(\\Gamma\\)分布族","text":"<p>\\(X\\sim \\Gamma(\\alpha,\\beta)\\)</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#chi2","level":3,"title":"\\(\\chi^{2}\\)分布(卡方分布)","text":"<p><code>K·Pearson</code></p> <p>\\(\\chi^{2}\\)的构造为\\(\\chi^{2}=\\sum\\limits_{i=1}^{n}x_{i}^{2}\\)，那么如何得到它的概率密度函数(PDF)?</p> <p>利用正态分布的性质可以得到，若是\\(X\\sim N(0,1),\\chi^{2}\\sim Ga\\left( \\frac{1}{2}, \\frac{1}{2} \\right)\\)，根据可加性得到卡方分布的概率密度函数为\\(p(y)=\\chi^{2}(n)=Ga\\left( \\frac{n}{2}, \\frac{1}{2} \\right)= \\frac{\\left( \\frac{1}{2} \\right)^{\\frac{n}{2}}}{\\Gamma\\left( \\frac{n}{2} \\right)}y^{\\frac{n}{2}-1}e^{- \\frac{y}{2}}\\)</p> <p>一般在各个教材中都会提到卡方分布的一个重要应用是下面的一个定理</p> <p>设\\(x_{1},x_{2},\\dots,x_{n}\\)是来自正态总体\\(N(\\mu,\\sigma^{2})\\)的样本，其样本均值与样本方差分别为</p> <p>$$ \\overline{x}= \\frac{1}{n}\\sum\\limits_{i=1}^{n} x_{i},s^{2}= \\frac{1}{n-1}\\sum\\limits_{i=1}^{n} \\left( x_{i}-\\overline{x} \\right) ^{2} $$ 则有</p> <p>(1)\\(\\overline{x}\\)与\\(s^{2}\\)相互独立 (2)\\(\\overline{x}\\sim N\\left( \\mu, \\frac{\\sigma^{2}}{n} \\right)\\) (3)\\(\\dfrac{(n-1)s^{2}}{\\sigma^{2}}\\sim \\chi^{2}(n-1)\\)</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#f","level":3,"title":"\\(F\\)分布","text":"<p>构造方法是\\(X_{1}\\sim \\chi^{2}(m),X_{2}\\sim \\chi^{2}(n)\\)，并且独立，使得\\(F= \\frac{\\frac{X_{1}}{m}}{\\frac{X_{2}}{n}}\\sim F(m,n)\\) </p> <p>也可以看出\\(F=\\frac{\\frac{\\sum\\limits_{i=1}^{m}y_{i}^{2}}{m}}{\\frac{\\sum\\limits_{i=1}^{n}x_{i}^{2}}{n}}\\),并根据一系列变换得到\\(\\frac{\\Gamma \\left( \\frac{m+n}{2} \\right)\\left( \\frac{m}{n} \\right)^{\\frac{m}{2}}}{\\Gamma \\left( \\frac{m}{2}\\Gamma \\left( \\frac{n}{2} \\right) \\right)}y^{\\frac{m}{2}-1}\\left( 1+ \\frac{m}{n}y \\right)^{- \\frac{m+n}{2}}\\)</p> <p>利用\\(\\chi^{2}\\)分布的性质可以得到相关\\(F\\)分布的性质：\\(X_{i}\\sim N(\\mu_{1},\\sigma_{1}^{^{2}}),Y_{i}\\sim N(\\mu_{2},\\sigma_{2}^{^{2}})\\)</p> <p>并且两个样本相互独立的情况下，有\\(F= \\dfrac{s_{x}^{2}/\\sigma_{1}^{2}}{s_{y}^{2}/\\sigma_{2}^{2}}\\sim F(m-1,n-1)\\)</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#t","level":3,"title":"\\(t\\)分布","text":"<p><code>Gosset and R·A·Fisher</code></p> <p>\\(t= \\frac{y_{1}}{\\sqrt{ \\left( \\sum\\limits_{i=1}^{n}x_{i}^{2} \\right) /n }}\\),若是两个随机变量独立，\\(X_{1}\\sim N(0,1),X_{2}\\sim \\chi^{2}(n),t=\\frac{X_{1}}{\\sqrt{ X_{2} / n }}\\)</p> <p>\\(X_{1},-X_{1}\\overset{IID}{\\sim}N(0,1)\\)，那么\\(t^{2}= \\frac{X_{1}^{2}}{X_{2}^{2} / n}\\sim F(1,n)\\),也称为自由度为\\(n\\)的\\(t\\)分布</p> <p>要想证明它与标准正态分布有良好的近似性质，可以考虑使用Slutsky定理避免讨论它的概率密度函数而直接导出，关于Slutsky定理的证明可能还需要Continuous mapping theorem ，有关这个Continuous mapping theorem的一部分证明还需要用到Portmanteau theorem(也是weak convergence的等价性质)</p> <p><code>Proof</code></p> <p>因为\\(\\frac{X_{2}}{n}\\sim E[X_{i}^{2}]=1\\)，而且分子趋向于标准正态分布，再使用\\(Slutsky\\)定理，可以直接得到\\(t\\)分布依概率收敛到标准正态分布</p> <p>或者也可以直接使用PDF进行证明，\\(p_{t}(y)= \\frac{\\Gamma \\left( \\frac{n+1}{2} \\right)}{\\sqrt{ n\\pi }\\Gamma \\left( \\frac{n}{2} \\right)}\\left( 1+ \\frac{y^{2}}{n} \\right)^{-\\frac{n+1}{2}}\\)</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_18","level":2,"title":"充分统计量","text":"","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_19","level":3,"title":"充分性的概念","text":"<p>\"样本加工不损失信息\"称为充分性</p> <p>一个简单的定义：在给定统计量\\(T\\)的取值后，\\(x_{1},\\dots,x_{n}\\)的条件分布与\\(\\theta\\)无关，则称统计量\\(T\\)是\\(\\theta\\)的充分统计量</p> <p>也就是\\(F_{\\theta}(X|T=t)\\)不依赖于参数\\(\\theta\\)，此条件分布已不含\\(\\theta\\)的信息</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_20","level":3,"title":"因子分解定理","text":"<p>[!TIP] 充分性原则 在充分统计量存在的场合，任何统计推断都可以基于充分统计量进行，这样可以简化统计推断的程序，通常将该原则称为充分性原则</p> <p>引入概率函数也就是将PDF和PMF结合统一起来的概念，给出Neyman的因子分解定理(相比定义可以更加简单的判断一个统计量是否充分)</p> <p>[!NOTE] 因子分解定理(Neyman) 总体概率函数\\(f(x,\\theta),x_{1},\\dots,x_{n}\\)是样本 ，那么\\(T\\)是充分统计量的充分必要条件是：\\(\\exists g(t,\\theta),h(x_{1},\\dots,x_{n})\\)使得任意的\\(\\theta\\)和任一组观测值\\(x_{1},\\dots,x_{n}\\),有： $$ f(x_{1},\\dots,x_{n};\\theta)=g(T(x_{1},\\dots,x_{n}),\\theta)h(x_{1},\\dots,x_{n}) $$ 其中\\(g(t,\\theta)\\)是通过统计量\\(T\\)的取值而依赖于样本</p> <p>那么进行推广得到更一般的命题也就是：</p> <p>若统计量\\(T\\)是充分统计量，存在某个函数\\(h(\\cdot)\\)使得\\(T\\)可以表示为\\(t=h(s)\\)，则说明统计量\\(S\\)也是充分统计量</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#_21","level":2,"title":"习题","text":"<p>[!tldr] HW1 茆诗松(2010) 概率论与数理统计(第二版) + 习题5.1 1、3、4 + 习题5.3 1、4、6、9、12、20、23</p> <p>评价：总的来说这次作业还是比较水，里面出现了一些很无聊的用基础概念的描述题，其他也是很基础的用概率论基本知识就足以完成，值得注意的只有一道计算样本偏度和样本峰度的题目(估计不会考，计算量有点ex了)</p> <p>[!tldr] HW2 王兆军(2023) 数理统计教程(第二版) + 习题一 8、9、13、14、15、24、26、28、31、41</p> <p>评价：总的习题质量比较高，需要对课本中的定理和分布有比较熟练的掌握，没有什么特别难的题</p>","path":["基本概念"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/","level":1,"title":"点估计","text":"<p>上一章讨论的是几个统计量的常用抽样分布以及充分统计量，还有因式分解定理用以判断是否为充分统计量，但是让我们回想一下引入充分统计量的目的</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#_2","level":2,"title":"引言","text":"<p>讲述了一些参数估计的方法和脉络，大致如下</p> <p>[!tip] Parameter estimation + 点估计   + 无偏估计 UE   + 一致最小方差无偏估计 UMVUE   + 极大似然估计 MLE + 区间估计   + 枢轴量法   + Fisher信仰推断方法</p> <p>上一章中主要讲述了常用统计量的抽样分布及充分统计量，引进统计量的目的在于为了对于感兴趣问题进行统计推断(充分性原则)，实际中感兴趣的问题则是多与分布族的未知参数有关. 那么接下来讨论的就应当是参数的估计和检验问题，本章讲述的就是参数的估计</p> <p>Remark: 这里的参数指下面三类未知参数  + 分布中所含的未知参数 + 分布中所含的未知参数的函数 \\(X\\sim N(\\mu,\\sigma^{2}),P(X\\le a)=\\Phi \\left( \\frac{a-\\mu}{\\sigma} \\right)\\) + 分布的各种特征数 \\(EX,Var(X)\\)</p> <p>一般常用\\(\\theta\\)来表示参数，参数\\(\\theta\\)所有可能取值组成的集合称为参数空间，常用\\(\\Theta\\)表示.参数估计问题就是根据样本构造适当的统计量对上述各种未知参数做出估计.</p> <p>参数估计的形式有：点估计和区间估计</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#_3","level":2,"title":"点估计的概念与无偏性","text":"<p>评价一个估计好坏的准则主要有三个</p> <ol> <li>无偏性</li> <li>有效性</li> <li>相合性(大样本性质)</li> </ol>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#_4","level":3,"title":"点估计及无偏性","text":"<p>点估计的定义比较简单且显然就是用来估计未知参数的统计量，而构造统计量应当满足一定的合理性，最常见的合理性要求是无偏性</p> <p>[!NOTE] 无偏估计的定义 设\\(\\hat{\\theta}=\\hat{\\theta}\\left( x_{1},\\dots,x_{n} \\right)\\)是\\(\\theta\\)的一个估计，若是对于属于参数空间中任意的一个\\(\\theta\\in\\Theta,\\)有\\(E_{\\theta}\\left( \\hat{\\theta} \\right)=\\theta\\)，则称\\(\\hat{\\theta}\\)是\\(\\theta\\)的无偏估计，否则称为有偏估计</p> <p>Remark: 完全可以将这个概念提前放置，然后就可以对前面的三大分布，样本方差的动机有比较好的初步了解(点名表扬zyd)</p> <p>无偏估计没有系统偏差,也就是将所有误差加起来求平均的值为0</p> <p>[!Example] 一些例子 样本均值是总体均值的无偏估计，总体\\(k\\)阶矩存在时，样本\\(k\\)阶原点矩就是总体的无偏估计，但中心矩则不同，例如样本方差就不是总体方差的无偏估计而是渐进无偏估计因为在样本量趋于无穷时可近似看作\\(\\sigma^{2}\\)的无偏估计</p> <p>那么为了修正原本的样本方差\\(s_{n}^{2}\\)，将系数减一得到新的样本方差\\(s^{2}\\)，在小样本的场合更多使用\\(s^{2}\\)估计\\(\\sigma^{2}\\)</p> <p>大偏差通常被视为估计的不足，刀切法就是一种缩小偏差的方法</p> <p>[!info] 刀切法,jackknife(Quenouile,named after Tukey) 设\\(T(x)\\)是基于样本\\(x=\\left( x_{1},\\dots,x_{n} \\right)\\)的关于参数\\(g(\\theta)\\)的估计量，且满足关系\\(E_{\\theta}\\left( T(x) \\right)=g(\\theta)+O\\left( \\frac{1}{n} \\right)\\).以\\(x_{(-i)}\\)表示从样本中删去\\(x_{i}\\)后的向量，定义刀切统计量为 $$ T_{j}(x)=nT(x)- \\frac{n-1}{n}\\sum\\limits_{i=1}^{n} T(x_{(-i)}) $$ 可以证明这种定义的刀切统计量\\(E_{\\theta}\\left( T_{j}(x) \\right)=g(\\theta)+O\\left( \\frac{1}{n^{2}} \\right)\\)，并且其方差不会增大</p> <p>[!help] Remark 关于刀切法的详细介绍可以参考Efron的专著</p> <p>并不是所有的参数都存在无偏估计，存在时称为可估的，否则称为不可估</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#_5","level":3,"title":"有效性","text":"<p>人们常用无偏估计的方差大小来衡量无偏估计优劣的标准，这就是有效性</p> <p>一个无偏估计比另一个更有效的定义就是该无偏估计的方差小于等于另一个并且至少有一个\\(\\theta\\)使得不等号严格成立</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#_6","level":2,"title":"矩估计及相合性","text":"","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#_7","level":3,"title":"替换原理和矩法估计","text":"<p>1900年\\(K·Pearson\\)提出的替换原理后来被称为矩法 + 用样本矩替换总体矩 + 用样本矩函数替换相应的总体矩函数</p> <p>实质是用经验分布函数替换总体，依据Glivenko定理</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#_8","level":3,"title":"概率函数已知时未知参数的矩估计","text":"<p>做法通常是反表示然后将已知的总体矩参量改为样本矩，然后做近似估计</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#_9","level":3,"title":"相合性","text":"<p>设\\(\\theta\\in\\Theta\\)为未知参数，给出\\(\\hat{\\theta_{n}}\\)是\\(\\theta\\)的一个估计量，\\(n\\)是样本容量，如果对于任何正数\\(\\epsilon\\)有 $$ \\lim\\limits_{ n \\to \\infty } P\\left( \\lvert \\hat{\\theta_{n}}-\\theta \\rvert\\ge \\epsilon  \\right) =0 $$ 那么称\\(\\hat{\\theta_{n}}\\)为参数的相合估计</p> <p>相合性是对估计的一个最基本要求，也就是随着样本量的无限增大，精度应当也无限逼近实际，能够达到任意指定的精度，不满足相合性要求的估计不予考虑.</p> <p>实质上也就是该估计量序列依概率收敛可应用依概率收敛的性质及各种大数定律</p> <p>给出两个判断相合性的定理：</p> <p>[!TIP] TH6.2.1 设\\(\\hat{\\theta}_{n}=\\hat{\\theta}_{_{n}}(x_{1},\\dots,x_{n})\\)是\\(\\theta\\)的一个估计量，若 $$ \\lim\\limits_{ n \\to \\infty } E\\left( \\hat{\\theta}{n} \\right) =\\theta, \\lim\\limits)=0 $$ 则} Var(\\hat{\\theta}_{n\\(\\hat{\\theta}_{n}\\)是\\(\\theta\\)的相合估计</p> <p><code>Proof.</code></p> <p>利用Chebyshev不等式把期望转换成方差，将\\(\\lvert \\hat{\\theta}_{n}-E(\\hat{\\theta}_{n}) \\rvert&lt; \\frac{\\epsilon}{2}\\implies \\lvert \\hat{\\theta}_{n}-E(\\hat{\\theta}_{n}) \\rvert&lt; \\frac{\\epsilon}{2}\\)修改为概率不等式的形式即可</p> <p>[!TIP] TH6.2.2 若\\(\\hat{\\theta}_{n_{1}},\\dots,\\hat{\\theta}_{n_{k}}\\)分别是\\(\\theta_{1},\\dots,\\theta _k\\)的相合估计，\\(\\eta=g\\left( \\theta_{1},\\dots,\\theta_{k} \\right)\\)是\\(\\theta_{1},\\dots,\\theta_{k}\\)的连续函数，则\\(\\hat{\\eta}_{n}=g\\left( \\hat{\\theta}_{n_{1}},\\dots,\\hat{\\theta}_{n_{k}} \\right)\\)是\\(\\eta\\)的相合估计</p> <p>接下来就可以开始介绍一些实用的统计量</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#em","level":2,"title":"最大似然估计与EM算法","text":"<p>最大似然估计(MLE)最早由Gauss在1821针对正态分布提出，由R·A·Fisher再次提出并证明了它的一些性质使之得到了广泛的应用.</p> <p>本节给出最大似然估计的定义与计算和在某些复杂情况下MLE的一种有效算法——EM算法，并介绍最大似然估计的渐进正态性</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#_10","level":3,"title":"最大似然估计","text":"","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#_11","level":2,"title":"矩估计","text":"<p>矩估计也称为moment estimation是K.Pearson提出的，主要思想也就是用各种样本矩替代总体矩，而样本矩因为完全不依赖总体参数，是统计量而总体矩与参数有关，但是又因为大数定律和中心极限定理可知样本矩是总体矩的良好估计也就是说我们完全可以用样本矩估计总体矩而估计出未知参数.</p> <p>主要有几个基本问题： + 使用样本矩估计总体矩，原点矩和中心矩都是矩估计 + 估计方程组的存在唯一性取决于实际 + 估计时尽量使用低阶矩</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#em_1","level":2,"title":"极大似然估计与EM算法","text":"<p>极大似然估计是Gauss提出、由Fisher推广的，本节除了给出极大似然估计的基本定义外还将给出求取某些复杂情况MLE的有效算法，即EM算法</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#_12","level":3,"title":"极大似然估计","text":"<p>基本思想：概率最大的事件最有可能发生</p> <p>满足这个不等式：选取的估计\\(\\hat{p(x)}\\) $$ P\\left{ X=x|\\hat{p(x)} \\right} \\geq P\\left{ X=x|p' \\right},\\forall p',\\forall x.  $$</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#_13","level":4,"title":"似然函数","text":"<p>[!NOTE] 似然函数(likehood function) 对于给定的样本观测值\\(x=\\left( x_{1},x_{2},\\dots,x_{n} \\right)\\)，称\\(f(x,\\theta)\\)为\\(\\theta\\)的似然函数，简称为似然函数，记为\\(L(\\theta,x)=f(x,\\theta),\\forall\\theta\\in\\Theta\\)</p> <p>极大似然估计也就是选取\\(\\hat{\\theta}\\)后似然函数取到最大值，实际求某个参数的MLE也就是求似然函数的极值问题，如果\\(L(\\theta,x)\\)关于\\(\\theta\\)可微，则\\(\\theta\\)的MLE可以通过求偏导得到.</p> <p>[!NOTE] 似然方程 求解办法 $$ \\frac{\\partial L(\\theta,x)}{\\partial\\theta_{j}}=0,j=1,2\\dots,k $$</p> <p>一个很重要的例子就是对于正态总体，均值与方差的估计和MLE一样</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#mleinvariance-of-mle","level":4,"title":"MLE的不变性(Invariance of MLE)","text":"<p>Reference: + Statistic Inference (Casella) Theorem 7.2.10 + Wikipedia-MLE + 知乎一篇文章 + 数理统计教程 王兆军 邹长亮</p> <p></p> <p>这个定理的内容本身十分直观，如下：</p> <p>[!NOTE] MLE的不变性 若\\(\\hat{\\theta}\\)是\\(\\theta\\)的MLE，则对于\\(\\theta\\)的任何函数\\(\\tau(\\theta)\\),\\(\\tau(\\hat{\\theta})\\)是\\(\\tau(\\theta)\\)的MLE.</p> <p><code>Proof.</code></p> <p>下面是参考的Casella的定义(这样就十分直观了)：</p> <p>[!tip] 诱导似然函数(Induced Likelihood Function) 如果原本的函数是一一对应的那么这种MLE的不变性实际上没有什么用处，所以我们比较关心的是非一对一情形，这也就提出了更一般的定理(任何函数的条件)，为了完成定理的证明首先应当做到将MLE的定义推广到函数上也就是我们研究的\\(\\tau(\\theta)\\)上. 为了达成这个目的我们应当先定义诱导似然函数，由下式给出： $\\(L^{*}(\\eta|x)=\\prod_{i=1}^{n} f(x_{i}|\\tau^{-1}(\\eta))=L(\\tau^{-1}(\\eta)|x)\\)$</p> <p>并且有\\(\\sup\\limits_{\\eta}L^{*}(\\eta|x)=\\sup\\limits_{\\eta}L(\\tau^{-1}(\\eta)|x)=\\sup\\limits_{\\theta}L(\\theta|x)\\)</p> <p>具体的证明也比较简单只需要按照定义书写一点数学分析废话(吐槽一下NKU的课本没有写清楚的什么是\\(g(\\theta)\\)的MLE,以至于笔者白白花费时间在错误的定义上百思不得其解,最终是自己查询了Casella和其他社区才得到答案)： $$ \\begin{aligned} G(w)=\\left{ \\theta:g(\\theta)=w \\right} ,&amp;M(w,x)=\\sup\\limits_{{\\theta\\in G(w)}}L(\\theta|x)\\ M(g(\\hat{\\theta});x)&amp;=\\sup\\limits_{\\theta\\in G(g(\\hat{\\theta}))}L(\\theta|x)=L(\\hat{\\theta}|x)=\\sup\\limits_{\\theta\\in \\Theta}L(\\theta|x)\\ &amp;\\geqslant \\sup\\limits_{\\theta\\in G(w)}L(\\theta|x)=M(w,x) \\end{aligned} $$ 注1：在这种定义下所谓的\\(M(w,x)\\)就摇身一变成为了\\(g(\\theta)\\)的似然函数了，否则在原本的情况下根本无法讨论. 注2：建议想更深入一点还是去看Casella，前置门槛也不高(NKU教材省略过多在作者眼里可能不值一提的细节，导致虽然本身内涵丰富但是阅读的难度被无端拉高)</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#mle","level":3,"title":"MLE的相合性","text":"<p>[!NOTE] Fisher信息量 Contents</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#em_2","level":3,"title":"EM算法","text":"","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#umvue","level":2,"title":"一致最小方差无偏估计(UMVUE)","text":"","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#mse","level":3,"title":"均方误差(MSE)","text":"<p>\\(MSE(\\hat{\\theta})=E(\\hat{\\theta}-\\theta)^{2}=Var(\\hat{\\theta})+(E \\hat{\\theta}-\\theta)^{2}\\)</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#umvue_1","level":3,"title":"一致最小方差无偏估计(UMVUE)","text":"<p>设\\(\\hat{\\theta}\\)是参数\\(\\theta\\)的无偏估计，若对于任意其它无偏估计\\(\\overset{\\sim}{\\theta}\\)，都有\\(Var(\\hat{\\theta})\\leqslant Var(\\overset{\\sim}{\\theta})\\)</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#umvue_2","level":3,"title":"UMVUE判断条件","text":"","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#cramer-raoc-r-inequality","level":3,"title":"Cramer-Rao不等式(C-R Inequality)","text":"","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#_14","level":3,"title":"完备统计量","text":"<p>[!NOTE] Lehmann-Scheffe Theorem \\(X_{1},X_{2},\\dots,X_{n}\\overset{IID}{\\sim}\\left\\{ f(x,\\theta) ,\\theta\\in \\Theta\\right\\}\\)，\\(T(X)\\)为\\(\\theta\\)的充分完备统计量，若\\(\\theta\\)可估，且\\(S(X)\\)是\\(\\theta\\)的无偏估计，则\\(S_{0}(T)=E(S(X)|T)\\)是\\(\\theta\\)的唯一UMVUE</p> <p><code>Proof.</code></p> <p>利用充分统计量构造两个新的UE再相减得到0的一个UE，然后使用Rao-Blackwell定理可以得到放缩式</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#bayes","level":2,"title":"Bayes估计","text":"","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#_15","level":3,"title":"点估计","text":"","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#mcmcmarkov-chain-monte-carlo-method","level":3,"title":"MCMC(Markov Chain Monte Carlo Method)","text":"","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#bootstrap","level":3,"title":"Bootstrap","text":"","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/Assets/%E7%82%B9%E4%BC%B0%E8%AE%A1/#_16","level":2,"title":"习题","text":"<p>[!tldr] HW3 王兆军(2023) 数理统计教程(第二版) + 习题二 3、15、25</p> <p>茆诗松(2010) 概率论与数理统计(第二版) + 习题6.1 3、8、10、11 + 习题6.2 3、4、6</p> <p>额外习题</p> <p>额外习题如下：</p> <p>设\\(\\left\\{f(x,\\theta);\\theta\\in\\Theta\\right\\}\\)是某参数分布族，如果</p> \\[f(x,\\theta)=c(\\theta)\\exp\\left(\\sum_{i=1}^kc_i(\\theta)T_i(x)\\right)h(x),\\] <p>则称此分布族为指数型分布族，其中\\(k\\) 为正整数，\\(c(\\theta)&gt;0,h(x)&gt;0.\\) </p> <p>一个PDF\\(f(x,\\theta)\\) 的支撑集定义为：\\(S=\\{x:f(x,\\theta)&gt;0\\}.\\)</p> <p>证明：</p> <p>(1)指数型分布族具有共同支撑集；</p> <p>(2)含两个未知参数的 Weibull 分布\\(W(\\alpha,\\theta)\\)不是指数型分布族，</p> <p>而\\(\\Gamma\\)分布族、\\(\\beta\\)分布族、Poisson分布族都是指数型分布族。</p> <p>[!tldr] HW4 王兆军(2023) 数理统计教程(第二版) + 习题二 3、15、25</p> <p>额外习题</p> <p>[!tldr] HW5 一道编程实现补充题如下</p> <p>[!NOTE] 补充题 设样本\\(X_1,\\cdots,X_n \\sim Gamma(\\alpha,\\lambda)\\),其密度函数为\\(f(x,\\alpha,\\lambda) = \\frac{\\lambda^\\alpha}{\\Gamma(\\alpha)}x^{\\alpha-1}e^{-\\lambda x}\\).取参数 \\(\\alpha\\) 和 \\(\\lambda\\) 的值分别为\\(\\alpha_0\\) 和 \\(\\lambda_0\\).产生随机样本 \\(X_1,\\cdots,X_n\\)。 (a) 用 Newton-Raphson 算法和 Fisher scoring 算法估计这两个参数 (b) 随机产生30组初值，分别用这两个算法得到结果，并比较这两个算法。 (c) 设 \\(\\alpha\\) 已知，Newton-Raphson 算法和 Fisher scoring 算法估计参数 \\(\\lambda\\)。并与结果 (a) 相比较。 涉及程序的内容，编程实现，并把程序和结果打印出来。程序可以字体变小后打印。</p> <p>(a)</p> <p>已知Gamma分布的密度函数为\\(f(x,\\alpha,\\lambda) = \\frac{\\lambda^\\alpha}{\\Gamma(\\alpha)}x^{\\alpha-1}e^{-\\lambda x}\\),可以计算对数似然函数的值为 $$ l(\\alpha,\\lambda|x)=n\\alpha \\ln\\lambda+(\\alpha-1)\\sum\\limits_{i=1}^{n} \\ln X_{i}-\\lambda \\sum\\limits_{i=1}^{n} X_{i}-n\\ln\\Gamma(\\alpha) $$ Newton-Raphson算法：\\(\\theta_{K+1}=\\theta_{k}-H(\\theta_{k})^{-1}g(\\theta_{k})\\)</p> <p>设参数向量\\((\\theta = (\\alpha,\\lambda)^T)\\)，迭代公式为\\(\\theta_{k + 1}=\\theta_{k}-H(\\theta_{k})^{-1}g(\\theta_{k})\\)，其中\\(g(\\theta)=(\\frac{\\partial l}{\\partial\\alpha},\\frac{\\partial l}{\\partial\\lambda})^T\\) 是梯度向量，\\(H(\\theta)\\)是Hesse矩阵: $$ g(\\theta)=\\begin{pmatrix}\\frac{\\partial l}{\\partial\\alpha}\\\\frac{\\partial l}{\\partial\\lambda }\\end{pmatrix}=\\begin{pmatrix} nlnλ−n\\frac{Γ(α)}{Γ′(α)}​+\\sum\\limits_{i=1}^{n} ​lnX_{i}​\\ \\frac{nα}{\\lambda}​−\\sum\\limits_{i=1}^{n} ​X_{i}​\\end{pmatrix} $$</p> \\[ H(\\theta)=\\begin{pmatrix}\\frac{\\partial^{2}l}{\\partial\\alpha^{2}}&amp;\\frac{\\partial^{2}l}{\\partial\\alpha\\partial\\lambda}\\\\\\frac{\\partial^{2}l}{\\partial\\lambda\\partial\\alpha}&amp;\\frac{\\partial^{2}l}{\\partial\\lambda^{2}}\\end{pmatrix}=\\begin{pmatrix} -n \\frac{\\Gamma''(\\alpha)\\Gamma(\\alpha)-(\\Gamma'(\\alpha)^{2})}{\\Gamma^{2}(\\alpha)}&amp;\\frac{n}{\\lambda}\\\\\\frac{n}{\\lambda}&amp;-\\frac{n\\alpha}{\\lambda^{2}} \\end{pmatrix} \\] <p>Fisher scoring算法：\\(\\theta_{K+1}=\\theta_{k}+I(\\theta_{k})^{-1}g(\\theta_{k})\\)</p> <p>其中\\(I(\\theta)=-E\\left[ H(\\theta) \\right]\\)，用样本估计的观测Fisher信息矩阵代替期望Fisher信息矩阵(矩阵中无与\\(X_{i}\\)有关的量，求期望不变)</p> <p>(b)</p> <p>[!NOTE] 随堂测试 例3.4.9(韦来生)设\\(X=(X_1,\\cdots,X_n)\\)为从 Poisson 分布\\(P(\\lambda)\\)中抽取的简单随机样本，求\\((1)g_1(\\lambda)=\\lambda;(2)g_2(\\lambda)=\\lambda^r,~r&gt;0\\)为自然数；\\((3)~g_3(\\lambda)=P_\\lambda(X_1=x)\\)的\\(UMVUE.\\)</p> <p><code>Sol.</code></p> <p>由 2.7 节和 2.8 节可知\\(T=T(\\boldsymbol{X})=\\sum_i=1^nX_i\\)为充分完全统计量</p> <p>(1)令\\(h_1(T)=T/n\\), \\(E(h_1(T))=E(\\overline{X})=\\lambda\\),故\\(h_1(T)\\)是充分完全统计量\\(T\\)的函数，且是\\(\\lambda\\)的无偏估计，故由 L-S 定理可知\\(h_1(T)\\)是\\(\\lambda\\)的UMVUE</p> <p>(2)由于\\(T\\sim P(n\\lambda)\\),令\\(h_2(T)\\)为\\(g_2(\\lambda)=\\lambda^r\\)的无偏估计，故有\\(E_\\lambda[h_2(T)]=g_2(\\lambda)\\),即</p> \\[\\sum_{t=0}^\\infty h_2(t)\\frac{e^{-n\\lambda}(n\\lambda)^t}{t!}=\\lambda^r.\\] <p>此式等价于</p> \\[\\sum_{t=0}^\\infty h_2(t)\\frac{n^t\\lambda^t}{t!}=\\lambda^re^{n\\lambda}.\\] <p>将上式右边作展开得</p> \\[\\lambda^re^{n\\lambda}=\\sum_{l=0}^\\infty\\frac{n^l\\lambda^{l+r}}{l!}=\\sum_{t=r}^\\infty\\frac{n^{t-r}\\lambda^t}{(t-r)!}.\\] <p>将其代入前一式右边得</p> \\[\\sum_{t=0}^\\infty h_2(t)\\frac{n^t\\lambda^t}{t!}=\\sum_{t=r}^\\infty\\frac{n^{t-r}\\lambda^t}{(t-r)!}.\\] <p>上述等式两边是\\(\\lambda\\)的幂级数，比较其系数得</p> \\[\\begin{aligned}&amp;h_{2}(t)=0,\\quad\\text{当 }t=0,1,\\cdots,r-1,\\\\&amp;h_{2}(t)=\\frac{t!\\:n^{t-r}}{(t-r)!n^t}=\\frac{t(t-1)\\cdots(t-r+1)}{n^r},\\quad\\text{当 }t=r,r+1,\\cdots.\\end{aligned}\\] <p>综合上述两式得</p> \\[h_2(T)=\\frac{T(T-1)\\cdots(T-r+1)}{n^r},\\] <p>为\\(g_2(\\lambda)=\\lambda^r\\)的无偏估计，\\(h_2(T)\\)是充分完全统计量\\(T\\)的函数，故由 L-S 定理可知\\(h_2(T)\\)为\\(g_2(\\lambda)\\)的 UMVUE</p> <p>(3)由\\(P_\\lambda(X_1=x)=e^{-\\lambda}\\lambda^x/x!\\),可见它是参数\\(\\lambda\\)的函数，故可用\\(g_3(\\lambda)\\)表示令\\(\\varphi(X_1)=I_[X_1=x]\\),则\\(E_\\lambda[\\varphi(X_1)]=P_\\lambda(X_1=x).\\)因此\\(\\varphi(X_1)\\)为\\(g_3(\\lambda)\\)的无偏估计. 注意到\\(T=T(\\boldsymbol X)=\\sum_i=1^nX_i\\sim P(n\\lambda)\\)和\\(\\sum_i=2^nX_i\\sim P((n-1)\\lambda)\\),故有</p> \\[h_3(t)=E(\\varphi(X_1)|T=t)=P_\\lambda(X_1=x|T=t)=\\frac{P_\\lambda(X_1=x,T=t)}{P_\\lambda(T=t)}$$ $$=\\frac{P_\\lambda(X_1=x)P_\\lambda(X_2+\\cdots+X_n=t-x)}{P_\\lambda(X_1+\\cdots+X_n=t)}=\\frac{(n-1)^{t-x}t!}{n^t(t-x)!x!}$$ $$=\\binom{t}{x}\\frac{(n-1)^{t-x}}{n^t}=\\binom{t}{x}\\Big(\\frac{1}{n}\\Big)^x\\Big(1-\\frac{1}{n}\\Big)^{t-x},\\quad t\\geqslant x.\\] <p>由引理 3.4.1 可知\\(h_3(T)\\)为\\(g_3(\\lambda)\\)的无偏估计，它又是充分完全统计量\\(T\\)的函数</p> <p>所以由 L-S 定理可知</p> \\[h_3(T)=\\begin{pmatrix}T\\\\x\\end{pmatrix}\\left(\\frac1n\\right)^x\\left(1-\\frac1n\\right)^{T-x}\\] <p>为\\(g_3(\\lambda)\\)的 UMVUE</p>","path":["点估计"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/","level":1,"title":"运筹与优化","text":"<p>[!tldr] 课程简介 所属大学：南开大学 主讲教师：顾然(Ran Gu) 先修要求：高等代数(线性代数)+数学分析(微积分) 课程难度：⭐⭐⭐ 预计学时：100h 给分情况：⭐⭐⭐ 考试难度：⭐⭐⭐ 备考策略：以作业为支撑集，大概80%~90%，实际上会有大量的作业原题(作业&gt;PPT)，掌握重要的基本算法的迭代方法基本就可以85+，但是老师和助教给分非常客观， 改多少就是多少，不会捞。 修读时间：Spring 25</p>","path":["运筹与优化"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/#_2","level":2,"title":"课程参考","text":"<ul> <li>参考书目<ul> <li>运筹学教程(第五版) 胡运权</li> <li>最优化理论与算法(第二版) 陈宝林</li> </ul> </li> <li>视频资源<ul> <li>中山大学运筹学</li> </ul> </li> </ul>","path":["运筹与优化"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/#_3","level":2,"title":"线性规划与目标规划","text":"<p>课程内容对应清华运筹教材的1-4章(其中包含基本的数学概念，凸集和凸函数的性质)，笔者会额外引入运输问题，表上作业法</p> <p>为了保证阅读的顺畅和内容的完整性，笔者将相关内容均放在一篇笔记内</p>","path":["运筹与优化"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/#_4","level":2,"title":"无约束问题","text":"<p>课程内容对应清华运筹教材的9-10章</p> <p>对于优化问题，最简单的显然是没有约束的情况，从这种简单的情况出发，为讨论有约束情况打下基础</p>","path":["运筹与优化"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/#lecture-structure","level":2,"title":"Lecture Structure","text":"<p>为了方便复习，也给出老师的讲授顺序供参考，下面是根据Slides名称给出的课程结构</p> <ul> <li>01运筹与优化简介√</li> <li>02数学知识与凸性</li> <li>03线性规划一</li> <li>04线性规划二<ul> <li>线性规划对偶课上习题</li> <li>线性规划灵敏度课上习题</li> </ul> </li> <li>05迭代法与一维搜索√</li> <li>06梯度法与共轭梯度法<ul> <li>梯度法与共轭梯度法课上习题</li> </ul> </li> <li>07牛顿法与拟牛顿法</li> <li>08无导数优化</li> <li>09约束最优化问题<ul> <li>最优性条件课上习题</li> </ul> </li> <li>10信赖域法与最小二乘<ul> <li>对偶课上习题</li> </ul> </li> </ul> <p>有约束情况不占主导(有常识性问题)，无约束情况为考察主体</p> <p>理论部分：</p> <ul> <li>凸分析，凸集，凸规划，凸集分离定理</li> <li>择一定理</li> <li>最优性条件(无约束条件)一阶和二阶(KKT条件)</li> </ul>","path":["运筹与优化"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/","level":1,"title":"无约束问题","text":"内容 重要性 描述和注 凸规划概念以及性质 ⭐⭐⭐ 主要掌握局部极值为全局极值 Fibonacci法和0.618法 ⭐⭐⭐⭐ 只需要掌握算法步骤应该就可以了 一维搜索 ⭐⭐⭐⭐ Armijo准则和Zoutendijk定理 最速下降法 ⭐⭐⭐⭐⭐ 相当重要的算法，机器学习的灵魂 共轭梯度法 ⭐⭐⭐⭐⭐ 思路很巧妙，除算法外还可以思考证明 拟牛顿法 ⭐⭐⭐⭐⭐ 掌握DFP,BFGS方法即可","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_2","level":2,"title":"基本概念","text":"<p>非线性规划问题的数学模型(同理线性规划，只是函数不再要求线性)</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_3","level":3,"title":"极值问题","text":"<ol> <li>局部极值和全局极值</li> <li>极值点存在的条件<ol> <li>必要条件：梯度为0</li> <li>充分条件：梯度为0且Hesse矩阵是半正定(半负定)</li> </ol> </li> <li>凸函数和凹函数(定义和性质)<ol> <li>凸函数的性质</li> <li>函数凸性的判定</li> </ol> </li> <li>凸函数的极值(极小值就是最小值)<ol> <li>凸函数的任一极小点就是它在\\(R\\)上的最小点，而且极小点集为凸集</li> <li>可微的凸函数，如果\\(\\exists X^{*}\\in R,\\forall X\\in R,\\nabla f(X^{*})^{T}(X-X^{*})\\geqslant 0\\)，则\\(X^{*}\\)是\\(f(X)\\)在\\(R\\)上的最小点</li> </ol> </li> </ol> <p>对于第三点中的性质与判定总结如下：</p> <p>[!NOTE] 凸函数简单性质 1. \\(f(x)\\)为定义在凸集\\(R\\)上的凸函数，则对于任意\\(\\beta\\in R&gt;0\\)，函数\\(\\beta f(x)\\)也是定义在\\(R\\)上的凸函数 2. \\(f_{1},f_{2}\\)为定义在凸集\\(R\\)上的凸函数，则\\(f=f_{1}+f_{2}\\)也是定义在\\(R\\)上的凸函数 3. \\(f(x)\\)为定义在凸集\\(R\\)上的凸函数，则对于任意\\(\\beta\\in R\\)，集合\\(S_{\\beta}\\left\\{ X|X\\in R,f(X)\\leqslant \\beta \\right\\}\\)是凸集(\\(S_{\\beta}\\)称为水平集)</p> <p>[!NOTE] 函数凸性的判定 显然可以利用定义直接判定，对于可微的凸函数也可以使用下面两个判定定理 1. 一阶条件 \\(R\\)为\\(E^{n}\\)上开凸集，\\(f(X)\\)在\\(R\\)上具有一阶连续偏导数，则\\(f(X)\\)为\\(R\\)上凸函数的充要条件是对任意\\(X^{(1)},X^{(2)}\\in R\\)，恒有\\(f(X^{(2)})\\geqslant f(X^{(1)})+\\nabla f(X^{(1)})^{T}(X^{(2)}-X^{(1)})\\) 2. 二阶条件 \\(R\\)为\\(E^{n}\\)上开凸集，\\(f(X)\\)在\\(R\\)上具有二阶连续偏导数，则\\(f(X)\\)为\\(R\\)上凸函数的充要条件是\\(f(X)\\)的Hessian矩阵\\(H(X)\\)在\\(R\\)上处处半正定</p> <p>凸函数的定义实际上是说凸函数两点间的线性插值不低于这个函数的值，而判定定理1则是说，基于某个点导数的线性近似不高于这个函数的值(几何意义的理解方式)</p> <p>可以证明若凸规划的可行域是凸集，局部最优解也是全局最优解，而且最优解的集合形成一个凸集，那么凸规划的目标函数为严格凸函数时，其最优解必定唯一(这一找到局部最优也就是全局最优)</p> <p>[!NOTE] Theorem 若\\(f(X)\\)是定义在凸集上的可微凸函数，若存在\\(X^{*}\\in R\\)，使得对于所有的\\(X\\in R\\)有\\(\\nabla f(X^{*})(X-X^{*})\\geqslant 0\\)，则\\(X^{*}\\)为\\(f(X)\\)在\\(R\\)上的最小点(全局极小值)</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#convex-planning","level":3,"title":"凸规划(convex planning)","text":"<p>[!important] Claim 凸的就是好的！</p> <p>凸规划是一类简单而又有重要意义的非线性规划(线性规划也是凸规划)</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_4","level":3,"title":"下降迭代算法","text":"<p>为了求某可微函数的最优解可以先使该函数的梯度为0，求得平稳点然后利用充分条件进行判定，对于简单函数这种方法是可行的，对于比较复杂的函数则不容易求解非线性方程组，可以直接使用迭代法.</p> <p>迭代法的基本思想是按照某种规划或算法找出比原解更好的解，得到一个序列然后用柯西收敛准则进行判定，由于计算机只能有限迭代所以达到一定精度后即可停止(注意算法需要给出一个初始估计值\\(X^{(0)}\\)).</p> <p>[!example] 一些基本定义 搜索方向：能够沿该方向使目标函数值有所下降 步长(步长因子)：沿着搜索方向移动的距离</p> <p>下降迭代算法的步骤：</p> <ol> <li>选定初始点</li> <li>确定搜索方向(最关键的一步)</li> <li>从初始点出发沿方向求步长产生下一个迭代点</li> <li>检查得到的新点是否为极小点或近似极小点</li> </ol> <p>注：各种算法的区分，主要是在于确定搜索方向的方法不同</p> <p>确定步长的方法：</p> <ul> <li>常数方法：定义为常数，无法保证目标函数值下降</li> <li>可接受点算法：只要能使目标函数下降就可以任意选取步长</li> <li>基于沿搜索方向使目标函数值下降最多，这一过程称为一维搜索或线搜索，确定的步长为最佳步长</li> </ul> <p>一维搜索的一个重要的性质就是：在搜索方向上所得最优点处的梯度和该搜索方向正交，归纳为下面的定理</p> <p>[!tip] Theorem 7 设\\(f(X)\\)有一阶连续偏导数，\\(X^{(k+1)}\\)按下列规则迭代： \\(\\lambda_{k}:\\min f(X^{(k)}+\\lambda P^{(k)}),X^{(k+1)}=X^{(k)}+\\lambda_{k}P^{(k)}\\) 则有\\(\\nabla f(X^{(k+1)})^{T}P^{(k)}=0\\)</p> <p><code>Proof.</code></p> <p>简单证明一下，构造函数\\(\\phi(\\lambda)=f(X^{(k)}+\\lambda P^{(k)})\\)，那么有\\(\\phi'(\\lambda_{k})=0\\)(一阶条件)，代入函数为\\(\\nabla f(X^{(k)}+\\lambda_{k}P^{(k)})^{T}P^{(k)}=\\nabla f(X^{(k+1)})^{T}P^{(k)}=0\\)</p> <p>下面讨论算法的收敛速度</p> <p>若是序列\\(\\left\\{ X^{(k)} \\right\\}\\)收敛于\\(X^{*}\\)，存在与迭代次数无关的数\\(0&lt;\\beta&lt;\\infty\\)和\\(\\alpha \\geqslant 1\\)，使得K从某个\\(k_{0}&gt;0\\)开始，都有</p> \\[ \\lVert X^{(k+1)}-X^{*} \\rVert \\leqslant \\beta \\lVert X^{(k)}-X^{*} \\rVert ^{\\alpha} \\] <p>就称\\(\\left\\{ X^{(k)} \\right\\}\\)收敛的阶为\\(\\alpha\\)，或是\\(\\alpha\\)阶收敛</p> <ul> <li>\\(\\alpha=2\\)称为二阶收敛，也可说具有二阶敛速</li> <li>\\(\\alpha&gt;1\\)称为超线性收敛</li> <li>\\(\\alpha=1\\)，且\\(0&lt;\\beta&lt;1\\)称线性收敛或一阶收敛</li> <li>\\(\\alpha=1,\\beta=1\\)称为次线性收敛</li> </ul> <p>注：就是一些概念而已，类似Lipschitz条件</p> <p>还需要决定什么时候停止计算</p> <p>常用的终止计算准则(\\(\\varepsilon_{i}\\)为事先给定的足够小的正数)：</p> <ol> <li>根据相继两次迭代的绝对误差：\\(\\lvert X^{(k+1)}-X^{(k)} \\rvert&lt;\\varepsilon_{1}\\)</li> <li>根据相继两次迭代的相对误差：\\(\\frac{\\lvert X^{(k+1)}-X^{(k)} \\rvert}{\\lvert X^{(k)} \\rvert}&lt; \\varepsilon_{3}\\)，这时要求分母不接近于0</li> <li>根据目标函数梯度的模足够小：\\(\\lvert \\nabla f(X^{(k)}) \\rvert&lt;\\varepsilon_{5}\\)</li> </ol>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_5","level":2,"title":"一维搜索","text":"<p>常用的一维搜索方法</p> <ul> <li>试探法(\"斐波那契法\"，0.618法)</li> <li>插值法(抛物线插值法，三次插值法)</li> <li>微积分中的求根法(切线法，二分法)</li> </ul> <p>注：以下的两种方法Fibonacci法和0.618法都需要在单峰函数的条件下使用否则可能会收敛到错误的位置(错误收敛).</p> <p>补充单峰函数的定义(这在图形上是显然的)：</p> <p>[!NOTE] 单峰函数 \\(f\\)是定义在\\(\\left[ a,b \\right]\\)上的一元实函数，\\(\\overline{x}\\)是\\(f\\)在\\(\\left[ a,b \\right]\\)上的极小点，并且对任意的\\(x^{(1)},x^{(2)}\\in \\left[ a,b \\right],x^{(1)}&lt;x^{(2)}\\)，有\\(x^{(2)}\\leqslant \\overline{x},f(x^{(1)})&gt;f(x^{(2)})\\),\\(x^{(1)}\\geqslant \\overline{x},f(x^{(1)})&lt;f(x^{(2)})\\)</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#fibonacci","level":3,"title":"Fibonacci法","text":"<p>算法原理(考虑单峰函数)：</p> <ul> <li>内部取两个点划分区间</li> <li>判断两点函数值大小重新确认区间</li> <li>继续搜索</li> </ul> <p>实际就是通过不断缩短区间长度达到即使在区间内反复摆动也可以达到比较好的近似极值点的效果</p> <p>[!question] 缩短率与计算次数的关系 计算函数值\\(n\\)次，能把包含极小点的区间缩小到什么程度?计算\\(n\\)次可以把原本多大的区间缩小为一个单位长度的区间.</p> <p>这种方法迭代n次的缩短率符合Fibonacci数列的值记第n次迭代值为\\(F_{n}\\)</p> <p>那么如果要使迭代n次后的长度缩短为原本长度的\\(\\delta\\)倍(中文上语病忽略)，只需要保证\\(F_{n}\\geqslant \\frac{1}{\\delta}\\)</p> <p>缩短区间的步骤：</p> <ol> <li>确定试点的个数\\(n\\)，简单根据Fabonacci数列的值即可得到</li> <li>选取前两个试点的位置</li> <li>\\(t_{1}=a_{0}+ \\frac{F_{n-2}}{F_{n}}(b_{1}-a_{1})=b_{0}+\\frac{F_{n-1}}{F_{n}}(a_{0}-b_{0})\\)</li> <li>\\(t_{1}'=a_{0}+ \\frac{F_{n-1}}{F_{n}}(b_{0}-a_{0})\\)</li> <li>计算两个函数值比较大小</li> <li>计算新的点函数值然后迭代 </li> </ol> <p>可以画一个简单的图表示点的复用关系</p> <p></p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#0618","level":3,"title":"0.618法(黄金分割法)","text":"<p>实际上就是Fibonacci方法的比值求极限得到黄金分割比，然后利用黄金分割点的内生性就可以增加选取点和分割区间的效率(数学文化的含金量还在上升)</p> <p>不管是黄金分割法还是Fibonacci法，选取的点基本都被复用过，这样就提高了效率减少了成本：不要浪费！</p> <p>其他的一些方法：</p> <ul> <li>二分法</li> <li>牛顿法<ul> <li>在极小点附近用二阶泰勒展开逼近得到估计</li> <li>一直利用切线迭代即可</li> </ul> </li> <li>割线法</li> <li>抛物线法</li> <li>两点三次插值法</li> </ul> <p>[!tip] 信息和算法 已知信息的多少会决定算法的复杂度和算法效率，所以笔者想到了一些优化方向： + 少信息如何达到基本的精度和效率？ + 多信息怎么达到最高的效率？</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_6","level":3,"title":"牛顿法","text":"<p>基本思想：在极小点附近用二阶Talor多项式近似目标函数\\(f(x)\\)，进而求出极小点的估计值</p> \\[ \\min f(X)\\ x\\in \\mathbb{R}^{1} \\] <p>令</p> \\[ \\phi(x)=f(x^{(k)})+f'(x^{(k)})(x-x^{(k)})+ \\frac{1}{2}f''(x^{(k)})(x-x^{(k)})^{2} \\] <p>求导得</p> \\[ \\begin{aligned} \\phi'(x)&amp;=f'(x^{(k)})+f''(x^{(k)})(x-x^{(k)})=0\\\\ x^{(k+1)}&amp;=x^{(k)}- \\frac{f'(x^{(k)})}{f''(x^{(k)})} \\end{aligned} \\] <p>[!NOTE] 牛顿法(算法步骤) (1) 给定初点\\(x^{(0)}\\)，允许误差\\(\\varepsilon&gt;0,k=0\\) (2) 若\\(\\lvert f'(x^{(k)}) \\rvert&lt;\\varepsilon\\)，则停止迭代，得到\\(x^{(k)}\\) (3) 计算点\\(x^{(k+1)}\\)</p> \\[x^{(k+1)}=x^{(k)}- \\frac{f'(x^{(k)})}{f''(x^{(k)})},k=k+1 \\] <p>牛顿法的收敛速度和收敛性受初始点选择的影响较大，如果初始点选择的很接近目标函数极小值点那么收敛的会很快，反之不一定收敛</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_7","level":3,"title":"割线法","text":"\\[ \\phi(x)=f'(x^{(k)})+ \\frac{f'(x^{(k)})-f'(x^{(k-1)})}{x^{(k)}-x^{(k-1)}}(x-x^{(k)})=0 \\] <p>如图所示：</p> <p></p> <pre><code>def secant_method(f, x0, x1, iterations):\n    \"\"\"Return the root calculated using the secant method.\"\"\"\n    for i in range(iterations):\n        x2 = x1 - f(x1) * (x1 - x0) / float(f(x1) - f(x0))\n        x0, x1 = x1, x2\n        # Apply a stopping criterion here (see below)\n    return x2\n\ndef f_example(x):\n    return x ** 2 - 612\n\nroot = secant_method(f_example, 10, 30, 5)\n\nprint(f\"Root: {root}\")  # Root: 24.738633748750722\n</code></pre> <p>相比于牛顿法来说收敛速度比较慢，但是不需要计算二阶导数，缺点就是和牛顿法一样也不具有全局收敛性，如果初始点选择的不好可能不收敛</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_8","level":3,"title":"抛物线法","text":"<p>基本思想是在极小点附近用二次三项式\\(\\phi(x)\\)逼近目标函数\\(f(x)\\)，令\\(\\phi(x),f(x)\\)在三个点处具有相同的函数值并且还具有以下关系：</p> \\[ f(x^{1})&gt;f(x^{2}),f(x^{2})&lt;f(x^{3});x^{1}&lt;x^{2}&lt;x^{3} \\] <p>那么为了求\\(\\phi(x)\\)的极小点，令\\(\\phi'(x)=b+2cx=0,x= - \\frac{b}{2c}\\)</p> <p>插值法的原理比较多，也比较复杂但是并不是很难可以自己参考资料(可以参考JLU的一本数值分析初步)</p> <p>以下是补充的内容，考试不做要求</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#alpha_k","level":2,"title":"\\(\\alpha_{k}\\)的选取","text":"","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_9","level":3,"title":"精确线搜索算法","text":"<p>首先构造一元辅助函数(\\(d^{k}\\)是给定的下降方向)</p> \\[ \\phi(\\alpha)=f(x^{k}+\\alpha d^{k}) \\] <p>线搜索的目标是选取合适的步长使得\\(\\phi(\\alpha_{k})\\)尽可能减小，也就是</p> <ul> <li>\\(\\alpha _k\\)应该使得\\(f\\)充分下降</li> <li>不应在寻找\\(\\alpha_{k}\\)上花费过多的计算量(由于这一点精确线搜索实际使用较少)</li> </ul> <p>自然的想法就是寻找\\(\\alpha_{k}\\)，使得\\(\\alpha_{k}=arg\\min\\limits_{\\alpha&gt;0}\\phi(\\alpha)\\)</p> <p>那么这就是解析的最佳的步长，这种线搜索算法就称为精确线搜索算法</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_10","level":3,"title":"非精确线搜索算法","text":"<p>如果不要求最小仅要求满足某些不等式约束条件，这种线搜索方法就称为非精确线搜索算法，选取\\(\\alpha_{k}\\)需要满足的要求被称为线搜索准则，线搜索准则的合适与否直接决定了算法的收敛性。</p> <ul> <li>Armijo准则</li> <li>Goldstein准则</li> <li>Wolfe准则</li> <li>Zoutendijk定理</li> </ul> <p>为了保证每一步的迭代充分下降引入下面的Armijo准则，这也是最基本的一个准则.</p> <p>[!tip] Armijo准则 设\\(d^{k}\\)是点\\(x^{k}\\)的下降方向，若</p> \\[f(x^{k}+\\alpha d^{k})\\leqslant f(x^{k})+c_{1}\\alpha \\nabla f(x^{k})^{T}d^{k}\\] <p>则称步长\\(\\alpha\\)满足Armoji准则，其中\\(c_{1}\\in(0,1)\\)是一个常数</p> <p>为了克服Armijo准则的缺陷需要引入其他准则保证每一步的\\(\\alpha^{k}\\)不会太小，并且需要配合其他准则保证迭代的收敛性，因为\\(\\alpha=0\\)显然是满足条件的，但是此时迭代点不变</p> <p>[!example] 回退法 给定初值后，通过不断以指数方式缩小试探步长，找出第一个满足Armijo准则的点，回退法选取\\(\\alpha_{k}=\\gamma^{j_{0}} \\hat{\\alpha}\\) 这种算法称为回退法是因为它的实验值由大至小，保证输出的\\(\\alpha_{k}\\)尽可能的大，并且由于下降方向是给定的，当\\(\\alpha\\)充分小时一定会满足Armijo准则，也就确保了算法一定会终止 实际应用中也会给\\(\\alpha\\)设定一个下界，防止步长过小</p> <p>Armoji准则只要求\\(\\left( \\alpha,\\phi(\\alpha) \\right)\\)必须处在某直线下方，我们也可使用相同的形式使得该点必须处在另一条直线的上方，这就是Armijo-Goldstein准则(Goldstein准则)</p> <p>[!NOTE] Goldstein准则 设\\(d^{k}\\)是点\\(x^{k}\\)的下降方向，若</p> \\[\\begin{aligned} f(x^{k}+\\alpha d^{l})&amp;\\leqslant f(x^{k})+c\\alpha \\nabla f(x^{k})^{T}d^{k}\\\\ f(x^{k}+\\alpha d^{l})&amp;\\geqslant f(x^{k})+(1-c)\\alpha \\nabla f(x^{k})^{T}d^{k} \\end{aligned}\\] <p>则称步长\\(\\alpha\\)满足Goldstein准则，其中\\(c\\in\\left( 0, \\frac{1}{2} \\right)\\)是一个常数</p> <p>Goldstein准则也有直观的几何含义，指的是\\(\\left( \\alpha,\\phi(\\alpha) \\right)\\)必须在两条直线之间，这种做法就可以去掉一些过小的\\(\\alpha\\)</p> <p>需要指出Goldstein准则能够使得函数值充分下降但是也可能避开了最优的函数值(考虑单峰函数即可举出例子)，这引导我们给出新的Wolfe准则：</p> <ul> <li>第一条就是Armijo准则</li> <li>第二个不等式是Wolfe准则的本质要求，也称为曲率条件(实际上就是\\(\\phi'(\\alpha)\\geqslant c_{2}\\phi'(0)\\))，这保证步长不会过小，因为原本的导数希望是负数(选取的是下降方向，想想下降方向的定义呢)，所以为了逼近0就可以进行放大。实际上这种做法可以改进，使得斜率必须增大的同时，也使得无法增加的特别大(可能使得步长过于宽松导致错过最优解，保证收敛的平稳性)，因此还有加强版本的Wolfe准则曲率条件：\\(\\lvert \\phi'(\\alpha) \\rvert \\leqslant c_{2}\\lvert \\phi'(0) \\rvert)\\)</li> </ul> <p>这个部分知乎有一篇笔记我认为写的很清楚</p> <p>[!tip] Wolfe准则 设\\(d^{k}\\)是点\\(x^{k}\\)的下降方向，若</p> \\[\\begin{aligned} f(x^{k}+\\alpha d^{l})&amp;\\leqslant f(x^{k})+c_{1}\\alpha \\nabla f(x^{k})^{T}d^{k}\\\\ \\nabla f(x^{k}+\\alpha d^{l})^{T}d^{k}&amp;\\geqslant c_{2}\\nabla f(x^{k})^{T}d^{k} \\end{aligned}\\] <p>则称步长\\(\\alpha\\)满足Wolfe准则，其中\\(c_{1},c_{2}\\in\\left( 0, 1\\right)\\)是常数且\\(c_{1}&lt;c_{2}\\)</p> <p>由于极小值点满足Wolfe准则，永远满足条件2，而选择较小的\\(c_{1}\\)可以使得满足条件1，那么在大多数情况下使用Wolfe准则会包含线搜索子问题的精确解</p> <p>这里的Wolfe条件包含有强Wolfe条件和弱Wolfe条件</p> <p>[!NOTE] Zoutendijk定理 考虑一般的迭代格式：\\(x^{k+1}=x^{k}+\\alpha_{k}d^{k}\\)，其中\\(d^{k}\\)是搜索方向，\\(\\alpha_{k}\\)是步长，而且满足Wolfe准则，假设目标函数下有界，连续可微并且梯度满足Lipschitz连续：\\(\\lVert \\nabla f(x)-\\nabla f(y) \\rVert\\leqslant L\\lVert x-y \\rVert,\\forall x,y\\in \\mathbb{R}^{n}\\) 那么</p> \\[\\sum\\limits_{k=0}^{\\infty} \\cos ^{2}\\theta_{k}\\lVert \\nabla f(x^{k}) \\rVert ^{2}&lt;+\\infty\\] <p>其中\\(\\cos\\theta_{k}\\)是负梯度\\(-\\nabla f(x^{k})\\)和下降方向\\(d^{k}\\)夹角的余弦，即</p> \\[\\cos\\theta_{k}= \\frac{-\\nabla f(x^{k})^{T}d^{k}}{\\lVert \\nabla f(x^{k}) \\rVert \\lVert d^{k} \\rVert }\\] <p>这个不等式也被称为Zoutendijk条件</p> <p>注1：根据Zoutendijk条件即可得到成立时应当有\\(\\lim\\limits_{ k\\to \\infty }\\nabla f(x^{k})=0\\)，线搜索算法收敛性建立在Zoutendijk条件之上，本质要求是下降方向与负梯度方向不趋于正交，几何直观上就是如果趋于正交Tarlor展开后函数值几乎不变，所以要求\\(d^{k}\\)与梯度正交方向夹角有一致下界</p> <p>注2： 该部分主要注意Armijo准则和Zoutendijk条件即可</p> <p>注3：对于收敛性算法和收敛性分析其实是笔者比较感兴趣的问题，希望有机会能再补充一门数值计算课(可能会选计算数学那边的课或者自己看书)，并且渐进理论也是统计上很重要的一个方向.</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_11","level":2,"title":"无约束极值问题的解法","text":"<p>本节研究无约束极值问题</p> \\[ \\min f(X)\\ x\\in E^{n} \\] <p>求解上述问题常使用迭代法，可分为两类</p> <ul> <li>利用函数的一阶或二阶导数，用到了函数的解析性质，称为解析法</li> <li>仅用到函数值不用到解析性质那么称为直接法</li> </ul> <p>本章介绍几种常用的基本方法，前三种为解析法，后一种属于直接法</p> <p>参考资料： 1. 机器学习之数学(博客园) 2. 最速下降法的简洁原理介绍</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_12","level":3,"title":"梯度法(最速下降法)","text":"","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_13","level":4,"title":"梯度法的基本原理","text":"<p>梯度下降法(Gradient descent)，顾名思义，就是自变量沿着梯度向量的反方向进行移动，因为梯度的方向是上升的方向，负梯度方向就是下降最快的方向.</p> <p>通过在负梯度方向的一维搜索，来确定使\\(f(X)\\)最小的\\(\\lambda_{k}\\)，这种梯度法就是所谓的最速下降法。</p> <p>下面给出计算步骤：</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_14","level":4,"title":"计算步骤","text":"<ol> <li>给定初始近似点和精度要求，如果精度满足，即为近似极小点</li> <li>若是不满足，求步长，计算下个迭代点，求步长的方法可用精确线搜索(最佳步长)，或非精确线搜索</li> <li>一般的，如此迭代直到找到符合条件的近似解</li> </ol> <p>若是\\(f(X)\\)具有二阶连续偏导数，那么在\\(X^{(k)}\\)作泰勒展开就可以近似：</p> \\[ \\begin{aligned} f(X^{(k)}-\\lambda \\nabla f(X^{(k)}))\\approx f(X^{(k)})-\\nabla f(X^{(k)})^{T}\\lambda \\nabla f(X^{(k)})\\\\ +\\frac{1}{2}\\lambda\\nabla f(X^{(k)})^{T}H(X^{(k)}) \\nabla f(X^{(k)}) \\end{aligned} \\] <p>那么可以对\\(\\lambda\\)求导使得等于0，得到近似的最佳步长</p> \\[ \\lambda_{k}=\\frac{\\nabla f(X^{(k)})^{T} \\nabla f(X^{(k)})}{\\nabla f(X^{(k)})^{T}H(X^{(k)}) \\nabla f(X^{(k)})} \\]","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_15","level":4,"title":"最速下降法算法","text":"<p>最速下降法(Steepest descent)是梯度下降法的一种更具体实现形式，其理念为在每次迭代中选择合适的步长\\(\\alpha_{k}\\)，使得目标函数值能够得到最大程度的减少。</p> <p>每一次迭代都在梯度的反方向，我们总可以找到一个新的点使得在这个方向上达到最小值，也就是方向与步长都达到最优(局部上).</p> <p>注：每次迭代的路径与上一次垂直，并且如果梯度不等于0下一次迭代必定下降</p> <p></p> <p>[!NOTE] 最速下降法(算法) Step 1 给出\\(x_{1}\\in \\mathbb{R}^{n},0\\leqslant \\varepsilon \\ll 1,k:=1\\) Step 2 \\(d_{k}=-\\nabla f(x_{k}),\\lVert d_{k} \\rVert_{2}\\leqslant \\varepsilon\\)停止 Step 3 利用精确线搜索\\(\\alpha_{k}&gt;0\\),\\(f(x_{k}+\\alpha_{k}d_{k})=\\min\\limits_{\\alpha&gt;0}f(x_{k}+\\alpha d_{k})\\) Step 4 \\(x_{k+1}=x_{k}+\\alpha_{k} d_{k},k:=k+1\\)，回到2</p> <p>注：\\(\\alpha_{k}\\)为步长，在深度学习中被称为学习率(learning rate)，控制了梯度下降速度的快慢.</p> <p>理解一个算法最好还是依靠例子进行实操：</p> <p>[!example] 使用梯度法 求\\(f(X)=(x_{1}-1)^{2}+(x_{2}-1)^{2}\\)的极小点，\\(\\varepsilon=0.1\\)</p> <p><code>Sol.</code></p> <p>取初始点\\(X^{(0)}=(0,0)^{T}\\)</p> <p>那么\\(\\nabla f(X)=\\left[ 2(x_{1}-1),2(x_{2}-1) \\right]^{T}\\)，\\(\\nabla f(X^{(0)})=(-2,-2)^{T}\\)</p> <p>还有\\(\\lVert \\nabla f(X^{(0)}) \\rVert^{2}=\\left( \\sqrt{ (-2)^{2}+(-2)^{2} } \\right)^{2}=8&gt;\\varepsilon\\)</p> \\[ H(X)=\\begin{pmatrix} 2 &amp; 0 \\\\ 0 &amp; 2 \\end{pmatrix} \\] \\[ \\begin{aligned} \\lambda_{k}&amp;=\\frac{\\nabla f(X^{(k)})^{T} \\nabla f(X^{(k)})}{\\nabla f(X^{(k)})^{T}H(X^{(k)}) \\nabla f(X^{(k)})}\\\\ &amp;=\\frac{(-2,-2)(-2,-2)^{T}}{(-2,-2)\\begin{pmatrix} 2 &amp; 0 \\\\ 0 &amp; 2  \\end{pmatrix}(-2,-2)^{T}}\\\\ &amp;=\\frac{1}{2} \\end{aligned} \\] \\[ X^{(1)}=X^{(0)}-\\lambda_{0}\\nabla f(X^{(0)})=\\begin{pmatrix} 0 \\\\ 0  \\end{pmatrix}-\\frac{1}{2}\\begin{pmatrix} -2 \\\\ -2 \\end{pmatrix}=\\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}\\implies \\nabla f(X^{(1)})=\\mathbf{0} \\] <p>求解完毕</p> <p>需要注意的是如果确定了步长，那么不一定收敛，迭代点可能会出现来回震荡的问题，所以必须不断减少步长的值</p> <p>注1：由于负梯度方向的最速下降性，容易被误以为负梯度方向是理想的搜索方向，但是实际上\\(X\\)点处的负梯度方向在局部上才具有那种最速下降的性质，如果在全局上(对于整个极小化过程来说)则不一定.</p> <p>注2：有时用最速下降法趋近极小点时，其搜索路径呈直角锯齿状，在开头几步，目标函数值下降较快，但接近极小点\\(X^{*}\\)时，收敛速度就不理想了.特别是当目标函数的等值线椭圆比较扁平时，收敛速度就更慢了.因此，在实用中，常将梯度法和其他方法联合起来应用，在前期使用梯度法，而在接近极小点时，则使用收敛较快的其他方法.</p> <p>注3：机器学习中的梯度下降法，梯度下降法和反向传播算法是深度学习的基石，我们用梯度下降法更新神经网络的参数，用反向传播算法一层一层地将误差由后向前传播</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#conjugate-gradient-method","level":3,"title":"共轭梯度法(Conjugate gradient method)","text":"<p>参考资料</p> <ul> <li>共轭梯度法(Conjugate Gradient Method)</li> </ul> <p>下面给出一些基本的定义：</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_16","level":4,"title":"共轭方向","text":"<p>\\(X,Y\\)是\\(\\mathbb{R}^{n}\\)中的两个向量，若有\\(X^{T}Y=0\\)，就称\\(X,Y\\)正交</p> <p>推广正交到共轭，再设\\(A\\)为\\(n\\times n\\)的正定阵，那么如果\\(X,AY\\)正交有</p> \\[ X^{T}AT=0 \\] <p>则称\\(X,Y\\)关于\\(A\\)共轭.</p> <p>注：如果\\(A=I\\)，则上述条件即为通常的正交.</p> <p>下面是共轭的一个小的性质：</p> <p>[!NOTE] 定理(共轭独立) \\(A\\)为\\(n\\times n\\)正定阵，\\(P^{1},P^{2},\\dots,P^{n}\\)为\\(A\\)共轭的非零向量，那么这组向量线性无关</p> <p><code>Proof.</code></p> <p>按照定义写出线性表达式，然后利用共轭乘上其中任意一个向量与\\(A\\)的乘积，\\(\\left( P^{i} \\right)^{T}A\\)，根据共轭可知\\(\\alpha_{i}=0\\)，循环使用得线性无关.</p> <p>考虑无约束极值问题的一个特殊情形：</p> \\[ \\min f(X)= \\frac{1}{2}X^{T}AX+B^{T}X+c \\] <p>其中A为对称正定阵，\\(X,B\\in E^{n},c\\in \\mathbb{R}\\)</p> <p>上面的问题也被称为正定二次函数极小问题，在整个最优化问题中起着极其重要的作用</p> <p>对于这个问题有一个很有用的定理</p> <p>[!NOTE] 二次终止定理 设向量\\(P_{i},i=0,\\dots,n-1\\)为A的共轭，从任一点\\(X^{(0)}\\)出发分别以\\(P^{(0)},P^{(1)},\\dots,P^{(n-1)}\\)为搜索方向的算法，经过n次一维搜索收敛于问题的极小点</p> <p><code>Proof.</code></p> <p>\\(\\nabla f(X)=AX+B\\)，设每次搜索后得到的近似解为\\(X^{(1)},\\dots,X^{(n)}\\)，相继代入算法方程可知：</p> \\[ \\nabla f(X^{(n)})=\\nabla f(X^{(k+1)})+\\lambda_{k+1}AP^{(k+1)}+\\dots\\lambda_{n-1}AP^{(n-1)} \\] <p>由于一维搜索时为了确定最佳步长有\\(\\nabla f(X^{(k+1)})P^{(k)}=0\\)</p> \\[ \\begin{aligned} (P^{(k)})^{T}\\nabla f(X^{(n)})&amp;=(P^{(k)})^{T}\\nabla f(X^{(k+1)})+\\lambda_{k+1}(P^{(k)})^{T}AP^{(k+1)}+\\dots\\lambda_{n-1}(P^{(k)})^{T}AP^{(n-1)}\\\\ &amp;=0 \\end{aligned} \\] <p>从而可知\\(\\nabla f(X^{(n)})=0\\)</p> <p>十分巧妙的利用最优步长的方程式代入化简递推式</p> <p>注：任一初始点的条件十分强大，因为推导过程中由于共轭的性质将所有的项全部归为0了，收敛速度与初始点无关，并且一定会收敛！</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_17","level":4,"title":"正定二次函数的共轭梯度法","text":"<p>由于\\(A\\)对称正定阵，存在唯一极小点，若是已知某共轭向量组可以利用上述定理求得极小点，这就是共轭梯度法</p> \\[ \\left\\{ \\begin{matrix} X^{(k+1)}=X^{(k)}+\\lambda_{k}P^{(k)} \\\\ \\lambda_{k}:\\min\\limits_{\\lambda} f(X^{(k)}+\\lambda P^{(k)}) \\\\ X^{(n)}=X^{*} \\end{matrix} \\right. \\] <p>下面开始详细解释共轭梯度法的过程和公式推导的过程：</p> <p>注：一个重要的迭代条件是\\(\\nabla f(X)=AX+B\\implies\\)</p> \\[ \\nabla f(X^{(k+1)})-\\nabla f(X^{(k)})=A(X^{(k+1)}-X^{(k)}) \\] <p>但是\\(X^{(k+1)}=X^{(k)}+\\lambda_{k}P^{(k)}\\implies \\nabla f(X^{(k+1)})-\\nabla f(X^{(k)})=\\lambda_{k}AP^{(k)}\\)</p> <ol> <li>任取初始近似点，并以该点的负梯度方向为搜索方向也就是\\(P^{(0)}=-\\nabla f(X^{(0)})\\)</li> <li>进行一维搜索，沿着\\(X^{(0)}+\\lambda P^{(0)}\\)，算出\\(\\nabla f(X^{(1)})\\)，根据原本的共轭性质得到\\(\\nabla f(X^{(1)})^{T}P^{(0)}=-\\nabla f(X^{(1)})^{T}\\nabla f(X^{(0)})=0\\)，从而可知正交</li> <li>不同迭代点的梯度构成正交系，于是可以在它们生成的二维子空间内寻找\\(P^{(1)}=-\\nabla f(X^{(1)})+\\alpha_{0}\\nabla f(X^{(0)})\\)</li> </ol> <p>注：为了满足正交的条件也就是需要满足方程组：</p> \\[ \\left[ -\\nabla f(X^{(1)})+\\alpha_{0}\\nabla f(X^{(0)}) \\right] ^{T}\\left[  \\nabla f(X^{(1)})-\\nabla f(X^{(0)}) \\right] =0 \\] <p>方便起见令\\(\\beta_{0}=-\\alpha_{0}= \\frac{\\nabla f(X^{(1)})^{T}\\nabla f(X^{(1)})}{\\nabla f(X^{(0)})^{T}\\nabla f(X^{(0)})}\\)</p> \\[ P^{(1)}=-\\nabla f(X^{(1)})+\\beta_{0}P^{(0)} \\] <ol> <li>下面的过程类似，同样是正交系，在子空间内找下一个共轭的向量，然后继续推导迭代点的梯度</li> </ol> <p>一直迭代就可以得到一般的共轭梯度法计算公式：</p> \\[ \\left\\{ \\begin{matrix} X^{(k+1)}&amp;=&amp;X^{(k)}+\\lambda_{k}P^{(k)} \\\\ \\lambda_{k}&amp;=&amp;- \\frac{\\nabla f(X^{(k)})^{T}P^{(k)}}{(P^{(k)})^{T}AP^{(k)}} \\\\ P^{(k+1)}&amp;=&amp;-\\nabla f(X^{(k+1)})+\\beta_{k}P^{(k)} \\\\ \\beta_{k}&amp;= &amp;\\frac{\\nabla f(X^{(k+1)})^{T}\\nabla f(X^{(k+1)})}{\\nabla f(X^{(k)})^{T}\\nabla f(X^{(k)})} \\\\ k&amp;=&amp;0,1,2\\dots,n-1 \\end{matrix} \\right. \\]","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_18","level":4,"title":"计算步骤","text":"<ol> <li>选择初始近似，给出允许误差</li> <li>计算共轭向量，导出下一个迭代点，计算步长可以使用一维搜索法</li> <li>继续迭代下一个近似点</li> <li>若是梯度模平方小于允许误差就停止,否则回到3</li> </ol> <p>注：理论上二次函数只要迭代n次一定可以找到极小点，但是实际计算中由于数据的舍入和计算误差积累往往不能达到，但是维数最大到n继续迭代没有意义，那么就应当以\\(X^{(n)}\\)作为新的初始近似，重新开始迭代.</p> <p>理论总是比较枯燥的，下面给出一个实例：</p> <p>[!example] 试用共轭梯度法求下述二次函数的极小点 $\\(f(X)= \\frac{3}{2}x_{1}^{2}+ \\frac{1}{2}x_{2}^{2}-x_{1}x_{2}-2x_{1}\\)$</p> <p><code>Sol.</code></p> <p>化为\\(f(X)= \\frac{1}{2}X^{T}AX+B^{T}X+c\\)的形式：</p> \\[ A=\\begin{pmatrix} 3 &amp; -1 \\\\ -1 &amp; 1 \\end{pmatrix} \\] <p>\\(X^{(0)}=(-2,4)^{T},\\nabla f(X)=\\left[ (3x_{1}-x_{2}-2),(x_{2}-x_{1}) \\right]^{T},\\nabla f(X^{(0)})=(-12,6)^{T}\\)</p> <p>可以得到\\(\\lambda_{0}= - \\frac{\\nabla f(X^{(0)})^{T}P^{(0)}}{(P^{(0)})^{T}AP^{(0)}},P^{(0)}=-\\nabla f(X^{(0)})\\)</p> <p>然后\\(X^{(1)}=X^{(0)}+\\lambda_{0}P^{(0)},\\beta_{0}= \\frac{\\nabla f(X^{(1)})^{T}\\nabla f(X^{(1)})}{\\nabla f(X^{(0)})^{T}\\nabla f(X^{(0)})}\\)，继续迭代即可</p> <p>注：为了掌握这种方法，建议还是多做一些练习</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_19","level":4,"title":"非二次函数的共轭梯度法","text":"<p>这种不规整的问题往往采用的都是化归方法，将复杂问题转化为我们研究过的比较简单的问题，也就是在迭代点附近做二阶的泰勒展开，就可以当作二次函数做了.</p> <p>对于一般的非二次函数，共轭梯度法的计算依然适用，公式同理</p> <p>一般非二次函数使共轭性遭受破坏，因而要以\\(n\\)步迭代取得终止常常是不可能的。所以在实际应用时，如迭代步数\\(k\\leqslant n\\)已达到要求的精度，则以\\(X(k)\\)作为要求的近似解。否则可将前n步作为一个循环，同时以所得到的\\(X(n)\\)作为新的初始近似重新开始，进行第二个循环。重复进行，直至满足要求的精度为止。 </p> <p>注1：有趣的拓展，关于共轭梯度法还有许多不同的公式，例如Fletcher-Reeves公式、Dai-Yuan公式等(四个方法)，四个方法可通过两个分子分母的组合得到，另一个重要的共轭梯度法PRP方法，在实际中表现比Fletcher-Reeves方法好得多.</p> <p>注2：这里的拓展可以深挖，主要是不同的\\(\\beta_{k}\\)的问题，其中的原理可以查阅相关的参考文献</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_20","level":3,"title":"牛顿法与拟牛顿法","text":"<p>拟牛顿法是近30多年来发展起来的，它是求解无约束极值问题的一种有效方法。由于它既避免了计算二阶导数矩阵及其求逆过程，又比梯度法的收敛速度快，特别是对高维问题具有显著的优越性，因而使变尺度法获得了很高的声誉，至今仍被公认为求解无约束极值问题最有效的算法之一</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_21","level":4,"title":"牛顿法原理","text":"<p>假定无约束极值问题的目标函数二阶可求偏导，\\(X^{(k)}\\)为其极小点的某一近似，在这个点附近取\\(f(X)\\)的二阶泰勒展开：</p> \\[ f(X)\\approx f(X^{(k)})+\\nabla f(X^{(k)})^{T}\\Delta X+\\frac{1}{2} \\Delta X^{T}H(X^{(k)})\\Delta X \\] <p>极小点满足\\(\\nabla f(X^{(k)})+H(X^{(k)})\\Delta X=0\\)</p> <p>从而\\(X=X^{(k)}-H(X^{(k)})^{-1}\\nabla f(X^{(k)})\\)</p> <p>那么如果函数是二次函数，Hesse阵就是常数阵，逼近是准确的，从任意一点出发一步即可求出\\(f(X)\\)的极小点(假定\\(H(X^{(k)})\\)正定)</p> <p>如果不是，那么就是近似表达式，这时就常常取\\(-H(X^{(k)}\\nabla f(X^{(k)}))\\)为搜索方向，即</p> \\[ \\left\\{ \\begin{matrix} P^{(k)}=-H(X^{(k)})^{-1}\\nabla f(X^{(k)}) \\\\ X^{(k+1)}=X^{(k)}+\\lambda_{k}P^{(k) } \\\\ \\lambda_{k}:\\min f(X^{(k)}+\\lambda P^{(k)}) \\end{matrix} \\right. \\] <p>牛顿法的算法：</p> <ol> <li>给出初始点\\(x_{1}\\in \\mathbb{R}^{n},0\\leqslant \\varepsilon&lt;1,k:=1\\)</li> <li>如果\\(\\lVert \\nabla f(x_{k}) \\rVert_{2}\\leqslant \\varepsilon\\)，停止，否则\\(d_{k}=-\\left[ \\nabla^{2}f(x_{k}) \\right]^{-1}\\nabla f(x_{k})\\)(Newton Step)</li> <li>利用线搜索求\\(\\alpha_{k}&gt;0\\);\\(x_{k+1}=x_{k}+\\alpha_{k}d_{k};k=k+1\\)，回到2</li> </ol> <p>如果\\(\\nabla^{2}f(x_{k})\\)不正定，那么牛顿法的搜索方向可能不是下降方向，就需要修正，将牛顿法的搜索方向记为\\(d_{k}^{N}\\)(Newton step)</p> <p>修正方法：</p> \\[ d_{k}=\\left\\{ \\begin{matrix} d_{k}^{N},\\cos(d_{k}^{N},-g_{k})\\geqslant\\eta \\\\ -g_{k},otherwise \\end{matrix} \\right. \\] <p>这样可以确保搜索方向，也就保证了算法的收敛性</p> <p>但是现实是，实际问题中的目标函数过于复杂，求逆阵是困难的于是我们设法构造另一个矩阵\\(\\overline{H}^{(k)}\\)，用它来直接逼近二阶导数矩阵的逆阵\\(H(X^{(k)})^{-1}\\)</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_22","level":4,"title":"构造近似矩阵","text":"<p>明确一下要求是在每一步充分利用已有信息确认下一步的搜索方向，并且每做一次迭代就要使目标函数值有所下降，并且近似矩阵应当收敛于逆阵</p> <p>由于二次函数时，Hesse阵为常数阵，那么在其任意两点\\(X^{(k)},X^{(k+1)}\\)，有梯度之差为\\(\\nabla f(X^{(k+1)})-\\nabla f(X^{(k)})=A(X^{(k+1)}-X^{(k)})\\)</p> <p>以下条件也被称为拟牛顿条件</p> \\[ X^{(k+1)}-X^{(k)}=\\overline{H}^{(k+1)}\\left[ \\nabla f(X^{(k+1)})-\\nabla f(X^{(k)}) \\right]  \\] <p>简化记号为：</p> \\[ \\left\\{ \\begin{matrix} \\Delta G^{(k)}&amp;=&amp;\\nabla f(X^{(k+1)})-\\nabla f(X^{(k)})\\\\ \\Delta X^{(k)}&amp;=&amp;X^{(k+1)}-X^{(k)}\\\\ \\end{matrix}\\right. \\] <p>可以简单记为\\(\\Delta X^{(k)}=\\overline{H}^{(k+1)}\\Delta G^{(k)}\\)</p> <p>那么为了使\\(\\overline{H}^{(k+1)}\\)满足拟牛顿条件，要求\\(\\Delta  \\overline{H}^{(k)}\\Delta G^{(k)}=\\Delta X^{(k)}-\\overline{H}^{(k)}\\Delta G^{(k)}\\)</p> <p>可以试图构造一个简单的形式，根据上式也可以进行猜想：</p> \\[ \\Delta  \\overline{H}^{(k)}=\\Delta X^{(k)}(Q^{(k)})^{T}-\\overline{H}^{(k)}\\Delta G^{(k)}(W^{(k)})^{T} \\] <p>那么反代就可以得到\\((Q^{(k)})^{T}\\Delta G^{(k)}=(W^{(k)})^{T}\\Delta G^{(k)}=1\\)</p> <p>找到对应的校正矩阵：</p> \\[ \\Delta  \\overline{H}^{(k)}=\\frac{\\Delta X^{(k)}(\\Delta X^{(k)})^{T}}{(\\Delta G^{(k)})^{T}\\Delta X^{(k)}}- \\frac{\\overline{H}^{(k)}\\Delta G^{(k)}(\\Delta G^{(k)})^{T}\\overline{H}^{(k)}}{(\\Delta G^{(k)})^{T}\\overline{H}^{(k)}\\Delta G^{(k)}} \\] <p>可以利用校正矩阵得到</p> \\[ \\overline{H}^{(k+1)}=\\overline{H}^{(k)}+ \\frac{\\Delta X^{(k)}(\\Delta X^{(k)})^{T}}{(\\Delta G^{(k)})^{T}\\Delta X^{(k)}}- \\frac{\\overline{H}^{(k)}\\Delta G^{(k)}(\\Delta G^{(k)})^{T}\\overline{H}^{(k)}}{(\\Delta G^{(k)})^{T}\\overline{H}^{(k)}\\Delta G^{(k)}} \\] <p>拟牛顿法的计算步骤：</p> <ol> <li>给定初始点\\(X^{(0)}\\)及梯度允许误差\\(\\varepsilon&gt;0\\)</li> <li>若 $$ \\lVert \\nabla f(X^{(0)}) \\rVert ^{2}\\leqslant \\varepsilon $$ 则\\(X^{(0)}\\)为近似极小点，停止，否则转入3</li> <li>令\\(\\overline{H}^{(0)}=I,P^{(0)}=-\\overline{H}^{(0)}\\nabla f(X^{(0)})\\)</li> </ol> <p>注1:上述方法首先由戴维顿(Davidon)提出，后经弗莱彻(Fletcher)和鲍威尔(Powell)加以改进，故称DFP法，或DFP拟牛顿法.</p> <p>注2:拟牛顿法也称为变尺度(variable metric)方法.</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#smwsherman-morrison-woodbury-formula","level":4,"title":"SMW(Sherman-Morrison-Woodbury) Formula","text":"\\[ (A+UV^{T})^{-1}=A^{-1}-A^{-1}U(I_{k}+V^{T}A^{-1}U)^{-1}V^{T}A^{-1} \\] <p>高阶矩阵和低秩矩阵如何快速求解逆阵？直接对低秩的矩阵进行求逆计算就可以节约大量的计算量!</p> <p>注：曾经在高等代数中遇到过并且写过习题(参考谢启鸿白皮书)</p> <p>下面是另一个著名的拟牛顿法：</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#bfgs","level":4,"title":"BFGS方法","text":"<p>它的矩阵修正公式为：</p> \\[ \\begin{aligned} B_{k+1}&amp;=B_{k}- \\frac{B_{k}s_{k}s_{k}^{T}B_{k}}{s_{k}^{T}B_{k}s_{k}}+ \\frac{y_{k}y_{k}^{T}}{s_{k}^{T}y_{k}}\\\\ H_{k+1}&amp;=H_{k}- \\frac{H_{k}y_{k}s_{k}^{T}+s_{k}y_{k}^{T}H_{k}}{y_{k}^{T}s_{k}}+\\left( 1+ \\frac{y_{k}^{T}H_{k}y_{k}}{s_{k}^{T}y_{k}} \\right) \\frac{s_{k}s_{k}^{T}}{s_{k}^{T}y_{k}} \\end{aligned} \\] <p>注意如果将\\(B_{k}\\iff H_{k},s_{k}\\iff y_{k}\\)对换，那么可以将DFP方法和BFGS方法相互转换(对偶性质)，BFGS和DFP方法称为互为对偶方法.</p> <p>Broyden利用BFGS和DFP公式构造出一族拟牛顿修正公式：</p> \\[ B_{k+1}(\\theta)=B_{k}- \\frac{B_{k}s_{k}s_{k}^{T}B_{k}}{s_{k}^{T}B_{k}s_{k}}+ \\frac{y_{k}y_{k}^{T}}{s_{k}^{T}y_{k}}+\\theta w_{k}w_{k}^{T} \\] <p>取\\(\\theta=0\\)得到BFGS修正公式，\\(\\theta=1\\)得到DFP修正公式</p> <p>一族包含三个参数的修正公式由Huang给出形式为：</p> \\[ H_{k+1}=H_{k}- \\frac{H_{k}y_{k}y_{k}^{T}H_{k}}{y_{k}^{T}H_{k}y_{k}}+\\rho_{k} \\frac{s_{k}s_{k}^{T}}{s_{k}^{T}y_{k}}+(\\tau_{k}s_{k}+\\xi_{k}H_{k}y_{k}) v_{k} \\] <p>那么Broyden族是Huang族中所有对称且满足拟牛顿方程的修正公式</p> <p>拟牛顿法有两个重要的性质：</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%97%A0%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/#_23","level":4,"title":"不变性和二次终止性","text":"<ul> <li>不变性</li> </ul> <p>拟牛顿法的一个重要性质是不变性(invariance)，也就是经过线性变换后不变，利用这个性质分析算法时可以把\\(H_{1}=1\\)假设代入.</p> <p>线性变换：\\(\\overset{\\sim}{x}=Ax+a\\)，目标函数变为\\(f(A^{-1}(\\overset{\\sim}{x}-a))=f(x)\\)</p> \\[ \\nabla \\overset{\\sim}{x}\\overset{\\sim}{f}(\\overset{\\sim}{x})=A^{-T}\\nabla f(x) \\] <ul> <li>二次终止性</li> </ul> <p>Huang族中的任何方法在精确线搜索下具有二次终止性，在一定条件的假定下，算法必有限终止</p> <p>拟牛顿法的收敛性一直以来是比较热门的研究课题，拟牛顿法收敛性研究比较成熟和完善，但仍有一些重要问题没有解决，比如DFP方法的总体收敛性问题.</p>","path":["无约束问题"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/","level":1,"title":"线性规划与目标规划","text":"","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_2","level":2,"title":"线性规划与单纯形法","text":"内容 重要性 描述和注 单纯形表(单纯形法) ⭐⭐⭐⭐⭐ 整个线性规划问题的核心，剩余的方法都建立在这之上 对偶问题转换 ⭐⭐⭐ 注意变量约束和条件约束的符号变化即可 利用对偶原理快速计算最优解 ⭐⭐⭐⭐ 主要掌握对偶定理和互补松弛性 对偶单纯形法 ⭐⭐⭐⭐ 与单纯形表极其类似所以前面掌握的好会比较容易掌握 灵敏度分析 ⭐⭐⭐ 改变原本的一些参数判断最优解的变化","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_3","level":3,"title":"线性规划问题及其数学模型","text":"<p>[!quote] 目标 1. 了解线性规划模型的提出和背景 2. 能够使用图解法求解线性规划问题</p> <p>参考资料：如何理解线性规划中的单纯形法和单纯形表？</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_4","level":4,"title":"问题提出","text":"<p>简单来说就是约束条件为线性函数，并且想要求解某个函数(目标函数)的最值的优化问题，从实际问题中抽象出线性规划模型.</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_5","level":4,"title":"图解法","text":"<p>非常的容易，实际上就是利用图形解决二维的线性规划问题，我们曾经在小学二年级学习过这种方法.</p> <p>主要的聚焦点在于这个简单的二维情形给出的一些启发:</p> <ul> <li>解的情况<ul> <li>无穷多最优解</li> <li>无界解</li> <li>无可行解</li> <li>唯一最优解</li> </ul> </li> </ul>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_6","level":4,"title":"线性规划问题的标准形式","text":"<p>可以使用向量表示也可以使用矩阵</p> <p>将多种情况化归为简单的一种情况讨论是数学上常用的思想，我们在这里也可以将多种情况都归结于标准形式的线性规划问题的解决：</p> <ul> <li>目标函数(最大化)<ul> <li>如果是最小化，则加负号即可</li> </ul> </li> <li>约束条件(不等式)<ul> <li>如果是\\(\\leqslant\\)形式，可以采取在左边加入松弛变量的方法</li> <li>相反是\\(\\geqslant\\)形式，则采用在左边减去一个松弛变量的做法</li> <li>如果是无约束的变量可以使用两个非负变量相减代替</li> </ul> </li> </ul>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_7","level":4,"title":"线性规划问题的解概念","text":"<p>[!NOTE] 可行解 满足约束条件的解称为可行解，使目标函数达到最大值的可行解称为最优解</p> <p>[!NOTE] 基，基向量，基变量 \\(B\\)是系数矩阵\\(A\\)中的\\(m\\times m\\)阶非奇异子矩阵(\\(\\lvert B \\rvert\\neq 0\\))，则称\\(B\\)为基</p> \\[ B=\\begin{pmatrix} a_{11}&amp;a_{12}\\dots&amp;a_{1m} \\\\ a_{21}&amp;a_{22}\\dots&amp;a_{2m} \\\\ \\vdots \\\\ a_{m1}&amp;a_{m2}\\dots&amp;a_{mm} \\end{pmatrix}=\\left( P_{1},P_{2}\\dots P_{m} \\right) \\] <p>\\(P_{j}(j=1,2\\dots,m)\\)为基向量 \\(x_{j}(j=1,2\\dots,m)\\)为基变量</p> <p>[!TIP] 基解 \\(m\\)个方程,\\(n\\)个变量(n&gt;m)，选择其中\\(\\binom{n}{n-m}\\)个为0，求出基解:max=\\(\\binom{n}{m}\\)</p> <p>由于选取的矩阵是非异阵所以满秩，也就是线性无关</p> <p>[!NOTE] 基可行解，可行基 满足非负条件的基解也称为基可行解，对应基可行解的基，称为可行基</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_8","level":3,"title":"线性规划问题的几何意义","text":"<p>[!quote] 目标 1. 了解解的概念 2. 理解部分基本定理 3. 理解单纯形法迭代原理</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_9","level":4,"title":"基本概念","text":"<ol> <li>凸集</li> <li>凸组合</li> <li>顶点</li> </ol> <p>[!info] 利用顶点的定义 顶点的定义是无法用凸集中不同两点进行线性组合得到，本节的部分定理用到了这一定义进行反证.</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_10","level":4,"title":"几个定理","text":"<p>[!NOTE] Theorem 1 若线性规划问题存在可行域，则可行域为凸集</p> <p><code>Proof  is easy</code></p> <p>[!info] Lemma 1 线性规划问题的可行解为基可行解\\(\\iff\\)\\(X\\)的正分量对应的系数列向量是线性无关的</p> <p><code>Proof.</code></p> <p>\\(\\implies\\) 由定义可以知道，基可行解的基变量对应系数列向量组成一个基(线性无关的向量组的子集仍然线性无关)，基是系数矩阵的满秩子矩阵，所以各系数列向量必线性独立</p> <p>\\(\\impliedby\\) 不妨设出k个正分量且线性独立，必有\\(k\\leqslant m\\)，相等时构成基，显然成立，否则可以使用基扩张定理构造出新的基，使其为X</p> <p>[!NOTE] Theorem 2 线性规划问题的基可行解\\(X\\)对应于可行域\\(D\\)的顶点</p> <p><code>Proof.</code></p> <p>反证法，转而证明非可行域顶点\\(\\iff\\)非基可行解</p> <p>\\(\\impliedby\\) 构造\\(X=\\left( X_{1},X_{2},\\dots,X_{k},0,\\dots,0 \\right)\\)，前k个系数列向量线性相关(利用引理)，得到一个零元，利用零元构造两个可行解，对其进行线性表出，证明X不是顶点</p> <p>\\(\\implies\\) 利用不是顶点，就可以用顶点线性表出，构造出线性相关即可</p> <p>[!NOTE] Lemma 2 若\\(K\\)是有界闭凸集，则任何一点\\(X\\in K\\)可表示为\\(K\\)的顶点的凸组合</p> <p>[!NOTE] Theorem 3 若是可行域有界，线性规划问题的目标函数一定可以在可行域顶点上达到最优</p> <p>换言之，若线性规划问题有最优解，一定存在一个基可行解为最优解</p> <p>假设最优解，利用定理2，反证不是顶点，构造\\(X_{0}+\\mu\\delta,X_{0}-\\mu\\delta\\)，得到无穷多个最优解(那么可以移动至顶点，有界性保证了一定可以取到) </p> <p>[!tldr] 基本结论 线性规划问题所有的可行解构成一个凸集，或者无界域，有限多个顶点，每个基可行解对应可行域的一个顶点 若是有最优解，一定可以在顶点上得到，而顶点数目有限那么全部遍历后一定就可以得到最优解，但是如果\\(m,n\\)较大，全部遍历是不太现实的，所以提出了单纯形法 如果在一个顶点上的值优于周围顶点，一定是最优解</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_11","level":3,"title":"单纯形法","text":"<p>[!cite] 目标 1. 掌握单纯形法的计算步骤 2. 利用单纯形法判别解的形式 3. 掌握单纯形法的几种变形 4. 了解修正单纯形法的改进</p> <p>1947年在美国五角大楼工作，Dantzig常常被空军要求去解实际的计划问题：分配空军的人力、经费、飞机和其它资 源。他给这些问题建立了线性规划模型，并提出著名的单纯形法(Simplex Method)。</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_12","level":4,"title":"粗糙过程","text":"<p>基本思路：从线性方程组中找出一个个单纯形，每个单纯形可以求得一组解，然后判断该解使目标函数变大或变小，决定下一步的单纯形，也就是迭代的过程，直到实现了最大值或最小值为止.</p> <p>要想更好的掌握这种方法最好是选取两三个例子自己进行迭代，这里只是给出普通的理论方法</p> <ol> <li>先化为标准形式</li> <li>找出一组基(base，通常为单位阵)，用非基变量表示基变量</li> <li>将目标函数化为非基变量的组合</li> <li>取非基变量为0，得到一个基可行解</li> <li>判定：如果目标函数中还有正系数的非基变量就可以更换(如果是求最大值)</li> <li>迭代4,5</li> </ol> <p>这里就涉及到换入换出变量的确定问题</p> <ul> <li>选择正系数最大的非基变量为换入变量(直观上这使得增速最大)，然后找出换出变量</li> <li>让非基变量中的不换入变量为0，就可以得出一个用换入变量表示原基变量的线性方程组，为了满足非负的要求，选取先接触到极限也就是0的那个变量</li> </ul> <p>确定换入换出变量后就可以重新构建方程组和基变量了，再使所谓的非基变量为0(重复4)，得到另一个基可行解，如果非基变量的系数还是正的，说明可以继续迭代，重复上述过程，确认换入换出变量，然后取0，得到新的基可行解，当所有的非基变量系数为负数时，说明达到了最大值.</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_13","level":4,"title":"初始基可行解的确定","text":"<p>对于上面给出的做法，我们发现首先要确定初始的基可行解，方法如下 1. 直接观察 2. 加入松弛变量 3. 加入非负人工变量</p> <p>[!info] 加入人工变量的方法 实际上是为了构造出类似松弛变量那样的单位矩阵，采用人造基的方法，可以使用大\\(M\\)法，\\(M\\)是相当大的正数(可以理解为正无穷),对人工变量起到惩罚的作用,逼迫辅助线性规划的最优解中人工变量均为0</p> <p>这里给出一个矩阵方法的简单推导：</p> \\[ \\begin{aligned} Ax &amp; =b \\\\ \\left[ B \\ N \\right] \\left[ \\begin{matrix} x_{B} \\\\ x_{N} \\end{matrix} \\right] &amp; =Bx_{B}+Nx_{N}=b \\\\ x_{B} &amp; =B^{-1}b-B^{-1}Nx_{N}   \\\\ f &amp; =cx=f_{0}-\\sum\\limits_{j\\in R}\\left( z_{j}-c_{j} \\right) x_{j}  \\end{aligned} \\] <p>还需要一个单纯形乘子的定义\\(w=c_{B}B^{-1},z_{i}=wp_{i}\\)</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_14","level":4,"title":"最优性检验与解的判别","text":"<p>由于线性规划问题求解过程中解的多样性，我们需要建立解的判别准则</p> \\[ \\begin{aligned} z= &amp; \\sum\\limits_{j=1}^{n} c_{j}x_{j}=\\sum\\limits_{j=1}^{m} c_{j}x_{j}+\\sum\\limits_{i=m+1}^{n} c_{i}x_{i} \\\\  &amp; =\\sum\\limits_{i=1}^{m} c_{i}b_{i}' +\\sum\\limits_{j=m+1}^{n} \\left( c_{j}-\\sum\\limits_{i=1}^{m} c_{i}a_{ij}' \\right) x_{j} \\\\ x_{i} &amp; =b_{i}'-\\sum\\limits_{j=m+1}^{n}a_{ij}' x_{j} \\ i=1,2\\dots m \\\\  z&amp; =z_{0} +\\sum\\limits_{j=m+1}^{n }(c_{j}-z_{j})x_{j}  \\\\ \\sigma_{j} &amp; =c_{j}-z_{j} \\\\ z &amp; =z_{0}+\\sum\\limits_{j=m+1}^{n} \\sigma_{j}x_{j} \\end{aligned} \\] <ol> <li>最优解的判别定理</li> </ol> <p>由此可得最优解判定定理，若\\(X_{0}\\)代表一个基可行解，而且对于一切的\\(j=m+1,\\dots,n，\\sigma_{j}\\leqslant 0\\)，则称为最优解，其中\\(\\sigma_{j}\\)为检验数.</p> <ol> <li>无穷多最优解判别定理</li> </ol> <p>同样符合1中的条件，检验数均非正，如果存在某个非基变量的检验数为0，那么线性规划问题有无穷多最优解</p> <ol> <li>无界解判别定理</li> </ol>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_15","level":4,"title":"基变换","text":"<p>针对初始基可行解不是最优解也不能判别无界时，需要找新的基可行解</p> <p>方法是从原本的可行解基中更换一个列向量，并且保证线性独立，得到新的可行基，称为基变换.</p> <p>涉及到前面的一些规则再次阐述，尤其是\\(\\theta\\)规则的部分，选择最小的换出</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_16","level":4,"title":"迭代(旋转)","text":"<p>由于原本是单位阵，那么逆阵应该也是单位阵，进行主元消去恰好是进行逆变换也就是乘上逆矩阵的做法，得到的下一个矩阵也是单位阵，于是可以一直使用主元消去的方法.</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_17","level":3,"title":"单纯形法的计算步骤","text":"<p>综合上方的矩阵做法和理论推导，将运算简化为表格计算，得到下方的单纯形表</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_18","level":4,"title":"单纯形表","text":"<p>为了便于理解计算关系，设计一种表用于计算，称为单纯形表，功能与增广矩阵相似，可以将线性约束关系与目标函数组成\\(m+1 \\times n+1\\)的方程组</p> <p>给出一个矩阵的表示：</p> f \\(x_{B}\\) \\(x_{N}\\) 右端 \\(x_{B}\\) 0 \\(I_{m}\\) \\(B^{-1}N\\) \\(B^{-1}b\\) f 1 0 \\(c_{B}B^{-1}N-c_{N}\\) \\(c_{B}B^{-1}b\\) <p>这是一种展开的表示方法，其中第一行不是表的一部分，只是表头</p> \\[ \\begin{pmatrix} -z &amp; x_{1} &amp; x_{2}\\dots  &amp; x_{m} &amp; x_{m+1} &amp; \\dots  &amp; x_{n} &amp; b \\\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; a_{1,m+1} &amp; \\dots &amp; a_{1n} &amp; b_{1} \\\\ \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; a_{m,m+1} &amp; \\dots &amp; a_{mn} &amp; b_{m} \\\\ 1 &amp; c_{1} &amp; \\dots &amp; c_{m} &amp; c_{m+1}   &amp; \\dots &amp; c_{n} &amp; 0 \\end{pmatrix} \\] \\[ \\begin{pmatrix} -z &amp; x_{1} &amp; x_{2}\\dots  &amp; x_{m} &amp; x_{m+1} &amp; \\dots  &amp; x_{n} &amp; b \\\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; a_{1,m+1} &amp; \\dots &amp; a_{1n} &amp; b_{1} \\\\ \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; a_{m,m+1} &amp; \\dots &amp; a_{mn} &amp; b_{m} \\\\ 1 &amp;0&amp; \\dots &amp; 0 &amp; c_{m+1}-\\sum\\limits_{i=1}^{m} c_{i}a_{i,m+1}   &amp; \\dots &amp; c_{n}-\\sum\\limits_{i=1}^{m} c_{i}a_{i,n} &amp; -\\sum\\limits_{i=1}^{m} c_{i}b_{i} \\end{pmatrix} \\]","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_19","level":4,"title":"计算步骤","text":"<p>第二张表称为初始单纯形表，每迭代一次就构造一个新的单纯形表</p> <ol> <li>先建立初始单纯形表</li> <li>检查检验数，如果没有得到最优解，转入下一步</li> <li>在检验数为正的列向量中确认最大的为换入向量</li> <li>找到出基变量，方法是\\(\\theta\\)检验法</li> <li>高斯消去法得到新的单纯形表</li> <li>重复2-5</li> </ol> <p>只需要一个例子就可以明白了.</p> \\(c_{j}\\) \\(\\to\\) 2 3 0 0 0 \\(C_{B}\\) \\(X_{B}\\) b x1 x2 x3 x4 x5 \\(\\theta\\) 0 X3 8 1 2 1 0 0 4 0 X4 16 4 0 0 1 0 - 0 X5 12 0 [4] 0 0 1 3 - z 0 2 3 0 0 0 <p>可知x2为换入变量，再计算\\(\\theta\\)，得到最小值是3，它所在行对应的x5是换出变量，所在行和所在列交叉处的[4]称为主元素或枢元素(pivot element)</p> <p>利用主元素将所在列变为\\((0,0,1)^{T}\\)，然后将\\(x_{2}\\to x_{5}\\)</p> \\(c_{j}\\) \\(\\to\\) 2 3 0 0 0 \\(C_{B}\\) \\(X_{B}\\) b x1 x2 x3 x4 x5 \\(\\theta\\) 0 X3 2 [1] 0 1 0 \\(-\\frac{1}{2}\\) 2 0 X4 16 4 0 0 1 0 4 3 X2 3 0 1 0 0 \\(\\frac{1}{4}\\) - - z -9 2 0 0 0 \\(-\\frac{3}{4}\\) <p>发现有\\(c_{1}-z_{1}=2&gt;0\\)，说明x1为换入变量，换出变量是x3</p> \\(c_{j}\\) \\(\\to\\) 2 3 0 0 0 \\(C_{B}\\) \\(X_{B}\\) b x1 x2 x3 x4 x5 \\(\\theta\\) 2 X1 2 1 0 1 0 \\(-\\frac{1}{2}\\) - 0 X4 8 0 0 -4 1 [2] 4 3 X2 3 0 1 0 0 \\(\\frac{1}{4}\\) 12 - z -13 0 0 -2 0 \\(\\frac{1}{4}\\) <p>x5为换入变量，换出变量是x4</p> \\(c_{j}\\) \\(\\to\\) 2 3 0 0 0 \\(C_{B}\\) \\(X_{B}\\) b x1 x2 x3 x4 x5 \\(\\theta\\) 2 X1 4 1 0 1 \\(\\frac{1}4\\) 0 0 X5 4 0 0 -2 \\(\\frac{1}{2}\\) 1 3 X2 2 0 1 \\(\\frac{1}{2}\\) \\(-\\frac{1}{8}\\) 0 - z -14 0 \\(-\\frac{3}{2}\\) \\(-\\frac{1}{8}\\) 0 0","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_20","level":3,"title":"单纯形法的进一步讨论","text":"","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_21","level":4,"title":"人工变量法","text":"<p>[!pldr] 基本思想 原本的做法需要依靠加入松弛变量构造出初始的单位阵作为基向量，但是如果不是符合\\(\\leqslant\\)的方程就无法按照原本的方法进行，这时候可以考虑人工变量法直接加入基变量构造出单位矩阵，仍然得到初始基可行解，但是如果不加以约束，这显然会出现不符合题设的解 + 由于人工变量是加入原本约束条件的虚拟变量，所以必须要将它们从基变量中逐个替换出来 + 基变量不再含有非零的人工变量表示有解，反之无可行解</p> <ol> <li>大M法</li> </ol> <p>思路：如果是求最小值，目标函数中给人工变量赋以很大的系数(惩罚函数)，那么如果要求最小值，就不可能仍然含有人工变量</p> <ol> <li>两阶段法<ol> <li>第一阶段：不考虑原问题是否存在基可行解，加入人工变量，构造仅含人工变量的目标函数和要求实现最小化，如果最小值为0，则说明原问题存在基可行解，可以进行二阶段计算</li> <li>第二阶段：第一阶段计算得到的最终表除去人工变量，将目标函数换回原问题的目标函数系数，然后以此作为初始表，启动单纯形法</li> </ol> </li> </ol>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_22","level":4,"title":"退化","text":"<p>使用最小比值规则确定换出变量时发现存在两个以上相同的最小比值，下一次迭代中将出现一个或者几个基变量等于零，这就出现退化解，这时可以采用一些方法规避循环：“摄动法”，“字典序法”.</p> <p>Remark：Bland规则 1. 选取检验数大于零中下标最小的非基变量为换入变量 2. 按照最小比值规则计算出现两个以上最小比值选取下标最小(或最大)的基变量为换出变量 3. 一定要统一规则</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_23","level":4,"title":"检验数的几种表示形式","text":"<p>最大值和最小值选择不同的方向</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_24","level":3,"title":"单纯形法的矩阵描述","text":"<p>在上文已提前给出，在此不再赘述(矩阵描述更加简洁但是可能会更依赖代数功底一些)</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_25","level":3,"title":"改进单纯形法","text":"<p>传统单纯形法的局限性，换基后新的基变量对应的原始矩阵求逆会造成无谓的计算浪费</p> <p>求解线性规划问题的关键就是找到\\(B^{-1}\\)，如果能简化逆阵计算就可以大大缩短时间，做法也是比较固定的：找到主元素，计算新的向量，左乘得到逆阵后即可化为单位阵.</p> <p>也就是将入基的向量化为出基向量的列向量的样子</p> <ul> <li>锁定主元</li> <li>非主元化为零</li> </ul> <p>[!NOTE] 小结 实际上就是用简单的高斯消去法代替求逆阵的过程，如果是提取阅读了课本或是网上的一些资料可能会发现一开始用的就是改进后的方法. 笔者前面也是直接按照改进后方法计算和书写，老师的讲义中在3.5提到了这一点，也使用的是这一简单方法</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_26","level":4,"title":"单纯形法的小结","text":"<ul> <li>变量处理</li> <li>约束条件处理</li> <li>目标函数</li> <li>大M法</li> <li>两阶段法</li> </ul> <p>[!warning] 大M法 如果需要使用计算机的机器语言进行求解，大M法中的M不够明确就有可能出现无法正确求解的问题，所以进一步讨论两阶段法，保证过程的明确且唯一。</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_27","level":2,"title":"对偶理论和灵敏度分析","text":"<p>[!quote] 目标 + 对偶问题   + 对偶的含义   + 对偶问题的一般形式 + 基本性质   + 单纯形法的矩阵描述   + 对偶问题的基本性质 + 影子价格</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_28","level":3,"title":"对偶问题的提出","text":"<p>网课中有一个例子笔者觉得不错，就是以两个公司相互交易的角度，原本是卖方而转换为买方，那么如何获利最大化就是将收购对方公司的资本降到最低，这也就是目标，然后就是对方凭什么让出资源，那么就需要约束，让出所得不低于原有盈利。这也就是经典的生产问题和资源收购问题。</p> <p>注意：但是有些问题的对偶问题不一定有比较明确的现实意义，但是只要是线性规划问题一定有它对应的对偶问题。</p> <p>简单来说就是最大和最小对偶，大于号和小于号调换，将\\(C\\iff b\\)，系数矩阵转置(对调一下自变量)，这样就得到了原线性规划问题(LP)的对偶问题(DP)</p> \\[ \\begin{aligned} max z  &amp; =CX \\\\ AX &amp; \\leqslant b \\\\ X  &amp; \\geqslant   0 \\end{aligned} \\] <p>转换为：</p> \\[ \\begin{aligned} min w  &amp; =b^{T}Y \\\\ A^{T}Y &amp; \\geqslant C^{T} \\\\ Y &amp; \\geqslant   0 \\end{aligned} \\] <p>但是这种方程毕竟还是太简单和特殊了，我们最好还是给出对偶问题的一般形式-非对称形式的转化方法</p> <p>注：由于对偶问题的对偶问题就是原问题所以可以只掌握最小化或是最大化问题的变化根据不同的原问题选择正推或者逆推进行检验，为了保险起见应当两个都学相互检验。</p> <p>理论上都应该转化为标准形式然后再进行对偶问题的转换，但是下面给出了一种直接写出的方法。 </p> <p>[!tip] 关于非对称形式的详细解释 可以参考中山大学郭老师的讲解</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_29","level":3,"title":"线性规划的对偶理论","text":"","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_30","level":4,"title":"转换方法","text":"<p>对称的就按照之前的方法进行，如果是不对称的可以将等式分解为两个不等式，再通过加负号的方法转换为单边的不等式约束，然后按对称形式变换关系可写出它的对偶问题(不用那么麻烦直接转置了按照法则对应也可以)</p> <ul> <li>目标函数符号相反：最大对偶最小，最小对偶最大(非常容易)</li> <li>将原本的\\(b\\)系数对调目标函数的系数(也非常容易)</li> <li>新的对偶问题系数矩阵是原矩阵的转置(同样非常容易)</li> <li>下面是唯一具有难度的约束条件和变量的符号转换问题，笔者自己总结了一套规律<ul> <li>给出一组对应关系极小化问题对应\\(\\geqslant\\)，极大化问题对应\\(\\leqslant\\)，然后再看下面的问题</li> <li>先看原问题的约束条件，如果符合上面的对应关系，变量约束为\\(\\geqslant 0\\)，如果不符合则改为\\(\\leqslant 0\\)，如果取等就是无约束情况反而简单了</li> <li>再看原问题的变量约束，仍然是那条对应关系只不过以0为分界(极小化问题就是非负限制\\(\\geqslant 0\\)，极大化问题就是非正的限制\\(\\leqslant 0\\))，符合的话约束就是\\(\\leqslant\\)，不符合就是\\(\\geqslant\\)，无约束实际是最简单的直接取等</li> <li>注意：这种对应关系是符合最初的优化生产问题的</li> </ul> </li> </ul> <p>[!example] 复杂一点的例子</p> \\[\\begin{aligned} \\max -x_{1}+x_{2}&amp;+x_{3}\\\\ x_{1}+x_{2}+2x_{3}&amp;\\leqslant 25\\\\ -x_{1}+2x_{2}-x_{3}&amp;\\geqslant 2\\\\ x_{1}-x_{2}+x_{3}&amp;=3\\\\ x_{1},x_{2}&amp;\\geqslant 0 \\end{aligned}\\] <p>根据上面的法则写出对偶问题：</p> \\[ \\begin{aligned} \\min 25y_{1}+2y_{2}&amp;+3y_{3}\\\\ y_{1}-y_{2}+y_{3}&amp;\\geqslant -1\\\\  y_{1}+2y_{2}-y_{3}&amp;\\geqslant 1\\\\  2y_{1}-y_{2}+y_{3}&amp;=1\\\\ y_{1}\\geqslant 0,y_{2}&amp;\\leqslant 0 \\end{aligned} \\]","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_31","level":4,"title":"对偶问题的基本性质","text":"<ol> <li>对称性：</li> <li>对偶问题的对偶是原问题</li> <li>弱对偶性：每一个问题的可行解的目标函数值都给出对偶问题的目标函数的界</li> <li>\\(\\overline{X}\\)为原问题可行解，\\(\\overline{Y}\\)是对偶问题可行解，\\(C \\overline{X}\\leqslant \\overline{Y}b\\)</li> <li>无界性：</li> <li>若是原问题为无界解，则对偶问题无可行解</li> <li>最优性：  </li> <li>\\(C \\overline{X}=\\overline{Y}b\\)，\\(\\overline{X},\\overline{Y}\\)是最优解</li> <li>对偶定理：</li> <li>两个问题均有可行解</li> <li>若原问题有最优解，那么对偶问题也有最优解，且最优解目标函数值相等</li> <li>互补松弛性：很重要，可以很好的简化得到对偶问题最优解的过程</li> <li>\\(\\overline{X},\\overline{Y}\\)为原问题和对偶问题可行解，\\(\\overline{Y}X_{S}=0,Y_{S}\\overline{X}=0 \\iff  \\overline{X},\\overline{Y}\\)最优解</li> <li>以下是从课本(最优化理论与算法-陈宝林)中的摘取(感觉比Slides详细)<ul> <li>如果\\(x^{(0)},w^{(0)}\\)是原问题和对偶问题的可行解，那么两者均为最优解的充要条件是对于任意的\\(i,j\\)，满足</li> <li> <ol> <li>如果\\(x_{j}^{(0)}&gt;0\\)，就有\\(w^{(0)}p_{j}=c_{j}\\)</li> </ol> </li> <li> <ol> <li>如果\\(w^{(0)}p_{j}&lt;c_{j}\\)，\\(x_{j}^{(0)}=0\\)</li> </ol> </li> <li> <ol> <li>如果\\(w_{j}^{(0)}&gt;0\\)，就有\\(A_{i}x^{(0)}=b_{i}\\)</li> </ol> </li> <li> <ol> <li>如果\\(A_{i}x^{(0)}&gt;b_{i}\\)，\\(w_{j}^{(0)}=0\\)</li> </ol> </li> </ul> </li> <li>原问题检验数与对偶问题解的关系</li> </ol> <p>补充互补松弛性的应用： 1. 对偶问题取到最优解中变量如果非零，它所对应的约束条件在原问题中取等；如果取零则忽略 2. 原问题也是同理，原因是如果没有办法取等那么松弛变量一定大于零</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_32","level":3,"title":"对偶问题的经济解释——影子价格","text":"<p>给出乘子，实际意义应当是其他条件不变的情况下，单位资源变化所引起的目标函数的最优值的变化，本质上是对于具体工厂的具体产品而存在的特殊价格，在完全市场经济条件下，如果某种资源市场价格低于该厂影子价格就可以买进以扩大生产，如果高于企业影子价格则应当卖掉.</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_33","level":3,"title":"对偶单纯形法","text":"<p>[!cite] 目标 + 理解对偶单纯形法的基本思路，与普通的单纯形法对比 + 了解对偶单纯形法的计算步骤</p> <p>根据对偶问题的对称性，可以这样考虑：若保持对偶问题的解是基可行解，即\\(c_j−C_BB^{-1}P_j \\leqslant 0\\)，而原问题在非可行解的基础上，通过逐步迭代达到基可行解，这样也得到了最优解。其优点是原问题的初始解不一定是基可行解，可从非基可行解开始迭代.</p> <p>基本思路：</p> <ul> <li>满足两条性质：可行性和最优性</li> <li>单纯形法：先满足可行性再逐渐逼近最优性</li> <li>对偶单纯形法：先满足最优性，再逐渐逼近可行性</li> </ul> <p>这里的原理还需要了解一下，可以参考胡运权老师书的写法(实际主要就是利用了对偶定理)</p> <p></p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_34","level":4,"title":"计算步骤","text":"<ol> <li>检验数均小于零-对偶问题可行解</li> <li>判断\\(b\\)列向量是否全部非负，若是，达到最优，停止迭代，否则进入3</li> <li>决定出基变量，选取最小的一个(负值中绝对值最大的一个)</li> <li> <p>确定换入变量，找到主元素</p> </li> <li> <p>确定出基变量 找到\\(b\\)列中小于零的一行(如果不止一个就选择最小的为出基变量)</p> </li> <li>确定入基变量 确定行之后还需要寻找对应行中\\(a_{rj}&lt;0\\)的非基变量考虑作为入基变量</li> </ol> \\[ \\theta=min\\left\\{ \\frac{c_{j}-z_{j}}{a_{rj}}\\big|a_{rj}&lt;0 \\right\\} = \\frac{c_{s}-z_{s}}{a_{rs}} \\] <p>注：为什么要找小于0的呢，因为换基之后需要化为1，如果是正数无法改变\\(b\\)的符号仍然为负相当于没有变化</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_35","level":3,"title":"灵敏度分析","text":"<p>讨论线性规划问题时其中的常数值实际往往是估计值和预测值，那么就会问 1. 已求得的线性规划问题的最优解有什么变化在系数变化时 2. 在什么范围变化，最优解不会发生什么变化</p> <p>以下也是针对各种线性规划中常量值的变化进行分析讨论</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_36","level":4,"title":"资源数量变化的分析","text":"<p>也就是增加一个矩阵，将变化后的值加到\\(b\\)列上即可</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#c_j","level":4,"title":"目标函数中价值系数\\(c_{j}\\)的变化分析","text":"<p>不影响约束增广矩阵，直接在最终的单纯形表里改就可以了，其他的除了检验数应该都不变，也就是只需要重新计算检验数，那么就可以重新迭代。</p> <p>如果最优解不变需要检验数仍然小于等于0，也就是不需要迭代了，只需要进行不等式组求解就可以了。</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#a_ij","level":4,"title":"技术系数\\(a_{ij}\\)的变化","text":"<p>两种情况</p> <ul> <li>\\(A\\)的变化带来\\(B\\)的变化 过于复杂了，为什么不重做？类似不变化的操作步骤，然后将那一列修正为基向量的0、1形式，构造后可能发现可行性和最优性都发生了变化。</li> <li>\\(A\\)的变化不带来\\(B\\)的变化 体现在最终的单纯形表上也就是\\(B^{-1}A+B^{-1}\\Delta A\\)</li> </ul>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_37","level":4,"title":"新增变量","text":"<p>直接在终表中左乘\\(B^{-1}\\)和它的系数后加上，但是还需要增加新的基变量，构造新的单位阵</p>","path":["线性规划与目标规划"],"tags":[]},{"location":"%E7%BB%9F%E8%AE%A1%E5%AD%A6/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/#_38","level":4,"title":"决定是否继续迭代的总结","text":"可行性 最优性 方法 不满足 满足 对偶单纯形法继续迭代 满足 不满足 单纯形法继续迭代 不满足 不满足 引进人工变量，重新计算 满足 满足 最优解不变，停止迭代 <p>这里需要比较多的练习进行适应，这样才能确保能够快速选择合适的方法进行计算</p>","path":["线性规划与目标规划"],"tags":[]}]}